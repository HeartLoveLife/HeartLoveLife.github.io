<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Sentinel-5P遥感数据下载及预处理教程【20250105】</title>
      <link href="/2025/01/05/Sentinel5P-Process/"/>
      <url>/2025/01/05/Sentinel5P-Process/</url>
      
        <content type="html"><![CDATA[<p>Sentinel-5P是欧空局（Europe Space Agency，ESA）于2017年10月13日发射的一颗全球大气污染监测卫星。卫星搭载了对流层观测仪（Tropospheric Monitoring Instrument，TROPOMI），可以有效的观测全球各地大气中痕量气体组分，包括NO<sub>2</sub>、O<sub>3</sub>、SO<sub>2</sub>、 HCHO、CH<sub>4</sub>和CO等重要的与人类活动密切相关的指标，加强了对气溶胶和云的观测。</p><h2 id="sentinel-5p数据介绍">⛄Sentinel-5P数据介绍</h2><h3 id="数据产品">👀数据产品</h3><p><code>TROPOMI</code>是目前世界上技术最先进、空间分辨率最高的大气监测光谱仪，成像幅宽达2600km，每日覆盖全球各地，成像分辨率达<code>7km×3.5km</code>，ESA提供了<code>L1B</code>和<code>L2</code>两种级别的数据下载。<code>L2</code>级数据产品介绍如下表：</p><p>官网产品数据介绍：<a href="https://sentiwiki.copernicus.eu/web/sentinel-5p">https://sentiwiki.copernicus.eu/web/sentinel-5p</a></p><table><colgroup><col style="width: 25%" /><col style="width: 74%" /></colgroup><thead><tr class="header"><th>Product type</th><th>Parameter</th></tr></thead><tbody><tr class="odd"><td>L2__O3____</td><td>Ozone (O<sub>3</sub>) total column（总柱含量）</td></tr><tr class="even"><td>L2__O3_TCL</td><td>Ozone (O<sub>3</sub>) tropospheric column（对流层柱含量）</td></tr><tr class="odd"><td>L2__O3__PR</td><td>Ozone (O<sub>3</sub>) profile（总剖面数据）</td></tr><tr class="even"><td>L2__NO2___</td><td>Nitrogen Dioxide (NO<sub>2</sub>)，total and tropospheric columns（总柱和对流层柱含量）</td></tr><tr class="odd"><td>L2__SO2___</td><td>Sulfur Dioxide (SO<sub>2</sub>) total column（总柱含量）</td></tr><tr class="even"><td>L2__CO____</td><td>Carbon Monoxide (CO) total column（总柱含量）</td></tr><tr class="odd"><td>L2__CH4___</td><td>Methane (CH<sub>4</sub>) total column（总柱含量）</td></tr><tr class="even"><td>L2__HCHO__</td><td>Formaldehyde (HCHO) total column（总柱含量）</td></tr><tr class="odd"><td>L2__CLOUD_</td><td>Cloud fraction, albedo, top pressure（云量、反照率、云顶大气压）</td></tr><tr class="even"><td>L2__AER_AI</td><td>UV Aerosol Index（紫外区域气溶胶指数）</td></tr><tr class="odd"><td>L2__AER_LH</td><td>Aerosol Layer Height (mid-level pressure)（气溶胶层高度（中等气压））</td></tr><tr class="even"><td>UV product</td><td>Surface Irradiance/erythemal dose</td></tr><tr class="odd"><td>L2__NP_BDx, x=3, 6, 7</td><td>Suomi-NPP VIIRS Clouds（云产品辅助数据）</td></tr></tbody></table><p>L2级数据产品根据生产时间/质量分为三种数据流：</p><ul><li>近实时数据流（near-real-time，<code>NRTI</code>），卫星成像3小时后即可获取，数据可能不完整或存在质量缺陷。</li><li>离线数据流（Offline，<code>OFFL</code>），一般成像后几天即可获得。</li><li>再次处理数据流（Reprocessing，<code>RPRO</code>），有些数据可能经过了多次处理，获得的最新的质量最佳的版本。</li></ul><p>一般情况下，长期的时序变化研究不可以混用不同级别的数据流，推荐使用最新的<code>RPRO</code>数据以保证数据质量。</p><h3 id="数据下载">👀数据下载</h3><p>下载教程：<a href="https://blog.csdn.net/twg666/article/details/134089146">Sentinel--哨兵系列数据下载地址及流程更新【202310】</a></p><h2 id="sentinel-5p数据预处理">⛄Sentinel-5P数据预处理</h2><p>本博客以L2级HCHO产品（近实时数据流HCHO总柱含量）为例：</p><blockquote><p>S5P_NRTI_L2__HCHO___20241015T052816_20241015T053316_36303_03_020601_20241015T061049.nc</p></blockquote><h3 id="方法1envi处理">👀方法1：ENVI处理</h3><blockquote><ul><li><p>GLT几何校正法利用输入的几何文件生成一个地理位置查找表文件（Geographic Lookup Table, GLT），从该文件中可以了解到某个初始像元在最终输出结果中实际的地理位置。</p></li><li><p>地理位置查找表文件是一个二维图像文件，文件中包含两个波段:地理校正影像的行和列。文件对应的灰度值表示原始影像每个像素对应的地理位置坐标信息，用有符号整型储存，它的符号说明输出像元是对应于真实的输入像元，是由邻近像元生成的填实像元（infill pixel）。符号为正时说明使用了真实的像元位置值；符号为负时说明使用了邻近像元的位置值，值为0说明周围7个象元内没有邻近像元位置值。</p></li><li><p>GLT文件包含初始影像每个像元的地理定位信息，它的校正精度很高。避免了通过地面控制点利用二次多项式几何校正法对低分辨率影像数据的处理。</p></li></ul></blockquote><p>（1）打开步骤：Open as→Generic Formasts→HDF5/NetCDF-4，或者直接将数据文件拖进ENVI。</p><p>（2）地理位置数据和浓度产品数据分开读取：将经纬度数据读取成一个图层，将HCHO柱浓度数据读取为另一个图层。</p><p><a href="https://imgse.com/i/pE9kYdS"><img src="https://s21.ax1x.com/2025/01/05/pE9kYdS.jpg" alt="pE9kYdS.jpg" /></a></p><p>（3）制作GLT文件，在ENVI工具箱中搜索Build GLT，在弹出的对话框中，Input X Geometry Band选择经度数据，Input Y Geometry Band选择纬度数据。 在接下来的对话框中，投影信息选择WGS-84，Geographic Lat/Lon。</p><p><img src = "https://s21.ax1x.com/2025/01/05/pE9kJZ8.jpg" align="center"></p><p>（4）在Build Geometry Lookup File Parameters对话框中，像元大小选择默认，旋转角度（Rotation）为0（正上方为北）。</p><p><img src = "https://s21.ax1x.com/2025/01/05/pE9k8qf.jpg" align="center"></p><p>（5）利用GLT文件对HCHO数据进行校正，工具箱中搜索Georeference from GLT，在Input Geometry Lookup File对话框中选择GLT文件，在Input Data File对话框中选择待校正的HCHO数据文件。</p><p><a href="https://imgse.com/i/pE9kwzn"><img src="https://s21.ax1x.com/2025/01/05/pE9kwzn.jpg" alt="pE9kwzn.jpg" /></a></p><p><a href="https://imgse.com/i/pE9kUiQ"><img src="https://s21.ax1x.com/2025/01/05/pE9kUiQ.jpg" alt="pE9kUiQ.jpg" /></a></p><blockquote><p><strong>存在问题</strong>：针对ENVI方式的处理结果，小编存在诸多疑问。我们通过ENVI加载数据或者Panoply软件加载数据，获取数据的行列：358×450；但是经过ENVI处理之后，分辨率Pixel: 0.044004 Degrees，Dims: 849 x 527 x 1。（ENVI中列在前，行在后）<strong>出现行列数不对应的问题？？</strong></p></blockquote><h3 id="方法2panoply可视化展示">👀方法2：Panoply可视化展示</h3><p>Panoply是一款跨平台的数据可视化软件工具，专门用于绘制地理参考以及其他数组数据，包括netCDF、HDF、GRIB等格式。Panoply运行需要JAVA环境，配置JAVA环境后，解压程序包，双击Panoply.exe即可。</p><ul><li><p>官网下载：<a href="https://www.giss.nasa.gov/tools/panoply/">https://www.giss.nasa.gov/tools/panoply/</a></p></li><li><p>博客下载：<a href="https://download.csdn.net/download/twg666/90224750?spm=1001.2014.3001.5501">遥感数据处理及可视化-第三方辅助工具集</a></p></li></ul><p><a href="https://imgse.com/i/pE9ktIg"><img src="https://s21.ax1x.com/2025/01/05/pE9ktIg.jpg" alt="pE9ktIg.jpg" /></a></p><p><a href="https://imgse.com/i/pE9kaGj"><img src="https://s21.ax1x.com/2025/01/05/pE9kaGj.jpg" alt="pE9kaGj.jpg" /></a></p><h3 id="方法3s5processor处理">👀方法3：S5Processor处理</h3><p>为了把S5P的NC数据正确转为TIFF数据，试了多种方法，在GitHub上面发现了一个R包：S5Processor</p><ul><li><p>S5Processor包地址：<a href="https://github.com/MBalthasar/S5Processor">https://github.com/MBalthasar/S5Processor</a></p></li><li><p>R及RStudio下载安装教程：<a href="https://blog.csdn.net/W_chuanqi/article/details/123626811">参考博客①</a>、<a href="https://blog.csdn.net/xfsong2012/article/details/138805643">参考博客②</a>、<a href="https://blog.csdn.net/xhmico/article/details/122443660">参考博客③</a></p></li><li><p>R包镜像地址：<a href="https://cran.r-project.org/src/contrib/Archive/">https://cran.r-project.org/src/contrib/Archive/</a></p></li></ul><p>（1）首先，这个包需要借助Rtools，下载Rtools，根据自己运行环境选择合适的版本，安装即可。</p><ul><li>Rtools下载地址：<a href="https://cran.r-project.org/bin/windows/Rtools/">https://cran.r-project.org/bin/windows/Rtools/</a></li></ul><p>（2）提示没有devtools，则直接安装该包即可。</p><p><img src = "https://s21.ax1x.com/2025/01/05/pE9AL7T.png" align="center"></p><p><img src = "https://s21.ax1x.com/2025/01/05/pE9kdRs.jpg" align="center"></p><p>（3）安装S5Processor包</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">devtools::install_github(&quot;MBalthasar/S5Processor&quot;)</span><br></pre></td></tr></table></figure><blockquote><p>在安装过程中，可能会遇到依赖包缺少的问题，比如<code>maptools</code>、<code>rgdal</code>、<code>rgeos</code>包，需要在R包镜像地址中检索并下载对应版本的包，进行手动安装。</p></blockquote><p>（4）实例代码</p><p>基于R语言，使用S5Processor包对S5P数据进行TIFF格式转换，便于在GIS中进行分析。</p><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">devtools<span class="operator">::</span>install_github<span class="punctuation">(</span><span class="string">&quot;MBalthasar/S5Processor&quot;</span><span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>S5Processor<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>ncdf4<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>ggplot2<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>dismo<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>maptools<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>raster<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>geosphere<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>rgdal<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>rgeos<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>sp<span class="punctuation">)</span></span><br><span class="line">S5P_HCHO <span class="operator">&lt;-</span> S5P_process<span class="punctuation">(</span>input <span class="operator">=</span> <span class="string">&quot;D:\\Desktop\\data\\S5P_NRTI_L2__HCHO\\S5P_NRTI_L2__HCHO___20241015T052816_20241015T053316_36303_03_020601_20241015T061049.nc&quot;</span><span class="punctuation">,</span> product <span class="operator">=</span> <span class="number">6</span><span class="punctuation">)</span></span><br><span class="line">writeRaster<span class="punctuation">(</span>S5P_HCHO<span class="punctuation">,</span> <span class="string">&quot;D:\\Desktop\\data\\S5P_NRTI_L2__HCHO\\S5P_HCHO_R.tif&quot;</span><span class="punctuation">,</span> format <span class="operator">=</span> <span class="string">&#x27;GTiff&#x27;</span><span class="punctuation">,</span> overwrite <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><blockquote><ul><li><p>针对代码中<code>product</code>参数值，相信很多朋友疑惑，如何获取呢？？</p></li><li><p>大部分博客中NO<sub>2</sub>实例的取值都是一样的（比如39），但是对于其它产品数据如何确定呢？？</p></li><li><p>小编开始也很疑惑，最后通过不断调试代码，能够输出产品列表，判断出对应编号。</p></li></ul></blockquote><p>（5）转换结果</p><p><a href="https://imgse.com/i/pE9Abn0"><img src="https://s21.ax1x.com/2025/01/05/pE9Abn0.jpg" alt="pE9Abn0.jpg" /></a></p><p><a href="https://imgse.com/i/pE9AqBV"><img src="https://s21.ax1x.com/2025/01/05/pE9AqBV.jpg" alt="pE9AqBV.jpg" /></a></p><blockquote><p><strong>存在问题</strong>：针对R包方式的处理结果，小编仍然存在诸多疑问。我们通过ENVI加载数据或者Panoply软件加载数据，获取数据的行列：358×450；但是通过R包方式处理之后，分辨率Pixel: 0.240748 x 0.17972 Degrees，Dims: 155 x 129 x 1。（ENVI中列在前，行在后）<strong>依然出现行列数不对应的问题？？并且和ENVI处理结果的行列数也不相同？？但是两者结果的整体趋势保持一致。</strong></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 遥感数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Sentinel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>碳汇估算方法概述及基于RS的碳汇估算模型详述【20241116】</title>
      <link href="/2024/11/16/RS-CSink-Method/"/>
      <url>/2024/11/16/RS-CSink-Method/</url>
      
        <content type="html"><![CDATA[<p>陆地生态系统在全球碳循环中扮演着极为重要的角色，准确地评估陆地生态系统碳源/汇时空变化和相关地表过程对全球气候变化的响应是有效预测气候变化的重要基础，也是目前全球气候变化研究中较为重要的前沿科学领域之一。生态系统碳循环根据排放和吸收之间的关系可以分为碳源和碳汇，其中碳源表示生态系统的排放量大于吸收量，而碳汇则表示生态系统的吸收量大于排放量。 根据最新的生态系统碳汇的定义："生态系统碳汇是指不同生态系统相关关联共同对于全球生态系统碳平衡的作用，不仅包括传统的植树造林、增加绿化面积等措施对于碳吸收的贡献，也包括草原、湿地、海洋等生态系统吸收大气中二氧化碳的过程，同时也涵盖土壤、永久性冻土固定的碳储量"。</p><blockquote><p>[1]刘坤,张慧,孔令辉,等.陆地生态系统碳汇评估方法研究进展[J].生态学报,2023,43(10):4294-4307.</p><p>[2]朴世龙,何悦,王旭辉,等.中国陆地生态系统碳汇估算:方法、进展、展望[J].中国科学:地球科学,2022,52(06):1010-1020.</p><p>[3]洪长桥,金晓斌,陈昌春,等.集成遥感数据的陆地净初级生产力估算模型研究综述[J].地理科学进展,2017,36(08):924-939.</p><p>[4]方精云,柯金虎,唐志尧,等.生物生产力的"4P"概念、估算及其相互关系[J].植物生态学报,2001,(04):414-419.</p></blockquote><h2 id="前言">⛄前言</h2><p>自工业革命以来，人类对化石燃料的消耗，导致<span class="math inline">\(CO_2\)</span>等温室气体被大量释放，大气中的<span class="math inline">\(CO_2\)</span>浓度从1750年约278<span class="math inline">\(\mu mol/mol\)</span>增加到2021年11月的415.01<span class="math inline">\(\mu mol/mol\)</span>，从2006年开始中国取代美国成为世界上最大的<span class="math inline">\(CO_2\)</span>排放国，2020年的碳排放量约为10.7<span class="math inline">\(P g\)</span>（<span class="math inline">\(1 Pg=10^{15}g=10\)</span>亿t）<span class="math inline">\(CO_2\)</span>当量，占同年全球排放量的31%，未来中国实现碳中和所需的碳减排压力远超过世界上其他任何一个发达国家。为此，2020年我国提出："二氧化碳排放力争在2030年达到峰值，2060年实现碳中和目标"，这不仅是实现我国自身可持续发展的需求，也是展现我国作为负责任大国的作为和担当。 减少<span class="math inline">\(CO_2\)</span>排放和增加碳汇是最主要的两种实现"碳中和"目标的手段，而碳汇增加的重点在于提高生态系统的质量和稳定性，巩固提升生态系统的碳汇能力。中国陆地生态系统占全球陆地面积的6.4%，其净<span class="math inline">\(CO_2\)</span>的吸收量占全球吸收量的10％-30％，是全球和区域碳循环及其模式研究的重点地区。根据预测，在2060年中国陆地生态系统碳汇潜力将达到0.36<span class="math inline">\(Pg C/a\)</span>，抵消的同期化石燃料燃烧和工业活动导致的碳排放的比例将达到43％。因此，在中国开展陆地生态系统碳汇研究不仅是改进生态系统管理、保障生态安全的急迫需求，同时也为实现"碳中和"目标路线图和时间表提供科学基础。随着科技水平的进步，适用于不同时空尺度的碳汇水平观测技术和碳汇强度评估方法不断地得到发展和完善。在全球尺度和中国尺度的陆地生态系统碳汇评估研究中，根据数据的来源及模型方法的原理可以将陆地生态系统碳汇方法分为"自下而上"和"自上而下"两类。</p><p><strong>"自下而上"方法</strong>利用地面调查数据、气象观测数据，使用模型方法模拟区域或全球陆地生态系统碳汇，主要包括地表植被生物量和土壤碳的地面调查与清查方法、涡度相关法、生态过程模型等方法。常用的模型包括通过温度、降水等气候因子，海拔、坡度、坡向、经纬度等地理因子与植被生物量、蓄积量之间的关系来估算陆地生态系统生产力的经验模型；通过考虑植被生长与光能利用效率(光合有效辐射)以及植被内部生理生态过程(光合作用、呼吸作用等)来估算陆地生态系统尺度生产力的生态过程模型。</p><p><strong>"自上而下"方法</strong>主要利用碳同化反演技术，基于不同平台的(地基平台、航空遥感平台、卫星遥感)大气温室气体浓度观测，结合气象场数据和大气辐射传输模型计算陆地生态系统碳汇强度，常用的方法有基于大气<span class="math inline">\(CO_2\)</span>浓度的碳同化方法以及卫星遥感数据反演方法。</p><h2 id="基本概念">⛄基本概念</h2><ul><li><strong>生物量</strong>(<code>Biomass</code>)：是研宄森林第一性生产力的基础，也是评价森林生态系统结构与功能的重要指标。它是泛指单位面积所有生物生产的有机物质的总量，其包括林木的生物量(干、枝、叶、皮、花果、根、种子和凋落物的总重量)和林下植被层的生物量。</li><li><strong>总初级生产力</strong>(<code>Gross Primary Productivity</code>，GPP)：是指单位时间内绿色植物通过光合作用途径把无机物质合成为有机物质的总量或固定的总能量，即植被冠层通过光合作用固定大气<span class="math inline">\(CO_2\)</span>的通量。GPP决定了进入生态系统的初始物质和能量，是生态系统碳循环的基础。</li></ul><blockquote><p>当今全球陆地生态系统GPP约为120-130<span class="math inline">\(Pg C yr^{-1}\)</span>，约为全球化石燃料和土地利用变化导致的总排放通量的12-15倍。</p></blockquote><ul><li><p><strong>净初级生产力</strong>(<code>Net Primary Productivity</code>，NPP)：是绿色植物在单位面积、单位时间内所固定的有机物质总量，是由光合作用所产生的有机物质总量(GPP)中扣除自养呼吸(<code>Autotrophic Respiration</code>，Ra)后的剩余部分。通常，林分NPP为单位时间内植物的生长量、植物凋落物及枯落物量和被动物吃掉的损失量三者之和。NPP是重要的生态指标(可表征产量和承载力等)。</p></li><li><p><strong>自养呼吸</strong>(<code>Autotrophic Respiration</code>，Ra)：植被自身呼吸释放的碳通量，包括维持呼吸(<code>Maintenance respiration</code>, Rm)和生长呼吸(<code>Growth respiration</code>, Rg)两个分量。Rg可以假设为GPP的25%；Rm与植被类型、生物量和温度有关，随生物量和温度上升。</p></li></ul><p><span class="math display">\[NPP=GPP-Ra=GPP-(Rm+Rg)\]</span></p><ul><li><p><strong>碳利用效率</strong>=NPP/GPP，一般为<strong>0.45</strong>左右，有较大的时空变化。</p></li><li><p><strong>净生态系统生产力</strong>(<code>Net Ecosystem Productivity</code>，NEP)：又称<strong>净生态系统交换量</strong>(<code>Net Ecosystem Exchange</code>，NEE)，是森林NPP与异养呼吸(<code>Heterotrophic respiration</code>，Rh)的差值。它是在没有扰动条件下，如林火、虫害及收获等情况下，森林植被和土壤储存碳库的净变化量，数量等于森林生态系统与大气间的净碳交换量。当NEP&gt;0时，森林生态系统为碳汇，反之则为碳源。</p></li><li><p><strong>异养呼吸</strong>(<code>Heterotrophic respiration</code>，Rh)：微生物活动、分解凋落物和土壤有机碳过程中向大气排放<span class="math inline">\(CO_2\)</span>的通量。Rh受多个因子影响，包括：植被凋落物和土壤有机碳量、土壤温度、土壤湿度、土壤质地、凋落物的木质素(Lignin)含量等。</p></li></ul><p><span class="math display">\[NEP=NPP-Rh=GPP-(Ra+Rh)=GPP-Re\]</span></p><blockquote><p>Re：生态系统呼吸。相对于GPP、Ra、NPP和Rh，NEP是一个非常小的量。</p></blockquote><ul><li><strong>净生态群落生产力</strong>(<code>Net Biome Productivity</code>，NBP)：是NEP减去各类自然和人为千扰(如火灾、病虫害、森林间伐及收获)等非生物呼吸消耗所剩下的部分。NBP是应用于区域或更大尺度的生物生产力的概念，其数据变化于正负值之间。实际上，NBP在数值上就是全球变化研究中所使用的陆地碳收支的概念，其大小可直接反映人类活动的影响程度。对于碳收支研究来说，将NBP从NEP中分离出来是很难的，因为各种自然和人为干扰具有很强的不确定性，减少其不确定性是全球碳循环研宄中的一个重要课题。因此，在大尺度的研究上，人们往往用NEP的数值来代替NBP，从而估算碳储量。</li></ul><p><span class="math display">\[NBP=NEP-De\]</span></p><blockquote><p>De: 扰动(火、病虫害和砍伐等)导致的碳排放。</p></blockquote><p><strong>碳汇量</strong>与<strong>碳储量</strong>都可以用来描述碳汇的性质，但表达的意义不同，碳储量是存量，碳汇量是流量。以森林碳汇为例：森林有5大碳储库，分别是地上和地下生物量、凋落物和枯死木等死有机质、土壤有机碳库；而森林碳汇是指森林通过植物光合作用吸收大气中的二氧化碳，并将其固定在生物体和土壤中的活动、过程或机制。<strong>森林碳储量</strong>是指某个时间点森林生态系统各碳库中碳元素的储备量(或质量)，是森林生态系统多年累积的结果；而<strong>森林碳汇量</strong>可以用一定时间内森林碳储量的变化量之和来表示。</p><h2 id="碳汇估算方法">⛄碳汇估算方法</h2><p>区域陆地生态系统碳收支估算方法大体可分为"<strong>自下而上(Bottom-up)</strong>"和"<strong>自上而下(Top-down)</strong>"两种不同类型。"自下而上"的估算方法是指将样点或网格尺度的地面观测、模拟结果推广至区域尺度，常用的"自下而上"方法包括清查法、涡度相关法和生态系统过程模型模拟法等。"自上而下"的估算方法主要指基于大气<span class="math inline">\(CO_2\)</span>浓度反演陆地生态系统碳汇，即大气反演法。可以理解的是，不同估算方法的优缺点和不确定性来源均不尽相同。</p><h3 id="自下而上碳汇方法">👀"自下而上"碳汇方法</h3><p><strong>（1）样地清查法</strong></p><p>样地清查法主要基于不同时期资源清查资料的比较来估算陆地生态系统(主要是植被和土壤)碳储量变化，即陆地生态系统碳汇强度。例如: 基于连续的森林资源清查数据，计算木材蓄积量变化，再通过生物量转换方程推导出森林生物量碳储量变化。对于缺乏连续清查数据的生态系统类型，如灌木、草地等，则可建立植被碳储量观测值和遥感植被指数之间的统计关系，结合遥感植被指数变化，估算植被碳储量变化。此外，利用不同时期的土壤普查数据与野外实测资料，同样可以估算不同时期土壤碳储量的变化。汇总植被与土壤碳储量的变化，即可以得到整个区域的生态系统碳汇。</p><p>基于样地清查法的陆地生态系统碳汇评估方法明确、技术简单，可以直接获得最为准确和可靠的数据，能够直接测算样点尺度植被和土壤的碳储量。其<strong>局限性</strong>主要包括：</p><ul><li><p>清查周期长。</p></li><li><p>清查数据侧重森林和草地等分布广泛的生态系统，而在灌丛、湿地等面积占比低的生态系统，长期观测的清查数据稀缺，导致区域尺度汇总结果存在一定的偏差。</p></li><li><p>鉴于陆地生态系统空间异质性强，在从样点到区域尺度碳储量的转换过程也存在较大不确定性。</p></li><li><p>清查数据不包含生态系统碳横向转移，如木材产品中的碳以及随土壤侵蚀而转移的有机碳等。一般而言，资源清查数据的样点覆盖密度是制约基于清查法的碳汇估算准确度的核心因素。</p></li></ul><p><strong>（2）涡度相关法</strong></p><p>涡度相关法是基于微气象理论的目前唯一能直接测量大气与植被冠层及土壤间物质循环和能量交换的观测技术，实现了生态系统尺度的温室气体交换、能量平衡和生产力等功能与过程涉及的生态现象观察、生态要素观测、生态系统功能变化观测的融合。涡度相关法直接测定固定覆盖范围(<code>footprint</code>，通常数平方米到数平方千米)内陆地生态系统与大气间的净<span class="math inline">\(CO_2\)</span>交换量，据此通过尺度上演估算区域尺度净生态系统生产力(<code>NEP</code>)。目前全球通量观测网络联盟(<code>FLUXNET</code>)建立起900多个观测样点，形成全球性和区域性的覆盖不同气候带和植被区系的通量观测网络，包括美国通量网、欧洲通量网、亚洲通量网、中国通量网等共42个国家、23个区域性通量研究网络。中国陆地生态系统通量观测研究网络(<code>ChinaFLUX</code>)于2002年建成，截止目前拥有80多个台站，包括森林、草地、农田、湿地、荒漠、水域生态系统，通过应用微气象法进行生态系统<span class="math inline">\(CO_2\)</span>和水热通量长期定位观测的关键技术，为全球碳平衡与全球变化研究提供中国典型陆地生态系统碳、水汽、氮通量的长期观测数据。通过构建区域、国家及全球尺度的通量观测网络，可以研究不同时间尺度和空间尺度的陆地生态系统碳汇强度。</p><p>基于涡度相关方法的陆地生态系统碳汇研究，可以实施监测生态系统尺度上的陆地与大气碳交换，减少样地清查法中的数据误差，长期的点位观测可以规避生态环境数据的短期波动带来的不确定性，有利于探讨生态系统碳循环过程对气候变化的相应机制。涡度相关法主要优点在于可实现精细时间尺度(例如每半小时)上碳通量的长期连续定位观测，从而能反映气候波动对NEP的影响。涡度相关法的<strong>局限性</strong>主要包括：</p><ul><li><p>涡度相关法是基于微气象学原理，不可避免会受到观测数据缺失、下垫面地形和气象条件复杂、能量收支闭合度、周围建筑物高度要求、观测仪器系统误差等因素影响，从而给碳通量估算带来一定的观测误差和代表性误差。</p></li><li><p>通量塔数量偏少、设置不合理、覆盖范围小不能完全反映测量生态系统的景观异质性。</p></li><li><p>因涡度测量仪器和工作原理的缺陷，观测数据存在缺失，不能记录到光合作用的碳吸收和呼吸作用的碳排放数据，对于空缺碳通量数据的填补不同方法误差较大。</p></li><li><p>涡度测量仪器还不能准确区分记录的异常数据是生态系统碳循环的真实扰动数据还是无效记录数据；由于夜间的湍流被抑制会导致测量系统响应不足，测量数据值偏低，测量数据存在偏移现象(植被在休眠期和非光合作用时期记录到<span class="math inline">\(CO_2\)</span>吸收现象)。</p></li><li><p>森林生态系统通量观测站点常设置在人为影响较小的区域，难以兼顾林龄差异和生态系统异质性，导致区域尺度碳汇推演结果存在偏差。</p></li><li><p>农田生态系统涡度相关通量观测无法区分土壤碳收支部分与作物收获和秸秆，因而难以准确估算农业生态系统碳收支。</p></li><li><p>涡度观测法测定的碳通量通常不包含采伐、火灾等干扰因素的影响，因此可能高估了区域尺度上生态系统碳汇。</p></li></ul><p>总之，由于区域尺度上人为影响普遍存在且对碳汇有明显影响，涡度相关法通常很少用于直接估算区域尺度上碳汇大小，更多用于理解生态系统尺度上碳循环对气候变化的响应过程。</p><p><strong>（3）模型模拟法</strong></p><p>模型模拟法是应用数学方法定量描述陆地生态系统碳汇与生态环境因子观测值之间的关系，对当前碳汇状况进行评估，和对未来碳汇情景进行预测。根据模型在结构、参数及算法上的不同，可以分成经验模型和生态过程模型。</p><p>样地清查法中应用的异速生长模型、蓄积量—生物量转换模型、全碳库模型等都属于经验模型，经验模型不考虑环境因素的影响，模型参数没有特定的生态学含义，不能从机理上对碳汇过程进行解释。</p><p>随着对陆地生态系统碳循环过程中涉及的生物物理化学过程认识的逐步深入，越来越多的研究者通过分析太阳辐射传输、光合作用和呼吸作用、养分和水分循环等过程，将与过程相关的植被冠层结构(叶面积指数、覆盖度、植被高度、生物量)、辐射吸收(PAR、反照率、净辐射、地表温度、冠层温度、土壤温度)、生化(叶绿素、胡萝卜素、含氮量、叶片含水量)、功能(叶绿素荧光)参数；空气动力学温度、水汽压差、辐射、水热参数等物理参数作为驱动因子，构建基于生态系统碳循环过程的机理模型。根据驱动因子模型进一步可以分为<strong>静态模型</strong>和<strong>动态模型</strong>，静态模型主要包括<code>CENTURY</code>、<code>InTEC</code>和<code>Biome-BGC</code>等，在模拟期间，驱动因子(气候、植被)维持基线情景；动态模型种的植被物种分布会随着气候和土壤条件的变化发生改变，常用的模型有<code>IBIS</code>、<code>CEVSA</code>、<code>BIOME3</code>、<code>LPJ-DGVM</code>等。</p><p>利用生态过程模型模拟陆地生态系统碳汇，可以阐明生态系统组分与环境因子之间的交互作用，通过对因子进行归 因分析，评价不同因子对模型的贡献，同时也可以对未来陆地生态系统碳汇大小进行预测。模型模拟法的优势在于可定量区分不同因子对陆地碳汇变化的贡献，并可预测陆地碳汇的未来变化，其<strong>局限性</strong>主要包括：</p><ul><li>不同类型的模型在原理、结构和参数上存在差别，导致在陆地生态系统碳汇评估中存在很大的不确定性。</li><li>模型输入参数的固有误差和测量误差、模型参数相关作用产生的误差在应用过程中产生的误差传递最终都会误差累计到碳汇计算中。</li><li>传统经验模型缺少对估算结果机理性解释，物理模型(辐射传输、光能利用率模型)较为抽象，难以理解且缺少对于土壤呼吸的模拟。</li><li>过程模型将碳汇复杂的生物、物理、化学过程简化为几个主要的驱动因子，关键参数依赖经验设置，降低了碳汇估算的准确性。</li><li>模型方法很少会将生态系统人工管理措施考虑在内。</li></ul><h3 id="自上而下碳汇方法">👀"自上而下"碳汇方法</h3><p>陆地生态系统类型多样，分布范围广、异质性强，仅依靠地面观测数据难以满足大尺度陆地生态系统碳汇估算的需求。 因此，从数据获取角度出发，需要将地表点状观测拓展为空间上的面上监测，将定点定时的静态观测数据拓展为随时随地的动态观测，将局部的离散观测拓展为全局的连续观测。从20世纪70年代开始多光谱卫星、高光谱卫星、热红外传感器、激光雷达传感器、碳卫星陆续的发射并应用于陆地生态系统碳汇研究。 目前，应用遥感数据估算碳汇的发展趋势主要表现在4个方面：</p><ul><li><p>通过分析遥感数据植被指数、叶面积指数与地表植被的生产力的相关关系，构建统计模型估算生态系统生产力。</p></li><li><p>根据遥感数据构建光能利用率模型估算陆地生态系统的碳汇，常见的模型包括<code>CASA</code>模型、<code>BEPS</code>模型、基于MODIS卫星数据的<code>MODIS-GPP</code>模型、与涡度相关法相结合的<code>EC-LUE</code>模型。</p></li><li><p>基于卫星遥感数据中的日光诱导叶绿素荧光(SIF)与地表植被生产力之间的关系计算陆地生态系统碳汇。</p></li><li><p>利用大气<span class="math inline">\(CO_2\)</span>柱浓度观测数据，基于碳同化的方法反演生态系统碳通量，这是"自上而下"碳汇估算方法的基本原理。</p></li></ul><p>"自上而下"方法也是应用于陆地生态系统碳汇驱动因子分析的主要方法。陆地生态系统碳汇受多种因素影响，不仅包括土地利用/覆盖变化(森林砍伐、植树造林)等人类活动的直接影响，也包括<span class="math inline">\(CO_2\)</span>浓度增加、氮沉降、气溶胶等环境变化的影响，及温度、降水和光照等气候因素的影响。</p><h3 id="碳汇方法对比总结">👀碳汇方法对比总结</h3><p>通过对近年来中国陆地生态系统碳汇研究的文献进行梳理，总结相关的研究方法和结果，通过"自下而上"和"自上而下"两种方法估算的中国陆地生态系统碳汇大小为(0.07-1.91)<span class="math inline">\(Pg C/a\)</span>，其中：</p><ul><li><p>基于样地清查法估算的碳汇介于(0.13-0.31)<span class="math inline">\(Pg C/a\)</span></p></li><li><p>基于涡度相关法估算的中国区域碳汇介于(0.18-1.91)<span class="math inline">\(Pg C/a\)</span></p></li><li><p>基于模型法模拟的碳汇为(0.07-0.29)<span class="math inline">\(Pg C/a\)</span></p></li><li><p>"自上而下"方法反演得到的陆地生态系统碳汇为(0.28-1.11)<span class="math inline">\(Pg C/a\)</span></p></li></ul><p>通过比较两类碳汇估算方法可以看出，基于不同方法的我国陆地生态系统碳汇水平存在着明显的差异，"自上而下"方法计算的碳汇要普遍高于"自下而上"方法，这主要是因为"自上而下"方法假设化石燃料和非生物质燃料燃烧完全释放为<span class="math inline">\(CO_2\)</span>，未考虑其他的污染气体和非气态碳化合物，从而高估了大气中<span class="math inline">\(CO_2\)</span>的排放量，而基于"自下而上"的方法对于森林产品收获、水体沉积等从陆地生态系统碳库中转移部分缺乏考虑；此外，对于陆地生态系统的主体森林生态系统碳汇计算也存在很大的不确定性：对于森林定义的不同，统计的森林面积也有区别，森林碳汇往往只针对连片的森林乔木，对经济林、灌木林和其他类型林木较少纳入计算，这造成了森林生态系统碳汇水平的低估。</p><h2 id="集成遥感数据的碳汇估算模型">⛄集成遥感数据的碳汇估算模型</h2><p>21世纪初，伴随着对地物信息敏感的遥感观测数据的不断丰富与遥感处理技术的快速发展，时空异质性反映优势明显的集成遥感数据的陆地NPP估算模型逐渐兴起。尤其是近期多尺度、多分辨率遥感数据的出现，为模型参数时空特征的量化创造了有利的条件。同时结合遥感数据对植物生长机理与影响因素深入探讨，以及引入同化方法与耦合原理等新方法、新理论，为模型参数与结构的优化提供了新的思路。其中，遥感数据介入模型时主要采用两种方式：①同化方式，即结合遥感数据获取原非遥感参数；②驱动方式，即采用遥感数据构建模型参数。</p><h3 id="统计模型">👀统计模型</h3><p>植被指数(VI)、叶面积指数(LAI)等能反映植被长势状况；气候条件能影响植物生长发育过程。通过探讨VI、LAI、气象因子等与地面样点实测NPP之间的经验统计关系，构建统计模型，进而用于区域NPP估算。遥感数据大多用于反演VI、LAI，以驱动方式介入统计模型。依据考虑的因子个数，将目前应用较多的遥感数据驱动的统计模型划分为两类：</p><ul><li><p>第一类是基于VI或LAI等<strong>单个因子的线性或非线性关系模型</strong>，如简单线性回归、指数函数模型、幂函数模型、对数函数模型、移动平均回归及二次多项式函数模型等；</p></li><li><p>第二类是采用统计分析方法，考虑VI或LAI及<strong>气候条件</strong>等多类因子的综合模型。</p></li></ul><p>第一类统计模型发展过程中，利用以NDVI为代表的VI构建区域NPP估算模型最为常见。考虑到NDVI的地物表征适宜性及植被生长特征，NDVI不同使用方式为众多学者尝试，包括年内累积NDVI、生长季累积NDVI、每周NDVI、10天NDVI、年内平均NDVI、年内最大NDVI及某时间断面NDVI等。尽管NDVI与NPP相关性较好，但这种关系的强度受土地覆盖类型、土壤背景及土壤湿度等因素的影响。通过考虑这些因素，可构建精度较好的区域NPP估算模型。而从考虑土地覆盖类型角度来看，可通过以下三种方式提高区域NPP估算精度：①在植被(如草本、木本)混合生长区提取各自所占比例，进而基于NDVI等进行回归建模；②寻找不同土地覆盖类型区的基于NDVI等的最优关系模型；③选取多种植被指数(如RVI、NDVI、EVI、MSAVI及WDVI等)，获取不同土地覆盖类型最优关系，进而构建整合模型。由于植物生长过程受气候条件的影响，而第一类统计模型显然对于气候因素考虑欠缺，使得模型应用能力受到较大限制。通过相关性分析，结合VI或LAI及水分、温度、辐射等因子构建的综合模型，则是近期发展的第二类统计模型。</p><p>研究表明，<strong>日光诱导叶绿素荧光SIF</strong>与GPP在全球尺度上存在线性回归关系。在日光诱导荧光遥感方面的进一步探索，将为NPP估算提供新的思路。统计模型通过探讨VI、LAI及气候因子与NPP的经验统计关系，能在一定程度上估算区域NPP。但该方法尚存在以下 一些不足：</p><ul><li><p>对陆地生态系统过程与功能考虑不足，在植物物理和生理等机理解释方面存在一定局限。</p></li><li><p>在应用能力方面存在不足。目前主要关注自然植被类型(尤其是草地)，对于受人为影响较大的耕地、园地等土地覆盖类型变化较大的农用地研究不足；对于各土地覆盖类型在不同时期采用的VI类型等缺乏系统分析；现有统计模型一般建立在一定的时空尺度上，具有时空依赖性；统计模型是基于地面观测数据和遥感数据而建立，无法应用于预测研究。</p></li><li><p>模型构建存在不确定性。样地代表性及其观测的方法、遥感数据的质量及其对象适宜性等均可对研究结果产生较大影响。</p></li></ul><h3 id="光能利用率模型">👀光能利用率模型</h3><p>植被吸收的太阳辐射(APAR)与其生产力呈强相关，光能利用率(<span class="math inline">\(\varepsilon ^*\)</span>)可表示为同化过程中存储的化学能与吸收的太阳辐射的比值，二者的乘积可用来表征植被生产力；但二者受温度、水分、大气<span class="math inline">\(CO_2\)</span>浓度等外部条件限制。这一资源平衡原理，为光能利用率模型构建的理论基础。利用光能利用率模型估算NPP时有两种方式：</p><ul><li><p>一是以NPP为直接因变量；</p></li><li><p>二是以GPP为直接因变量，考虑自养呼吸或碳利用效率，间接估算NPP。</p></li></ul><blockquote><p><strong>常见的光能利用率模型：</strong>CASA模型、TEC模型、VPM模型、EC-LUE模型、3PG模型、AgI-LUE模型、C-Fix模型、TL-LUE模型、TL-LUEn模型、Modis-derived NPP模型、Beams模型、PEM模型、TURC模型、SEBAL模型、GEO-LUE模型、GLO-PEM模型、C-FLUX模型、<span class="math inline">\(N_{NPP}\)</span>模型。</p></blockquote><p>由于参数简单易得、具有一定机理性及遥感介入优势明显等原因，这类模型成为学者们研究区域NPP遥感估算的重点。不同光能利用率模型由于对土地覆盖类型、植被吸收光合有效辐射比(FPAR)、环境限制因子、光合有效辐射(PAR)及最大光能利用率(<span class="math inline">\(\varepsilon ^*\)</span>)等参数的考虑不同而存在差异。遥感数据介入光能利用率模型时，在土地覆盖类型和FPAR等方面，主要表现为驱动方式；在环境限制因子、PAR和<span class="math inline">\(\varepsilon ^*\)</span>方面，则主要表现为同化方式。通过对目前应用较多的集成遥感数据的光能利用率模型进行分析，从以下几方面论述模型特点及其发展过程：</p><ul><li>土地覆盖类型可从研究对象角度影响模型构建与应用，以不同土地覆盖类型为研究对象而建立的相应模型，其应用对象适宜性存在差异。</li><li><span class="math inline">\(\varepsilon ^*\)</span>影响模型估算的NPP结果，在各模型中由于取值方式、研究对象、时空尺度等原因而存在取值差异。<span class="math inline">\(\varepsilon ^*\)</span>取值时，则主要通过涡度通量观测、统计数据反演、样点实测反演及文献结果提取等方式获取对象(考虑时间、空间或土地覆盖类型等)适宜值。在土地覆盖类型混合区，可通过对区内各土地覆盖类型的<span class="math inline">\(\varepsilon ^*\)</span>进行加权平均，进而获取区内植被<span class="math inline">\(\varepsilon ^*\)</span>；而考虑到阴叶、阳叶光合作用差异，可将植被<span class="math inline">\(\varepsilon ^*\)</span>分为阴叶、阳叶；由于不同时空尺度下<span class="math inline">\(\varepsilon ^*\)</span>存在差异，还应详细考虑<span class="math inline">\(\varepsilon ^*\)</span>在区域NPP估算中的应用。学界对于<span class="math inline">\(\varepsilon ^*\)</span>的取值存在争议，因此这方面仍有待进一步研究。</li><li>光能利用率模型最初多利用辐射站点的太阳辐射数据获取PAR，但由于辐射站点较少，在中小尺度区域的应用受到限制。因此，采用气象站点数据与辐射站点数据的回归关系获取气象站点下的PAR，在某种程度上可以实现对辐射站点数据的加密。而从点到面的区域PAR估算则经历了由格网插值(尤其是克里金插值)到ANUSPLIN样条插值，由未考虑地形到考虑地形的过程。随着这些估算方式的改进，模型参数估算精度得到了提高，模型应用能力也相应得到了提高。从点数据推测面数据在一定程度上能获取区域PAR，但面数据的直接获取可能将进一步提高模型的估算精度。因此，近期基于遥感数据的区域PAR估算方法被逐步引入光能利用率模型。特别地，鉴于云层状况对光合作用的影响，对太阳辐射中的直接辐射和散射辐射分别加以考虑，将显著提高模型在有云条件下的模拟精度。</li><li>在一定尺度下，由FPAR产生的模型模拟不确定性可能大于气象数据。目前，在光能利用率模型中FPAR主要依据基于遥感数据获取的指标与其经验关系得到，相关指标主要有EVI、SR、NDVI、植被覆盖度FVC、植物覆盖比及叶面积指数LAI等。特别地，在<code>CASA</code>模型中，由于采用SR模拟时偏高，而采用NDVI模拟时偏低，因此一般常取由SR和NDVI模拟的FPAR的平均值；另外一部分模型，如<code>VPM</code>模型等，将FPAR分为光合部分和非光合部分，模拟植被生产力时多考虑光合作用部分的FPAR。</li><li>环境限制因子主要通过影响实际光能利用率(<span class="math inline">\(\varepsilon\)</span>)进而影响光合作用结果，不同模型对于这些环境限制因子的考虑不尽相同，原理或算法存在差异。<strong>温度</strong>(主要包括空气温度、土壤温度和植物生长温度等)和<strong>水分</strong>(包括土壤水分和水汽压差等)是光能利用率模型中的普遍限制因子。<strong>温度限制因子</strong>体现在高温、低温时植物内在生化作用对光合作用的限制，环境温度从最适温度向低温、高温变化时植物的光能转化率呈逐渐变小的趋势，还反映在对植物物候的影响等。<strong>水分限制因子</strong>主要反映植物所能利用的有效水分条件对光能利用率的影响，因此大部分模型考虑了土壤水分的影响；而水汽压差可通过影响气孔的开关状态进而影响光合作用、呼吸作用、蒸腾作用等，因而考虑水汽压差的模型也相对较多。除温度、水分之外，有些模型还考虑了其他因素：CO2施肥效应(<code>C-Fix</code>模型)、物候期(<code>VPM</code>模型)、林龄(<code>CFLUX</code>模型)及每月低于2℃的天数所占比例、冠层气孔导度及营养(<code>3PG</code>模型)等。多数模型采用最小值法或乘积法来表征对整体环境的限制。有研究表明，最小值法比乘积法更能整合多个环境限制因子对<span class="math inline">\(\varepsilon\)</span>的影响。</li><li>特别地，利用基于遥感数据的光化学指数PRI估算<span class="math inline">\(\varepsilon\)</span>，可能有助于提高光能利用率模型估算植被生产力的精度，可拓展光能利用率模型估算NPP的思路。</li></ul><p>光能利用率模型建立时采用不同的方式(体现在建模时针对不同土地覆盖类型、时空要求等而采用的参数计算过程存在差异)，导致模型的适用性特点不尽相同。<strong>从土地覆盖类型来看</strong>，<code>TURC</code>模型属于未考虑植被类型的通用性模型，因而对于不同地类的有效针对性存在不足；有些模型是针对具体地类而建立，模型适用性存在差别，例如 <span class="math inline">\(N_{NPP}\)</span>模型适用于草地、<code>SEBAL</code>模型适用于耕地等。<strong>从时间尺度来看</strong>，<code>C-FIX</code>、<code>MODIS-derived NPP</code>、<code>SEBAL</code>及<code>C-FLUX</code>等模型大多可用于计算日尺度NPP，这与模型中考虑的植被对环境因子的响应有关；而<code>VPM</code>、<code>CASA</code>等模型可基于遥感数据特点或研究对象，计算8天、10天、16天及月尺度NPP，时间拓展能力相对较强。<strong>从空间尺度来看</strong>，受气象数据与遥感数据的时空分辨率及不同区域植被功能型差异限制等，目前大多数模型为针对县以上区域进行NPP估算，基于镇域、小矿区、土地整治区等特定的大范围小尺度区域研究相对较少。</p><p>集成遥感数据的光能利用率模型机理性较好(相对于统计模型而言)、参数较少、时空拓展性较好，在区域尺度应用较普遍。但多数模型的主要参数一般基于经验关系得到，使其面临诸多不确定性。除太阳总辐射与PAR的关系、植被非光合作用部分对PAR的影响、PAR与APAR的关系、不同状态(包括类型、生长阶段及外部环境条件等)下的植物呼吸消耗、地下部分NPP等测算存在不确定性之外，多数模型对于时空尺度(例如随时间尺度的增大，<code>TL-LUE</code>模型、<code>TL-LUEn</code>模型与<code>MOD17</code>模型差异逐渐减少)、土地覆盖变化(例如同一块耕地，玉米、大豆隔年耕种，会导致其<span class="math inline">\(\varepsilon\)</span>模拟相对困难)以及影响<span class="math inline">\(\varepsilon\)</span>的冠层结构、氮的分布等也考虑不足。</p><h3 id="过程模型">👀过程模型</h3><p>通过对植物光合作用、蒸腾蒸发、呼吸作用、土壤湿度变化、有机物分解以及碳、氮、营养物质的动态过程等进行模拟，结合土壤、气象及植物生理学参数等，建立植被生产力估算模型，称为过程模型。模拟碳循环的过程模型数量众多，但多以气象、土壤等数据为驱动。现有集成遥感数据的过程模型多由遥感数据以同化方式介入生成，且数量较少。相关过程模型主要有<code>TEM</code>模型、<code>BEPS</code>模型、<code>Biome-BGC</code>模型、<code>InTEC</code>模型、<code>EPPML</code>模型、<code>SiB2</code>模型及<code>MOD-Sim-CYCLE</code>模型等。上述模型在发展早期，主要利用基于遥感数据获取的VI、LAI、FPAR、冠层绿度比及物候等作为模型光合作用部分的基础参数。相较于仅采用气象、土壤数据的过程模型，遥感数据的引入使相关模型应用能力得到了较大提升。</p><p>近年来，为提高集成遥感数据的过程模型适用性，众多学者相继开展探索，重点为<strong>模型结构优化</strong>和<strong>参数优化</strong>两方面。就模型结构优化而言，主要包括引入新的参数以及调整原有算法结构。就参数优化而言，主要包括利用同化数据如模型模拟数据(<code>MODIS GPP</code>、<code>BEPS</code>模拟结果等)或通量观测数据等，基于迭代优化等方法对关键参数进行优化，以及改进参数数据输入等。特别地，利用基于遥感数据获取的叶绿素含量指代最大羧化速率<span class="math inline">\(V_{cmax}\)</span>估算植被生产力，为集成遥感数据的过程模型发展提供了新的思路。相比于其他类模型，<strong>集成遥感数据的过程模型以植被-土壤-大气连续体为研究对象</strong>，机理性较强；但同时参数较多且复杂，导致其应用相对较少。当前，集成遥感数据的过程模型构建与发展存在以下问题：</p><ul><li>模型构建问题。植物的生理生态过程复杂，至今认识仍有限，致使模型构建仍存在诸多经验过程，无法清晰地解释植物在不同生长阶段、不同环境条件下的生物地球化学过程、生物地理过程与生物物理过程(例如同一植被在不同生长阶段的结构状态、在不同区域或不同干扰下的适应特征等)。</li><li>模型应用问题。当前过程模型中对于植被分类精度以及所讨论的植被类型相对有限，许多类型植被的相关研究不足；模型本地化过程中由于缺乏相应参数或验证数据(如通量观测或其他实测数据)而存在参数优化困难等问题；由于模型构建时，将时空信息反映较差的气象、土壤及水文等传统观测数据整合到植物光合作用过程，导致模型时间、空间扩展能力相对较差(目前多数模型以日时间尺度、中大区域以上空间尺度为主)，限制模型在其他时空尺度的应用。</li><li>模型数据问题。模型高精度模拟的特点对参数要求较高，而当前基础数据相对缺乏，所需初始数据和驱动数据的更新缓慢、精度有限；目前以同化方式介入为主的遥感数据的参与，尽管在一定程度上能提高过程模型应用能力，但作用相对有限(多用于光合作用过程模拟)，即遥感数据介入过程模型的能力有待提高。</li></ul><h3 id="耦合模型">👀耦合模型</h3><p>统计模型是基于经验统计关系建立的模型，尽管其空间异质性反映较好，但在植物物理和生理等机理解释方面存在明显局限。过程模型是基于叶片、冠层尺度的生理生态学分析而建立的"自下而上"模型，这类模型在利用试验点模拟外推至区域尺度时存在较大的不确定性，且难以充分反映景观的异质性。光能利用率模型是基于资源平衡理论而建立的"自上而下"模型，能较好地反映景观异质性，但缺乏充分解释物理现象的生理生态学机理。</p><p>为实现NPP的跨尺度高精度模拟，有学者对二者进行耦合，<code>GLOPEM-CEVSA</code>模型便是典型的基于光能利用率模型与过程模型的耦合模型，并在站点尺度得到了验证。<code>GLOPEM-CEVSA</code>模型在总初级生产力估算部分采用<code>GLOPEM</code>模型的算法，并在自养呼吸部分考虑了植物生理生态学过程机理，而非简单经验关系。初始化过程中需迭代运行至生态系统(植被和土壤碳库)平衡状态。它综合了过程模型与光能利用率模型的优点，较好地融合了气象数据、土壤数据及遥感数据(以驱动方式介入模型为主)等多源数据，一方面增加了模型机理性，另一方面增强了空间异质性反映。</p><p>然而，耦合模型由于复杂性程度仍高于光能利用率模型，参数、算法要求较高，并且与过程模型的整合也存在一定的困难，因此，耦合模型在当前应用与发展上存在理论与技术瓶颈。</p><h3 id="碳同化反演模型">👀碳同化反演模型</h3><p>基于<span class="math inline">\(CO_2\)</span>浓度观测数据的大气反演模型是近年来发展的陆地生态系统碳汇计算的新技术。它可以获取地面及高空的大区域的<span class="math inline">\(CO_2\)</span>三维空间数据，远距离实现对<span class="math inline">\(CO_2\)</span>气体的实时监测，不仅可以获取化石燃料燃烧排放的<span class="math inline">\(CO_2\)</span>信息，也可以监测生态系统中地—气<span class="math inline">\(CO_2\)</span>浓度变化。在2019年新修订的IPCC国家温室气体清单指南中，明确增加了基于<span class="math inline">\(CO_2\)</span>浓度观测的自上而下碳同化反演估算温室气体源⁃汇状况的方法，并可以作为独立数据验证排放因子法和过程模型法等自下而上的碳源汇估算模型。为了弥补地面<span class="math inline">\(CO_2\)</span>观测站点数量少的不足，多个国家先后发射了碳卫星应用于监测空间<span class="math inline">\(CO_2\)</span>浓度变化。联合卫星遥感数据和地面大气<span class="math inline">\(CO_2\)</span>浓度、站点通量数据和遥感地表参数等数据是全球碳同化系统的发展趋势。</p><p>大气反演法是基于大气传输模型和大气<span class="math inline">\(CO_2\)</span>浓度观测数据，并结合人为源<span class="math inline">\(CO_2\)</span>排放清单，估算陆地碳汇。大气反演法的优点在于其可实时评估全球尺度的陆地碳汇功能及其对气候变化的响应。大气反演法的<strong>局限性</strong>主要包括：</p><ul><li>遥感数据的时空分辨率较低、模型理论研究支撑不足，不能准确区分不同类型生态系统碳汇。</li><li>受传感器特性、大气辐射偏差、星下点角度等因素的影响，遥感数据出现的偏差。</li><li>大气<span class="math inline">\(CO_2\)</span>观测点的数量与分布格局(观测站主要分布在北美和欧洲，发展中国家地区观测站分布非常有限)、大气传输模型和同化方法的差异及不确定性、<span class="math inline">\(CO_2\)</span>排放清单(如化石燃料燃烧碳排放)的不确定性都会影响陆地生态系统碳汇的准确性。</li><li>大气反演法普遍未考虑非<span class="math inline">\(CO_2\)</span>形式的陆地与大气之间的碳交换，以及国际贸易导致的碳排放转移。</li></ul><p>总的来说，随着目标区域变小，大气反演结果的不确定性逐渐增大；就国家尺度而言，即使是具有较多的大气<span class="math inline">\(CO_2\)</span>观测站点的欧美国家，大气反演结果的不确定性也不可忽视。</p><h2 id="面临的挑战与展望">⛄面临的挑战与展望</h2><h3 id="面临的挑战">👀面临的挑战</h3><p>基于遥感数据估算NPP的模型研究成果丰硕，学术界通过对估算模型不断地改进、完善，大大提高了模型的应用能力。但目前集成遥感数据的NPP估算模型发展仍面临诸多挑战：</p><ul><li><strong>模型验证相对困难</strong>。当前主要采用通量观测、统计数据、其他模型结果、实地采样等数据来验证模型模拟结果，但这些数据使用时均存在局限性。①通量观测被认为是目前四种方法中较为精确的手段，能连续实时地观测碳等通量，但通量观测站仪器较为昂贵、站点数量少、站点所在土地覆盖类型相对有限；②统计数据一般为县域以上尺度数据，空间性反映不足，且受主观因素影响，数据不确定性较大；③不同模型结果由于模型模拟时所采用的步长、空间分辨率、使用的数据源等的差异而造成可比性较差；④实地采样则表现为数据获取困难，样点的代表性、适宜性及取样过程等均存在不确定性，且向区域及以上尺度推广困难。</li><li><strong>模型的生理生态机理尚未明晰</strong>。例如，不同植被对区域环境变化存在一定的自适应过程，即植被对环境响应存在差异，直接导致植被气候响应过程量化困难，而相应问题在现有模型中较少得到体现。另外，现有模型大多对生理生态过程进行了不同程度的简化，例如部分参数是通过经验关系获取，部分参数因为野外实验较为困难而采用常数值，均导致实际值与模拟结果存在一定的偏差等。</li><li><strong>模型应用存在诸多问题</strong>。①模型在矿区、土地整治区、土壤污染修复区以及城郊区等受人为干扰以及气象灾害、极端事件(林火、虫害)等自然干扰较强区域的研究与应用相对缺乏；②模型应用时所需遥感反演参数，已有产品精度有限(主要是由于卫星遥感传感器的时空分辨率局限等原因导致目前绝大部分产品的空间分辨率≤1km)；③参数厘定时对土地覆盖变化(如耕地作物种植的年内或年际变化等)考虑较少，涉及具体种类时通常按所属土地覆盖大类或相近类型进行处理；④在区域尺度应用时，模型本地化困难，例如光能利用率模型中最大光能利用率的取值问题，统计模型需重新构建经验关系问题，过程模型需进行相应参数优化(如BEPS模型中的最大羧化速率等)问题等；⑤数据处理技术存在不足，例如在数据融合技术(多源数据的融合需求)、数据计算能力(随着相应数据时空精度要求的提高，其数据量增量巨大)方面亟待加强。</li></ul><h3 id="展望">👀展望</h3><p>遥感手段的大尺度、动态实时观测等自身特点决定了其将具有很好的发展前景，在GPP/NPP/NEP估算模型中参数的量化及时空动态的表征能力等方面，具有传统统计观测手段所无法比拟的优势。当前，遥感数据的快速增加，众多遥感数据的免费提供，遥感观测形式的多样化，以及遥感处理技术水平的不断提高等，必将大大促进GPP/NPP/NEP估算模型的发展。</p><ul><li><strong>融合多学科视野，深入研究GPP/NPP/NEP的形成机理与影响因素</strong>。GPP/NPP/NEP形成过程复杂，涉及众多学科，这些学科的发展将促进GPP/NPP/NEP估算模型的发展。在理论上，借助于植物学、生态学、水文学、气象学、土壤学、物理学及灾害学等学科，可进一步认识GPP/NPP/NEP形成过程与影响因素，如土壤因素(有机质、营养及重金属含量等土壤性状)、气候因素(受雾霾、地形、云层及地物等影响的太阳辐射、温度及降水等)、水分因素(水分转移过程、水质条件等)、空气因素(<span class="math inline">\(CO_2\)</span>浓度与含氮量等)、植物因素(植物的结构、生长过程特点、光合作用、呼吸作用、蒸腾作用及环境自适应能力等)及外界干扰因素(虫害等自然灾害、人为干扰等)等。</li><li><strong>加快发展空天地一体化观测体系</strong>，为GPP/NPP/NEP估算模型提供大范围、长时间、高精度的遥感、地面观测及验证数据。强化由侧重单一源遥感(常规多光谱遥感)向完善多源遥感(荧光遥感、激光雷达、合成孔径雷达等)、由卫星遥感向融合航空(无人机遥感等)和地面遥感、由多光谱遥感向高光谱遥感、由低时空分辨率遥感向高时空分辨率遥感等方向发展。完善通量观测、实验站点、气象站点、辐射站点及常规统计等地面观测网络。</li><li><strong>提高遥感处理技术与地物信息识别能力</strong>，挖掘模型参数遥感化潜力，提高遥感产品适用性。①发展融合技术、同化算法，充分利用多源数据优势挖掘地物信息；②提高遥感数据处理技术，充分拓展荧光遥感、微波遥感等的应用能力；③加快探索新的遥感化参数，如基于遥感数据获取的日光诱导叶绿素荧光SIF、光化学指数PRI、叶绿素含量Chll等在GPP/NPP/NEP估算中的应用潜力；④充分整合现有遥感产品，如30m全球土地覆盖、GLASS地表参数等产品，并针对当前遥感产品空间分辨率大多不高于1km、时间分辨率相对较低(如土地覆盖产品更新缓慢)的缺陷，加快发展遥感手段和利用遥感观测数据生产高精度产品，例如加快开发基于高分四号、风云三号、资源三号等卫星的地表参数产品等，以此推进GPP/NPP/NEP估算模型的发展与应用。</li><li><strong>拓展GPP/NPP/NEP估算模型的时空尺度</strong>。由于地学现象的普遍复杂性，尺度转换是GPP/NPP/NEP估算建模过程中的重要科学问题。在一定空间分辨率的遥感数据下，空间尺度的差异往往导致像元的异质性，进而影响GPP/NPP/NEP估算的精度及模型的适用性，这一问题在时间尺度也同样存在。目前，学者已尝试建立不同时空尺度的GPP/NPP/NEP遥感估算模型，通过站点尺度的验证，在区域等较大尺度上取得了积极的研究进展。然而大多数研究仍局限于特定时空尺度，仍有必要充分考虑区域适宜性、地类适宜性及植被适宜性，加强GPP/NPP/NEP估算模型的综合集成，进一步完善相应的时空尺度转换技术。</li><li><strong>加快构建数据共享网络，增强模型估算GPP/NPP/NEP的软硬件支撑</strong>。模型复杂性是相对的，与数据来源、处理能力等存在关联。要借助发展日趋成熟的互联网构建共享网络，提高已有数据使用效率，进而促进GPP/NPP/NEP估算模型的发展。另外，鉴于数据的大量产生(例如高精度的数据必然带来数据量级倍增、多源数据的发展使数据源分析复杂化等)，必须开发或引入相应的数据处理方法、软件与存储设备等，以提高大数据处理能力，进而为大区域高精度GPP/NPP/NEP估算服务。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 遥感反演 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 碳汇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常见大气校正模型及6S模型安装部署【20241028】</title>
      <link href="/2024/10/28/Py6S-Model-Use/"/>
      <url>/2024/10/28/Py6S-Model-Use/</url>
      
        <content type="html"><![CDATA[<h2 id="常见大气校正模型">⛄常见大气校正模型</h2><p>大气校正是遥感图像标准化处理的重要环节，消除太阳辐射传输过程中大气对于遥感图像的影响，提高影像的清晰度，获取地物真实的光谱信息。由于大气条件较为复杂，且随区域地理分布和观测时间是动态变化的，国内外研究学者进行大量的研究工作，目前大气校正算法主要包括：基于辐射传输模型的大气校正算法、基于经验统计模型的大气校正和神经网络大气校正算法。</p><p><strong>基于辐射传输模型的大气校正方法</strong>主要包括<code>LOWTRAN</code>模型、<code>MODTRAN</code>模型、<code>FLAASH</code>模型、<code>6S</code>模型等，该方法充分考虑辐射传输过程中大气以及临近效应等的影响，是利用电磁波在大气中的辐射传输原理构建起来的，设置合适的大气校正参数是其最为关键的步骤，合适的参数能够反映大气分子、气溶胶等粒子的散射和水汽、臭氧等物质的吸收过程。<strong>基于经验统计模型的大气校正方法</strong>主要包括经验线性法、暗像元法、<code>QUAC</code>模型等，利用先验知识或实测数据，直接由遥感图像自身消除大气影响。<strong>神经网络方法</strong>是一种有效的非线性逼近方法，是功能强大且灵活多变的大气校正方法。</p><p><strong>Sen2cor</strong>是欧空局官方提供的<code>Sentinel2 MSI</code>影像的大气校正方法，用于生成<code>L2</code>级陆地产品。该算法是一种半经验算法，集成了基于图像检索和<code>LibRadtran</code>(辐射传输计算软件包)模型的查找表(<code>Look-Up-Tables</code>, <code>LUTs</code>)，以消除<code>S2 MSI</code>影像的大气影响。该方法将生成的大气校正查找表集成在程序中，这一操作简化了操作流程并缩短了程序运行的时间。</p><p><strong>La SRC</strong>是美国地质勘探局(<code>USGS</code>)专门为<code>Landsat8</code>数据设计的大气校正程序，主要用于支持地面遥感应用。USGS仅提供美国境内的<code>La SRC</code>产品，所以国内无法利用<code>La SRC</code>来进行大气校正，但<code>RSD</code>(Remote Sensing Desktop)软件引进了该算法的核心代码，重写全部流程管理代码，可以实现国内产品的<code>La SRC</code>大气校正，对相同数据集的<code>RSD L8</code>大气校正和<code>USGS LaSRC</code>产品进行对比，其差异可以忽略不计，所以可以用<code>RSD L8</code>来替代<code>La SRC</code>产品。</p><p><strong>ACOLITE</strong>是由比利时皇家自然科学研究所开发的<code>Landsat8 OLI</code>和<code>Sentinel2 MSI</code>处理软件，该软件用于校正沿海和内陆水域的图像，是一个完全基于图像的处理器。<code>ACOLITE</code>有两种内置大气校正方法，分别是指数外推(EXP)和暗光谱拟合(DSF)，DSF是通过自动搜索场景或子场景中的暗目标来构建光谱，从而来计算大气路径反射率，而不预先定义暗带，对气溶胶的空间变异性具有鲁棒性，与EXP算法相比有更好的应用潜力.</p><p><strong>iCOR</strong>是一种基于场景的大气校正处理器，可以处理沿海、内陆或过渡水域和陆地上收集的卫星数据。该处理器包括以下步骤：基于近红外842nm波段识别陆地和水的像元；使用陆地像元来推导气溶胶光学厚度，并使用<code>SIMEC</code>对水域和陆地目标的固定背景范围进行邻接校正；最后求解辐射传输方程。利用<code>SNAP</code>中的<code>iCOR</code>插件来完成<code>iCOR</code>大气校正(需配置Python2.7相关环境)。</p><blockquote><p><strong>参考文献（模型的详细阐述）：</strong></p><p><strong>[1]张焕炜.Landsat-8大气校正水陆邻近像元效应改进模型及在水深遥感的应用研究[D].2023.</strong></p><p><strong>[2]李海翠.鄱阳湖大气校正方法适用性评价研究[D].江西理工大学,2022.</strong></p></blockquote><h2 id="s大气校正模型">⛄6S大气校正模型</h2><p><code>6S</code>大气校正模型是美国马里兰大学地理系Vermote等人于1997年在5S模型的基础上改进的，很好地模拟太阳光在太阳－地面目标－传感器的传输过程中所受到的大气影响。相对<code>5S</code>模型，<code>6S</code>模型考虑了地面目标的海拔高度、非朗伯平面的情况和新的吸收气体种类(<code>CH4</code>，<code>N2O</code>，<code>CO</code>)，提高了瑞利和气溶胶散射作用的计算精度。光谱步长提高到了2.5nm。<code>6S</code>模型建立在辐射传输理论基础之上，模型应用范围广，不受研究区特点及目标类型等的影响。</p><blockquote><p><code>Py6S</code>只是<code>6S</code>模型的一个接口，没有可执行的编译文件。如果只安装<code>Py6S</code>会提示如下错误信息，所以需要编译制作可执行文件。</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 测试</span></span><br><span class="line"><span class="keyword">from</span> Py6S <span class="keyword">import</span> *</span><br><span class="line"><span class="built_in">print</span>(SixS.test())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出异常</span></span><br><span class="line">6S wrapper script by Robin Wilson</span><br><span class="line">Error: cannot find the sixs executable <span class="keyword">in</span> $PATH <span class="keyword">or</span> current directory.</span><br><span class="line"><span class="literal">None</span></span><br></pre></td></tr></table></figure><h3 id="s模型安装">👀6S模型安装</h3><p><strong>（1）安装包准备</strong></p><ul><li><p><code>x86_64-8.1.0-release-win32-seh-rt_v6-rev0.7z</code>（<code>mingw64</code>）</p></li><li><p><code>make-3.81.exe</code></p></li><li><p><code>tar-1.13-1-bin.exe</code></p></li><li><p><code>Fort99.zip</code></p></li><li><p><code>6SV-1.1.tar</code></p></li><li><p><code>Py6S-1.9.2.tar.gz</code></p></li></ul><p>安装包打包下载地址：<a href="https://download.csdn.net/download/twg666/89930630">安装包链接</a>（https://download.csdn.net/download/twg666/89930630）</p><p><strong>（2）mingw64安装及测试</strong></p><p>下载压缩包<code>x86_64-8.1.0-release-win32-seh-rt_v6-rev0.7z</code>，解压缩并放置对应路径，配置环境变量。</p><ul><li><p>配置步骤：我的电脑→属性→高级系统设置→选择环境变量→系统变量→选择"<code>Path</code>"→添加环境变量（<code>mingw</code>的<code>bin</code>文件的路径）。</p></li><li><p>命令测试：<code>CMD</code>命令行中输入<code>g++ -v</code>、<code>gcc -v</code>、<code>gdb -v</code>命令，显示对应的版本信息即可。</p></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 小编mingw64的bin路径</span></span><br><span class="line">D:\Py6S\mingw64\<span class="built_in">bin</span></span><br><span class="line">    </span><br><span class="line"><span class="comment"># mingw64测试，CMD命令行中输入以下命令。</span></span><br><span class="line">Microsoft Windows [版本 <span class="number">10.0</span><span class="number">.22631</span><span class="number">.4317</span>]</span><br><span class="line">(c) Microsoft Corporation。保留所有权利。</span><br><span class="line"></span><br><span class="line">C:\Users\twg&gt;g++ -v</span><br><span class="line">Using built-<span class="keyword">in</span> specs.</span><br><span class="line">COLLECT_GCC=g++</span><br><span class="line">COLLECT_LTO_WRAPPER=D:/Py6S/mingw64/<span class="built_in">bin</span>/../libexec/gcc/x86_64-w64-mingw32/<span class="number">8.1</span><span class="number">.0</span>/lto-wrapper.exe</span><br><span class="line">Target: x86_64-w64-mingw32</span><br><span class="line">Configured <span class="keyword">with</span>: ../../../src/gcc-<span class="number">8.1</span><span class="number">.0</span>/configure --host=x86_64-w64-mingw32 --build=x86_64-w64-mingw32 --target=x86_64-w64-mingw32 --prefix=/mingw64 --<span class="keyword">with</span>-sysroot=/c/mingw810/x86_64-<span class="number">810</span>-win32-seh-rt_v6-rev0/mingw64 --enable-shared --enable-static --disable-multilib --enable-languages=c,c++,fortran,lto --enable-libstdcxx-time=yes --enable-threads=win32 --enable-libgomp --enable-libatomic --enable-lto --enable-graphite --enable-checking=release --enable-fully-dynamic-string --enable-version-specific-runtime-libs --disable-libstdcxx-pch --disable-libstdcxx-debug --enable-bootstrap --disable-rpath --disable-win32-registry --disable-nls --disable-werror --disable-symvers --<span class="keyword">with</span>-gnu-<span class="keyword">as</span> --<span class="keyword">with</span>-gnu-ld --<span class="keyword">with</span>-arch=nocona --<span class="keyword">with</span>-tune=core2 --<span class="keyword">with</span>-libiconv --<span class="keyword">with</span>-system-zlib --<span class="keyword">with</span>-gmp=/c/mingw810/prerequisites/x86_64-w64-mingw32-static --<span class="keyword">with</span>-mpfr=/c/mingw810/prerequisites/x86_64-w64-mingw32-static --<span class="keyword">with</span>-mpc=/c/mingw810/prerequisites/x86_64-w64-mingw32-static --<span class="keyword">with</span>-isl=/c/mingw810/prerequisites/x86_64-w64-mingw32-static --<span class="keyword">with</span>-pkgversion=<span class="string">&#x27;x86_64-win32-seh-rev0, Built by MinGW-W64 project&#x27;</span> --<span class="keyword">with</span>-bugurl=https://sourceforge.net/projects/mingw-w64 CFLAGS=<span class="string">&#x27;-O2 -pipe -fno-ident -I/c/mingw810/x86_64-810-win32-seh-rt_v6-rev0/mingw64/opt/include -I/c/mingw810/prerequisites/x86_64-zlib-static/include -I/c/mingw810/prerequisites/x86_64-w64-mingw32-static/include&#x27;</span> CXXFLAGS=<span class="string">&#x27;-O2 -pipe -fno-ident -I/c/mingw810/x86_64-810-win32-seh-rt_v6-rev0/mingw64/opt/include -I/c/mingw810/prerequisites/x86_64-zlib-static/include -I/c/mingw810/prerequisites/x86_64-w64-mingw32-static/include&#x27;</span> CPPFLAGS=<span class="string">&#x27; -I/c/mingw810/x86_64-810-win32-seh-rt_v6-rev0/mingw64/opt/include -I/c/mingw810/prerequisites/x86_64-zlib-static/include -I/c/mingw810/prerequisites/x86_64-w64-mingw32-static/include&#x27;</span> LDFLAGS=<span class="string">&#x27;-pipe -fno-ident -L/c/mingw810/x86_64-810-win32-seh-rt_v6-rev0/mingw64/opt/lib -L/c/mingw810/prerequisites/x86_64-zlib-static/lib -L/c/mingw810/prerequisites/x86_64-w64-mingw32-static/lib &#x27;</span></span><br><span class="line">Thread model: win32</span><br><span class="line">gcc version <span class="number">8.1</span><span class="number">.0</span> (x86_64-win32-seh-rev0, Built by MinGW-W64 project)</span><br><span class="line"></span><br><span class="line">C:\Users\twg&gt;gcc -v</span><br><span class="line">Using built-<span class="keyword">in</span> specs.</span><br><span class="line">COLLECT_GCC=gcc</span><br><span class="line">COLLECT_LTO_WRAPPER=D:/Py6S/mingw64/<span class="built_in">bin</span>/../libexec/gcc/x86_64-w64-mingw32/<span class="number">8.1</span><span class="number">.0</span>/lto-wrapper.exe</span><br><span class="line">Target: x86_64-w64-mingw32</span><br><span class="line">Configured <span class="keyword">with</span>: ../../../src/gcc-<span class="number">8.1</span><span class="number">.0</span>/configure --host=x86_64-w64-mingw32 --build=x86_64-w64-mingw32 --target=x86_64-w64-mingw32 --prefix=/mingw64 --<span class="keyword">with</span>-sysroot=/c/mingw810/x86_64-<span class="number">810</span>-win32-seh-rt_v6-rev0/mingw64 --enable-shared --enable-static --disable-multilib --enable-languages=c,c++,fortran,lto --enable-libstdcxx-time=yes --enable-threads=win32 --enable-libgomp --enable-libatomic --enable-lto --enable-graphite --enable-checking=release --enable-fully-dynamic-string --enable-version-specific-runtime-libs --disable-libstdcxx-pch --disable-libstdcxx-debug --enable-bootstrap --disable-rpath --disable-win32-registry --disable-nls --disable-werror --disable-symvers --<span class="keyword">with</span>-gnu-<span class="keyword">as</span> --<span class="keyword">with</span>-gnu-ld --<span class="keyword">with</span>-arch=nocona --<span class="keyword">with</span>-tune=core2 --<span class="keyword">with</span>-libiconv --<span class="keyword">with</span>-system-zlib --<span class="keyword">with</span>-gmp=/c/mingw810/prerequisites/x86_64-w64-mingw32-static --<span class="keyword">with</span>-mpfr=/c/mingw810/prerequisites/x86_64-w64-mingw32-static --<span class="keyword">with</span>-mpc=/c/mingw810/prerequisites/x86_64-w64-mingw32-static --<span class="keyword">with</span>-isl=/c/mingw810/prerequisites/x86_64-w64-mingw32-static --<span class="keyword">with</span>-pkgversion=<span class="string">&#x27;x86_64-win32-seh-rev0, Built by MinGW-W64 project&#x27;</span> --<span class="keyword">with</span>-bugurl=https://sourceforge.net/projects/mingw-w64 CFLAGS=<span class="string">&#x27;-O2 -pipe -fno-ident -I/c/mingw810/x86_64-810-win32-seh-rt_v6-rev0/mingw64/opt/include -I/c/mingw810/prerequisites/x86_64-zlib-static/include -I/c/mingw810/prerequisites/x86_64-w64-mingw32-static/include&#x27;</span> CXXFLAGS=<span class="string">&#x27;-O2 -pipe -fno-ident -I/c/mingw810/x86_64-810-win32-seh-rt_v6-rev0/mingw64/opt/include -I/c/mingw810/prerequisites/x86_64-zlib-static/include -I/c/mingw810/prerequisites/x86_64-w64-mingw32-static/include&#x27;</span> CPPFLAGS=<span class="string">&#x27; -I/c/mingw810/x86_64-810-win32-seh-rt_v6-rev0/mingw64/opt/include -I/c/mingw810/prerequisites/x86_64-zlib-static/include -I/c/mingw810/prerequisites/x86_64-w64-mingw32-static/include&#x27;</span> LDFLAGS=<span class="string">&#x27;-pipe -fno-ident -L/c/mingw810/x86_64-810-win32-seh-rt_v6-rev0/mingw64/opt/lib -L/c/mingw810/prerequisites/x86_64-zlib-static/lib -L/c/mingw810/prerequisites/x86_64-w64-mingw32-static/lib &#x27;</span></span><br><span class="line">Thread model: win32</span><br><span class="line">gcc version <span class="number">8.1</span><span class="number">.0</span> (x86_64-win32-seh-rev0, Built by MinGW-W64 project)</span><br><span class="line"></span><br><span class="line">C:\Users\twg&gt;gdb -v</span><br><span class="line">GNU gdb (GDB) <span class="number">8.1</span></span><br><span class="line">Copyright (C) <span class="number">2018</span> Free Software Foundation, Inc.</span><br><span class="line">License GPLv3+: GNU GPL version <span class="number">3</span> <span class="keyword">or</span> later &lt;http://gnu.org/licenses/gpl.html&gt;</span><br><span class="line">This <span class="keyword">is</span> free software: you are free to change <span class="keyword">and</span> redistribute it.</span><br><span class="line">There <span class="keyword">is</span> NO WARRANTY, to the extent permitted by law.  <span class="type">Type</span> <span class="string">&quot;show copying&quot;</span></span><br><span class="line"><span class="keyword">and</span> <span class="string">&quot;show warranty&quot;</span> <span class="keyword">for</span> details.</span><br><span class="line">This GDB was configured <span class="keyword">as</span> <span class="string">&quot;x86_64-w64-mingw32&quot;</span>.</span><br><span class="line"><span class="type">Type</span> <span class="string">&quot;show configuration&quot;</span> <span class="keyword">for</span> configuration details.</span><br><span class="line">For bug reporting instructions, please see:</span><br><span class="line">&lt;http://www.gnu.org/software/gdb/bugs/&gt;.</span><br><span class="line">Find the GDB manual <span class="keyword">and</span> other documentation resources online at:</span><br><span class="line">&lt;http://www.gnu.org/software/gdb/documentation/&gt;.</span><br><span class="line">For <span class="built_in">help</span>, <span class="built_in">type</span> <span class="string">&quot;help&quot;</span>.</span><br><span class="line"><span class="type">Type</span> <span class="string">&quot;apropos word&quot;</span> to search <span class="keyword">for</span> commands related to <span class="string">&quot;word&quot;</span>.</span><br></pre></td></tr></table></figure><p><strong>（3）make和tar安装</strong></p><ul><li><p>另一种方式：通过<a href="https://gnuwin32.sourceforge.net/packages.html">GnuWin32 Packages</a>下载，双击<code>make-3.81.exe</code>和<code>tar-1.13-1-bin.exe</code>，安装即可。</p></li><li><p>配置步骤：我的电脑→属性→高级系统设置→选择环境变量→系统变量→选择"<code>Path</code>"→添加环境变量（<code>make</code>的<code>bin</code>文件的路径）。</p></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 小编make的bin路径</span></span><br><span class="line">D:\Py6S\GnuWin32\<span class="built_in">bin</span></span><br></pre></td></tr></table></figure><p><strong>（4）Fort99安装</strong></p><ul><li><p>另一种方式：通过<a href="http://www.cse.yorku.ca/~roumani/fortran/ftn.htm">Free FORTRAN Compilers</a>下载后解压，不需要安装，直接放到安装路径。</p></li><li><p>配置步骤：我的电脑→属性→高级系统设置→选择环境变量→系统变量→选择"<code>Path</code>"→添加环境变量（<code>Fort99</code>的<code>bin</code>文件的路径）。</p></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 小编make的bin路径</span></span><br><span class="line">D:\Py6S\Fort99\G77\<span class="built_in">bin</span></span><br></pre></td></tr></table></figure><p><strong>（5）6SV-1.1下载—安装—编译</strong></p><ul><li><p>另一种方式：通过<a href="https://rtwilson.com/downloads/">Index of /downloads</a>下载（<a href="https://rtwilson.com/downloads/6SV-1.1.tar">链接直达</a>），解压并找到文件夹中的<code>Makefile</code>文件。</p></li><li><p>原始的<code>Makefile</code>文件：</p></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHELL = /bin/sh</span><br><span class="line">SYSTEM  = HP-UX</span><br><span class="line">EXTRA   = +FPVZOUD +O3 -D$(SYSTEM)</span><br><span class="line">EXTRA   = -g</span><br><span class="line">EXTRA   = -O</span><br><span class="line">FFLAGS=  $(EXTRA)</span><br><span class="line">CFLAGS = -Ae $(EXTRA)</span><br><span class="line">FC      = g77 $(FFLAGS)</span><br><span class="line">CC      = cc $(CFLAGS)</span><br><span class="line"></span><br><span class="line">OBJECTS0 = AATSR.o ABSTRA.o AEROSO.o AKTOOL.o ATMREF.o AVHRR.o BBM.o BDM.o BRDFGRID.o \</span><br><span class="line">CHAND.o CLEARW.o CSALBR.o DICA1.o DICA2.o DICA3.o  DISCOM.o \</span><br><span class="line">DISCRE.o DUST.o ENVIRO.o EQUIVWL.o GAUSS.o GLI.o GOES.o HAPKALBE.o \</span><br><span class="line">HAPKBRDF.o HRV.o IAPIALBE.o IAPIBRDF.o IAPITOOLS.o INTERP.o ISO.o \</span><br><span class="line">KERNEL.o KERNELPOL.o LAKEW.o MAS.o MERIS.o METEO.o METH1.o METH2.o METH3.o METH4.o \</span><br><span class="line">METH5.o METH6.o MIDSUM.o MIDWIN.o MIE.o MINNALBE.o MINNBRDF.o \</span><br><span class="line">MOCA1.o MOCA2.o MOCA3.o MOCA4.o MOCA5.o MOCA6.o MODIS.o MSS.o NIOX1.o \</span><br><span class="line">MODISBRDF.o MODISALBE.o \</span><br><span class="line">NIOX2.o NIOX3.o NIOX4.o NIOX5.o NIOX6.o OCEA.o OCEAALBE.o OCEABRDF.o OCEABRDFFAST.o\</span><br><span class="line">OCEATOOLS.o ODA550.o ODRAYL.o OS.o OSPOL.o OXYG3.o OXYG4.o OXYG5.o OXYG6.o \</span><br><span class="line">OZON1.o PLANPOL.o POLDER.o POSGE.o POSGW.o POSLAN.o POSMTO.o POSNOA.o POSSOL.o POSSPO.o \</span><br><span class="line">POLGLIT.o POLNAD.o  \</span><br><span class="line">PRESPLANE.o PRESSURE.o PRINT_ERROR.o RAHMALBE.o RAHMBRDF.o ROUJALBE.o \</span><br><span class="line">ROUJBRDF.o SAND.o SCATRA.o SEAWIFS.o SOLIRR.o SOOT.o SPECINTERP.o SPLIE2.o \</span><br><span class="line">SPLIN2.o SPLINE.o SPLINT.o STM.o SUBSUM.o SUBWIN.o TM.o TROPIC.o \</span><br><span class="line">TRUNCA.o US62.o VARSOL.o VEGETA.o VERSALBE.o VERSBRDF.o VERSTOOLS.o \</span><br><span class="line">WALTALBE.o WALTBRDF.o WATE.o WAVA1.o WAVA2.o WAVA3.o WAVA4.o WAVA5.o \</span><br><span class="line">WAVA6.o AEROPROF.o ALI.o ASTER.o ETM.o HYPBLUE.o VGT.o VIIRS.o</span><br><span class="line"></span><br><span class="line">OBJECTS1= main.o </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sixs: $(OBJECTS0) $(OBJECTS1) </span><br><span class="line">$(FC)  $(OBJECTS1) $(OBJECTS0) -o sixsV1.1  -lm</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">rm -f *.o</span><br></pre></td></tr></table></figure><ul><li>修改后的<code>Makefile</code>文件：</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（1）修改1</span><br><span class="line">第8行：FC = g77 $(FFLAGS)修改为：</span><br><span class="line">FC = gfortran -std=legacy -ffixed-line-length-none -ffpe-summary=none $(FFLAGS)</span><br><span class="line">（2）修改2</span><br><span class="line">将35行的-lm删去，并将sixsV1.1添加.exe</span><br><span class="line">$(FC)  $(OBJECTS1) $(OBJECTS0) -o sixsV1.1.exe</span><br></pre></td></tr></table></figure><p>完整版如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHELL = /bin/sh</span><br><span class="line">SYSTEM  = HP-UX</span><br><span class="line">EXTRA   = +FPVZOUD +O3 -D$(SYSTEM)</span><br><span class="line">EXTRA   = -g</span><br><span class="line">EXTRA   = -O</span><br><span class="line">FFLAGS=  $(EXTRA)</span><br><span class="line">CFLAGS = -Ae $(EXTRA)</span><br><span class="line">FC      = gfortran -std=legacy -ffixed-line-length-none -ffpe-summary=none $(FFLAGS)</span><br><span class="line">CC      = cc $(CFLAGS)</span><br><span class="line"></span><br><span class="line">OBJECTS0 = AATSR.o ABSTRA.o AEROSO.o AKTOOL.o ATMREF.o AVHRR.o BBM.o BDM.o BRDFGRID.o \</span><br><span class="line">CHAND.o CLEARW.o CSALBR.o DICA1.o DICA2.o DICA3.o  DISCOM.o \</span><br><span class="line">DISCRE.o DUST.o ENVIRO.o EQUIVWL.o GAUSS.o GLI.o GOES.o HAPKALBE.o \</span><br><span class="line">HAPKBRDF.o HRV.o IAPIALBE.o IAPIBRDF.o IAPITOOLS.o INTERP.o ISO.o \</span><br><span class="line">KERNEL.o KERNELPOL.o LAKEW.o MAS.o MERIS.o METEO.o METH1.o METH2.o METH3.o METH4.o \</span><br><span class="line">METH5.o METH6.o MIDSUM.o MIDWIN.o MIE.o MINNALBE.o MINNBRDF.o \</span><br><span class="line">MOCA1.o MOCA2.o MOCA3.o MOCA4.o MOCA5.o MOCA6.o MODIS.o MSS.o NIOX1.o \</span><br><span class="line">MODISBRDF.o MODISALBE.o \</span><br><span class="line">NIOX2.o NIOX3.o NIOX4.o NIOX5.o NIOX6.o OCEA.o OCEAALBE.o OCEABRDF.o OCEABRDFFAST.o\</span><br><span class="line">OCEATOOLS.o ODA550.o ODRAYL.o OS.o OSPOL.o OXYG3.o OXYG4.o OXYG5.o OXYG6.o \</span><br><span class="line">OZON1.o PLANPOL.o POLDER.o POSGE.o POSGW.o POSLAN.o POSMTO.o POSNOA.o POSSOL.o POSSPO.o \</span><br><span class="line">POLGLIT.o POLNAD.o  \</span><br><span class="line">PRESPLANE.o PRESSURE.o PRINT_ERROR.o RAHMALBE.o RAHMBRDF.o ROUJALBE.o \</span><br><span class="line">ROUJBRDF.o SAND.o SCATRA.o SEAWIFS.o SOLIRR.o SOOT.o SPECINTERP.o SPLIE2.o \</span><br><span class="line">SPLIN2.o SPLINE.o SPLINT.o STM.o SUBSUM.o SUBWIN.o TM.o TROPIC.o \</span><br><span class="line">TRUNCA.o US62.o VARSOL.o VEGETA.o VERSALBE.o VERSBRDF.o VERSTOOLS.o \</span><br><span class="line">WALTALBE.o WALTBRDF.o WATE.o WAVA1.o WAVA2.o WAVA3.o WAVA4.o WAVA5.o \</span><br><span class="line">WAVA6.o AEROPROF.o ALI.o ASTER.o ETM.o HYPBLUE.o VGT.o VIIRS.o</span><br><span class="line"></span><br><span class="line">OBJECTS1= main.o </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sixs: $(OBJECTS0) $(OBJECTS1) </span><br><span class="line">$(FC)  $(OBJECTS1) $(OBJECTS0) -o sixsV1.1.exe</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">rm -f *.o</span><br></pre></td></tr></table></figure><ul><li>编译</li></ul><p>通过<code>cmd</code>打开<code>6SV1.1</code>文件夹，输入<code>make</code>命令即可得到<code>sixsV1.1.exe</code>，最后测试是否生成成功。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(1)输入Make，等待......</span><br><span class="line">(2)sixsV1.1.exe &lt; ..\Examples\Example_In_1.txt</span><br></pre></td></tr></table></figure><p><a href="https://imgse.com/i/pA0ffLd"><img src="https://s21.ax1x.com/2024/10/28/pA0ffLd.jpg" alt="pA0ffLd.jpg" /></a></p><blockquote><p>注意：一定要通过"<code>cmd</code>"打开测试，如果通过<code>Windows PowerShell</code>打开，会显示"<code>&lt;运算符是为将来使用而保留的</code>"的异常信息。<strong>若成功，就将编译成功的sixsV1.1.exe重命名为sixs.exe放在C:\Windows\System32路径下。</strong></p></blockquote><h3 id="py6s库安装测试">👀Py6S库安装测试</h3><p>由于<code>Py6S-1.9.2.tar.gz</code>是<code>.tar.gz</code>格式的，不是<code>.whl</code>格式的。安装教程如下：</p><p>解压→<code>setup.py</code>→<code>cmd</code>命令行切换到该目录→执行命令<code>Python.exe setup.py install</code>。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Py6S <span class="keyword">import</span> *</span><br><span class="line"><span class="built_in">print</span>(SixS.test())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果，成功标志如下：</span></span><br><span class="line">6S wrapper script by Robin Wilson</span><br><span class="line">Using 6S located at C:\WINDOWS\system32\sixs.exe</span><br><span class="line">Running 6S using a <span class="built_in">set</span> of test parameters</span><br><span class="line">6sV version: <span class="number">1.1</span></span><br><span class="line">The results are:</span><br><span class="line">Expected result: <span class="number">619.158000</span></span><br><span class="line">Actual result: <span class="number">619.158000</span></span><br><span class="line"><span class="comment">#### Results agree, Py6S is working correctly</span></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure><p><strong>基于6S模型Landsat8/Sentinel2/GF大气校正的具体应用：</strong><a href="https://github.com/Zhaoguanhua/AtmosphericCorrection">基于6S模型的多源影像大气校正工程</a></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> 大气校正 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 6S模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GUI编程之MATLAB入门详解（01）</title>
      <link href="/2024/09/23/Matlab-GUI-Design/"/>
      <url>/2024/09/23/Matlab-GUI-Design/</url>
      
        <content type="html"><![CDATA[<h2 id="前言">⛄前言</h2><p>图形用户界面的设计是MATLAB的核心应用之一。当用户与计算机之间或用户与计算机程序之间进行交互操作时，舒服高效的用户接口功能则会对用户产生极大的吸引力。图形用户界面（GUI）则通过窗口、图标、按钮、菜单、文本等图形对象构成用户界面。</p><p>MATLAB为用户构建应用程序提供了两个平台——<strong>GUIDE</strong>和<strong>App Designer</strong>。</p><p><strong>GUIDE</strong>是一个较老的平台，MATLAB用户已经使用了很多年。尽管用户已经能够使用GUIDE构建不同复杂程度的应用程序，但是它一直存在用户希望解决的工作流程和可用性问题。类似地，它所支持的组件集（主要是uicontrol集）也非常有限，并且基于一些遗留的技术。</p><p><strong>App Designer</strong>作为新的应用程序构建平台，在R2016a中引入。它集成了构建应用程序的两个任务——设置视觉组件和编程行为。它具有一个新的设计画布，更容易添加组件，并使用标签和面板进行有效组织。它包括一个内置的编辑器，用于管理只读部分中组件的生成代码，并为用户编写的回调代码提供可编辑的部分。它还支持一系列新的标准组件，如编辑字段、按钮和旋转器，以及用于创建仪表面板的仪表盘、旋钮、开关和灯。</p><p><strong>GUIDE</strong>和<strong>App Designer</strong>之间的主要区别在于所使用的技术。GUIDE的基础是Java Swing，甲骨文已经不再对其投入开发。虽然该平台可以获得一些短期的胜利，但从长远来看，不会得到新的扩展，也不允许我们为用户提供基于网络的工作流。AppDesigner建立在现代的基于web技术上，比如JavaScript、HTML和CSS，它给我们提供了一个平台，可以灵活地跟上用户的需求，并允许应用程序在web上运行。用户可以保持他们现有的基于Java的应用程序运行，并在合适的时候选择新的平台。</p><blockquote><p>Swing 是一个为Java设计的GUI工具包。</p><p>Swing是JAVA基础类的一部分。</p><p>Swing包括了图形用户界面（GUI）器件如：文本框，按钮，分隔窗格和表。</p></blockquote><p><strong><em>本博客以GUIDE的相关教程为例子进行阐述，App Designer相关教程待后续更新。</em></strong></p><h2 id="matlab图形用户界面">⛄Matlab图形用户界面</h2><p>句柄图形（Handle Graphics）系统是MATLAB中一种面向对象的绘图系统，该系统提供创建计算机图形所必需的各种功能，包括创建线、文字、网格、面及<strong>图形用户界面</strong>等。图形用户对象包括了众多的GUI对象，其中基本的图形用户界面对象分为3类：</p><ul><li><p>用户界面控件对象（<code>uicontrol</code>）</p></li><li><p>下拉式菜单对象（<code>uimenu</code>）</p></li><li><p>内容式菜单对象（<code>uicontextmenu</code>）</p></li></ul><p>在图形用户对象中，包括多个图形用户对象及多个图形用户接口容器对象，这些容器对象可以成为图形用户对象或其他容器的接口容器。利用上述对象进行周密的组织、设计，就可以设计出一个界面良好、操作方便、功能强大的图形用户界面。 GUI图形对象之间的层次树表如下图所示：</p><p><a href="https://imgse.com/i/pAMGBV0"><img src="https://s21.ax1x.com/2024/09/21/pAMGBV0.jpg" alt="pAMGBV0.jpg" /></a></p><h2 id="图形用户界面控件">⛄图形用户界面控件</h2><p>在绝大多数的图形用户界面下，都包含控件。控件是图形对象，它与菜单一起用于创建图形用户界面。通过使用各种类型的控件，可以建立操作简便、功能强大的图形用户界面。MATLAB R2018a的控件对象如下表所示：</p><table><colgroup><col style="width: 20%" /><col style="width: 80%" /></colgroup><thead><tr class="header"><th style="text-align: left;">控件对象类型</th><th style="text-align: left;">说明</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">Push Button</td><td style="text-align: left;">按钮：在按钮上通常显示文本标签。当用户在按钮上单击时，可以使系统MATLAB R2018a的回调函数执行某个操作，但不能用于属性或状态的选择。按钮按下后，可以恢复到原来的弹起状态。</td></tr><tr class="even"><td style="text-align: left;">slider</td><td style="text-align: left;">滑动框：和其他编程语言中的滑动条一样，由滑杆、指示器等部分对象组成。滑动框通常用于从一个数据范围中选择一个数据值。滑动框通常和其他的文本对象一起使用，用来表示滑动框的标题、当前值及滑动框的范围等。</td></tr><tr class="odd"><td style="text-align: left;">Radio Button</td><td style="text-align: left;">单选按钮：通常通过一个文本标签和一个圆圈或菱形构成组件，当选中时，该圆圈或菱形会处于填充状态；而取消选中时，圆圈和菱形则会恢复到无填充状态。单选按钮选择时，通常只能从一组选择对象中选择单个对象。</td></tr><tr class="even"><td style="text-align: left;">Check Box</td><td style="text-align: left;">复选框：每个复选框对象由复选项和相应的标签对象构成。当复选项选择激活后，复选框中会出现“×”；取消复选后，则会消失。</td></tr><tr class="odd"><td style="text-align: left;">Edit Text</td><td style="text-align: left;">文本编辑框：用户可以动态地修改或替换文本框中的内容。对于文本框对象，用户可以在属性中设置单行或多行文本输入属性。如果设置为单行文本输入，用户只能输入一行文本，按Enter键后表明输入结束；如果设置为多行文本输入，用户可以输入多行文本，换行时需按Ctrl+Enter组合键。</td></tr><tr class="even"><td style="text-align: left;">Static Text</td><td style="text-align: left;">静态文本：用于显示文本字符串，通常用于显示标题、标签、用户信息和当前值。此时，用户不能对显示的文本进行修改和编辑。</td></tr><tr class="odd"><td style="text-align: left;">Pop-up Menu</td><td style="text-align: left;">弹出式菜单：用户可以从弹出式菜单的多个选项中选择一个选项。当关闭菜单选项时，将会成为一个包含用户选择项的矩形或按钮，位于一定的矩形区域内。有些菜单项中还有其他子菜单选项，同样的方式可以用鼠标完成选择过程。</td></tr><tr class="even"><td style="text-align: left;">Listbox</td><td style="text-align: left;">列表框：产生的文本条目可以用于选择，但不能进行编辑。</td></tr><tr class="odd"><td style="text-align: left;">Toggle Button</td><td style="text-align: left;">开关按钮：创建切换。和普通按钮不同，开关按钮通常会交替呈现两种不同的状态（弹起或按下）。而普通按钮将会在按下后立即弹起。开关按钮和普通按钮一样，每次单击都会产生相应的操作。</td></tr><tr class="even"><td style="text-align: left;">Table</td><td style="text-align: left;">表格按钮：创建表格组件。具体使用可参见uitable函数。</td></tr><tr class="odd"><td style="text-align: left;">Axes</td><td style="text-align: left;">坐标系：用于在GUI中添加图形或图像。</td></tr><tr class="even"><td style="text-align: left;">Panel</td><td style="text-align: left;">面板：用于将GUI中的控件分组管理和显示。使用面板将相关控件分组显示可以使软件更易于理解。面板可以包含各种控件，包括按钮、坐标系及其他面板等。面板包含标题和边框等用户显示面板的属性和边界。面板中的控件与面板之间的位置为相对位置，当移动面板时，这些控件在面板中的位置不改变。</td></tr><tr class="odd"><td style="text-align: left;">Button Group</td><td style="text-align: left;">按钮组：按钮组类似于面板，但是按钮组的控件只包括单选按钮或者开关按钮。按钮中的所有控件，其控制代码必须写在按钮组的SelectionChangeFcn响应函数中，而不是用户接口控制响应函数中。按钮组会忽略其中控件的原有属性。</td></tr><tr class="even"><td style="text-align: left;">ActiveX Control</td><td style="text-align: left;">ActiveX控件：用于在GUI中显示控件。该功能只有在Windows操作系统下可用。</td></tr></tbody></table><h3 id="图形用户界面控件的创建">👀图形用户界面控件的创建</h3><p>MATLAB R2018a提供了命令行和GUI设计工具两种方式来创建图形用户界面控件。</p><p><strong>（1）命令行方式</strong></p><p>在命令行方式下，可以通过函数uicontrol来建立控件对象。ucontrol函数有如下几种调用格式：</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">Handle = uicontrol(parent)</span><br><span class="line">Handle = uicontrol(..., <span class="string">&#x27;PropertyName&#x27;</span>, PropertyValue, ...)。</span><br></pre></td></tr></table></figure><p>其中，Handle是创建的控件对象的句柄值；parent是控件所在的图形窗口的句柄值；PropertyName是空间的某个属性的属性名；PropertyValue 是与属性名相对应的属性值。第一种调用方式，采用uicontrol的Style属性的默认属性值，在图形窗口的左下角创建一个命令按钮。第二种调用方式，省略控件所在图形窗口的句柄值，表示在当前图形窗口创建控件对象。如果此时无图形窗口，MATLAB会自动创建一个图形窗口，然后在其中创建控件对象。</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% 创建一个命令按钮，其位置在[0.5 0.5 0.2 0.1]，单位是 normalized。当单击该命令按钮时，按钮的位置会随机变动。</span></span><br><span class="line">&gt;&gt;h = uicontrol(<span class="string">&#x27;style&#x27;</span>, <span class="string">&#x27;pushbutton&#x27;</span>, <span class="string">&#x27;Units&#x27;</span>, <span class="string">&#x27;normalized&#x27;</span>, <span class="string">&#x27;Position&#x27;</span>, [<span class="number">.5</span> <span class="number">.5</span> <span class="number">.2</span> <span class="number">.1</span>], <span class="string">&#x27;String&#x27;</span>, <span class="string">&#x27;单击此处&#x27;</span>, <span class="string">&#x27;Callback&#x27;</span>, <span class="string">&#x27;set(h,&#x27;&#x27;Position&#x27;&#x27;, [.8*rand .9*rand .2 .1])&#x27;</span>); </span><br></pre></td></tr></table></figure><p><strong>（2）GUI设计工具</strong></p><p>在命令行方式下创建控件对象时，需要记住用于创建控件对象的函数。而且要设置控件的属性，必须记住控件的大量属性的属性名，这对于修改控件的属性非常不便。在MATLAB R2018a中利用GUI设计工具中的对象设计编辑器(Layout Editor)，可以很容易地创建MATLAB支持的各种控件，而且通过对象属性检查器(Property Inspector)可以方便地修改、设置创建的控件的属性值。利用GUIDE创建GUI的流程包括：</p><ul><li><p>在命令行中输入<code>guide</code>打开<code>GUIDE</code>；</p></li><li><p>在弹出"GUIDE快速入门"窗口中，选择新建GUI（如果要修改已经做好的GUI界面，选择打开现有GUI），将保存路径前面的勾打上，然后点击浏览，选择想要保存的路径以及修改文件名，最后点击确定即可；</p><blockquote><p>MATLAB为GUI设计提供了4种模板，分别是：Blank GUI（空白模板，默认）、GUI with Uicontrols（带控件对象的GUI模板）、GUI with Axes and Menu（带坐标轴和菜单的GUI模板）、Modal Question Dialog（带模式问题对话框的GUI模板），可以根据需要选择创建。</p></blockquote></li><li><p>弹出"GUI设计窗口"，同时会生成两个相同文件名的文件，后缀分别为"<code>.fig</code>"和"<code>.m</code>"；</p></li><li><p>在"GUI设计窗口"中，左半部分为设计工具区，提供了设计GUI过程中所用的用户控件；中间网格形式是用户设计GUI的操作区域；</p><blockquote><p>GUI设计窗口中，选择"文件"——"预设"，在弹出的"预设项"设置对话框中选择"在组件选项板中显示名称"，点击"确认"，则GUIDE界面中的交互控件面板将会显示各控件的名称。</p></blockquote></li><li><p>在"GUI设计窗口"创建控件对象后，可以通过<strong>双击</strong>该控件对象来显示该对象的属性编辑器；</p></li><li><p>编辑GUI对应的ｍ文件，右击某个控件对象，选择查看回调，再选择callback；进入ｍ文件的编辑界面，找到对应控件对象的callback函数，对其进行编辑；</p></li><li><p>在"GUI设计窗口"的<code>.fig</code>中，点击运行，即可执行新建的GUI界面。</p></li></ul><h3 id="鼠标动作执行">👀鼠标动作执行</h3><p>在GUI方式下的应用程序最主要的输入设备就是鼠标，利用鼠标做出判断和交互动作。事实上，如今任何图形界面应用程序与操作系统都提供了对鼠标操作的支持。MATLAB也提供了对图形用户界面下应用程序鼠标操作的支持。</p><p>在MATLAB中，所有句柄图形对象都拥有一个ButtonDownFcn属性，大部分UI对象也都拥有Callback属性，对于uicontrol对象还拥有KeyPressFcn属性。图形对象则拥有如WindowButtonDownFcn、 WindowButtonUpFcn、 WindowButtonMotionFcn、KeyPressFcn、CloseRequestFcn及ResizeFcn属性。此外，所有的图形对象还拥有CreateFcn和DeleteFcn属性。这些属性值都是一个回调字符串，当这些属性激活时，鼠标光标的位置将会决定事件发生时的回调和执行函数。鼠标光标位于不同的对象时，所能触发该对象的回调函数及响应结果如下表：</p><table><colgroup><col style="width: 50%" /><col style="width: 50%" /></colgroup><thead><tr class="header"><th>鼠标光标位置及其它条件</th><th>响应事件</th></tr></thead><tbody><tr class="odd"><td>鼠标光标位于uimenu菜单项上，菜单项的Enable属性设置为on</td><td>改变uimenu对象的外观并为鼠标释放事件做好准备</td></tr><tr class="even"><td>鼠标光标位于uicontrol对象上，且该对象的Enable属性设置为on</td><td>改变uicontrol对象的外观并为鼠标释放事件做好准备</td></tr><tr class="odd"><td>鼠标光标位于uimenu菜单项上，菜单项的Enable属性设置为off</td><td>忽略鼠标键按下事件</td></tr><tr class="even"><td>鼠标光标位于uicontrol对象上，该对象的Enable属性设置为off或inactive</td><td>首先执行WindowButtonDownFcn回调函数，然后执行uicontrol对象的ButtonDownFcn回调代码</td></tr><tr class="odd"><td>鼠标光标位于除uimenu和uicontrol对象之外的其他图形对象上或附近</td><td>首先执行图形对象WindowButtonDownFcn回调函数代码，然后执行鼠标所指对象的ButtonDownFcn回调函数代码</td></tr><tr class="even"><td>鼠标光标位于图形对象的内部，但不在其他对象上或附近</td><td>首先执行图形对象WindowButtonDocn回调函数代码，然后执行该对象的ButtonDownFcn回调函数代码</td></tr></tbody></table><p>在选择执行回调函数时，MATLAB R2018a通常会根据图形中的区域来决定回调函数的执行和选择。</p><ul><li>在选择时，通常根据3个区域来进行选择；</li><li>当鼠标光标位于句柄图形对象的Position属性确定的范围内时，即可认为鼠标光标位于该对象上；</li><li>如果鼠标光标没有位于对象之上，但位于对象的有效选择区域之内，那么可以认为鼠标光标位于该对象附近；</li><li>如果鼠标光标既不在一个对象上，也不在一个对象附近，那么鼠标光标远离该对象；</li><li>当对象或选择区域出现重叠时，通常会利用对象的叠放次序来确定哪一个对象被鼠标选中。</li></ul><p>如果在鼠标光标附近的uimenu、uicontextmenu、uicontrol对象的Enable属性被设置为on，那么鼠标单击过程将会触发对象的Callback属性字符串的执行。</p><p>当按下鼠标时，uicontrol对象将会做好被触发的准备，通常会改变uicontrol对象或uimenu的外观，释放鼠标，则会触发相应的回调函数执行过程。如果鼠标光标不在一个uicontrol对象或uimenu对象上，那么将会按照鼠标按下和鼠标释放过程来执行。</p><p>当鼠标释放时，系统将会产生一个鼠标释放事件。当该事件发生时，图形对象的CurrentPoint属性首先更新，同时图形对象的WindowButtonUpFcn回调函数代码被触发执行。</p><p>如果鼠标光标在图形对象的内部移动，将会产生鼠标光标的移动事件。当该事件发生时，图形的CurrentPoint属性将会被更新，同时图形的WindowButtonMotionFcn回调函数将会被触发执行。</p><h3 id="事件队列的执行顺序">👀事件队列的执行顺序</h3><p>创建图形用户界面后，用户可以通过任意方式与该图形用户界面产生交互操作。在进行交互操作的过程中，每次交互都会产生一个事件，这些事件将会形成一系列的事件序列。同时，图形窗口的输入和输出事件也将会作为图形用户界面对象的事件被列入事件队列中。列入事件队列中的事件包括鼠标光标的移动和触发回调执行的鼠标按键按下或释放操作，以及waitforbuttonpress、waitfor、drawnow、figure、getframe、pause等事件，这些事件在需要处理的事件队列中会按照顺序依次执行和操作。一般情况，终止回调函数代码的执行过程是不允许的，但在优先级较高的命令如waitforbuttonpress、waitfor、drawnow、getframe、pause或figure等执行时，系统将会把执行过程中的回调函数代码挂起，并检测事件队列中未完成的每个事件。</p><p>如果将回调函数相应对象的Interruptible属性设置为on，那么在系统处理完所有未完成事件后，将会恢复被挂起的回调过程，并执行完毕。如果将该属性设置为off，那么系统将会只处理没有完成的屏幕刷新事件。</p><p>如果对象的BusyAction属性设置为cancel，那么中断回调执行的事件将会被忽略。如果将该属性设置为queue，那么中断回调执行的事件将会被保存在队列中，直到被中断的回调函数执行完毕后再响应该事件。</p><h3 id="回调函数的编写">👀回调函数的编写</h3><p>在图形用户界面编写的过程中，使用句柄图形和图形用户界面函数可以充分利用回调函数的代码编写来扩展用户选择的任务执行过程。在执行回调函数的过程中，可以将回调函数设置为回调函数字符串，然后将这些回调字符串传递给eval函数来完成执行过程。</p><p>当图形用户对象运行执行回调函数代码时，将会根据该函数来进行函数代码的回调执行过程。如果有多个回调函数需要执行，则可以把这些回调过程编写为switch切换结构来完成回调执行过程。但通过这种方法来编写回调函数代码时，数据的获取和传递将是需要解决的一个重要问题。如可以使用persistent声明来限定数据。通过persistent函数进行限定时，工作区中所存储的该数据将会在函数执行过程中被使用。但如果有多个图形用户界面对象存在，那么多个图形用户界面对象将共享该persistent数据。</p><p>传递数据也可通过句柄图形对象的tag属性来进行。由于句柄图形对象的tag属性是句柄图形对象的唯一标识字符串，用户可以使用findobj函数来寻找指定tag字符串的图形用户对象。当找到该对象后，可以通过getappdata、setappdata、rmappdata和isappdata函数来对所得到的对象数据进行处理。</p><table><thead><tr class="header"><th>数据函数</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>Value=getappdata(h, name)</td><td>获得应用程序中定义的数值</td></tr><tr class="even"><td>setappdata(h, name, value)</td><td>设置应用程序中的数值</td></tr><tr class="odd"><td>rmappdata(h, name)</td><td>删除应用程序中的数值</td></tr><tr class="even"><td>isappdata(h, name)</td><td>判断是否为句柄函数值</td></tr></tbody></table><h2 id="对话框对象">⛄对话框对象</h2><p>在GUI程序设计中，对话框是最重要的显示信息和取得用户数据的用户界面对象。对话框一般包含一个或多个按钮以供用户输入或者弹出显示的信息，由用户决定要采取的措施。在绝大部分的程序设计软件中，如Visual Basic、Delphi、Visual C++，都可以方便地进行对话框设计。MATLAB也提供了一些进行对话框设计的有用函数。使用对话框，可以使图形用户界面更加友好，易于为用户理解。总的来说，MATLAB R2018a中的对话框分为两大类，第一类是公共对话框，第二类是一般对话框。</p><h3 id="公共对话框">👀公共对话框</h3><p>常用的公共对话框函数如下表所示：</p><table><thead><tr class="header"><th>对话框函数</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>uigetfile</td><td>标准的打开对话框</td></tr><tr class="even"><td>uiputfile</td><td>保存文件对话框</td></tr><tr class="odd"><td>uisetfont</td><td>生成字体和字体属性选择对话框</td></tr><tr class="even"><td>uisetcolor</td><td>颜色设置对话框</td></tr><tr class="odd"><td>pagesetupdlg</td><td>页面设置对话框</td></tr><tr class="even"><td>printpreview</td><td>打印预览对话框</td></tr><tr class="odd"><td>printdlg</td><td>打印对话框</td></tr></tbody></table><p><strong>（1）文件打开对话框</strong></p><p>文件打开对话框用于打开某个文件。在Windows系统中，几乎所有应用软件都提供文件打开对话框。在MATLAB中，调用文件打开对话框的函数为uigetfile。该函数的调用格式如下表所示：</p><table><colgroup><col style="width: 42%" /><col style="width: 57%" /></colgroup><thead><tr class="header"><th>格式</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>uigetfile</td><td>在显示的文件打开对话框中，列出当前目录下MATLAB能识别的所有文件</td></tr><tr class="even"><td>uigetfile('FilterSpec')</td><td>在显示的文件打开对话框中，列出当前目录下由参数FilterSpec指定的类型文件。参数FilterSpec是一个文件类型过滤字符串，用于指定要显示的文件类型。例如，'*.m'显示当前目录下MATLAB中的所有M文件</td></tr><tr class="odd"><td>uigetfile('FilterSpec', 'DialogTitle')</td><td>与第二种调用格式基本相同，只是该调用格式设定了文件打开对话框的标题名，默认标题为字符串Select file to open</td></tr><tr class="even"><td>uigetfile('FilterSpec', 'DialogTitle', x, y)</td><td>与第三种调用格式基本相同，只是该调用格式还指定了对话框显示时的位置。显示位置由参数x与y决定。x、y是从屏幕左上角算起的水平与垂直距离。距离单位是像素</td></tr><tr class="odd"><td>[fname,pname]=uigetfile(…)</td><td>返回打开文件的文件名与路径。其中，输入参数fname存放的是打开的文件名，pname包含文件的路径</td></tr></tbody></table><p><strong>（2）文件保存对话框</strong></p><p>文件保存对话框用于保存某个文件。在MATLAB中，调用文件保存对话框的函数为uiputfile。该函数的调用格式如下表所示：</p><table><colgroup><col style="width: 41%" /><col style="width: 58%" /></colgroup><thead><tr class="header"><th>格式</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>uiputfile</td><td>显示用于保存文件的对话框，列出当前目录下MATLAB能识别的所有文件</td></tr><tr class="even"><td>uiputfile('InitFile')</td><td>在显示的文件保存对话框中，列出当前目录下由参数InitFile指定的类型文件。参数InitFile是一个文件类型过滤字符串，用于指定要保存的文件类型。例如，'*.m'显示当前目录下 MATLAB 中的所有 M 文件</td></tr><tr class="odd"><td>uiputfile('InitFile', 'DialogTitle')</td><td>与第二种调用格式基本相同，只是该调用格式设定了文件保存对话框的标题名，默认标题为字符串 Select file to write</td></tr><tr class="even"><td>uiputfile('InitFile', 'DialogTitle', x, y)</td><td>与第三种调用格式基本相同，只是该调用格式还指定了对话框显示时的位置。显示位置由参数x与y决定。x、y是从屏幕左上角算起的水平与垂直距离。距离单位是像素</td></tr><tr class="odd"><td>[fname,pname]=uiputfile(…)</td><td>返回保存的文件的文件名与路径。其中，输入参数fname存放的是保存的文件名，pname 包含文件的路径</td></tr></tbody></table><p><strong>（3）颜色设置对话框</strong></p><p>颜色设置对话框可用于交互式设置某个图形对象的前景色或背景色。在绝大部分的程序设计软件中，都提供了这个公共对话框。在MATLAB中，调用颜色设置对话框的函数为uisetcolor。该函数的调用格式如下表所示：</p><table><colgroup><col style="width: 36%" /><col style="width: 63%" /></colgroup><thead><tr class="header"><th>格式</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>c=uisetcolor(h_or_c, 'DialogTitle')</td><td>输入参数中的h_or_c可以是一个图形对象的句柄，也可以是一个三色RGB向量。若是图形对象的句柄，那么该图形对象必须有一个颜色属性；若是三色RGB向量，那么输入的必须是一个有效的RGB向量，此时输入的颜色初始化颜色对话框。对于输入的参数是图形对象句柄，颜色对话框被初始化为黑色。输入参数中的DialogTitle字符串用于标明颜色对话框的标题名。输出参数c返回用户选择的RGB向量值</td></tr></tbody></table><p><strong>（4）字体设置对话框</strong></p><p>字体设置对话框可用于交互式修改文本字符串、坐标轴或控件对象的字体属性。修改的字体属性包括FontName、FontUnits、FontSize、FontWeight、FontAngle等。在MATLAB中，调用字体设置对话框的函数为 uisetfont。该函数的调用格式如下表所示：</p><table><colgroup><col style="width: 31%" /><col style="width: 68%" /></colgroup><thead><tr class="header"><th>格式</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>uisetfont</td><td>显示用于进行字体设置的对话框，对话框中列出了字体、字形、字体大小等字段。返回的是选择的字体的属性值</td></tr><tr class="even"><td>uisetfont('DialogTitle')</td><td>与第一种调用格式基本相同，只是该调用格式设定了字体设置对话框的标题名，默认标题为字符串Font</td></tr><tr class="odd"><td>uisetfont(h)</td><td>输入参数h是一个对象句柄。该调用格式用对象句柄中的字体属性值初始化字体设置对话框中的属性值，用户可以利用字体设置对话框重新设置对象的字体属性值。返回重新设置后的字体的属性值</td></tr><tr class="even"><td>uisetfont(h, 'DialogTitle')</td><td>与第三种即uisetfont(h)的调用格式基本相同，只是该调用格式还设定了字体设置对话框的标题名，默认标题为字符串Font</td></tr><tr class="odd"><td>uisetfont(S)</td><td>输入参数S是一个字体属性结构，是一个或多个下列属性的合法值：FontName、FontUnits、FontSize、FontWeight、FontAngle，否则输入值会被忽略。该调用格式用字体属性结构S中的成员值来初始化字体设置对话框中的属性值。用户可以利用字体设置对话框重新设置对象的字体属性值。返回重新设置后的字体的属性值</td></tr><tr class="even"><td>uisetfont(S, 'DialogTitle')</td><td>与第五种即uisetfont(S)的调用格式基本相同，只是该调用格式还设定了字体设置对话框的标题名，默认标题为字符串Font</td></tr><tr class="odd"><td>S = uisetfont(…)</td><td>返回字体属性（FontName、FontUnits、FontSize、FontWeight、FontAngle）的属性值，被保存在结构S中</td></tr></tbody></table><p><strong>（5）打印页面设置对话框</strong></p><p>打印页面设置对话框可用于对打印输出时的页面进行设置。在许多应用软件中，都提供了进行打印页面设置的对话框。在MATLAB中，调用打印页面设置对话框的函数为pagesetupdlg。该函数的调用格式如下表所示：</p><table><colgroup><col style="width: 25%" /><col style="width: 74%" /></colgroup><thead><tr class="header"><th>格式</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>dlg=pagesetupdlg(fig)</td><td>用默认的页面设置属性为图形窗口创建一个打印页面设置对话框。输入参数fig必须是单个图形窗口的句柄，而不是一个图形窗口向量。若省略参数fig，那么默认的图形窗口对象是当前窗口对象。输出参数返回已设置了的打印页面属性值</td></tr></tbody></table><p>在MTALAB R2018a中，pagesetupdlg函数被打印预览对话框函数printprview合并。</p><p><strong>（6）打印预览对话框</strong></p><p>打印预览对话框用于对打印输出的页面进行预览。在许多应用软件中，都提供了打印预览的对话框。在MATLAB中，调用打印预览对话框的函数为printpreview。该函数的调用格式如下表所示：</p><table><thead><tr class="header"><th>格式</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>printprview</td><td>显示当前图形窗口对象的打印预览对话框</td></tr><tr class="even"><td>printprview(fig)</td><td>显示指定的图形窗口对象fig的打印预览对话框</td></tr></tbody></table><p>在打印预览对话框的上面有相应的分组按钮控件，用户可以进行相应的编辑控制操作。</p><p><strong>（7）打印对话框</strong></p><p>打印对话框是专门进行打印的对话框，这是任何图形用户界面的应用软件都会提供的对话框。在MATLAB中，调用打印对话框的函数为printdlg。该函数的调用格式如下表所示：</p><table><colgroup><col style="width: 34%" /><col style="width: 65%" /></colgroup><thead><tr class="header"><th>格式</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>printdlg</td><td>显示出标准的Windows打印对话框（在Windows系统中）。它打印当前图形窗口内的图形对象</td></tr><tr class="even"><td>printdlg(fig)</td><td>显示出标准的Windows打印对话框（在Windows系统中），但它打印由输入参数fig指定的图形窗口内的对象。输入参数fig是将要打印的图形窗口的句柄</td></tr><tr class="odd"><td>printdlg('-crossplatform', fig)</td><td>显示标准的crossplatform模式的MATLAB打印对话框。输入参数fig是将要打印的图形窗口的句柄</td></tr><tr class="even"><td>printdlg('-setup', fig)</td><td>显示打印对话框的开始模式。在这里有可以不进行打印而设置的默认选项</td></tr></tbody></table><h3 id="一般对话框">👀一般对话框</h3><p>除了提供大量标准的公共对话框，MATLAB R2018a还提供了大量的一般对话框函数：</p><table><thead><tr class="header"><th>对话框函数</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>helpdlg</td><td>帮助对话框</td></tr><tr class="even"><td>errordlg</td><td>错误消息对话框</td></tr><tr class="odd"><td>msgbox</td><td>信息提示对话框</td></tr><tr class="even"><td>questdlg</td><td>询问对话框</td></tr><tr class="odd"><td>warndlg</td><td>警告消息显示对话框</td></tr><tr class="even"><td>inputdlg</td><td>变量输入对话框</td></tr><tr class="odd"><td>listdlg</td><td>列表选择对话框</td></tr><tr class="even"><td>axlimdlg</td><td>生成坐标轴范围设置对话框</td></tr><tr class="odd"><td>dialog</td><td>创建对话框或图形用户对象类型的图形窗口</td></tr><tr class="even"><td>menu</td><td>菜单类型的选择对话框</td></tr><tr class="odd"><td>waitbar</td><td>显示等待进度条</td></tr></tbody></table><p><strong>（1）帮助对话框</strong></p><p>在操作应用软件时，当用户不知道该如何操作时，帮助信息将会帮助用户进行正确操作，显示帮助信息的对话框就是帮助对话框。MATLAB提供的创建帮助对话框的函数是helpdlg。该函数的调用格式如下表所示：</p><table><colgroup><col style="width: 34%" /><col style="width: 65%" /></colgroup><thead><tr class="header"><th>格式</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>helpdlg</td><td>创建一个默认的帮助对话框。默认的对话框名为"Help Dialog"，在对话框内包含一个名为"This is the default help string"的字符串</td></tr><tr class="even"><td>helpdlg('helpstring'）</td><td>创建一个帮助对话框。该对话框仍然叫作"Help Dialog"，但对话框内显示的帮助信息由输入参数helpstring决定</td></tr><tr class="odd"><td>helpdlg('helpstring', 'dlgname')</td><td>创建一个帮助对话框。该对话框的名称由输入参数dlgname决定，对话框内显示的帮助信息由输入参数helpstring决定</td></tr><tr class="even"><td>h = helpdlg(…)</td><td>返回创建的帮助对话框的句柄，句柄存放在输入参数h中，输入参数与前面的调用格式的输入参数相同</td></tr></tbody></table><p>MATLAB会自动设置帮助对话框的宽度，使其能够显示出helpstring字符串的全部帮助信息。</p><p><strong>（2）错误消息对话框</strong></p><p>在开发的应用软件中，当用户进行了错误的操作后，应该显示错误消息对话框，使用户知道错误的原因，以便采取正确的操作。此时，就要用到错误消息对话框。MATLAB提供的创建错误消息对话框的函数是errordlg，该函数的调用格式如下表所示：</p><table><colgroup><col style="width: 40%" /><col style="width: 60%" /></colgroup><thead><tr class="header"><th>格式</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>errordlg</td><td>创建一个默认的错误消息对话框。默认的对话框名为"Error Dialog"，在对话框内包含一个名为"This is the default error string"的字符串</td></tr><tr class="even"><td>errordlg('errorstring')</td><td>创建一个错误消息对话框。该对话框仍然叫作"Error Dialog"，但对话框内显示的错误消息由输入参数errorstring决定</td></tr><tr class="odd"><td>errordlg('errorstring', 'dlgname')</td><td>创建一个错误消息对话框。该对话框的名称由输入参数dlgname决定，对话框内显示的帮助信息由输入参数errorstring决定</td></tr><tr class="even"><td>errordlg('errorstring', 'dlgname', 'on')</td><td>创建一个错误消息对话框。当要创建的对话框已经存在时，输入参数on把已经存在的对话框显示在屏幕的最前端，而不再创建同名的新对话框</td></tr><tr class="odd"><td>h = errordlg(…)</td><td>返回创建的错误消息对话框的句柄，句柄存放在输入参数h中。输入参数与前面的调用格式的输入参数相同</td></tr></tbody></table><p>MATLAB会自动设置错误消息对话框的宽度，使其能够显示出errorstring字符串的全部错误信息。显示的错误消息对话框的外观依赖于不同的操作系统。</p><p><strong>（3）信息提示对话框</strong></p><p>在面临多种选择或应该显示某种提示情况时，一般就会显示信息提示，此时就要借助于信息提示对话框。MATLAB提供的创建信息提示对话框的函数是msgbox。该函数的调用格式如下表所示：</p><table><colgroup><col style="width: 45%" /><col style="width: 54%" /></colgroup><thead><tr class="header"><th>格式</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>msgbox(message)</td><td>创建一个信息提示对话框。创建的对话框会自动设置对话框的宽度，使其能够显示出全部提示信息。输入参数message存储的是要显示的提示信息。该参数取值可以是一个字符串向量或字符串矩阵</td></tr><tr class="even"><td>msgbox(message, title)</td><td>创建的信息提示对话框与第一种格式即msgbox(message)创建的对话框基本相同，只是该对话框有一个标题名，标题名由输入参数title决定。参数title是一个字符串</td></tr><tr class="odd"><td>msgbox(message, title, 'icon')</td><td>创建的信息提示对话框除了包含提示信息与标题名，对话框上还有一些图标。图标由参数icon决定，icon可选的值有none、error、help、warn、custom，默认值是none</td></tr><tr class="even"><td>msgbox(message,title, 'custom', iconData, iconCmap)</td><td>创建的信息提示对话框中的图标是用户自定义的图标。定义图标的图像数据存放在参数iconData中，定义图像的颜色数据存放在参数iconCmap中</td></tr><tr class="odd"><td>Msgbox = (…, 'createMode')</td><td>参数createMode用于决定创建的信息提示对话框是模式对话框还是无模式对话框。参数createMode的可选值有modal、non-modal和replace。其中，replace 值用标题名相同的对话框代替另外一个已经打开的对话框</td></tr><tr class="even"><td>H = msgbox(…)</td><td>返回创建的信息提示对话框的句柄，句柄存放在输入参数h中。输入参数与前面的调用格式的输入参数相同</td></tr></tbody></table><p><strong>（4）询问对话框</strong></p><p>当对问题的解决可能存在多种选择时，会显示询问对话框，由用户决定应该采取的步骤。例如，保存文件的文件名与当前目录中存在的某个文件名相同时，会显示询问对话框。MATLAB提供的创建询问对话框的函数是questdlg。该函数的调用格式如下表所示：</p><table><colgroup><col style="width: 50%" /><col style="width: 50%" /></colgroup><thead><tr class="header"><th>格式</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>button = questdlg('qstring')</td><td>创建一个问题显示的模式对话框。该对话框中有3个命令按钮，分别为Yes、No、Cancel。显示的问题由输入参数qstring（字符串类型）决定。输出参数button返回的是用户按下的命令按钮的名字</td></tr><tr class="even"><td>button = questdlg('qstring', 'title')</td><td>创建的询问对话框的标题由参数title决定。该标题显示在对话框的标题栏中</td></tr><tr class="odd"><td>button = questdlg('qstring', 'title', 'default')</td><td>创建的询问对话框，当按下Enter键时，返回参数button中的值是参数default设置的值。default 必须是Yes、No、Cancel中的一个</td></tr><tr class="even"><td>button = questdlg('qstring', 'title', 'str1', 'str2', 'default')</td><td>创建的询问对话框有两个命令按钮，按钮上显示的字符由参数str1与str2决定。default设置当用户按下Enter键时返回的参数值。default必须是str1、str2中的一个</td></tr><tr class="odd"><td>button = questdlg('qstring', 'title', 'str1', 'str2', 'str3', 'default')</td><td>创建的询问对话框中有3个命令按钮，按钮上显示的字符由参数str1、str2与 str3决定。default设置当用户按下Enter键时返回的参数值。default必须是str1、str2或str3中的一个</td></tr></tbody></table><p>MATLAB会自动设置询问对话框的宽度，使其能够显示出qstring字符串的全部信息。</p><p><strong>（5）警告消息显示对话框</strong></p><p>在操作应用软件时，当用户进行了不恰当的操作后，应该显示警告消息显示对话框，使用户知道该操作可能导致错误，以便采取正确的操作。此时，就要用到警告消息显示对话框。MATLAB提供的创建警告消息显示对话框的函数是warndlg。该函数的调用格式如下表所示：</p><table><colgroup><col style="width: 38%" /><col style="width: 61%" /></colgroup><thead><tr class="header"><th>格式</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>warndlg</td><td>创建一个默认的警告消息显示对话框。默认的对话框名为"warning Dialog"，在对话框内包含一个名为"This is the default warning string"的字符串</td></tr><tr class="even"><td>warndlg('warnstring')</td><td>创建一个警告消息显示对话框。该对话框仍然叫作"warning Dialog"，警告信息由输入参数warnstring决定</td></tr><tr class="odd"><td>warndlg('warnstring', 'dlgname')</td><td>创建一个警告消息显示对话框。该对话框的名称由输入参数dlgname决定，对话框内显示的警告信息由输入参数warnstring决定</td></tr><tr class="even"><td>warndlg('warnstring', 'dlgname', 'on')</td><td>创建一个警告消息显示对话框。当要创建的对话框已经存在时，输入参数on把已经存在的对话框显示在屏幕的最前端，而不再创建同名的新对话框</td></tr><tr class="odd"><td>H = warndlg(…)</td><td>返回创建的警告消息显示对话框的句柄，句柄存放在输入参数h中。输入参数与前面的调用格式的输入参数相同</td></tr></tbody></table><p>MATLAB会自动设置警告消息显示对话框的宽度，使其能够显示出warnstring字符串的全部警告信息。显示的警告消息对话框的外观依赖于不同的操作系统。</p><p><strong>（6）变量输入对话框</strong></p><p>在许多应用软件中，当需要用户输入变量时，就会显示一个输入对话框。MATLAB提供的创建变量输入对话框的函数是inputdlg。该函数的调用格式如下表所示：</p><table><colgroup><col style="width: 48%" /><col style="width: 51%" /></colgroup><thead><tr class="header"><th>格式</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>answer = inputdlg(prompt)</td><td>创建一个模式变量输入对话框。输入参数是提示输入信息的字符串。返回值answer存储用户输入的变量值</td></tr><tr class="even"><td>answer = inputdlg(prompt, title)</td><td>创建的模式变量输入对话框的标题名由参数title决定。该参数是一个字符串</td></tr><tr class="odd"><td>answer = inputdlg(prompt, title, lineNo)</td><td>创建的模式变量输入对话框中用于输入变量的可编辑文本框的行数由lineNo决定。该参数可以是标量、列向量或矩阵。lineNo的默认值是1。有多个可编辑文本框时，用户输入的值都存储在参数answer中，只是此时要求answer是一个向量值</td></tr><tr class="even"><td>answer = inputdlg(prompt, title, lineNo, defAns)</td><td>创建的变量输入对话框的每个可编辑文本框中的默认值由参数defAns决定。defAns的值就显示在每个可编辑文本中。参数defAns是一个字符向量，其元素的个数必须与参数prompt中元素的个数相等</td></tr><tr class="odd"><td>answer = inputdlg(prompt, title, lineNo, defAns, Resize)</td><td>输入参数用于决定创建的变量输入对话框的大小能否被调整。若取值是字符串on，那么创建的对话框的大小可以被调整；若取值是字符串off，那么创建的对话框的大小不能被调整</td></tr></tbody></table><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% 创建一个变量输入对话框，可以输入一个整数与一个颜色名。第一个可编辑文本框的行数为2行，其默认值为20；第二个可编辑文本框的行数是4行，其默认值是HSV。</span></span><br><span class="line">prompt = &#123;<span class="string">&#x27;输入矩阵大小:&#x27;</span>,<span class="string">&#x27;输入色彩模型名:&#x27;</span>&#125;; </span><br><span class="line">title = <span class="string">&#x27;输入标题&#x27;</span>; </span><br><span class="line">lines = [<span class="number">2</span> <span class="number">4</span>]; </span><br><span class="line">def = &#123;<span class="string">&#x27;20&#x27;</span>,<span class="string">&#x27;HSV&#x27;</span>&#125;; </span><br><span class="line">answer = inputdlg(prompt,title,lines,def); </span><br></pre></td></tr></table></figure><p><strong>（7）列表选择对话框</strong></p><p>当存在多个选项时，最好提供给用户一个列表框，把所有可能的选项都列出来，使用户能从中选择一个需要的值。在这种情况下就要用到列表选择对话框。MATLAB提供的创建列表选择对话框的函数是listdlg。该函数的调用格式如下表所示：</p><table><colgroup><col style="width: 42%" /><col style="width: 57%" /></colgroup><thead><tr class="header"><th>格式</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>[Selection, ok] = listdlg('ListString', S, …)</td><td>创建一个列表选择模式对话框。从列表框中可以选择一个或多个列表项。输出变量是一个向量，存储的是选择的列表项的索引号。在单模式选择状态下，它的长度是1。当输出变量OK是0时，变量Selection是空向量[]。若用户单击列表选择对话框中的OK按钮，则输出变量OK值是1；若单击该对话框中的Cancel按钮或关闭列表选择对话框，则输出变量OK值是0。双击选择的列表项或选中列表项，然后单击对话框中的OK按钮，其效果一样。在多模式选择状态下，单击对话框中的Select all按钮，可以选择所有的列表项</td></tr></tbody></table><p>列表选择对话框中的输入参数可以选取下表中所列的值：</p><table><thead><tr class="header"><th>参数</th><th>参数功能简介</th></tr></thead><tbody><tr class="odd"><td>'ListString'</td><td>该参数用于设置列表框中的列表项，是一个字符向量</td></tr><tr class="even"><td>'SelectionMode'</td><td>该参数用于设置是单模式还是多模式选择，默认是多模式选择。参数取值是一个字符串，可以取single或multiple</td></tr><tr class="odd"><td>'LiseSize'</td><td>该参数用于设置列表框的大小，是一个两元素向量[width height]，默认值是[160 300]，单位是像素</td></tr><tr class="even"><td>'InitialValue'</td><td>该参数用于说明初始选择的列表项的索引，默认是1，即第一项。参数的取值是一个向量</td></tr><tr class="odd"><td>'Name'</td><td>该参数用于设置列表选择对话框的标题名。默认是空字符串</td></tr><tr class="even"><td>'PromptString'</td><td>该参数是一个字符矩阵或字符向量，用于标明在列表框上面的说明性文本。默认是空</td></tr><tr class="odd"><td>'OKString'</td><td>该参数用于设置OK按钮上的文本。默认是字符串OK</td></tr><tr class="even"><td>'CancelString'</td><td>该参数用于设置Cancel按钮上的文本。默认是字符串Cancel</td></tr><tr class="odd"><td>'uh'</td><td>该参数用于设置控件按钮的高度。默认是18，单位是像素</td></tr><tr class="even"><td>'fus'</td><td>该参数用于设置框架与控件对象之间的距离。默认是8，单位是像素</td></tr><tr class="odd"><td>'ffs'</td><td>该参数用于设置框架与图形窗口对象之间的距离。默认是8，单位是像素</td></tr></tbody></table><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">d = dir; </span><br><span class="line">str = &#123;d.name&#125;; </span><br><span class="line">[s,v] = listdlg(<span class="string">&#x27;Promptstring&#x27;</span>,<span class="string">&#x27;选择文件:&#x27;</span>,<span class="string">&#x27;selectionmode&#x27;</span>,<span class="string">&#x27;single&#x27;</span>, <span class="string">&#x27;listsize&#x27;</span>, [<span class="number">300</span> <span class="number">400</span>],<span class="string">&#x27;liststring&#x27;</span>,str); </span><br></pre></td></tr></table></figure><p>除了前面介绍的对话框函数，MATLAB R2018a还提供了一些其他的对话框函数，例如用于创建对话框或图形用户对象类型的图形窗口的dialog函数、菜单类型的选择对话框menu函数及显示等待进度条的waitbar函数等。关于它们的创建方法，可以参考MATLAB帮助文件。</p><h2 id="界面菜单">⛄界面菜单</h2><p>大多数的图形用户界面（GUI）通过选择各级菜单，可以执行相应的命令，实现相应的功能。一般地，从菜单的标题或名字可以大概了解该菜单的功能。在使用MATLAB创建图形用户界面时，也常常需要产生界面菜单；在编辑其他编辑对象时，需要产生弹出菜单，即上下文菜单。这两种菜单在MATLAB中可以通过uimenu或uicontextmenu来产生。</p><h3 id="菜单建立">👀菜单建立</h3><p>在MATLAB R2018a中，可以通过命令行和GUI设计工具的菜单编辑器Menu Editor两种方式来建立界面菜单。</p><p><strong>（1）命令行方式</strong></p><p>在命令行方式下，可以通过函数uimenu来建立下拉式菜单对象。uimenu函数常见的命令格式如下表所示：</p><table><colgroup><col style="width: 48%" /><col style="width: 51%" /></colgroup><thead><tr class="header"><th>格式</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>uimenu('PropertyName', PropertyValue, …）</td><td>使用指定的属性值在当前图形窗口产生菜单，可以产生的属性值后面将做介绍</td></tr><tr class="even"><td>uimenu(parent, 'PropertyName', PrpertyValue, …)</td><td>在父菜单中产生子菜单，或在由父窗口指定的上下文菜单中产生菜单项。如果父句柄指向另一个uimenu对象或uicontextmenu对象的图形，那么将会产生新的菜单栏</td></tr><tr class="odd"><td>handle = uimenu('PropertyName', PropertyValue, …）</td><td>可以返回菜单句柄，其余的设置同上</td></tr><tr class="even"><td>handle = uimenu(parent, 'PropertyName', PropertyVaLue, …)</td><td>可以返回菜单句柄</td></tr></tbody></table><p>在命令行方式下，可以通过函数uicontextmenu来创建内容式菜单对象。uicontextmenu函数常见的命令格式如下表所示：</p><table><colgroup><col style="width: 50%" /><col style="width: 50%" /></colgroup><thead><tr class="header"><th>格式</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>Hm_contextmenu = uicontextmenu('PropertyName', PropertyValue, …）</td><td>Hm_contextmenu是创建的菜单项的句柄值；PropertyName是菜单的某个属性的属性名；PropertyValue是与菜单属性名相对应的属性值</td></tr></tbody></table><p>利用uicontextmenu函数生成内容式菜单后，再通过函数uimenu可在以往创建的内容式菜单中添加子菜单。然后可以通过set把创建的内容式菜单与某个对象相联系，通过设置对象的uicontextmenu属性，使内容式菜单依附于该对象。</p><p><strong>（2）GUI设计工具菜单编辑器</strong></p><p>在命令行方式下创建菜单时，需要记住用于创建的函数，而且要记住大量菜单属性的属性名，这对于创建菜单非常不方便。在MATLAB中利用GUI设计工具中的菜单编辑器（Menu Editor），可以很方便地创建下拉式菜单与内容式菜单。</p><h3 id="菜单属性">👀菜单属性</h3><p>利用函数uimenu 或 uicontextmenu 建立菜单时，可以定义菜单属性的属性值。利用函数set，可以设置、改变属性的属性值；利用函数get，可以获得菜单属性的属性值，也可以通过Property Inspector GUI设计工具来设置、改变菜单的属性值。</p><p><strong>（1）uimenu菜单的属性</strong></p><p>在菜单中，uimenu函数的属性名称和属性值的常用设置如下表所示：</p><p>①外观及风格控制属性</p><table><thead><tr class="header"><th>属性名称（PropertyName）</th><th>属性值（PropertyValue）</th><th>说 明</th></tr></thead><tbody><tr class="odd"><td>Checked</td><td>Value：on，off <br/>Default：off</td><td>菜单项前是否添加核选标记"√"</td></tr><tr class="even"><td>Label</td><td>Value：String</td><td>设置菜单的标题名称</td></tr><tr class="odd"><td>Separator</td><td>Value：on，off <br/>Default：off</td><td>分隔条</td></tr><tr class="even"><td>Foregroundcolor</td><td>Value：ColorSpec <br/>Default：[0 0 0]</td><td>文本颜色</td></tr><tr class="odd"><td>Visible</td><td>Value：on，off <br/>Default：on</td><td>控制uimenu菜单的可见状态</td></tr></tbody></table><p>②基本信息属性</p><table><thead><tr class="header"><th>属性名称（PropertyName）</th><th>属性值（PropertyValue）</th><th>说 明</th></tr></thead><tbody><tr class="odd"><td>Accelerator</td><td>Value：character</td><td>键盘加速键</td></tr><tr class="even"><td>Children</td><td>Value：Vectorofhandles</td><td>子菜单句柄</td></tr><tr class="odd"><td>Enable</td><td>Value：cancel，queue <br/>Default：queue</td><td>禁止或使用uimenu</td></tr><tr class="even"><td>Parent</td><td>Value：handle</td><td>菜单对象的父对象</td></tr><tr class="odd"><td>Tag</td><td>Value：String</td><td>用户指定的对象标识符</td></tr><tr class="even"><td>Type</td><td>Value：String(read-only) <br/>Default：uimenu</td><td>图形对象的类</td></tr><tr class="odd"><td>UserData</td><td>Value：matrix</td><td>用户指定的数据</td></tr></tbody></table><p>③位置信息属性</p><table><thead><tr class="header"><th>属性名称（PropertyName）</th><th>属性值（PropertyValue）</th><th>说 明</th></tr></thead><tbody><tr class="odd"><td>Position</td><td>Value：scalar <br/>Default：[1]</td><td>相对的uimenu的位置</td></tr></tbody></table><p>④回调函数执行控制属性</p><table><thead><tr class="header"><th>属性名称（PropertyName）</th><th>属性值（PropertyValue）</th><th>说 明</th></tr></thead><tbody><tr class="odd"><td>BusyAction</td><td>Value：cancel，queue <br/>Default：queue</td><td>回调函数中断</td></tr><tr class="even"><td>Callback</td><td>Value：string</td><td>控制动作</td></tr><tr class="odd"><td>CreateFcn</td><td>Value：string</td><td>在对象生成过程中执行回调</td></tr><tr class="even"><td>DeleteFcn</td><td>Value：string</td><td>在对象删除过程中执行回调</td></tr><tr class="odd"><td>Interruptible</td><td>Value：on，off <br/>Default：on</td><td>回调函数的中断方式</td></tr></tbody></table><p>⑤控制操作属性</p><table><thead><tr class="header"><th>属性名称（PropertyName）</th><th>属性值（PropertyValue）</th><th>说 明</th></tr></thead><tbody><tr class="odd"><td>Handle Visibility</td><td>Value：on，callback，off <br/>Default：on</td><td>在命令行或GUI中是否可见</td></tr></tbody></table><p><strong>（2）uicontextmenu菜单的属性</strong></p><p>参见uimenu菜单的属性。在命令行方式或者GUI设计方式下，可以方便地对uimenu菜单与uicontextmenu菜单的属性进行设置、修改。</p><h2 id="图形界面创建工具guide">⛄图形界面创建工具GUIDE</h2><p>如果只在MATLAB命令行窗口中输入命令来编写GUI界面，那么编程的效率实在是太低了。MATLAB提供了功能强大的GUIDE模板，用于创建各种用户图形对象。通过该GUIDE模板的使用，可以自动生成相应的M文件框架，简化了用户编写图形界面程序的工作。如果需要更改相关的内容，则可以直接打开M文件进行修改或编写自己的代码。图形界面创建工具GUIDE大大增强了图形界面创建的能力。</p><p><strong>（1）利用创建工具GUIDE进行GUI设计</strong></p><p>利用创建工具 GUIDE 进行 GUI 设计的步骤和方法：</p><ul><li><strong>GUIDE的启动</strong></li></ul><p>在MATLAB的命令行中输入guide，启动图形界面创建工具GUIDE，系统弹出GUIDE快速入门对话框。该对话框中主要包括两个选项卡：①创建GUI选项卡，包含了4种类型的GUI模板：默认的空白GUI模板、带有Uicontrol控件的GUI模板、带有坐标轴和菜单的GUI模板及模态对话框模板；②打开现有GUI选项卡，打开已有的GUI对象或者单击该选项卡中的浏览按钮来浏览选择已经存在的GUI对象。</p><p><a href="https://imgse.com/i/pAMGwbq"><img src="https://s21.ax1x.com/2024/09/21/pAMGwbq.jpg" alt="pAMGwbq.jpg" /></a></p><p>如果需要对GUI编辑界面的显示属性进行修改或重新设置，则可以选择"文件"→"预设选项"命令进行设置。可以设置的属性包括在组件选项板中显示名称、在窗口标题中显示文件扩展名、在窗口标题中显示文件路径及为新生成的回调函数添加注释等。</p><ul><li><p><strong>创建图形用户界面对象</strong>：在打开的图形用户界面上添加控件来完成这个图形界面的布局和控制。</p></li><li><p><strong>设置组件的属性</strong>：从工具栏中选择"属性检查器"，设置属性。</p></li><li><p><strong>编写回调函数</strong>：完成图形用户界面的编辑后，添加回调函数执行代码，才能完成图形函数的处理过程。</p></li><li><p><strong>图形用户界面的执行</strong>：在图形用户编辑界面中单击"运行"按钮 来运行编辑过的图形用户界面（GUI）。</p></li></ul><p><a href="https://imgse.com/i/pAMIqNq"><img src="https://s21.ax1x.com/2024/09/22/pAMIqNq.jpg" alt="pAMIqNq.jpg" /></a></p><p><strong>（2）GUIDE创建的工具</strong></p><p>在使用GUIDE创建图形用户界面时，有些比较常用的功能，能够更好地帮助用户完成图形用户界面的绘制过程。</p><ul><li>位置调整工具："工具"→"对齐对象"<ul><li>排列组件对象以完成界面的布局和排布。</li></ul></li><li>网格和标尺："工具"→"网格和标尺"<ul><li>调整改变网格线的间距或显示标尺。</li></ul></li><li>对象浏览器："视图"→"对象浏览器"或选择工具栏中的“对象浏览器”图标，<ul><li>查看放置在图形界面中对象的名称及相互之间的继承关系等。</li></ul></li><li>GUI组件选项："工具"→"GUI选项"，<ul><li>①调整大小的方式（不可调整大小/成比例/其他）；</li><li>②命令行的可访问性（回调/禁用/启用/其他），在创建图形对象的过程中，选择是否通过命令行方式来访问各种对象；</li><li>③生成FIG文件和MALTAB文件，此项可以设置用户在创建GUI对象时，是否生成FIG文件和M文件；</li><li>④仅生成FIG文件，此时仅仅创建FIG文件，可以使用open或hgload来显示该文件，一般在用户希望创建一个与M文件完全不同的实例时，可以选择此选项。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Matlab </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GUI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MODIS/Landsat/Sentinel下载教程详解【常用网站及方法枚举】</title>
      <link href="/2024/09/15/RS-data-dowmload/"/>
      <url>/2024/09/15/RS-data-dowmload/</url>
      
        <content type="html"><![CDATA[<h2 id="前言">⛄前言</h2><p>在当今快速发展的地球观测时代，遥感技术作为获取地球表面及其环境信息的重要手段，正以前所未有的广度和深度改变着我们对自然界的认知与管理方式。MODIS（Moderate-resolution Imaging Spectroradiometer，中分辨率成像光谱仪）、Landsat系列卫星以及Sentinel（哨兵）卫星，作为当前遥感数据领域的三大支柱，各自以其独特的观测能力、数据分辨率和覆盖范围，为全球科研工作者、环境管理者、灾害监测部门等提供了丰富的地球观测数据资源。</p><p>随着气候变化、环境退化、自然灾害频发等问题日益严峻，对高精度、高时效的地球观测数据需求日益增长。MODIS以其每日覆盖全球的高频观测能力，成为监测全球环境变化、气候趋势及农作物生长状况的重要工具；Landsat系列卫星以其长期的历史数据积累和中等空间分辨率，成为土地利用变化、城市扩张、森林覆盖监测等领域不可或缺的数据源；而Sentinel卫星系列，则以其多光谱、雷达及大气监测等多种传感器组合，为海洋监测、陆地变化检测、紧急响应等提供了全方位的支持。所以，掌握MODIS/Landsat/Sentinel遥感数据的下载方法，对于促进科学研究、提升环境监测能力、指导灾害应急响应及促进可持续发展等方面具有深远的意义。具体而言：</p><ul><li><strong>促进科学研究</strong>：科研人员可以便捷地获取到高质量、多源融合的遥感数据，开展气候变化研究、生态系统评估、资源环境调查等，为制定科学合理的环境保护与资源开发政策提供科学依据。</li><li><strong>提升环境监测能力</strong>：环境管理部门通过定期下载和分析这些遥感数据，能够实时监测环境质量变化，如空气质量、水体污染、土壤侵蚀等，为环境监管和治理提供有力支持。</li><li><strong>指导灾害应急响应</strong>：在自然灾害发生时，如洪水、地震、森林火灾等，快速获取灾区遥感影像，能够准确评估灾害损失，指导救援物资调配和灾后重建工作，有效减轻灾害影响。</li><li><strong>促进可持续发展</strong>：通过长期跟踪监测，可以评估人类活动对自然环境的影响，为制定和实施可持续发展战略提供数据支撑，促进经济、社会与环境的协调发展。</li></ul><p>因此，笔者通过总结梳理一份详尽的<strong>多源遥感数据下载教程</strong>，不仅能够帮助用户掌握数据获取的基本技能，更是推动遥感技术在各个领域广泛应用、服务全球可持续发展的关键一步。</p><blockquote><p><strong>注意</strong>：关于NASA、USGS、<a href="https://dataspace.copernicus.eu/">哥白尼数据空间生态系统</a>的账号，请大家自行注册。本博客只介绍和展示多源遥感数据的常用网站，具体筛选数据和下载数据的流程都是大同小异的，大家可根据各自需求进行操作；针对MODIS和Landsat等遥感数据，还将介绍批量下载以及提高下载速度的方案。</p><p>如果<strong>可爱、聪明</strong>的您具有一定的知识储备和编程知识，也可以通过<strong>Google Earth Engine</strong>处理及下载遥感影像。</p></blockquote><h2 id="多源遥感数据下载网站">⛄多源遥感数据下载网站</h2><h3 id="modis">👀MODIS</h3><p><strong>（1）NASA Earthdata Search</strong></p><p>官方网站：<a href="https://www.earthdata.nasa.gov/">Earthdata</a>（<a href="https://www.earthdata.nasa.gov">https://www.earthdata.nasa.gov</a>）</p><p><a href="https://imgse.com/i/pAudz6g"><img src="https://s21.ax1x.com/2024/09/15/pAudz6g.jpg" alt="pAudz6g.jpg" /></a></p><p>下载网站：<a href="https://search.earthdata.nasa.gov/search">Earthdata Search</a>（<a href="https://search.earthdata.nasa.gov/search">https://search.earthdata.nasa.gov/search</a>）</p><p><a href="https://imgse.com/i/pAuwC0s"><img src="https://s21.ax1x.com/2024/09/15/pAuwC0s.jpg" alt="pAuwC0s.jpg" /></a></p><p><strong>（2）NASA LAADS DAAC</strong></p><p>官方网站：<a href="https://ladsweb.modaps.eosdis.nasa.gov/">LAADS DAAC</a>（<a href="https://ladsweb.modaps.eosdis.nasa.gov">https://ladsweb.modaps.eosdis.nasa.gov</a>）</p><p>了解更多LAADS DAAC信息，请点击<a href="https://ladsweb.modaps.eosdis.nasa.gov/about/">关于LAADS DAAC</a></p><p><a href="https://imgse.com/i/pAuwSXQ"><img src="https://s21.ax1x.com/2024/09/15/pAuwSXQ.jpg" alt="pAuwSXQ.jpg" /></a></p><p>下载网站：<a href="https://ladsweb.modaps.eosdis.nasa.gov/search/">LAADS DAAC Search</a>（<a href="https://ladsweb.modaps.eosdis.nasa.gov/search/">https://ladsweb.modaps.eosdis.nasa.gov/search/</a>）</p><p><a href="https://imgse.com/i/pAuw9mj"><img src="https://s21.ax1x.com/2024/09/15/pAuw9mj.jpg" alt="pAuw9mj.jpg" /></a></p><p><strong>（3）NASA Worldview</strong></p><p>NASA Worldview是一个功能强大的在线平台，它允许用户交互式地浏览全球范围内的全分辨率卫星图像。不仅显示卫星图像，还集成了实时云层数据和超过800个世界图层，为用户提供了丰富的地球观测视角。该平台通常能够在卫星观测后60到125分钟内发布图像，确保用户获取到的是接近实时的地球观测数据。主要特点如下：</p><ul><li><strong>实时性</strong>：通过集成多源卫星数据，NASA Worldview能够为用户提供接近实时的地球观测图像，这对于监测环境变化、自然灾害等具有重要意义。</li><li><strong>交互性</strong>：用户可以通过滑动时间轴查看历史数据，放大和缩小不同的区域以获取更详细的图像信息，还可以根据需要调整图层的显示，以满足不同的研究和分析需求。</li><li><strong>多源性</strong>：平台集成了来自不同卫星和传感器的数据，包括NASA自己的Terra/MODIS等，以及可能的合作机构数据，为用户提供多样化的数据源选择。</li><li><strong>支持下载</strong>：虽然NASA Worldview主要是一个在线浏览平台，但用户也可以下载基础数据，特别是与全球降水测量任务相关的数据，以支持时间关键型应用领域如野火管理、空气质量测量和洪水监测等。</li></ul><p>官方网站：<a href="https://worldview.earthdata.nasa.gov/">Worldview</a>（<a href="https://worldview.earthdata.nasa.gov/">https://worldview.earthdata.nasa.gov/</a>）</p><p><a href="https://imgse.com/i/pAuwFkq"><img src="https://s21.ax1x.com/2024/09/15/pAuwFkq.jpg" alt="pAuwFkq.jpg" /></a></p><h3 id="landsat">👀Landsat</h3><p><strong>（1）USGS Earthexplorer</strong></p><p>官方网站：<a href="https://earthexplorer.usgs.gov/">USGS</a>（<a href="https://earthexplorer.usgs.gov">https://earthexplorer.usgs.gov</a>），<strong>科学上网</strong>。</p><p><a href="https://imgse.com/i/pAuwAhV"><img src="https://s21.ax1x.com/2024/09/15/pAuwAhV.jpg" alt="pAuwAhV.jpg" /></a></p><p><strong>（2）LandsatLook</strong></p><p>官方网站：<a href="https://landsatlook.usgs.gov/">LandsatLook</a>（<a href="https://landsatlook.usgs.gov">https://landsatlook.usgs.gov</a>）</p><blockquote><p><strong>LandsatLook</strong> is a tool that allows rapid online viewing and access to the USGS Landsat <strong>Collection 2 data</strong>. LandsatLook leverages resources available via a commercial cloud environment including Cloud Optimized GeoTIFF (COG) and Spatio Temporal Asset Catalog (STAC) metadata.</p></blockquote><p>下载网站：<a href="https://landsatlook.usgs.gov/explore">LandsatLook Explore</a>（<a href="https://landsatlook.usgs.gov/explore">https://landsatlook.usgs.gov/explore</a>）</p><p><a href="https://imgse.com/i/pAuwP7n"><img src="https://s21.ax1x.com/2024/09/15/pAuwP7n.jpg" alt="pAuwP7n.jpg" /></a></p><h3 id="sentinel">👀Sentinel</h3><p>官方网站：<a href="https://dataspace.copernicus.eu/">Copernicus</a>（<a href="https://dataspace.copernicus.eu">https://dataspace.copernicus.eu</a>）</p><p><a href="https://imgse.com/i/pAu0bJP"><img src="https://s21.ax1x.com/2024/09/15/pAu0bJP.jpg" alt="pAu0bJP.jpg" /></a></p><p>下载网站：<a href="https://browser.dataspace.copernicus.eu/">Copernicus Browser</a>（<a href="https://browser.dataspace.copernicus.eu">https://browser.dataspace.copernicus.eu</a>）</p><p><a href="https://imgse.com/i/pAuwkt0"><img src="https://s21.ax1x.com/2024/09/15/pAuwkt0.jpg" alt="pAuwkt0.jpg" /></a></p><h2 id="数据批量下载方法">⛄数据批量下载方法</h2><h3 id="modis-1">👀MODIS</h3><p>这里以NASA LAADS DAAC为例，下载MODIS数据。假设已完成数据订单的提交申请，<a href="https://ladsweb.modaps.eosdis.nasa.gov/tools-and-services/data-download-scripts/#alternative">官方下载帮助</a>。</p><p><a href="https://imgse.com/i/pAuoY2F"><img src="https://s21.ax1x.com/2024/09/16/pAuoY2F.jpg" alt="pAuoY2F.jpg" /></a></p><p><strong>（1）wget</strong></p><ul><li><p>wget安装：<a href="https://blog.csdn.net/m0_45447650/article/details/125786723">安装教程</a></p></li><li><p>wget使用：参照官方给的输入命令，查找替换相关参数。在CMD窗口中输入以下命令：</p></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget -e robots=off -m -np -R .html,.tmp -nH --cut-dirs=3 &quot;https://ladsweb.modaps.eosdis.nasa.gov/archive/allData/PATH_TO_DATA_DIRECTORY&quot; --header &quot;Authorization: Bearer MY_TOKEN&quot; -P TARGET_DIRECTORY_ON_YOUR_FILE_SYSTEM</span><br></pre></td></tr></table></figure><blockquote><p>Be sure to replace the following:</p><ul><li>PATH_TO_DATA_DIRECTORY: location of source directory in LAADS Archive。<strong>数据订单网址</strong>，如https://ladsweb.modaps.eosdis.nasa.gov/archive/orders/#########/</li><li>TOKEN: Your token。<strong>账号秘钥</strong>：<a href="https://ladsweb.modaps.eosdis.nasa.gov/learn/download-files-using-edl-tokens/">Token查询教程</a></li><li>TARGET_DIRECTORY_ON_YOUR_FILE_SYSTEM: Where you would like to download the files。<strong>下载存放地址</strong></li></ul></blockquote><p>wget下载例子（初步尝试速度较慢）：</p><p><a href="https://imgse.com/i/pAuotv4"><img src="https://s21.ax1x.com/2024/09/16/pAuotv4.jpg" alt="pAuotv4.jpg" /></a></p><p><strong>（2）Python</strong></p><ul><li>首先，在<a href="https://ladsweb.modaps.eosdis.nasa.gov/tools-and-services/data-download-scripts/#python">官方下载帮助</a>（即"Download Help"）中选择"<a href="https://ladsweb.modaps.eosdis.nasa.gov/tools-and-services/data-download-scripts/#python">Python方式</a>"，点击"Download source"超链接，获取文件为"<code>laads-data-download.py.txt</code>"，然后移除"<code>.txt</code>"后缀扩展。</li></ul><p><a href="https://imgse.com/i/pAuo35V"><img src="https://s21.ax1x.com/2024/09/16/pAuo35V.jpg" alt="pAuo35V.jpg" /></a></p><ul><li>假设"<strong>聪明的您</strong>"已经配置好Python环境，输入以下命令：</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python laads-data-download.py -s 数据订单地址 -d 下载存放地址 -t 账号秘钥</span><br></pre></td></tr></table></figure><p>Python下载例子（初步尝试速度较快）：</p><p><a href="https://imgse.com/i/pAuoGCT"><img src="https://s21.ax1x.com/2024/09/16/pAuoGCT.jpg" alt="pAuoGCT.jpg" /></a></p><p><strong>（3）火狐浏览器的DownThemAll插件</strong></p><ul><li>安装火狐浏览器和<code>DownThemAll!</code>扩展工具，在数据订单界面选择数据，右键选择"<code>DownThemAll!</code>"；</li></ul><p><a href="https://imgse.com/i/pAuoJ8U"><img src="https://s21.ax1x.com/2024/09/16/pAuoJ8U.jpg" alt="pAuoJ8U.jpg" /></a></p><ul><li>根据"<code>DownThemAll!</code>"的筛选器快速识别对应的文件，点击"下载"即可。</li></ul><p><a href="https://imgse.com/i/pAuoUKJ"><img src="https://s21.ax1x.com/2024/09/16/pAuoUKJ.jpg" alt="pAuoUKJ.jpg" /></a></p><p>DownThemAll下载例子（初步尝试速度较慢或适中）：</p><p><a href="https://imgse.com/i/pAuoar9"><img src="https://s21.ax1x.com/2024/09/16/pAuoar9.jpg" alt="pAuoar9.jpg" /></a></p><p><strong>（4）IDM</strong></p><ul><li>安装"<code>Internet Download Manager</code>"，在数据订单界面选择数据，右键选择"<code>IDM Integration Module</code>"→"<code>使用IDM下载全部链接</code>"；</li><li>在"<code>使用IDM下载全部链接</code>"窗口中，设置筛选条件和保存路径，点击"确认"即可。</li></ul><p><a href="https://imgse.com/i/pAuodbR"><img src="https://s21.ax1x.com/2024/09/16/pAuodbR.jpg" alt="pAuodbR.jpg" /></a></p><p>IDM下载例子（初步尝试速度较快）：</p><p><a href="https://imgse.com/i/pAu7wh6"><img src="https://s21.ax1x.com/2024/09/16/pAu7wh6.jpg" alt="pAu7wh6.jpg" /></a></p><h3 id="landsat-1">👀Landsat</h3><p>这里以USGS为例，下载Landsat数据。假设Landsat数据下载进度已经到"<code>Search Results</code>"界面。</p><p><strong>（1）Bulk Download Web Application</strong></p><ul><li>根据筛选条件获取数据条目，每条数据下面有个小菜单，选择按钮【<code>Add to Bulk Download</code>】，将想要批量下载的数据添加到【<code>Item Basket</code>】，如果该数据添加成功，那么按钮就会变成绿色的；</li></ul><p><a href="https://imgse.com/i/pAu7D1O"><img src="https://s21.ax1x.com/2024/09/16/pAu7D1O.jpg" alt="pAu7D1O.jpg" /></a></p><ul><li>上方菜单中的【<code>Item Basket</code>】右边的数字就会变成对于所选择的数据量；点击【<code>Item Basket</code>】进入到如下界面，并点击【<code>Start Order</code>】；</li></ul><p><a href="https://imgse.com/i/pAu7tB9"><img src="https://s21.ax1x.com/2024/09/16/pAu7tB9.jpg" alt="pAu7tB9.jpg" /></a></p><ul><li>加载片刻出现以下界面，点击Landsat 8-9左边的倒三角标，将展开所选的各个数据；此界面可以通过【<code>Options</code>】或各个数据最右侧的按钮进行操作；通过鼠标左键，单击批量下载的数据，最后点击【<code>Submit Product Selections</code>】；</li></ul><p><a href="https://imgse.com/i/pAu7aA1"><img src="https://s21.ax1x.com/2024/09/16/pAu7aA1.jpg" alt="pAu7aA1.jpg" /></a></p><ul><li>Order创建成功会返回如下界面，显示Order名称，如果网络正常，对应邮箱在1-2分钟之内收到USGS的邮件通知；点击界面中超链接【<code>Bulk Download Web Application</code>】或者【<code>Start Downloading</code>】，进入批量下载界面（官方提醒，通过该Web应用下载不需安装Java环境，但需要基于chrome浏览器或edge浏览器，本次测试使用chrome浏览器）</li></ul><p><a href="https://imgse.com/i/pAu7N7R"><img src="https://s21.ax1x.com/2024/09/16/pAu7N7R.jpg" alt="pAu7N7R.jpg" /></a></p><ul><li>跳转到如下界面后，点击绿色按钮【<code>Launch Bulk Download Web Application</code>】</li></ul><p><a href="https://imgse.com/i/pAu7rcD"><img src="https://s21.ax1x.com/2024/09/16/pAu7rcD.jpg" alt="pAu7rcD.jpg" /></a></p><ul><li>选择【<code>Open Order</code>】后→弹出窗口，依次确认，可以提前新建存放数据的文件夹；</li></ul><p><a href="https://imgse.com/i/pAu7dtx"><img src="https://s21.ax1x.com/2024/09/16/pAu7dtx.jpg" alt="pAu7dtx.jpg" /></a></p><p><a href="https://imgse.com/i/pAu7B9K"><img src="https://s21.ax1x.com/2024/09/16/pAu7B9K.jpg" alt="pAu7B9K.jpg" /></a></p><p><strong>（2）IDM</strong></p><ul><li>操作步骤，同上；</li><li>但是当浏览器开启IDM扩展工具时，在利用【<code>Bulk Download Web Application</code>】下载时，会自动调用IDM进行下载。</li></ul><p><a href="https://imgse.com/i/pAKJIKA"><img src="https://s21.ax1x.com/2024/09/18/pAKJIKA.jpg" alt="pAKJIKA.jpg" /></a></p><blockquote><p>注意：通过<code>USGS Earthexplorer</code>网站可以下载<code>L1</code>、<code>L2</code>级数据；通过<code>LandsatLook</code>网站只能下载<code>L2SP</code>级数据，筛选数据后，直接点击下载即可，下载速度比较快。</p></blockquote><h3 id="sentinel-1">👀Sentinel</h3><ul><li>筛选数据，直接点击下载即可，下载速度比较快。</li><li>详细下载教程，请参考笔者的博客：<a href="https://blog.csdn.net/twg666/article/details/134089146">Sentinel--哨兵系列数据下载地址及流程更新【202310】</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 遥感数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Sentinel </tag>
            
            <tag> MODIS </tag>
            
            <tag> Landsat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GUI编程之PyQt5入门详解（01）</title>
      <link href="/2024/08/25/Python-GUI-Design/"/>
      <url>/2024/08/25/Python-GUI-Design/</url>
      
        <content type="html"><![CDATA[<p>GUI是Graphical User Interface的英文简称，即图形用户界面，准确地说，GUI就是屏幕产品的视觉体验和互动操作部分。GUI是一种结合计算机科学、美学、心理学、行为学及各商业领域需求分析的人机系统工程，强调人一机一环境三者作为一个系统进行总体设计。</p><h2 id="认识pyqt5">⛄认识PyQt5</h2><h3 id="pyqt5框架简介">👀PyQt5框架简介</h3><p>Python最初是作为一门脚本语言开发的，并不具备GUI功能，但由于其本身具有良好的可扩展性，能够不断地通过C/C++模块进行功能性扩展，因此目前已经有相当多的GUI控件集（Toolkit）可以在Python中使用了。Python中经常使用的GUI控件集有PyQt、Tkinter、wxPython、Kivy、PyGUI和Libavg，其中PyQt是Qt为Python专门提供的GUI扩展。</p><p>Qt是挪威Trolltech（奇趣科技公司）开发的一个C++ GUI应用程序，其包括跨平台类库、集成开发工具和跨平台IDE，既可以用于开发GUI程序，也可以用于开发非GUI程序。使用Qt只需开发一次应用程序，便可跨不同桌面和嵌入式操作系统部署该应用程序，而无须重新编写源代码。和Python一样，Qt也具有相当优秀的跨平台特性，使用Qt开发的应用程序能够在Windows、Linux和Mac OS平台之间轻松移植。</p><p>PyQt是一个用于创建GUI应用程序的跨平台的工具包，它将Python编程语言和Qt库成功融合在一起。Qt库是目前最强大的GUI库之一。PyQt是由Phil Thompson开发的，实现了一个Python模块集，拥有620多个类、将近6000个函数。PyQt可以运行在所有主流的操作系统上，包括UNIX、Windows和Mac OS。PyQt采用双许可证，开发人员可以选择GPL（GNU通用公共许可证）和商业许可。在此之前，GPL版本只能用在UNIX上；从PyQt4开始，GPL版本可用于所有支持的平台上。</p><p>博客：<a href="https://blog.csdn.net/qq_38463737/article/details/107605926">基础教程网站和书籍推荐</a></p><ul><li><p><a href="https://www.riverbankcomputing.com/">PyQt5官方网站</a></p></li><li><p><a href="https://www.riverbankcomputing.com/static/Docs/PyQt5/module_index.html">PyQt5全部模块文档</a></p></li><li><p><a href="https://www.riverbankcomputing.com/static/Docs/PyQt5/api/qtwidgets/qtwidgets-module.html">PyQt5 QtWidgets控件文档</a></p></li><li><p><a href="https://www.qt.io/zh-cn/">Qt官方中文网站</a></p></li><li><p><a href="https://doc.qt.io/">Qt官方文档网站</a></p></li><li><p><a href="https://doc.qt.io/qt-5/qtmodules.html">Qt5全部模块文档</a></p></li><li><p><a href="https://doc.qt.io/qt-5/qtwidgets-module.html">Qt5 QtWidgets控件文档</a></p></li></ul><h3 id="pyqt5的特点">👀PyQt5的特点</h3><p>PyQt5严格遵循Qt的发布许可，拥有双重协议，自由开发者可以选择使用免费的GPL版本，如果准备将PyQt用于商业活动，则必须为此交付商业许可费用。PyQt具有如下优秀的特性：</p><ul><li><p>基于高性能的Qt的GUI控件集；</p></li><li><p>能够跨平台运行在Windows、Linux和Mac OS等系统上；</p></li><li><p>使用信号/槽（signal/slot）机制进行通信；</p></li><li><p>对Qt库的完全封装；</p></li><li><p>可以使用Qt成熟的IDE（如Qt Designer）进行图形界面设计，并自动生成可执行的Python代码；</p></li><li><p>提供了一整套种类繁多的窗口控件。</p></li></ul><h3 id="qt与pyqt的关系">👀Qt与PyQt的关系</h3><p>首先，PyQt是Qt框架的Python语言实现。PyQt提供了一个设计良好的窗口控件集合，每一个PyQt控件都有其对应的Qt控件。所以PyQt与Qt的类库和API非常详细，而且PyQt不再使用qmake系统和Q_OBJECT宏，使得PyQt再也没有编译链接错误，PyQt的代码也更加友好。</p><p>其次，在开发速度上，由于PyQt的核心就是Qt库，也是用C++编写的，所以即使逻辑代码运行速度慢一点，也不会成为性能瓶颈。在使用方式上，PyQt也没有失去Python的优雅语法、快速开发的能力。Python相对于C++的优点是在编程效率上，可以看到标准的Qt例子移植到PyQt后的代码具有相同的功能，使用相同的应用程序接口，Python版本的代码只有原来的50%~60%，而且更容易阅读。在开发效率上，由于Python是一种面向对象的语言，语法简单、高效，相对于C++而言，使用Python编写程序可以提高开发效率，减少开发成本。</p><p>最后，PyQt向Python程序员提供了使用完整的Qt应用程序接口的函数，几乎可以用Python做任何Qt能做的事。Qt和PyQt的设计都是完全面向对象的。Qt使用一种称为信号/槽的机制在窗口控件之间传递事件和消息。这种机制完全不同于其他图形界面开发库所采用的回调（callback）机制，使用信号/槽可以使程序更加安全和简洁。所开发的应用程序越大，Qt/PyQt的这个优势就越明显。</p><h3 id="图形界面开发库介绍">👀图形界面开发库介绍</h3><p>从Python语言的诞生之日起，有许多优秀的GUI工具集被整合到Python当中，使得Python也可以在图形界面编程领域大展身手。</p><p><strong>（1）Tkinter</strong></p><p>Tkinter是绑定了Python的Tk GUI工具集，就是Python包装的Tcl代码，通过内嵌在Python解释器内部的Tcl解释器实现。将Tkinter的调用转换成Tcl命令，然后交给Tcl解释器进行解释，实现Python的GUI。Tk和其他语言的绑定，比如PerlTk，是直接由Tk中的C库实现的。</p><p>Tkinter是Python事实上的标准GUI，在Python中使用Tk GUI工具集的标准接口，已经包含在Python Windows安装程序中，著名的IDLE就是使用Tkinter实现GUI的。</p><p><strong>（2）wxPython</strong></p><p>wxPython是Python对跨平台的GUI工具集wxWidgets（用 C++编写）的包装，作为Python的一个扩展模块来实现。wxPython是比较流行的Tkinter的一个替代品，在各种平台上都表现良好。</p><p><strong>（3）PyGTK</strong></p><p>PyGTK是Python对GTK+GUI库的一系列包装。PyGTK是比较流行的Tkinter的一个替代品，Gnome下许多著名应用程序的GUI都是使用PyGTK实现的，比如BitTorrent、GIMP等。PyGTK和Gedit都有可选的实现，在Windows平台上似乎表现不太好，这一点也无可厚非，毕竟使用的是GTK的GUI库。</p><p><strong>（4）PySide</strong></p><p>PySide由Qt官方维护，是Python对跨平台的GUI工具集Qt的另一个包装，捆绑在Python当中。PySide是比较流行的Tkinter的一个替代品，拥有LGPL 2.1授权许可，允许进行免费的开源软件和私有的商业软件的开发。</p><p>在以上图形界面开发库中，前三个没有类似于Qt Designer（UI制作工具，它可以通过可视化操作创建UI文件，然后通过工具快速编译成Python文件，因此也可以把它视为一个代码生成器）的工具，所有的代码都需要手动输入，学习曲线非常陡峭；而第四个PySide本质上也是Qt的Python封装，只是支持Qt的版本比较老，而且官方已经停止维护这个库。所以，对于Python使用者来说，使用PyQt进行GUI开发是最好的选择。</p><h2 id="qt-designer的使用">⛄Qt Designer的使用</h2><p>制作程序UI界面，一般可以通过UI制作工具和纯代码编写两种方式来实现。在PyQt5中，也可以采用这两种方式。本入门教程通过Qt Designer工具来制作UI界面。</p><h3 id="qt-designer快速入门">👀Qt Designer快速入门</h3><p>Qt Designer，即Qt设计师，是一个强大、灵活的可视化GUI设计工具，可以帮助我们加快开发PyQt程序的速度。它是专门用来制作PyQt程序中UI界面的工具，它生成的UI界面是一个后缀为.ui的文件，可以通过命令将.ui文件转换成.py格式的文件，并被其他Python文件引用。Qt Designer符合MVC（模型一视图一控制器）设计模式，做到了显示和业务逻辑的分离。Qt Designer具有以下优点。</p><ul><li><p>使用简单，通过拖曳和点击就可以完成复杂的界面设计，而且还可以随时预览查看效果图。</p></li><li><p>转换Python文件方便。Qt Designer可以将设计好的用户界面保存为<code>.ui</code>文件，其实是XML 格式的文本文件。为了在PyQt中使用<code>.ui</code>文件，可以通过 pyuic5命令将<code>.ui</code>文件转换为<code>.py</code>文件件，然后将<code>.py</code>文件引入到自定义的Python代码中。</p></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 笔者机器上Qt Designer的安装路径</span></span><br><span class="line">D:\Anaconda3\Lib\site-packages\pyqt5_tools\Qt\<span class="built_in">bin</span>\designer.exe</span><br></pre></td></tr></table></figure><p><strong>（1）新建主窗口</strong></p><p>打开PyQt5的Qt Designer，会自动弹出“新建窗体”对话框。在模板选项中，最常用的就是Widget（通用窗口）和 Main Window（主窗口）。在PyQt5中Widget被分离出来，用来替代Dialog，并将Widget放入了QtWidget 模块库中。</p><p><strong>（2）窗口主要区域</strong></p><ul><li><p>Widget Box（工具箱），提供了很多控件，包括常用的按钮、单选按钮、文本框等，可以直接拖放到主窗口中。在菜单栏中选择”窗体“→”预览“，或者按”Ctrl+R“快捷键，查看预览效果。</p></li><li><p>主窗口：即新建的窗口，界面设计的主窗口；</p></li><li><p>对象查看器：可以查看主窗口中放置的对象列表；</p></li><li><p>属性编辑器：提供了对窗口、控件、布局的属性编辑功能；</p></li><li><p>信号/槽编辑器、动作编辑器和资源浏览器：在信号/槽编辑器中，可以为控件添加自定义的信号和槽函数，编辑控件的信号和槽函数；在资源浏览器中，可以为控件添加图片，比如Label、Button的背景图片。</p></li></ul><p><strong>（3）查看UI文件</strong></p><p>采用Qt Designer工具设计的界面文件默认为<code>.ui</code>文件，描述了窗口中控件的属性列表和布局显示。<code>.ui</code>文件里面包含的内容是按照XML（可扩展标记语言）格式处理的，文件中包含的参数信息与使用Qt Designer打开<code>.ui</code>文件时显示的信息是一致的。</p><p><strong>（4）将<code>.ui</code>文件转换为<code>.py</code>文件</strong></p><p>使用Qt Designer设计的用户界面默认保存为<code>.ui</code>文件，其内容结构类似于XML，但这种文件并不是我们想要的，我们想要的是<code>.py</code>文件，所以还需要使用其他方法将<code>.ui</code>文件转换为<code>.py</code>文件。<a href="https://www.riverbankcomputing.com/static/Docs/PyQt5/designer.html#pyuic5">pyuic5官方网站</a></p><ul><li><p>第一种方法：通过编译器将<code>.ui</code>文件转换为<code>.py</code>;</p></li><li><p>第二种方法：通过命令行将<code>.ui</code>文件转换为<code>.py</code>。PyQt5安装成功后，<code>pyuic5</code>命令行工具默认安装在<code>Scripts</code>文件夹下。</p></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 笔者机器上pyuic5命令行工具的路径</span></span><br><span class="line">D:\Anaconda3\Scripts</span><br><span class="line"><span class="comment"># 输入以下命令将将.ui文件转换为.py</span></span><br><span class="line">pyuic5 -o ******.py ******.ui</span><br></pre></td></tr></table></figure><ul><li>第三种方法：通过Python脚本<code>.ui</code>文件转换为<code>.py</code>。该脚本本质上是用Python代码把上述命令行操作封装起来，只要把该Python文件放在需要转换界面文件的目录下，直接运行即可，其执行效果和直接执行转换命令是一样的。其完整代码如下：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> os.path</span><br><span class="line"></span><br><span class="line"><span class="comment"># UI文件所在的路径</span></span><br><span class="line"><span class="built_in">dir</span> = <span class="string">&#x27;./&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出目录下的所有UI文件</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">listUiFile</span>():</span><br><span class="line">    <span class="built_in">list</span> = []</span><br><span class="line">    <span class="comment"># os.listdir()方法用于返回指定的文件夹包含的文件或文件夹的名字的列表</span></span><br><span class="line">    files = os.listdir(<span class="built_in">dir</span>)</span><br><span class="line">    <span class="keyword">for</span> filename <span class="keyword">in</span> files:</span><br><span class="line">        <span class="comment"># os.path.splitext()方法用于分割路径，返回路径名和文件扩展名的元组。</span></span><br><span class="line">        <span class="keyword">if</span> os.path.splitext(filename)[<span class="number">1</span>] == <span class="string">&quot;.ui&quot;</span>:</span><br><span class="line">            <span class="built_in">list</span>.append(filename)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 把扩展名为.ui的文件改成扩展名为.py的文件</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">transPyFile</span>(<span class="params">filename</span>):</span><br><span class="line">    <span class="keyword">return</span> os.path.splitext(filename)[<span class="number">0</span>] + <span class="string">&quot;.py&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用系统命令把UI文件转换成Python文件</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">runMain</span>():</span><br><span class="line">    <span class="built_in">list</span> = listUiFile()</span><br><span class="line">    <span class="keyword">for</span> uifile <span class="keyword">in</span> <span class="built_in">list</span>:</span><br><span class="line">        pyfile = transPyFile(uifile)</span><br><span class="line">        cmd = <span class="string">&quot;pyuic5 -o &#123;pyfile&#125; &#123;uifile&#125;&quot;</span>.<span class="built_in">format</span>(pyfile=pyfile, uifile=uifile)</span><br><span class="line">        <span class="comment"># print(cmd)</span></span><br><span class="line">        os.system(cmd)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 程序入口</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    runMain()   </span><br></pre></td></tr></table></figure><p><strong>（5）界面与逻辑分离</strong></p><p>由<code>.ui</code>文件编译而来的<code>.py</code>文件称为界面文件，由于界面文件每次编译时都会初始化，所以需要新建一个<code>.py</code>文件调用界面文件，这个新建的<code>.py</code>文件被称为逻辑文件，也可以称为业务文件。界面文件和逻辑文件是两个相对独立的文件，通过上述方法就实现了界面与逻辑的分离（也就是我们之前所说的“显示和业务逻辑的分离”）。实现界面与逻辑的分离方法很简单，只需要新建一个<code>.py</code>文件，并继承界面文件的主窗口类即可。其完整代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtWidgets <span class="keyword">import</span> QApplication, QMainWindow</span><br><span class="line"><span class="comment"># FistWindow为由.ui文件编译形成的.py界面文件</span></span><br><span class="line"><span class="keyword">from</span> FistWindow <span class="keyword">import</span> Ui_MainWindow</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyMainWindow</span>(QMainWindow, Ui_MainWindow):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, parent = <span class="literal">None</span></span>):</span><br><span class="line">        <span class="built_in">super</span>(MyMainWindow, self).__init__(parent)</span><br><span class="line">        self.setupUi(self)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app = QApplication(sys.argv)</span><br><span class="line">    mywin = MyMainWindow()</span><br><span class="line">    mywin.show()</span><br><span class="line">    sys.exit(app.exec_())</span><br></pre></td></tr></table></figure><p>上面的代码实现了业务逻辑，代码结构也比较清晰。如果以后想要更新界面，只需要对<code>.ui</code>文件进行更新，然后再编译成对应的<code>.py</code>文件即可；而逻辑文件则视情况做一些调整，一般情况下不需要调整太多。</p><h3 id="布局管理入门">👀布局管理入门</h3><p><strong>（1）布局类型</strong></p><p>Qt Designer提供了4种窗口布局方式，它们位于Qt Designer主窗口左侧区域的Widget Box（工具箱）里的Layouts（布局）栏中，分别是：</p><ul><li><p>Vertical Layout（垂直布局）：控件默认按照从上到下的顺序进行纵向添加。</p></li><li><p>Horizontal Layout（水平布局）：控件默认按照从左到右的顺序进行横向添加。</p></li><li><p>Grid Layout（柵格布局）：将窗口控件放入一个网格之中，然后将它们合理地划分成若干行（row）和列（column），并把其中的每个窗口控件放置在合适的单元（cell）中，这里的单元即是指由行和列交叉所划分出来的空间。</p></li><li><p>Form Layout（表单布局）：控件以两列的形式布局在表单中，其中左列包含标签，右列包含输入控件。</p></li></ul><p>一般进行布局有两种方式：一是通过布局管理器进行布局；二是通过容器控件进行布局。所谓容器控件，就是指能够容纳子控件的控件。使用容器控件，目的是将容器控件中的控件归为一类，以有别于其他控件。<strong>使用容器进行控件布局本质上还是调用布局管理器进行的</strong>。</p><p><strong>（2）Qt Designer布局的顺序</strong></p><p>使用Qt Designer开发一个完整的GUI程序流程如下：</p><ul><li><p>将一个窗口控件拖入窗口中并放置在大致正确的位置上。除了容器（container）窗口，一般不需要调整窗口的尺寸大小。</p></li><li><p>对于要用代码引用的窗口控件，应指定一个名字：对于需要微调的窗口控件，可以设置其对应的属性。</p></li><li><p>重复步骤1和2，直到所需要的全部窗口控件都放到了窗口中。</p></li><li><p>如有需要，在窗口控件之间可以用Vertical Spacer、Horizontal Spacer、Horizontal Line、Vertical Line隔开（实际上前两步就可以包含这部分内容）。</p></li><li><p>选择需要布局的窗口控件，使用布局管理器或者切分窗口（splitter）对它们进行布局。</p></li><li><p>重复步骤5，直到所有的窗口控件和分隔符都布局好为止。</p></li><li><p>单击窗口，并使用布局管理器对其进行布局。</p></li><li><p>为窗口的标签设置伙伴关系。</p></li><li><p>如果按键次序有问题，则需要设置窗口的Tab键次序。</p></li><li><p>在适当的地方为内置的信号和槽建立信号与槽连接。</p></li><li><p>预览窗口（Ctrl+R），并检查所有的内容能否按照设想进行工作。</p></li><li><p>设置窗口的对象名（在类中会用到这个名字）、窗口的标题并进行保存。</p></li><li><p>编译窗口（命令行中使用pyuic5），根据需要生成对话框代码。</p></li><li><p>编写代码，即业务逻辑文件。</p></li></ul><p><strong>设置伙伴关系</strong>：即是控件之间的相互关联，使得可以通过一个控件控制另一个控件；</p><p><strong>设置Tab键次序</strong>：程序中，在一个控件上使用Tab键会跳到另一个控件上，其跳转的规则或顺序即为Tab顺序。</p><blockquote><p>伙伴关系设置是单方向的，即设置后只是单方向的控制。伙伴关系一般包含两个控件，暂且称为控制控件A和被控制控件B，即可以由控件A来控制控件B，一般情况下控件A（即控制控件）只能是Label控件。其他的不能设置伙伴关系，控件B（即被控制控件）没有要求。由于伙伴关系中的控制控件只能是Label控件，而Label控件在程序中无法选中或单击，故而通常给Label设置热键。</p><p>快捷键：在全局可以直接使用的键及组合，例如：选中控件使用（ctrl+1）即可完成水平布局，其为快捷键。</p><p>热键：相对于快捷键有所区别。热键是只有在打开了某个窗口时，出现了下拉菜单，只有在这个菜单展开的时候才可使用“快捷键”调用相应功能。</p></blockquote><h3 id="信号和槽关联">👀信号和槽关联</h3><p>信号（signal）和槽（slot）是Qt的核心机制。在创建事件循环之后，通过建立信号和槽的连接就可以实现对象之间的通信。当信号发射（emit）时，连接的槽函数将会自动执行。</p><blockquote><p>在PyQt5中，信号和槽通过QObject.signal.connect()连接。</p><p>注意：使用QObject.signal.connect()连接的槽函数不要加括号，否则会出错。</p></blockquote><p>所有从QObject 类或其子类（如QWidget）派生的类都能够包含信号和槽。当对象改变其状态时，信号就由该对象发射出去。槽用于接收信号，但它们是普通的对象成员函数。多个信号可以与单个槽进行连接，单个信号也可以与多个槽进行连接。总之，信号和槽构建了一种强大的控件编程机制。</p><p>在Qt编程中，通过Qt信号槽机制对鼠标或键盘在界面上的操作进行响应处理，例如对鼠标单击按钮的处理。Qt中的控件能够发射什么信号，以及在什么情况下发射信号，在Qt的文档中有说明，不同的控件能够发射的信号种类和触发时机也是不同的。那么如何为控件发射的信号指定对应的处理槽函数呢？一般有三种方法：</p><ul><li><p>第一种是在窗口的UI设计中操作添加信号和槽;</p></li><li><p>第二种是通过代码连接信号和槽；</p></li><li><p>第三种是通过集成开发环境IDE和编译器产生信号和槽。</p></li></ul><h3 id="菜单栏和工具栏">👀菜单栏和工具栏</h3><p>MainWindow即主窗口，主要包含菜单栏、工具栏、任务栏等。双击菜单栏上的”在这里输入“，然后输入文字，最后按回车键即可生成菜单。</p><ul><li><p>子菜单可以通过动作编辑器或者属性编辑器中的Shortcut来添加快捷键。</p></li><li><p>动作编辑器中，双击需要编辑的动作，可以对其进行设置并添加图标、快捷键等。</p></li><li><p>默认生成的主窗口是不显示工具栏的，可以通过单击鼠标右键来添加工具栏；工具栏上的图标，可以通过<strong>动作编辑器</strong>建立并<strong>拖入</strong>工具栏中。</p></li><li><p>加载其他窗口，在当前窗口中嵌套另一个窗口。①首先创建第二个窗口，完成窗口设计，将<code>.ui</code>文件转换为<code>.py</code>文件；②在主窗口的业务逻辑<code>.py</code>中，创建类，集成子界面文件的主窗口类；③在主窗口的主界面类中生成子窗口实例，创建触发事件（信号→槽函数）；④定义槽函数，添加子窗口。</p></li></ul><h3 id="资源文件打包">👀资源文件打包</h3><p>使用PyQt5生成的应用程序引用图片资源主要有两种方法，第一种方法是将资源文件转换为Python文件，然后引用Python文件；第二种方法是在程序中通过相对路径引用外部图片资源。这里以第一种方法为例：</p><p><strong>（1）新建资源文件apprcc.qrc</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;RCC&gt;</span><br><span class="line">  &lt;qresource&gt;</span><br><span class="line">  &lt;/qresource&gt;</span><br><span class="line">&lt;/RCC&gt;</span><br></pre></td></tr></table></figure><p>打开Qt Designer，进入<strong>资源浏览器</strong>界面，然后打开资源文件<code>apprcc.qrc</code>，设置图片资源的前缀为pic，最后添加或删除图片资源。（它是以XML格式存储的）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;RCC&gt;</span><br><span class="line">  &lt;qresource prefix=&quot;pic&quot;&gt;</span><br><span class="line">    &lt;file&gt;image/001.jpg&lt;/file&gt;</span><br><span class="line">    &lt;file&gt;image/002.jpg&lt;/file&gt;</span><br><span class="line">  &lt;/qresource&gt;</span><br><span class="line">&lt;/RCC&gt;</span><br></pre></td></tr></table></figure><p><strong>（2）在窗体中放置控件</strong></p><p>在窗体中放置控件，并使用图片资源。将<code>.ui</code>文件转化为<code>.py</code>文件，运行<code>.py</code>文件，会抛出如下异常信息，提示找不到<code>apprcc_rc</code>。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ModuleNotFoundError: No module named <span class="string">&#x27;apprcc_rc&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这说明在脚本中使用以下代码导入的模块异常</span></span><br><span class="line"><span class="keyword">import</span> apprcc_rc</span><br></pre></td></tr></table></figure><p><strong>（3）转换资源文件</strong></p><p>使用<code>pyrcc5</code>命令将<code>apprcc.qrc</code>文件转换为<code>apprcc_rc.py</code>文件（之所以添加<code>_rc</code>，是因为Qt Designer导入资源文件时默认是加<code>_rc</code>的）</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pyrcc5 apprcc.qrc -o apprcc_rc.py</span><br></pre></td></tr></table></figure><p>转换完成后，在同级目录下会多出一个与<code>*.qrc</code>文件同名的<code>*_rc.py</code></p><p><strong>（4）导入<code>.py</code>资源文件</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> apprcc_rc</span><br></pre></td></tr></table></figure><p>在Qt Designer中使用图片资源时，图片资源的引入路径是冒号<code>:</code>加图片的路径，示例代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">:/pic/image/<span class="number">002.j</span>pg</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 注意到上面的路径与qrc文件的路径稍微有些不同，多了一个前缀&quot;pic&quot;，原因是Qt Designer会自动根据qrc中的qresource标签来调整这个路径。在qresource标签中有一个&quot;pic&quot;属性，Qt Designer会自动把&quot;pic&quot;添加到图片路径images/002.jpg中。</span></span><br></pre></td></tr></table></figure><h2 id="pyqt5基本窗口控件">⛄PyQt5基本窗口控件</h2><h3 id="创建窗口类">👀创建窗口类</h3><p>QMainWindow、QWidget和QDialog三个类都是用来创建窗口的，可以直接使用，也可继承后再使用。</p><p>QMainWindow主窗口为用户提供一个应用程序框架，该窗口可以包含菜单栏、工具栏、状态栏、标题栏等，是最常见的窗口形式，是GUI程序的主窗口。</p><p>QWidget是所有用户界面对象的基类，所有的窗口和控件都直接或间接继承自QWidget类。QWidget是在PyQt中建立界面的主要元素，在PyQt中把没有嵌入到其他控件中的控件称为窗口，一般窗口都有边框、标题栏。窗口是指程序的整体界面，可以包含标题栏、菜单栏、工具栏、关闭按钮、最小化按钮、最大化按钮；控件是指按钮、复选框、文本框、表格、进度条等这些组成程序的基本元素。一个程序可以有多个窗口，一个窗口也可以有多个控件。</p><p>QDialog是对话框窗口的基类。对话框主要用来执行短期任务，或者与用户进行互动，它可以是模态的，也可以是非模态的。QDialog窗口没有菜单栏、工具栏、状态栏。</p><p>如果是主窗口，就使用QMainWindow类；如果是对话框，就使用QDialog类；如果不确定，或者有可能作为顶层窗口，也有可能嵌入到其他窗口中，那么就使用QWidget类。</p><h3 id="qwidget">👀QWidget</h3><p>PyQt使用统一的坐标系统来定位窗口控件的位置和大小。以屏幕的左上角为原点，即（0, 0）点，从左向右为x轴正向，从上向下为y轴正向，整个屏幕的坐标系统就用来定位顶层窗口的。此外，在窗口内部也有自己的坐标系统，该坐标系统仍然以左上角作为原点，从左向右为x轴正向，从上向下为y轴正向，原点、x轴、y轴围成的区域叫作 Client Area（客户区），在客户区的周围则是标题栏（Window Title）和边框（Frame）。</p><ul><li>QWidget直接提供的成员函数：x()、y()获得窗口左上角的坐标，width()、height()获得客户区的宽度和高度。</li><li>QWidget的geometry()提供的成员函数：x()、y()获得客户区左上角的坐标，width()、height()获得客户区的宽度和高度。</li><li>QWidget的frameGeometry()提供的成员函数：x()、y()获得窗口左上角的坐标，width()、height()获得包含客户区、标题栏和边框在内的整个窗口的宽度和高度。</li></ul><h3 id="qlabel">👀QLabel</h3><p>QLabel对象作为一个占位符可以显示不可编辑的文本或图片，也可以放置一个GIF动画，还可以被用作提示标记为其他控件。纯文本、链接或富文本可以显示在标签上。其设置属性的方法和常用信号可以参考Qt Designer的属性编辑器和信号/槽编辑器。</p><h3 id="文本框类控件">👀文本框类控件</h3><p><strong>（1）QLineEdit类</strong></p><p>QLineEdit类是一个单行文本框控件，可以输入单行字符串。如果需要输入多行宇符串，则使用QTextEdit类。其设置属性的方法和常用信号可以参考Qt Designer的属性编辑器和信号/槽编辑器，下面以几个为例：</p><ul><li><p>setAlignment()：按固定值方式对齐文本。</p></li><li><p>setPlaceholderText()：设置文本框浮显文字。</p></li><li><p>setEchoMode()：设置文本框显示格式（正常显示、密码类型输入、密码掩码字符等等）。</p></li><li><p>setValidator()：设置文本框的验证器（验证规则），将限制任意可能输入的文本。比如整数、浮点数、正则表达式。</p></li></ul><p><strong>（2）QTextEdit类</strong></p><p>QTextEdit类是一个多行文本框控件，可以显示多行文本内容，当文本内容超出显示范围时，可以显示水平垂直滚动条。QTextEdit不仅可以显示文本还可以显示HTML文档。其设置属性的方法和常用信号可以参考Qt Designer的属性编辑器和信号/槽编辑器。</p><p>setPlainText()：设置多行文本框的文本内容；</p><p>toPlainText()：返回多行文本框的文本内容；</p><p>setHtml()：设置多行文本框的内容为HTML文档，HTML文档是描述网页的；</p><p>toHtml()：返回多行文本框的HTML文档内容；</p><p>clear()：清除多行文本框的内容。</p><h3 id="按钮类控件">👀按钮类控件</h3><p><strong>（1）QAbstractButton</strong></p><p>在任何GUI设计中，按钮都是最重要的和常用的触发动作请求的方式，用来与用户进行交互操作。在PyQt中根据不同使用场景将按钮划分为不同表现形式。按钮的基类是QAbstractButton，提供了按钮的通用性功能。该基类为抽象类，不能实例化，必须由其它按钮类继承QAbstractButton类，来实现不同的功能、不同的表现形式。常见的按钮类包括：QPushButton、QToolButton、QRadioButton和QCheckBox。这些按钮类均继承自QAbstractButton类，根据各自的使用场景通过图形展现出来。QAbstractButton提供的状态如下：</p><table><thead><tr class="header"><th>状态</th><th>含义</th></tr></thead><tbody><tr class="odd"><td>isDown()</td><td>提示按钮是否被按下</td></tr><tr class="even"><td>isChecked()</td><td>提示按钮是否已经标记</td></tr><tr class="odd"><td>isEnable()</td><td>提示按钮是否可以被用户点击</td></tr><tr class="even"><td>isCheckAble()</td><td>提示按钮是否为可标记的</td></tr><tr class="odd"><td>setAutoRepeat()</td><td>设置按钮是否在用户长按时可以自动重复执行</td></tr></tbody></table><p>QAbstractButton提供的信号如下：</p><table><thead><tr class="header"><th>信号</th><th>含义</th></tr></thead><tbody><tr class="odd"><td>Pressed</td><td>当鼠标指针在按钮上并按下左键时触发该信号</td></tr><tr class="even"><td>Released</td><td>当鼠标左键被释放时触发该信号</td></tr><tr class="odd"><td>Clicked</td><td>当鼠标左键被按下然后释放时，或者快捷键被释放时触发该信号</td></tr><tr class="even"><td>Toggled</td><td>当按钮的标记状态发生改变时触发该信号</td></tr></tbody></table><p><strong>（2）QPushButton</strong></p><p>QPushButton类继承QAbstractButton类，形状是长方形，文本标题或图标可以显示在长方形上。它是一种命令按钮，可以单击该按钮执行一些命令，或响应一些事件。常见的有"确认"/"申请"/"取消"/"关闭"/"是"/"否"等按钮。命令按钮通常通过文本来描述执行的动作，有时候也会通过快捷键来执行对应按钮的命令。QPushButton类中的常用方法：</p><table><thead><tr class="header"><th>方法</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>setCheckable()</td><td>设置按钮是否已经被选中，如果设置为True，则表示按钮将保持已点击和释放状态</td></tr><tr class="even"><td>toggle()</td><td>在按钮状态之间进行切换</td></tr><tr class="odd"><td>setIcon()</td><td>设置按钮上的图标</td></tr><tr class="even"><td>setEnabled()</td><td>设置按钮是否可以使用，当设置为False时，按钮变成不可用状态，点击不会发射信号</td></tr><tr class="odd"><td>isChecked()</td><td>返回按钮的状态。返回值为True或False</td></tr><tr class="even"><td>setDefault()</td><td>设置按钮的默认状态</td></tr><tr class="odd"><td>setText()</td><td>设置按钮的显示文本</td></tr><tr class="even"><td>text()</td><td>返回按钮的显示文本</td></tr></tbody></table><p><strong>（3）QRadioButton</strong></p><p>QRadioButton类继承QAbstractButton类，它提供一组可供选择的按钮和文本标签，用户可以选择其中一个选项，标签用于显示对应文本信息。单选钮是一种开关按钮，可以切换为on或者off，即checked或者unchecked，主要是为用户提供"多选一"的选择。</p><p>QRadioButton是单选钮控件默认是独占的（Exclusive）。对于继承自同一个父类Widget的多个单选钮，它们属于同一个按钮组合，在单选钮组里，一次只能选择一个单选钮。如果需要多个独占的按钮组合，则需要将它们放在 QGroupBox或QButtonGroup中。</p><p>当将单选钮切换到on或off时，会发送toggled信号，绑定这个信号，在按钮状态发生改变时，触发相应的行为。在QRadioButton中，toggled信号是在切换单选钮状态（开、关）时发射的，而clicked信号则在每次点击单选钮时都会发射。在实际中，一般只有状态改变时才有必要去响应，因此toggled信号更适合状态监控。QRadioButton类中的常用方法如下：</p><table><thead><tr class="header"><th>方法</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>setCheckable()</td><td>设置按钮是否已经被选中，可以改变单选钮的选中状态，如果设置为True，则表示单选钮将保持已点击和释放状态</td></tr><tr class="even"><td>isChecked()</td><td>返回单选钮的状态。返回值为True或False</td></tr><tr class="odd"><td>setText()</td><td>设置单选钮的显示文本</td></tr><tr class="even"><td>text()</td><td>返回单选钮的显示文本</td></tr></tbody></table><p><strong>（4）QCheckBox</strong></p><p>QCheckBox类继承QAbstractButton类，提供一组带文本标签的复选框，用户可选择多个选项。和QPushButton一样，复选框可以显示文本或者图标，其中文本可以通过构造函数或者setText()来设置；图标可以通过setIcon()来设置。在视觉上，QButtonGroup可以把许多复选框组织在一起。</p><p>QCheckBox（复选框）和QRadioButton（单选钮）都是选项按钮，因为它们都可以在开（选中）或者关（未选中）之间切换。它们的区别是对用户选择的限制：单选钮提供了"多选一"的选择；而复选框提供的是"多选多"的选择。QCheckBox通常被应用在需要用户选择一个或多个可用的选项的场景中。</p><p>只要复选框被选中或取消选中，都会发射stateChanged信号。如果想在复选框状态改变时触发相应的行为，请连接这个信号，可以使用isChecked()来查询复选框是否被选中。除了常用的选中和未选中两种状态，QCheckBox还提供了第三种状态（半选中）来表明"没有变化"。当需要为用户提供一个选中或者未选中复选框的选择时，这种状态是很有用的。如果需要第三种状态，则可以通过setTristate()来使它生效，并使用checkState()来查询当前的切换状态。QCheckBox类中的常用方法如下：</p><table><thead><tr class="header"><th>方法</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>setChecked()</td><td>设置复选框的状态，设置为True时表示选中复选框，设置为False时表示取消选中复选框</td></tr><tr class="even"><td>setText()</td><td>设置复选框的显示文本</td></tr><tr class="odd"><td>text()</td><td>返回复选框的显示文本</td></tr><tr class="even"><td>isChecked()</td><td>检查复选框是否被选中</td></tr><tr class="odd"><td>setTristate()</td><td>设置复选框为一个三态复选框</td></tr></tbody></table><p>三态复选框有三种状态：</p><table><thead><tr class="header"><th>名称</th><th>值</th><th>含义</th></tr></thead><tbody><tr class="odd"><td>Qt.Checked</td><td>2</td><td>组件没有被选中（默认值）</td></tr><tr class="even"><td>Qt.PartiallyChecked</td><td>1</td><td>组件被半选中</td></tr><tr class="odd"><td>Qt.Unchecked</td><td>0</td><td>组件被选中</td></tr></tbody></table><h3 id="qcombobox下拉列表框">👀QComboBox(下拉列表框)</h3><p>QComboBox是一个集按钮和下拉选项于一体的控件，也被称为下拉列表框。QComboBox类中的常用方法如下：</p><table><thead><tr class="header"><th>方法</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>addItem()</td><td>添加一个下拉选项</td></tr><tr class="even"><td>addItems()</td><td>从列表中添加下拉选项</td></tr><tr class="odd"><td>Clear()</td><td>删除下拉选项集合中的所有选项</td></tr><tr class="even"><td>count()</td><td>返回下拉选项集合中的数目</td></tr><tr class="odd"><td>currentText()</td><td>返回选中选项的文本</td></tr><tr class="even"><td>itemText(i)</td><td>获取索引为i的item的选项文本</td></tr><tr class="odd"><td>currentIndex()</td><td>返回选中项的索引</td></tr><tr class="even"><td>setItemText(int index, text)</td><td>改变序号为index项的文本</td></tr></tbody></table><p>QComboBox类中的常用信号如下：</p><table><thead><tr class="header"><th>信号</th><th>含义</th></tr></thead><tbody><tr class="odd"><td>Activated</td><td>当用户选中一个下拉选项时发射该信号</td></tr><tr class="even"><td>currentIndexChanged</td><td>当下拉选项的索引发生改变时发射该信号</td></tr><tr class="odd"><td>highlighted</td><td>当选中一个已经选中的下拉选项时，发射该信号</td></tr></tbody></table><h3 id="qspinbox计数器">👀QSpinBox(计数器)</h3><p>QSpinBox是一个计数器控件，允许用户选择一个整数值，通过单击向上/向下按钮或按键盘上的上/下箭头来增加/减少当前显示的值，当然用户也可以输入值。</p><p>在默认情况下，QSpinBox的取值范围是0~99，每次改变的步长值为1。QSpinBox类和QDoubleSpinBox类均派生自QAbstractSpinBox类。QSpinBox用于处理整数值，QDoubleSpinBox用于处理浮点值，它们之间的区别就是处理数据的类型不同，其他功能都基本相同。QDoubleSpinBox的默认精度是两位小数，但可以通过setDecimals()来改变。QSpinBox类中的常用方法如下：</p><table><thead><tr class="header"><th>方法</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>setMinimum()</td><td>设置计数器的下界</td></tr><tr class="even"><td>setMaximum()</td><td>设置计数器的上界</td></tr><tr class="odd"><td>setRange()</td><td>设置计算器的最大值、最小值和步长值</td></tr><tr class="even"><td>setValue()</td><td>设置计算器的当前值</td></tr><tr class="odd"><td>Value()</td><td>返回计数器的当前值</td></tr><tr class="even"><td>setSingleStep()</td><td>设置计数器的步长值</td></tr></tbody></table><p>每次单击向上/向下按钮时，QSpinBox计数器都会发射valueChanged信号，可以从相应的槽函数中通过value()函数获得计数器的当前值。</p><h3 id="qslider滑动条">👀QSlider(滑动条)</h3><p>QSlider控件提供了一个垂直或水平的滑动条，滑动条是一个用于控制有界值的典型控件，它允许用户沿水平或垂直方向在某一范围内移动滑块，并将滑块所在的位置转换成一个合法范围内的整数值。有时候这种方式比输入数字或者使用SpinBox（计数器）更加自然。在槽函数中对滑块所在位置的处理相当于从整数之间的最小值和最高值进行取值。一个滑块条控件可以以水平或垂直的方式显示，在构造函数中进行设置。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">self.sp = QSlider(Qt.Horizontal)</span><br><span class="line">self.sp = QSlider(Qt.Vertical)</span><br></pre></td></tr></table></figure><p>QSlider类中的常用方法如下：</p><table><colgroup><col style="width: 22%" /><col style="width: 77%" /></colgroup><thead><tr class="header"><th>方法</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>setMinimum()</td><td>设置滑动条控件的最小值</td></tr><tr class="even"><td>setMaximum()</td><td>设置滑动条控件的最大值</td></tr><tr class="odd"><td>setSingleStep()</td><td>设置滑动条控件递增/递减的步长值</td></tr><tr class="even"><td>setValue()</td><td>设置滑动条控件的值</td></tr><tr class="odd"><td>value()</td><td>获取滑动条控件的值</td></tr><tr class="even"><td>setTickInterval()</td><td>设置刻度间隔</td></tr><tr class="odd"><td>setTickPosition()</td><td>设置刻度标记的位置，可以输入一个枚举值，这个枚举值指定刻度线相对于滑块和用户操作的位置。以下是可以输入的枚举值：<br />①QSlider.NoTicks，不绘制任何刻度线；<br />②QSlider.TicksBothSides，在滑块的两侧绘制刻度线；<br />③QSlider.TicksAbove，在（水平）滑块上方绘制刻度线；<br />④QSlider.TicksBelow，在（水平）滑块下方绘制刻度线；<br />⑤QSlider.TicksLeft，在（垂直）滑块左侧绘制刻度线；<br />⑥QSlider.TicksRight，在（垂直）滑块右侧绘制刻度线。</td></tr></tbody></table><p>QSlider类中的常用信号如下：</p><table><thead><tr class="header"><th>信号</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>valueChanged</td><td>当滑块的值发生改变时发射此信号，此信号时最常用的</td></tr><tr class="even"><td>sliderPressed</td><td>当用户按下滑块时发射此信号</td></tr><tr class="odd"><td>sliderMoved</td><td>当用户拖动滑块时发射此信号</td></tr><tr class="even"><td>sliderReleased</td><td>当用户释放滑块时发射此信号</td></tr></tbody></table><h3 id="对话框类控件">👀对话框类控件</h3><p><strong>（1）QDialog</strong></p><p>为了更好地实现人机交互，比如Windows及Linux等系统均会提供一系列的标准对话框来完成特定场景下的功能，如选择字号大小、字体颜色等。在PyQt5中定义了一系列的标准对话框类，让使用者能够方便和快捷地通过各个类完成字号大小、字体颜色以及文件的选择等。</p><p>QDialog类的子类主要有<strong>QMessageBox</strong>、<strong>QInputDialog</strong>、<strong>QFontDialog</strong>、<strong>QFileDialog</strong>等。QDialog类中的常用方法如下：</p><table><colgroup><col style="width: 24%" /><col style="width: 75%" /></colgroup><thead><tr class="header"><th>方法</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>setWindowTitle()</td><td>设置对话框标题</td></tr><tr class="even"><td>setWindowModality()</td><td>设置窗口模态。取值如下：<br />①Qt.NonModal，非模态，可以和程序的其它窗口交互；<br />②Qt.WindowModal，窗口模态，程序在未处理完当前对话框时，将阻止和对话框的父窗口进行交互；<br />③Qt.ApplicationModal，应用程序模态，阻止和任何其他窗口进行交互。</td></tr></tbody></table><p>当用户按下Esc键时，对话框窗口将会默认调用QDialog.reject()方法，然后关闭对话框窗口。</p><p><strong>（2）QMessageBox</strong></p><p>QMessageBox是一种通用的弹出式对话框，用于显示消息，允许用户通过单击不同的标准按钮对消息进行反馈。每个标准按钮都有一个预定义的文本、角色和十六进制数。QMessageBox类提供了许多常用的弹出式对话框，如提示、警告、错误、询问、关于等对话框。这些不同类型的QMessageBox对话框只是显示时的图标不同，其他功能是一样的。QMessageBox类中的常用方法如下：</p><table><colgroup><col style="width: 50%" /><col style="width: 50%" /></colgroup><thead><tr class="header"><th>方法</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>information(QWidget parent, title, text, buttons, defaultButton)</td><td>弹出消息对话框，用来告诉用户关于提示信息，各参数解释如下：<br />①parent，指定的父窗口控件；<br />②title，对话框标题；<br />③text，对话框文本；<br />④buttons，多个标准按钮，默认OK按钮；<br />⑤defaultButton，默认选中的标准按钮，默认是第一个标准按钮。</td></tr><tr class="even"><td>question(QWidget parent, title, text, buttons, defaultButton)</td><td>弹出问答/提问对话框（各参数解释同上），用来告诉用户关于提问信息。</td></tr><tr class="odd"><td>warning(QWidget parent, title, text, buttons, defaultButton)</td><td>弹出警告对话框（各参数解释同上），用来告诉用户关于不寻常的错误消息。</td></tr><tr class="even"><td>critical(QWidget parent, title, text, buttons, defaultButton)</td><td>弹出严重错误对话框（各参数解释同上），用来告诉用户关于严重的错误信息。</td></tr><tr class="odd"><td>about(QWidget parent, title, text)</td><td>弹出关于对话框（各参数解释同上）</td></tr><tr class="even"><td>setTitle()</td><td>设置标题</td></tr><tr class="odd"><td>setText()</td><td>设置消息正文</td></tr><tr class="even"><td>setIcon()</td><td>设置弹出对话框的图片</td></tr></tbody></table><p>QMessageBox的标准按钮类型如下：</p><table><thead><tr class="header"><th>类型</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>QMessage.Ok</td><td>同意操作</td></tr><tr class="even"><td>QMessage.Cancel</td><td>取消操作</td></tr><tr class="odd"><td>QMessage.Yes</td><td>同意操作</td></tr><tr class="even"><td>QMessage.No</td><td>取消操作</td></tr><tr class="odd"><td>QMessage.Abort</td><td>终止操作</td></tr><tr class="even"><td>QMessage.Retry</td><td>重试操作</td></tr><tr class="odd"><td>QMessage.Ignore</td><td>忽略操作</td></tr></tbody></table><p><strong>（3）QInputDialog</strong></p><p>QInputDialog控件是一个标准对话框，由一个文本框和两个按钮（OK按钮和Cancel按钮）组成。当用户单击OK或Enter键后，在父窗口可以收集通过QInputDialog控件输入的信息。QInputDialog控件是QDialog标准对话框的一部分。在QInputDialog控件中可以输入数字、字符串或列表中的选项，用于提示必要的信息。QInputDialog类中的常用方法如下：</p><table><thead><tr class="header"><th>方法</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>getInt()</td><td>从控件中获得标准整数输入</td></tr><tr class="even"><td>getDouble()</td><td>从控件中获得标准浮点数输入</td></tr><tr class="odd"><td>getText()</td><td>从控件中获得标准字符串输入</td></tr><tr class="even"><td>getItem()</td><td>从控件中获得列表里的选项输入</td></tr></tbody></table><p><strong>（4）QFontDialog</strong></p><p>QFontDialog控件是一个常用的字体选择对话框，可以让用户选择所显示文本的字号大小、样式和格式。此控件是QDialog标准对话框的一部分。使用QFontDialog类的静态方法getFont()，可以从字体选择对话框中选择文本的显示字号大小、样式和格式。</p><p><strong>（5）QFileDialog</strong></p><p>QFileDialog是用于打开和保存文件的标准对话框。QFileDialog类继承自QDialog类。QFileDialog在打开文件时使用了文件过滤器，用于显示指定扩展名的文件。也可以设置使用QFileDialog打开文件时的起始目录和指定扩展名的文件。QFileDialog类中的常用方法如下：</p><table><colgroup><col style="width: 22%" /><col style="width: 77%" /></colgroup><thead><tr class="header"><th>方法</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>getOpenFileName()</td><td>返回用户所选择文件的名称，并打开该文件</td></tr><tr class="even"><td>getSaveFileName()</td><td>使用用户选择的文件名并保存文件</td></tr><tr class="odd"><td>setFileMode()</td><td>可以选择的文件类型，枚举常量是：<br />①QFileDialog.AnyFile，任何文件；<br />②QFileDialog.ExistingFile，已存在的文件<br />③QFileDialog.Directory，文件目录；<br />④QFileDialog.ExistingFiles，已经存在的多个文件</td></tr><tr class="even"><td>setFilter()</td><td>设置过滤器，只显示过滤器允许的文件类型</td></tr></tbody></table><h3 id="窗口绘图类控件">👀窗口绘图类控件</h3><p>在PyQt5中，一般可以通过QPainter、QPen和QBrush这三个类来实现绘图功能。此外，QPixmap的作用是加载并呈现本地图像，而图像的呈现本质上也是通过绘图方式实现的，所以QPixmap也可以被视为绘图的一个类。</p><p><strong>（1）QPainter</strong></p><p>QPainter类在QWidget（控件）上执行绘图操作，它是一个绘制工具，为大部分图形界面提供了高度优化的函数，使QPainter类可以绘制从简单的直线到复杂的饼图等。绘制操作在QWidget.paintEvent()中完成。绘制方法必须放在QtGui.QPainter对象的begin()和end()之间。QPainter类在控件或其他绘图设备上执行较低级别的图形绘制功能，并通过如下方法进行绘制。</p><table><colgroup><col style="width: 40%" /><col style="width: 60%" /></colgroup><thead><tr class="header"><th>方法</th><th></th></tr></thead><tbody><tr class="odd"><td>begin()</td><td>开始在目标设备上绘制</td></tr><tr class="even"><td>drawArc()</td><td>在起始角度和最终角度之间画弧</td></tr><tr class="odd"><td>drawEllipse()</td><td>在一个矩形内画一个椭圆</td></tr><tr class="even"><td>drawLine(int x1, int y1, int x2, int y2)</td><td>绘制一条指定了端点坐标的线，绘制从(x1,y1)到(x2,y2)的直线并且</td></tr><tr class="odd"><td>drawPixmap()</td><td>从图像文件中提取Pixmap并将其显示在指定的位置</td></tr><tr class="even"><td>drawPolygon()</td><td>使用坐标数组绘制多边形</td></tr><tr class="odd"><td>drawRect(int x, int y, int w, int h)</td><td>以给定的宽度w和高度h从左上角坐标(x,y)绘制一个矩形</td></tr><tr class="even"><td>drawText()</td><td>显示给定坐标处的文字</td></tr><tr class="odd"><td>fillRect()</td><td>使用QColor参数填充矩形</td></tr><tr class="even"><td>setBrush()</td><td>设置画笔风格</td></tr><tr class="odd"><td>setPen()</td><td>设置用于绘制的笔的颜色、大小和样式</td></tr></tbody></table><p>还可以设置画笔风格（PenStyle），这是一个枚举类，可以由QPainter类绘制。画笔风格如表下所示：</p><table><thead><tr class="header"><th>枚举类型</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>Qt.NoPen</td><td>没有线。比如QPainter.drawRect()填充，但没有绘制任何边界线</td></tr><tr class="even"><td>Qt.SolidLine</td><td>一条简单的线</td></tr><tr class="odd"><td>Qt.DashLine</td><td>由一些像素分隔的短线</td></tr><tr class="even"><td>Qt.DotLine</td><td>由一些像素分隔的点</td></tr><tr class="odd"><td>Qt.DashDotLine</td><td>轮流交替的点和短线</td></tr><tr class="even"><td>Qt.DashDotDotLine</td><td>一条短线、两个点</td></tr><tr class="odd"><td>Qt.MPenStyle</td><td>画笔风格的掩码</td></tr></tbody></table><p><strong>（2）QPen</strong></p><p>QPen（钢笔）是一个基本的图形对象，用于绘制直线、曲线或者给轮廓画出矩形、椭圆形、多边形及其他形状等。</p><p><strong>（3）QBrush</strong></p><p>QBrush（画刷）是一个基本的图形对象，用于填充如矩形、椭圆形或多边形等形状。QBrush有三种类型：预定义、过渡和纹理图案。</p><p><strong>（4）QPixmap</strong></p><p>QPixmap类用于绘图设备的图像显示，它可以作为一个QPaintDevice对象，也可以加载到一个控件中，通常是标签或按钮，用于在标签或按钮上显示图像。QPixmap可以读取的图像文件类型有BMP、GIF、JPG、JPEG、PNG、PBM、PGM、PPM、XBM、XPM等。QPixmap类中的常用方法如下：</p><table><thead><tr class="header"><th>方法</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>copy()</td><td>从QRect对象复制到QPixmap对象</td></tr><tr class="even"><td>fromImage()</td><td>将QImage对象转换为QPixmap对象</td></tr><tr class="odd"><td>grabWidget()</td><td>从给定的窗口小控件创建一个像素图</td></tr><tr class="even"><td>grabWindow()</td><td>从窗口中创建数据的像素图</td></tr><tr class="odd"><td>load()</td><td>加载图像文件作为QPixmap对象</td></tr><tr class="even"><td>save()</td><td>将QPixmap对象保存为文件</td></tr><tr class="odd"><td>toImage()</td><td>将QPixmap对象转换为QImage对象</td></tr></tbody></table><h3 id="拖曳与剪贴板">👀拖曳与剪贴板</h3><p><strong>（1）Drag与Drop</strong></p><p>为用户提供的拖曳功能很直观，在很多桌面应用程序中，复制或移动对象都可以通过拖曳来完成。基于MIME类型的拖曳数据传输是基于QDrag类的。QMimeData对象将关联的数据与其对应的MIME类型相关联。MIME类型的数据可以简单理解为互联网上的各种资源，比如文本、音频和视频资源等，互联网上的每一种资源都属于一种MIME类型的数据。MimeData类函数允许检测和使用方便的MIME类型如下：</p><table><thead><tr class="header"><th>判断函数</th><th>设置函数</th><th>获取函数</th><th>MIME类型</th></tr></thead><tbody><tr class="odd"><td>hasText()</td><td>text()</td><td>setText()</td><td>text/plain</td></tr><tr class="even"><td>hasHtml()</td><td>html()</td><td>setHtml()</td><td>text/html</td></tr><tr class="odd"><td>hasUrls()</td><td>urls()</td><td>setUrls()</td><td>text/uri-list</td></tr><tr class="even"><td>hasImage()</td><td>imageData()</td><td>setImageData()</td><td>image/*</td></tr><tr class="odd"><td>hasColor()</td><td>colorData()</td><td>setColorData()</td><td>application/x-color</td></tr></tbody></table><p>许多QWidget对象都支持拖曳动作，允许拖曳数据的控件必须设置QWidget.setDragEnabled()为True。另外，控件应该响应拖曳事件，以便存储所拖曳的数据。常用的拖曳事件如下：</p><table><colgroup><col style="width: 18%" /><col style="width: 81%" /></colgroup><thead><tr class="header"><th>事件</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>DragEnterEvent</td><td>当执行一个拖曳控件操作，并且鼠标指针进入该控件时，这个事件将被触发。在这个事件中可以获得被操作的窗口控件，还可以有条件地接受或拒绝该拖曳操作</td></tr><tr class="even"><td>DragMoveEvent</td><td>在拖曳操作进行时会触发该事件</td></tr><tr class="odd"><td>DragLeaveEvent</td><td>当执行一个拖曳控件操作，并且鼠标指针离开该控件时，这个事件将被触发</td></tr><tr class="even"><td>DropEvent</td><td>当拖曳操作在目标控件上被释放时，这个事件将被触发</td></tr></tbody></table><p><strong>（2）QClipboard</strong></p><p>QClipboard类提供了对系统剪贴板的访问，可以在应用程序之间复制和粘贴数据。它的操作类似于QDrag类，并使用类似的数据类型。QApplication类有一个静态方法clipboard()，它返回对剪贴板对象的引用。任何类型的MimeData都可以从剪贴板复制或粘贴。QClipboard类中的常用方法如下：</p><table><thead><tr class="header"><th>方法</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>clear()</td><td>清除剪贴板的内容</td></tr><tr class="even"><td>setImage()</td><td>将QImage对象复制到剪贴板中</td></tr><tr class="odd"><td>setMimeData()</td><td>将MIME数据设置为剪贴板</td></tr><tr class="even"><td>setPixmap()</td><td>从剪贴板中复制Pixmap对象</td></tr><tr class="odd"><td>setText()</td><td>从剪贴板中复制文本</td></tr><tr class="even"><td>text()</td><td>从剪贴板中检索文本</td></tr></tbody></table><p>QClipboard类中的常用信号如下：</p><table><thead><tr class="header"><th>信号</th><th>含义</th></tr></thead><tbody><tr class="odd"><td>dataChanged</td><td>当剪贴板内容发生变化时，这个信号被发射</td></tr></tbody></table><h3 id="日历与时间">👀日历与时间</h3><p><strong>（1）QCalendar</strong></p><p>QCalendar是一个日历控件，它提供了一个基于月份的视图，允许用户通过鼠标或键盘选择日期，默认选中的是今天的日期。也可以对日历的日期范围进行规定。QCalendar类中的常用方法如下：</p><table><colgroup><col style="width: 24%" /><col style="width: 75%" /></colgroup><thead><tr class="header"><th>方法</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>setDateRange()</td><td>设置日期范围供选择</td></tr><tr class="even"><td>setFirstDayOfWeek()</td><td>重新设置星期的第一天，默认是星期日。参数枚举(<code>Qt.Monday</code>,<code>Qt.Tuesday</code>, <code>Qt.Wednesday</code>,<code>Qt.Thursday</code>,<code>Qt.Friday</code>,<code>Qt.Saturday</code>,<code>Qt.Sunday</code>)</td></tr><tr class="odd"><td>setMaximumDate()</td><td>设置最大日期</td></tr><tr class="even"><td>setMinimumDate()</td><td>设置最小日期</td></tr><tr class="odd"><td>setSelectedDate()</td><td>设置一个QDate对象，作为日期控件所选定的日期</td></tr><tr class="even"><td>MaximumDate()</td><td>获取日历控件的最大日期</td></tr><tr class="odd"><td>MinimumDate()</td><td>获取日历控件的最小日期</td></tr><tr class="even"><td>SelectedDate()</td><td>返回当前选定的日期</td></tr><tr class="odd"><td>setGridvisible()</td><td>设置日历控件是否显示网格</td></tr></tbody></table><p><strong>（2）QDateTimeEdit</strong></p><p>QDateTimeEdit是一个允许用户编辑日期时间的控件，可以使用键盘和上、下箭头按钮来增加或减少日期时间值。如当使用鼠标选中QDateTimeEdit中的年份时，可以使用键盘上的上、下键来改变数值。QDateTimeEdit通过setDisplayFormat()函数来设置显示的日期时间格式。QDateTimeEdit类中的常用方法如下：</p><table><colgroup><col style="width: 23%" /><col style="width: 76%" /></colgroup><thead><tr class="header"><th>方法</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>setDisplayFormat()</td><td>设置日期时间格式。<br />①yyyy，代表年份，用4位数表示<br/>②MM，代表月份，取值范围为01-12<br/>③dd，代表日，取值范围为01-31<br/>④HH，代表小时，取值范围为00-23<br/>⑤mm，代表分钟，取值范围为00-59<br/>⑥ss，代表秒，取值范围位00-59</td></tr><tr class="even"><td>setMaximumDate()</td><td>设置控件的最大日期</td></tr><tr class="odd"><td>setMinimumDate()</td><td>设置控件的最小日期</td></tr><tr class="even"><td>time()</td><td>返回编辑的时间</td></tr><tr class="odd"><td>date()</td><td>返回编辑的日期</td></tr></tbody></table><p>QDateTimeEdit类中的常用信号如下：</p><table><thead><tr class="header"><th>信号</th><th>含义</th></tr></thead><tbody><tr class="odd"><td>dateChanged</td><td>当日期改变时发射此信号</td></tr><tr class="even"><td>dataTimeChanged</td><td>当日期时间改变时发射此信号</td></tr><tr class="odd"><td>timeChanged</td><td>当时间改变时发射此信号</td></tr></tbody></table><p>QDateEdit和QTimeEdit类均继承自QDateTimeEdit类，它们的许多特性和功能都由QDateTimeEdit类提供。</p><p><strong>设置显示格式时要注意：</strong>QDateEdit用来编辑控件的日期，仅包括年、月和日；QTimeEdit用来编辑控件的时间，仅包括小时、分钟和秒。不要用QDateEdit来设置或获取时间，也不要用QTimeEdit来设置或获取日期。如果要同时操作日期时间，请使用QDateTimeEdit。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dateEdit = QDateEdit(self)</span><br><span class="line">timeEdit = QTimeEdit(self)</span><br><span class="line">dạteEdit.setDisplayFormat(<span class="string">&quot;yyyy-MM-dd&quot;</span>)</span><br><span class="line">timeEdit.setDisplayFormat(<span class="string">&quot;HH:mm:ss&quot;</span>)</span><br></pre></td></tr></table></figure><p><strong>设置弹出日历时要注意：</strong>用来弹出日历的类只有QDateTimeEdit和QDateEdit，而QTimeEdit类虽然在语法上可以设置弹出日历，但不起作用。使用它们弹出日历的正确方法如下。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dateTimeEdit = QDateTimeEdit(self)</span><br><span class="line">dateEdit = QDatesdit(self)</span><br><span class="line">dateTimeEdit.setCalendarPopup(<span class="literal">True</span>)</span><br><span class="line">dateEdit.setCalendarPopup(<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p>在默认情况下，如果QDateTimeEdit类构造时不指定日期时间，那么系统会为其设置一个和本地相同的日期时间格式，并且值为2000年1月1日0时0分0秒。也可以手动指定控件显示的日期时间。除通过构造函数指定所显示的日期时间外，也可以根据QDateTimeEdit提供的槽函数来设置，比如setDateTime()、setDate()、setTime()函数。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># （1）初始化QDateTimeEdit类</span></span><br><span class="line">dateTimeEdit = QDateTimeEdit(self)</span><br><span class="line">dateTimeEdit2 = QDateTimeEdit(QDateTime.currentDateTime(), self)</span><br><span class="line">dateEdit = QDateTimeEdit(QDate.currentDate(), self)</span><br><span class="line">timeEdit = QDateTimeEdit(QTime.currentTime(), self)</span><br><span class="line"></span><br><span class="line"><span class="comment"># （2）设置日期时间格式</span></span><br><span class="line"><span class="comment"># 如果不想使用系统默认的格式，则可以通过setDisplayFormat()来自定义日期时间格式</span></span><br><span class="line">dateTimeEdit.setDisplayFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>)</span><br><span class="line">dateTimeEdit2.setDisplayFormat(<span class="string">&quot;yyyy/MM/dd HH-mm-ss&quot;</span>)</span><br><span class="line">dateEdit.setDisplayFormat(<span class="string">&quot;yyyy.MM.dd&quot;</span>)</span><br><span class="line">timeEdit.setDisplayFormat(<span class="string">&quot;HH:mm:ss&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># （3）设置日期时间范围。设置日期时间为今天(currentDate)，同时限制有效日期的范围为：距离今天±365天。</span></span><br><span class="line">dateTimeEdit2.setbisplayFormat (<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>)</span><br><span class="line"><span class="comment"># 设置最小日期</span></span><br><span class="line">dateTimeEdit2.setMinimumDate(QDate.currentDate().addDays(-<span class="number">365</span>))</span><br><span class="line"><span class="comment"># 设置最大日期</span></span><br><span class="line">dateTimeEdit2.setMaximumDate(QDate.currentDate().addDays(<span class="number">365</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># （4）弹出日历</span></span><br><span class="line"><span class="comment"># 在默认情况下，只能通过上下箭头来改变日期时间。如果要弹出日历控件，只需调用setCalendarPopup(True)</span></span><br><span class="line">dateTimeEdit2.setCalendarPopup(<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># （5）获取日期时间</span></span><br><span class="line"><span class="comment"># 可以通过date()、dateTime()等方法来获取日期时间对象，如果要获取年、月、日等信息，则可以调用QDate的 year()、month()、day()等函数。</span></span><br><span class="line">dateTime = self.dateTimeEdit2.dateTime()</span><br><span class="line"><span class="comment"># 最大日期</span></span><br><span class="line">maxDate = self.dateTimeEdit2.maximumDate()</span><br><span class="line"><span class="comment"># 最大日期时间</span></span><br><span class="line">maxDateTime = self.dateTimeEdit2.maximumDateTime()</span><br><span class="line"><span class="comment"># 最大时间</span></span><br><span class="line">maxTime = self.dateTimeEdit2.maximumTime()</span><br><span class="line"><span class="comment"># 最小日期</span></span><br><span class="line">minDate = self.dateTimeEdit2.minimumDate()</span><br><span class="line"><span class="comment"># 最小日期时间</span></span><br><span class="line">minDateTime-self.dateTimeEdit2.minimumDateTime()</span><br><span class="line"><span class="comment"># 最小时间</span></span><br><span class="line">minTime-self.dateTimeEdit2.minimumTime()</span><br><span class="line"></span><br><span class="line"><span class="comment"># （6）信号和槽函数</span></span><br><span class="line"><span class="comment"># QDateTimeEdit控件常用的信号是dateChanged、dateTimeChanged和timeChanged，分别在改变日期、日期时间、时间时发射。</span></span><br><span class="line">dateTimeEdit2.dateChanged.connect(self.onDateChanged)</span><br><span class="line">dateTimeEdit2.dateTimeChanged.connect(self.onDateTimeChanged)</span><br><span class="line">dateTimeEdit2.timeChanged.connect(self.onTimeChanged)</span><br><span class="line"><span class="comment"># 日期发生改变时执行</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">onDateChanged</span>(<span class="params">self，date</span>):</span><br><span class="line"><span class="built_in">print</span>(date)</span><br><span class="line"><span class="comment"># 无论是日期还是时间发生改变时都会执行</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">onDateTimeChanged</span>(<span class="params">self，dateTime</span>):</span><br><span class="line"><span class="built_in">print</span>(dateTime)</span><br><span class="line"><span class="comment"># 时间发生改变时执行</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">onTimeChanged</span>(<span class="params">self，time</span>):</span><br><span class="line"><span class="built_in">print</span>(time)</span><br></pre></td></tr></table></figure><h3 id="菜单栏工具栏与状态栏">👀菜单栏、工具栏与状态栏</h3><p><strong>（1）菜单栏</strong></p><p>在QMainWindow对象的标题栏下方，水平的QMenuBar被保留显示QMenu对象。QMenu类提供了一个可以添加到菜单栏的小控件，也用于创建上下文菜单和弹出菜单。每个QMenu对象都可以包含一个或多个QAction对象或级联的QMenu对象。要创建一个弹出菜单，PyQt API提供了createPopupMenu()函数；menuBar()函数用于返回主窗口的QMenuBar对象；addMenu()函数可以将菜单添加到菜单栏中；通过addAction()函数可以在菜单中进行添加操作。在设计菜单系统时使用的一些重要方法如下：</p><table><thead><tr class="header"><th>方法</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>menuBar()</td><td>返回主窗口的QMenuBar对象</td></tr><tr class="even"><td>addMenu()</td><td>在菜单栏中添加一个新的QMenu对象</td></tr><tr class="odd"><td>addAction()</td><td>向QMenu小控件中添加一个操作按钮，其中包含文本或图标</td></tr><tr class="even"><td>setEnabled()</td><td>将操作按钮状态设置为启用/禁用</td></tr><tr class="odd"><td>addSeparator()</td><td>在菜单中添加一条分隔线</td></tr><tr class="even"><td>clear()</td><td>删除菜单/菜单栏的内容</td></tr><tr class="odd"><td>setShortcut()</td><td>将快捷键关联到操作按钮</td></tr><tr class="even"><td>setText()</td><td>设置菜单项的文本</td></tr><tr class="odd"><td>setTitle()</td><td>设置QMenu小控件的标题</td></tr><tr class="even"><td>text()</td><td>返回与QAction对象关联的文本</td></tr><tr class="odd"><td>title()</td><td>返回QMenu小控件的标题</td></tr></tbody></table><p>单击任何QAction按钮时，QMenu对象都会发射triggered信号。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 菜单中的操作按钮可以是字符串或QAction对象</span></span><br><span class="line">file = bar.addMenu(<span class="string">&quot;File&quot;</span>)</span><br><span class="line">file.addAction(<span class="string">&quot;New&quot;</span>)</span><br><span class="line">save = QAction(<span class="string">&quot;Save&quot;</span>, self)</span><br><span class="line">save.setShortcut(<span class="string">&quot;Ctrl+S&quot;</span>)</span><br><span class="line">file.addAction(save)</span><br><span class="line"><span class="comment"># 菜单发射triggered信号，将该信号连接到槽函数proecesstrigger()，该函数接收信号的QAction对象。</span></span><br><span class="line">file.triggered[QAction].connect(self.processtrigger)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">processtrigger</span>(<span class="params">self, q</span>):</span><br><span class="line"><span class="built_in">print</span>(q.text() + <span class="string">&quot; is triggered&quot;</span>)</span><br></pre></td></tr></table></figure><p><strong>（2）QToolBar</strong></p><p>QToolBar控件是由文本按钮、图标或其他小控件按钮组成的可移动面板，通常位于菜单栏下方。QToolBar类中的常用方法如下：</p><table><thead><tr class="header"><th>方法</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>addAction()</td><td>添加具有文本或图标的工具按钮</td></tr><tr class="even"><td>addSeparator()</td><td>分组显示工具按钮</td></tr><tr class="odd"><td>addWidget()</td><td>在工具栏中添加按钮以外的控件</td></tr><tr class="even"><td>addToolBar()</td><td>使用QMainWindow类的方法添加一个新的工具栏</td></tr><tr class="odd"><td>setMovable()</td><td>工具栏变得可移动</td></tr><tr class="even"><td>setOrientation()</td><td>工具栏的方向可以设置为Qt.Horizontal或Qt.vertical</td></tr></tbody></table><p>每当单击工具栏中的按钮时，都将发射actionTriggered信号。另外，这个信号将关联的QAction对象的引用发送到连接的槽函数上。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 调用addToolBar()方法在工具栏区域添加文件工具栏</span></span><br><span class="line">tb = self.addToolBar(<span class="string">&quot;File&quot;</span>)</span><br><span class="line"><span class="comment"># 添加具有文本标题的工具按钮，工具栏通常包含图形按钮。具有图标和名称的QAction对象将被添加到工具栏中。</span></span><br><span class="line">new = QAction(QIcon(<span class="string">&quot;./images/new. png&quot;</span>), <span class="string">&quot;new&quot;</span>, self)</span><br><span class="line">tb.addAction(new)</span><br><span class="line">openf = QAction(QIcon(<span class="string">&quot;./images/open. png&quot;</span>), <span class="string">&quot;open&quot;</span>, self)</span><br><span class="line">tb.addAction(openf)</span><br><span class="line">save = QAction(QIcon(<span class="string">&quot;./images/save. png&quot;</span>), <span class="string">&quot;save&quot;</span>, self)</span><br><span class="line">tb.addAction(save)</span><br><span class="line"><span class="comment"># 将actionTriggered信号连接到槽函数toolbtnpressed()</span></span><br><span class="line">tb.actionTriggered[QAction].connect(self.toolbtnpressed)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">toolbtnpressed</span>(<span class="params">self, a</span>):</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;pressed tool button is&quot;</span>, a.text())</span><br></pre></td></tr></table></figure><p><strong>（3）QStatusBar</strong></p><p>MainWindow对象在底部保留有一个水平条，作为状态栏（QStatusBar），用于显示永久的或临时的状态信息。 通过主窗口的QMainWindow的setStatusBar()函数设置状态栏，核心代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">self.statusBar = QStatusBar()</span><br><span class="line">self.setStatusBar(self.statusBar)</span><br></pre></td></tr></table></figure><p>QStatusBar类中的常用方法如下：</p><table><thead><tr class="header"><th>方法</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>addWidget()</td><td>在状态栏中添加给定的窗口小控件对象</td></tr><tr class="even"><td>addPermanentWidget()</td><td>在状态栏中永久添加给定的窗口小控件对象</td></tr><tr class="odd"><td>showMessage()</td><td>在状态栏中显示一条临时信息指定时间间隔</td></tr><tr class="even"><td>clearMessage()</td><td>删除正在显示的临时信息</td></tr><tr class="odd"><td>removeWidget()</td><td>从状态栏中删除指定的小控件</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">bar = self.menuBar()</span><br><span class="line">file = bar.addMenu(<span class="string">&quot;File&quot;</span>)</span><br><span class="line">file.addAction(<span class="string">&quot;show&quot;</span>)</span><br><span class="line"><span class="comment"># 当单击MenuBar的菜单时，将triggered信号与槽函数processTrigger()进行绑定。</span></span><br><span class="line">file.triggered[QAction].connect(self.processTrigger)</span><br><span class="line">self.statusBar = QStatusBar()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当单击&quot;show&quot;菜单选项时，会在状态栏显示提示信息，并在5秒后消失。</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">processTrigger</span>(<span class="params">self, q</span>):</span><br><span class="line"><span class="keyword">if</span>(q.text()==<span class="string">&quot;show&quot;</span>):</span><br><span class="line">self.statusBar.showMessage(q.text() + <span class="string">&quot;菜单选项被点击了&quot;</span>, <span class="number">5000</span>)</span><br></pre></td></tr></table></figure><h3 id="qprinter">👀QPrinter</h3><p>打印图像是图像处理软件中的一个常用功能。打印图像实际上是在QPaintDevice中画图，与平常在QWidget、QPixmap和QImage中画图一样，都是创建一个QPainter对象进行画图的，只是打印使用的是QPrinter，它本质上也是一个QPaintDevice（绘图设备）。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GUI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python深度学习之PyTorch基础教程</title>
      <link href="/2024/06/10/DL-PyTorch-Basic/"/>
      <url>/2024/06/10/DL-PyTorch-Basic/</url>
      
        <content type="html"><![CDATA[<h2 id="前言">⛄前言</h2><p>PyTorch是一个基于Torch的Python开源机器学习(深度学习)框架，由Facebook的人工智能研究院开发，不仅能够实现强大的GPU加速，还支持动态神经网络，使得研究人员和开发人员能够轻松构建和训练复杂的深度学习模型。与TensorFlow等其他框架相比，Pytorch的主要优势在于其简单易用的接口、高效的性能和强大的生态系统。PyTorch的主要特点和功能：</p><ul><li><strong>基本概念</strong>：PyTorch的基本概念包括张量(Tensor)、自动求导(Autograd)和动态计算图(Dynamic Computation Graph)。张量是PyTorch最基本的数据类型，类似于多维数组，用于存储和处理大规模的数值数据，并支持各种数学运算和操作。自动求导是PyTorch的一个重要特性，它能自动计算张量的梯度，有助于深度学习模型的训练。动态计算图则使得PyTorch的计算过程可以灵活地进行构建和修改，有助于开发复杂的神经网络模型。</li><li><strong>基本使用方法</strong>：PyTorch提供了丰富的API和工具，使得用户可以方便地创建和操作张量，进行基本的数学运算，以及构建和训练神经网络模型。例如，用户可以轻松地创建一个矩阵，进行加法操作，改变矩阵的维度，以及与NumPy进行协同操作等。</li><li><strong>软件特色</strong>：PyTorch由多个库组成，包括Tensor库、自动分化库、神经网络库、多处理库和实用函数库等。这些库提供了丰富的功能和工具，使得PyTorch既可以作为Numpy的替代品，也可以作为深度学习研究平台，提供最佳的灵活性和速度。</li><li><strong>生态系统组件</strong>：torchvision一个用于计算机视觉任务的库，包含常见数据集、预训练模型和工具；torchtext一个用于文本处理任务的库，支持文本清洗、分词等功能；torch.nn一个用于构建神经网络的模块，提供了各种层、损失函数和优化器；torch.distributed一个用于分布式训练的库，可以轻松实现多机多卡训练。</li><li><strong>学习资源</strong>：PyTorch官方文档提供了详细的教程和API文档，适合初学者入门和深入学习。此外，PyTorch中文网、GitHub上的开源项目以及博客、论坛和在线社区等也提供了丰富的教程、解答和讨论，有助于用户更好地学习和使用PyTorch。</li><li><strong>应用场景</strong>：PyTorch的应用场景非常广泛，包括图像识别、自然语言处理、计算机视觉等领域。例如，在图像识别领域，PyTorch可以用于训练图像分类器；在自然语言处理领域，PyTorch可以用于训练文本分类器；在计算机视觉领域，PyTorch可以用于实现计算机视觉推理系统等。</li></ul><p>总的来说，PyTorch是一个功能强大、灵活易用的深度学习平台，适用于各种人工智能研究和应用场景。PyTorch是一个基于Python的科学计算包，主要定位两类人群：</p><ul><li><p>NumPy的替代品，可以利用GPU的性能进行计算；</p></li><li><p>深度学习研究平台拥有足够的灵活性和速度。</p></li></ul><h2 id="pytorch基础">⛄PyTorch基础</h2><h3 id="numpy基础">👀Numpy基础</h3><p>在机器学习和深度学习中，图像、声音、文本等输入数据最终都要转换为数组或矩阵。如何有效地进行数组和矩阵的运算？这就需要充分利用Numpy。Numpy是数据科学的通用语言，而且与PyTorch关系非常密切，它是科学计算、深度学习的基石。尤其对PyTorch而言，其重要性更加明显。PyTorch中的Tensor与Numpy非常相似，它们之间可以非常方便地进行转换，掌握Numpy是学好PyTorch的重要基础。</p><p>Numpy(Numerical Python)提供了两种基本的对象：ndarray(N-dimensional Array Object)和ufunc(Universal Function Object)。ndarray是存储单一数据类型的多维数组，而ufunc则是能够对数组进行处理的函数。</p><h4 id="numpy数组">👁Numpy数组</h4><p><strong>（1）从已有数据中创建数组</strong></p><p>通过直接对Python的基础数据类型(如列表、元组等)进行转换来生成ndarray：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment"># 将列表转换成ndarray</span></span><br><span class="line">list1 = [<span class="number">3.5</span>, <span class="number">2.5</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">nd1 = np.array(list1)</span><br><span class="line"><span class="built_in">print</span>(nd1)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(nd1))</span><br><span class="line"><span class="comment"># 嵌套列表可以转换成多维ndarray</span></span><br><span class="line">list2 = [[<span class="number">3.5</span>, <span class="number">2.5</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]]</span><br><span class="line">nd2 = np.array(list2)</span><br><span class="line"><span class="built_in">print</span>(nd2)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(nd2))</span><br><span class="line"><span class="comment"># 将元组转换成ndarray</span></span><br><span class="line">list3 = (<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line">nd3 = np.array(list3)</span><br><span class="line"><span class="built_in">print</span>(nd3)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(nd3))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[<span class="number">3.5</span> <span class="number">2.5</span> <span class="number">0.</span>  <span class="number">1.</span>  <span class="number">2.</span> ]</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;numpy.ndarray&#x27;</span>&gt;</span><br><span class="line">[[<span class="number">3.5</span> <span class="number">2.5</span> <span class="number">0.</span>  <span class="number">1.</span>  <span class="number">2.</span> ]</span><br><span class="line"> [<span class="number">1.</span>  <span class="number">2.</span>  <span class="number">3.</span>  <span class="number">4.</span>  <span class="number">5.</span> ]]</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;numpy.ndarray&#x27;</span>&gt;</span><br><span class="line">[<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span>]</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;numpy.ndarray&#x27;</span>&gt;</span><br></pre></td></tr></table></figure><p><strong>（2）利用random模块生成数组</strong></p><p>在深度学习中，我们需要对一些参数进行初始化，为了更有效地训练模型，提高模型的性能，有些初始化还需要满足一定的条件，如满足正态分布或均匀分布等。np.random模块常用函数：</p><table><thead><tr class="header"><th>函数</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>np.random.random</td><td>生成0到1之间的随机数</td></tr><tr class="even"><td>np.random.uniform</td><td>生成均匀分布的随机数</td></tr><tr class="odd"><td>np.random.randn</td><td>生成标准正态的随机数</td></tr><tr class="even"><td>np.random.randint</td><td>生成随机的整数</td></tr><tr class="odd"><td>np.random.normal</td><td>生成正态分布</td></tr><tr class="even"><td>np.random.shuffle</td><td>随机打乱顺序</td></tr><tr class="odd"><td>np.random.seed</td><td>设置随机数种子</td></tr><tr class="even"><td>np.random.random_sample</td><td>生成随机的浮点数</td></tr><tr class="odd"><td>...</td><td>...</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">nd = np.random.random([<span class="number">3</span>, <span class="number">3</span>])</span><br><span class="line"><span class="built_in">print</span>(nd)</span><br><span class="line"><span class="built_in">print</span>(nd.shape)</span><br><span class="line">np.random.shuffle(nd)</span><br><span class="line"><span class="built_in">print</span>(nd)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[[<span class="number">0.96651734</span> <span class="number">0.71544924</span> <span class="number">0.70717421</span>]</span><br><span class="line"> [<span class="number">0.92522016</span> <span class="number">0.99484174</span> <span class="number">0.00550428</span>]</span><br><span class="line"> [<span class="number">0.36218919</span> <span class="number">0.11263693</span> <span class="number">0.1816698</span> ]]</span><br><span class="line">(<span class="number">3</span>, <span class="number">3</span>)</span><br><span class="line">[[<span class="number">0.92522016</span> <span class="number">0.99484174</span> <span class="number">0.00550428</span>]</span><br><span class="line"> [<span class="number">0.96651734</span> <span class="number">0.71544924</span> <span class="number">0.70717421</span>]</span><br><span class="line"> [<span class="number">0.36218919</span> <span class="number">0.11263693</span> <span class="number">0.1816698</span> ]]</span><br></pre></td></tr></table></figure><p><strong>（3）创建特定形状的多维数组</strong></p><p>参数初始化时，有时需要生成一些特殊矩阵，如全是0或1的数组或矩阵。</p><table><thead><tr class="header"><th>函数</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>np.zeros((m,n))</td><td>创建m×n的元素全为0的数组</td></tr><tr class="even"><td>np.ones((m,n))</td><td>创建m×n的元素全为1的数组</td></tr><tr class="odd"><td>np.empty((m,n))</td><td>创建m×n的空数组，空数据中的值并不为0，而是未初始化的垃圾值</td></tr><tr class="even"><td>np.zeros_like(ndarr)</td><td>以ndarr相同维度创建元素全为0数组</td></tr><tr class="odd"><td>np.ones_like(ndarr)</td><td>以ndarr相同维度创建元素全为1数组</td></tr><tr class="even"><td>np.empty_like(ndarr)</td><td>以ndarr相同维度创建空数组</td></tr><tr class="odd"><td>np.eye(m)</td><td>该函数用于创建一个m×m的矩阵，对角线为1，其余为0</td></tr><tr class="even"><td>np.full((m,n), value)</td><td>创建m×n的元素全为value的数组，value为指定值</td></tr><tr class="odd"><td>...</td><td>...</td></tr></tbody></table><p><strong>（4）利用arange、linspace函数生成数组</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># numpy模块中的arange、linspace函数</span></span><br><span class="line"><span class="comment"># start与stop用来指定范围，step用来设定步长。在生成一个ndarray时，start默认为0，步长step可为小数。Python有个内置函数range，其功能与此类似。</span></span><br><span class="line">np.arange([start,] stop[,step,], dtype=<span class="literal">None</span>)</span><br><span class="line"><span class="comment"># linspace可以根据输入的指定数据范围以及等份数量，自动生成一个线性等分向量，其中endpoint（包含终点）默认为True，等分数量num默认为50。如果将retstep设置为True，则会返回一个带步长的ndarray。</span></span><br><span class="line">np.linspace(start, stop, num=<span class="number">50</span>, endpoint=<span class="literal">True</span>, retstep=<span class="literal">False</span>, dtype=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure><h4 id="获取元素">👁获取元素</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">nd = np.random.random([<span class="number">10</span>])</span><br><span class="line"><span class="built_in">print</span>(nd)</span><br><span class="line"><span class="comment"># 获取指定位置的数据，获取第4个元素</span></span><br><span class="line"><span class="built_in">print</span>(nd[<span class="number">3</span>])</span><br><span class="line"><span class="comment"># 截取一段数据</span></span><br><span class="line"><span class="built_in">print</span>(nd[<span class="number">3</span>:<span class="number">6</span>])</span><br><span class="line"><span class="comment"># 截取固定间隔数据</span></span><br><span class="line"><span class="built_in">print</span>(nd[<span class="number">1</span>:<span class="number">6</span>:<span class="number">2</span>])</span><br><span class="line"><span class="comment"># 倒序取数</span></span><br><span class="line"><span class="built_in">print</span>(nd[::-<span class="number">2</span>])</span><br><span class="line"><span class="comment"># 截取一个多维数组的一个区域内数据</span></span><br><span class="line">nd1 = np.arange(<span class="number">25</span>).reshape([<span class="number">5</span>, <span class="number">5</span>])</span><br><span class="line"><span class="built_in">print</span>(nd1)</span><br><span class="line"><span class="built_in">print</span>(nd1[<span class="number">1</span>:<span class="number">3</span>, <span class="number">1</span>:<span class="number">3</span>])</span><br><span class="line"><span class="comment"># 截取一个多维数组中，数值在一个值域之内的数据</span></span><br><span class="line"><span class="built_in">print</span>(nd1[(nd1 &gt; <span class="number">3</span>) &amp; (nd1 &lt; <span class="number">10</span>)])</span><br><span class="line"><span class="comment"># 截取多维数组中，指定的行,如读取第2,3行</span></span><br><span class="line"><span class="built_in">print</span>(nd1[[<span class="number">1</span>, <span class="number">2</span>]])  <span class="comment"># 或nd12[1:3,:]</span></span><br><span class="line"><span class="comment"># 截取多维数组中，指定的列,如读取第2,3列</span></span><br><span class="line"><span class="built_in">print</span>(nd1[:, <span class="number">1</span>:<span class="number">3</span>])</span><br></pre></td></tr></table></figure><p>获取数组中的部分元素除了通过指定索引标签来实现外，还可以通过使用一些函数来实现，如通过random.choice函数从指定的样本中随机抽取数据。</p><h4 id="numpy的算术运算">👁Numpy的算术运算</h4><p>在机器学习和深度学习中，涉及大量的数组或矩阵运算，我们将重点介绍两种常用的运算。</p><ul><li><p>一种是对应元素相乘，又称为逐元乘法(Element-Wise Product)，运算符为np.multiply()或*。</p></li><li><p>一种是点积或内积元素，运算符为np.dot()。</p></li></ul><p><strong>（1）对应元素相乘</strong></p><p>对应元素相乘(Element-Wise Product)是两个矩阵中对应元素乘积。np.multiply函数用于数组或矩阵对应元素相乘，输出与相乘数组或矩阵的大小一致，其格式如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 格式</span></span><br><span class="line"><span class="comment"># x1、x2之间的对应元素相乘遵守广播规则</span></span><br><span class="line">numpy.multiply(x1, x2, /, out=<span class="literal">None</span>, *, where=<span class="literal">True</span>, casting=<span class="string">&#x27;same_kind&#x27;</span>, order=<span class="string">&#x27;K&#x27;</span>, dtype=<span class="literal">None</span>, subok=<span class="literal">True</span>[, signature, extobj])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">A = np.array([[<span class="number">1</span>, <span class="number">2</span>], [-<span class="number">1</span>, <span class="number">4</span>]])</span><br><span class="line">B = np.array([[<span class="number">2</span>, <span class="number">0</span>], [<span class="number">3</span>, <span class="number">4</span>]])</span><br><span class="line"><span class="built_in">print</span>(A*B)</span><br><span class="line"><span class="built_in">print</span>(np.multiply(A, B))</span><br><span class="line"><span class="comment"># Numpy数组不仅可以和数组进行对应元素相乘，还可以和单一数值（或称为标量）进行运算。运算时，Numpy数组中的每个元素都和标量进行运算，其间会用到广播机制</span></span><br><span class="line"><span class="built_in">print</span>(A*<span class="number">2.0</span>)</span><br><span class="line"><span class="built_in">print</span>(A/<span class="number">2.0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[[ <span class="number">2</span>  <span class="number">0</span>]</span><br><span class="line"> [-<span class="number">3</span> <span class="number">16</span>]]</span><br><span class="line">[[ <span class="number">2</span>  <span class="number">0</span>]</span><br><span class="line"> [-<span class="number">3</span> <span class="number">16</span>]]</span><br><span class="line">[[ <span class="number">2.</span>  <span class="number">4.</span>]</span><br><span class="line"> [-<span class="number">2.</span>  <span class="number">8.</span>]]</span><br><span class="line">[[ <span class="number">0.5</span>  <span class="number">1.</span> ]</span><br><span class="line"> [-<span class="number">0.5</span>  <span class="number">2.</span> ]]</span><br></pre></td></tr></table></figure><p>由此，推而广之，数组通过一些激活函数后，输出与输入形状一致。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">X = np.random.rand(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">softmoid</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> / (<span class="number">1</span> + np.exp(-x))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">relu</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> np.maximum(<span class="number">0</span>, x)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">softmax</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> np.exp(x) / np.<span class="built_in">sum</span>(np.exp(x))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;输入参数X的形状：&quot;</span>, X.shape)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;激活函数softmoid输出形状：&quot;</span>, softmoid(X).shape)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;激活函数relu输出形状：&quot;</span>, relu(X).shape)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;激活函数softmax输出形状：&quot;</span>, softmax(X).shape)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">输入参数X的形状： (<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">激活函数softmoid输出形状： (<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">激活函数relu输出形状： (<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">激活函数softmax输出形状： (<span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure><p><strong>（2）点积运算</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 格式</span></span><br><span class="line">numpy.dot(a, b, out=<span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例</span></span><br><span class="line"><span class="comment"># 矩阵X1和矩阵X2进行点积运算，其中X1和X2对应维度（即X1的第2个维度与X2的第1个维度）的元素个数必须保持一致。此外，矩阵X3的形状是由矩阵X1的行数与矩阵X2的列数构成的。</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">X1 = np.array([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]])</span><br><span class="line">X2 = np.array([[<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>], [<span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]])</span><br><span class="line">X3 = np.dot(X1, X2)</span><br><span class="line"><span class="built_in">print</span>(X3)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[[<span class="number">21</span> <span class="number">24</span> <span class="number">27</span>]</span><br><span class="line"> [<span class="number">47</span> <span class="number">54</span> <span class="number">61</span>]]</span><br></pre></td></tr></table></figure><h4 id="数组变形">👁数组变形</h4><p>在机器学习及深度学习的任务中，通常需要将处理好的数据以模型能接收的格式输入给模型，然后由模型通过一系列的运算，最终返回一个处理结果。然而，由于不同模型所接收的输入格式不一样，往往需要先对其进行一系列的变形和运算，从而将数据处理成符合模型要求的格式。在矩阵或者数组的运算中，经常会遇到需要把多个向量或矩阵按某轴方向合并，或展平（如在卷积或循环神经网络中，在全连接层之前，需要把矩阵展平）的情况。</p><p><strong>（1）更改数组的形状</strong></p><p>修改指定数组的形状是Numpy中最常见的操作之一，常见函数：</p><table><thead><tr class="header"><th>函数</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>arr.reshape</td><td>重新将向量arr维度进行改变，不修改向量本身</td></tr><tr class="even"><td>arr.resize</td><td>重新将向量arr维度进行改变，修改向量本身</td></tr><tr class="odd"><td>arr.T</td><td>对向量arr进行转置</td></tr><tr class="even"><td>arr.ravel</td><td>对向量arr进行展平，即将多维数组变成1维数组，不会产生原数组的副本</td></tr><tr class="odd"><td>arr.flatten</td><td>对向量arr进行展平，即将多维数组变成1维数组，返回原数组的副本</td></tr><tr class="even"><td>arr.squeeze</td><td>只能对维数为1的维度降维。对多维数组使用时不会报错，但是不会产生任何影响</td></tr><tr class="odd"><td>arr.transpose</td><td>对高维矩阵进行轴对换</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">arr = np.arange(<span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(arr)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span> * <span class="number">20</span>)</span><br><span class="line"><span class="comment"># (1)reshape改变向量的维度（不修改向量本身）：</span></span><br><span class="line"><span class="comment"># 将向量 arr 维度变换为2行5列</span></span><br><span class="line"><span class="built_in">print</span>(arr.reshape(<span class="number">2</span>, <span class="number">5</span>))</span><br><span class="line"><span class="comment"># 指定维度时可以只指定行数或列数, 其他用-1代替</span></span><br><span class="line"><span class="built_in">print</span>(arr.reshape(<span class="number">5</span>, -<span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(arr.reshape(-<span class="number">1</span>, <span class="number">5</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span> * <span class="number">20</span>)</span><br><span class="line"><span class="comment"># (2)resize改变向量的维度（修改向量本身）</span></span><br><span class="line"><span class="comment"># 将向量 arr 维度变换为2行5列</span></span><br><span class="line">arr.resize(<span class="number">2</span>, <span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(arr)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span> * <span class="number">20</span>)</span><br><span class="line"><span class="comment"># (3)T向量转置</span></span><br><span class="line"><span class="comment"># 将向量arr进行转置为5行2列</span></span><br><span class="line"><span class="built_in">print</span>(arr.T)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span> * <span class="number">20</span>)</span><br><span class="line"><span class="comment"># (4)ravel向量展平</span></span><br><span class="line"><span class="comment"># 按照列优先，展平</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;按照列优先，展平&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(arr.ravel(<span class="string">&#x27;F&#x27;</span>))</span><br><span class="line"><span class="comment"># 按照行优先，展平</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;按照行优先，展平&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(arr.ravel())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span> * <span class="number">20</span>)</span><br><span class="line"><span class="comment"># (5)flatten把矩阵转换为向量，这种需求经常出现在卷积网络与全连接层之间。</span></span><br><span class="line"><span class="built_in">print</span>(arr.flatten())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span> * <span class="number">20</span>)</span><br><span class="line"><span class="comment"># (6)squeeze这是一个主要用来降维的函数，把矩阵中含1的维度去掉。</span></span><br><span class="line">arr1 = np.arange(<span class="number">3</span>).reshape(<span class="number">3</span>, <span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(arr1.shape)  <span class="comment"># (3,1)</span></span><br><span class="line"><span class="built_in">print</span>(arr1.squeeze().shape)  <span class="comment"># (3,)</span></span><br><span class="line">arr2 = np.arange(<span class="number">6</span>).reshape(<span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(arr2.shape)  <span class="comment"># (3, 1, 2, 1)</span></span><br><span class="line"><span class="built_in">print</span>(arr2.squeeze().shape)  <span class="comment"># (3, 2)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span> * <span class="number">20</span>)</span><br><span class="line"><span class="comment"># (7)transpose对高维矩阵进行轴对换，在深度学习中经常使用，比如把图片中表示颜色顺序的RGB改为GBR。</span></span><br><span class="line">arr3 = np.arange(<span class="number">24</span>).reshape(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(arr3.shape)  <span class="comment"># (2, 3, 4)</span></span><br><span class="line"><span class="built_in">print</span>(arr3.transpose(<span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>).shape)  <span class="comment"># (3, 4, 2)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span>]</span><br><span class="line">********************</span><br><span class="line">[[<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>]</span><br><span class="line"> [<span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span>]]</span><br><span class="line">[[<span class="number">0</span> <span class="number">1</span>]</span><br><span class="line"> [<span class="number">2</span> <span class="number">3</span>]</span><br><span class="line"> [<span class="number">4</span> <span class="number">5</span>]</span><br><span class="line"> [<span class="number">6</span> <span class="number">7</span>]</span><br><span class="line"> [<span class="number">8</span> <span class="number">9</span>]]</span><br><span class="line">[[<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>]</span><br><span class="line"> [<span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span>]]</span><br><span class="line">********************</span><br><span class="line">[[<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>]</span><br><span class="line"> [<span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span>]]</span><br><span class="line">********************</span><br><span class="line">[[<span class="number">0</span> <span class="number">5</span>]</span><br><span class="line"> [<span class="number">1</span> <span class="number">6</span>]</span><br><span class="line"> [<span class="number">2</span> <span class="number">7</span>]</span><br><span class="line"> [<span class="number">3</span> <span class="number">8</span>]</span><br><span class="line"> [<span class="number">4</span> <span class="number">9</span>]]</span><br><span class="line">********************</span><br><span class="line">按照列优先，展平</span><br><span class="line">[<span class="number">0</span> <span class="number">5</span> <span class="number">1</span> <span class="number">6</span> <span class="number">2</span> <span class="number">7</span> <span class="number">3</span> <span class="number">8</span> <span class="number">4</span> <span class="number">9</span>]</span><br><span class="line">按照行优先，展平</span><br><span class="line">[<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span>]</span><br><span class="line">********************</span><br><span class="line">[<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span>]</span><br><span class="line">********************</span><br><span class="line">(<span class="number">3</span>, <span class="number">1</span>)</span><br><span class="line">(<span class="number">3</span>,)</span><br><span class="line">(<span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">(<span class="number">3</span>, <span class="number">2</span>)</span><br><span class="line">********************</span><br><span class="line">(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">(<span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure><p><strong>（2）合并数组</strong></p><p>合并数组也是最常见的操作之一，常见的用于数组或向量合并的方法。</p><table><thead><tr class="header"><th>函数</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>np.append</td><td>合并一维或多维数组，内存占用大</td></tr><tr class="even"><td>np.concatenate</td><td>沿指定轴连接数组或矩阵，没有内存问题</td></tr><tr class="odd"><td>np.stack</td><td>沿指定轴堆叠数组或矩阵，沿着新的轴加入一系列数组</td></tr><tr class="even"><td>np.hstack</td><td>按水平方向（列顺序）堆叠数组构成一个新的数组，堆叠的数组需要具有相同的维度</td></tr><tr class="odd"><td>np.vstack</td><td>按垂直方向（行顺序）堆叠数组构成一个新的数组，堆叠的数组需要具有相同的维度</td></tr><tr class="even"><td>np.dstack</td><td>沿深度方向将数组进行堆叠。将相同尺寸的数组沿着第三个维度（深度方向）进行水平叠加，返回一个新的数组。</td></tr><tr class="odd"><td>np.hsplit</td><td>将一个数组水平（列）分割成多个子数组</td></tr><tr class="even"><td>np.vsplit</td><td>将一个数组垂直（行）分割成多个子数组</td></tr></tbody></table><blockquote><ul><li><p>append、concatenate以及stack都有一个axis参数，用于控制数组的合并方式是按行还是按列。</p></li><li><p>对于append和concatenate，待合并的数组必须有相同的行数或列数（满足一个即可）。</p></li><li><p>stack、hstack、dstack，要求待合并的数组必须具有相同的形状(shape)。</p></li><li><p>numpy.hsplit(arr, indices_or_sections)和numpy.vsplit(arr, indices_or_sections)：①arr是要拆分的多维数组或矩阵[ndarray]；②indices_or_sections : [int or 1-D array] 如果indices_or_sections是一个整数N，数组将沿轴线被分成N个相等的数组。如果indices_or_sections是一个排序的整数的一维数组，这些整数表示该数组沿轴线的分割位置。</p></li></ul></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># (1)append</span></span><br><span class="line">a = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">b = np.array([<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>])</span><br><span class="line">c = np.append(a, b)</span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span> * <span class="number">20</span>)</span><br><span class="line">a1 = np.arange(<span class="number">4</span>).reshape(<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">b1 = np.arange(<span class="number">4</span>).reshape(<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line"><span class="comment"># 按行合并</span></span><br><span class="line">c1 = np.append(a1, b1, axis=<span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;按行合并后的结果&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(c1)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;合并后数据维度&#x27;</span>, c1.shape)</span><br><span class="line"><span class="comment"># 按列合并</span></span><br><span class="line">d2 = np.append(a1, b1, axis=<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;按列合并后的结果&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(d2)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;合并后数据维度&#x27;</span>, d2.shape)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span> * <span class="number">20</span>)</span><br><span class="line"><span class="comment"># (2)concatenate沿指定轴连接数组或矩阵</span></span><br><span class="line">a3 = np.array([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]])</span><br><span class="line">b3 = np.array([[<span class="number">5</span>, <span class="number">6</span>]])</span><br><span class="line">c3 = np.concatenate((a3, b3), axis=<span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(c3)</span><br><span class="line">d3 = np.concatenate((a3, b3.T), axis=<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(d3)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span> * <span class="number">20</span>)</span><br><span class="line"><span class="comment"># (3)stack沿指定轴堆叠数组或矩阵,axis=0/1/2</span></span><br><span class="line">a4 = np.array([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]])</span><br><span class="line">b4 = np.array([[<span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>]])</span><br><span class="line"><span class="built_in">print</span>(np.stack((a4, b4), axis=<span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span> * <span class="number">20</span>)</span><br><span class="line"><span class="comment"># (3)vstack和hstack</span></span><br><span class="line">a5 = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]])</span><br><span class="line">b5 = np.array([[<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]])</span><br><span class="line"><span class="built_in">print</span>(np.vstack((a5, b5)))</span><br><span class="line"><span class="built_in">print</span>(np.hstack((a5, b5)))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span> * <span class="number">20</span>)</span><br><span class="line"><span class="comment"># (4)dstack</span></span><br><span class="line">a6 = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]])</span><br><span class="line">b6 = np.array([[<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>], [<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>]])</span><br><span class="line"><span class="built_in">print</span>(np.dstack((a6, b6)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span>]</span><br><span class="line">********************</span><br><span class="line">按行合并后的结果</span><br><span class="line">[[<span class="number">0</span> <span class="number">1</span>]</span><br><span class="line"> [<span class="number">2</span> <span class="number">3</span>]</span><br><span class="line"> [<span class="number">0</span> <span class="number">1</span>]</span><br><span class="line"> [<span class="number">2</span> <span class="number">3</span>]]</span><br><span class="line">合并后数据维度 (<span class="number">4</span>, <span class="number">2</span>)</span><br><span class="line">按列合并后的结果</span><br><span class="line">[[<span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span>]</span><br><span class="line"> [<span class="number">2</span> <span class="number">3</span> <span class="number">2</span> <span class="number">3</span>]]</span><br><span class="line">合并后数据维度 (<span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line">********************</span><br><span class="line">[[<span class="number">1</span> <span class="number">2</span>]</span><br><span class="line"> [<span class="number">3</span> <span class="number">4</span>]</span><br><span class="line"> [<span class="number">5</span> <span class="number">6</span>]]</span><br><span class="line">[[<span class="number">1</span> <span class="number">2</span> <span class="number">5</span>]</span><br><span class="line"> [<span class="number">3</span> <span class="number">4</span> <span class="number">6</span>]]</span><br><span class="line">********************</span><br><span class="line">[[[<span class="number">1</span> <span class="number">2</span>]</span><br><span class="line">  [<span class="number">5</span> <span class="number">6</span>]]</span><br><span class="line"></span><br><span class="line"> [[<span class="number">3</span> <span class="number">4</span>]</span><br><span class="line">  [<span class="number">7</span> <span class="number">8</span>]]]</span><br><span class="line">********************</span><br><span class="line">[[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]</span><br><span class="line"> [<span class="number">4</span> <span class="number">5</span> <span class="number">6</span>]]</span><br><span class="line">[[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span>]]</span><br><span class="line">********************</span><br><span class="line">[[[ <span class="number">1</span>  <span class="number">7</span>]</span><br><span class="line">  [ <span class="number">2</span>  <span class="number">8</span>]</span><br><span class="line">  [ <span class="number">3</span>  <span class="number">9</span>]]</span><br><span class="line"></span><br><span class="line"> [[ <span class="number">4</span> <span class="number">10</span>]</span><br><span class="line">  [ <span class="number">5</span> <span class="number">11</span>]</span><br><span class="line">  [ <span class="number">6</span> <span class="number">12</span>]]]</span><br></pre></td></tr></table></figure><h4 id="批量处理">👁批量处理</h4><p>在深度学习中，由于源数据都比较大，通常需要用到批处理。如利用批量来计算梯度的随机梯度法(SGD)就是一个典型应用。深度学习的计算一般比较复杂，并且数据量一般比较大，如果一次处理整个数据，较大概率会出现资源瓶颈。为了更有效地计算，一般将整个数据集分批次处理。与处理整个数据集相反的另一个极端是每次只处理一条记录，这种方法也不科学，一次处理一条记录无法充分发挥GPU、Numpy的平行处理优势。因此，在实际使用中往往采用批量处理(Mini-Batch)的方法。如何把大数据拆分成多个批次呢？可采用如下步骤：</p><ol type="1"><li>数据集</li><li>随机打乱数据：shuffle()</li><li>定义批大小：batch_size</li><li>批处理数据集</li></ol><h4 id="通用函数">👁通用函数</h4><p>ufunc是universal function的缩写，它是一种能对数组的每个元素进行操作的函数。许多ufunc函数都是用C语言级别实现的，因此它们的计算速度非常快。此外，它们比math模块中的函数更灵活。math模块的输入一般是标量，但Numpy中的函数可以是向量或矩阵，而利用向量或矩阵可以避免使用循环语句，这点在机器学习、深度学习中非常重要。Numpy中的几个常用通用函数：</p><table><thead><tr class="header"><th>函数</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>sqrt</td><td>计算序列化数据的平方根</td></tr><tr class="even"><td>sin、cos</td><td>三角函数</td></tr><tr class="odd"><td>abs</td><td>计算序列化数据的绝对值</td></tr><tr class="even"><td>dot</td><td>矩阵运算</td></tr><tr class="odd"><td>log、log10、1og2</td><td>对数运算</td></tr><tr class="even"><td>exp</td><td>指数运算</td></tr><tr class="odd"><td>cumsum、cumproduct</td><td>累计求和、求积</td></tr><tr class="even"><td>sum</td><td>对一个序列化数据进行求和</td></tr><tr class="odd"><td>mean</td><td>计算均值</td></tr><tr class="even"><td>median</td><td>计算中位数</td></tr><tr class="odd"><td>std</td><td>计算标准差</td></tr><tr class="even"><td>var</td><td>计算方差</td></tr><tr class="odd"><td>corrcoef</td><td>计算相关系数</td></tr></tbody></table><h4 id="广播机制">👁广播机制</h4><p>Numpy的Universal functions中要求输入的数组shape是一致的，当数组的shape不相等时，则会使用广播机制。不过，调整数组使得shape一样，需要满足一定的规则，否则将出错。这些规则可归纳为以下4条。</p><ul><li>让所有输入数组都向其中shape最长的数组看齐，不足的部分则通过在前面加1补齐；</li><li>输出数组的shape是输入数组shape的各个轴上的最大值；</li><li>如果输入数组的某个轴和输出数组的对应轴的长度相同或者某个轴的长度为1时，这个数组能被用来计算，否则出错；</li><li>当输入数组的某个轴的长度为1时，沿着此轴运算时都用(或复制)此轴上的第一组值。</li></ul><blockquote><p>例子：A+B，其中A为4×1矩阵，B为一维向量（3,）。要相加，需要做如下处理：</p><ol type="1"><li>根据规则1，B需要向看齐，把B变为（1, 3）</li><li>根据规则2，输出的结果为各个轴上的最大值，即输出结果应该为（4, 3）矩阵，那么A如何由（4, 1）变为（4, 3）矩阵？B又如何由（1, 3）变为（4, 3）矩阵？</li><li>根据规则4，用此轴上的第一组值(要主要区分是哪个轴)，进行复制(但在实际处理中不是真正复制，否则太耗内存，而是采用其他对象如ogrid对象，进行网格处理)即可。</li></ol></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">A = np.arange(<span class="number">0</span>, <span class="number">40</span>,<span class="number">10</span>).reshape(<span class="number">4</span>, <span class="number">1</span>)</span><br><span class="line">B = np.arange(<span class="number">0</span>, <span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;A矩阵的形状:&#123;&#125;,B矩阵的形状:&#123;&#125;&quot;</span>.<span class="built_in">format</span>(A.shape,B.shape))</span><br><span class="line">C = A+B</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;C矩阵的形状:&#123;&#125;&quot;</span>.<span class="built_in">format</span>(C.shape))</span><br><span class="line"><span class="built_in">print</span>(C)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">A矩阵的形状:(<span class="number">4</span>, <span class="number">1</span>),B矩阵的形状:(<span class="number">3</span>,)</span><br><span class="line">C矩阵的形状:(<span class="number">4</span>, <span class="number">3</span>)</span><br><span class="line">[[ <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>]</span><br><span class="line"> [<span class="number">10</span> <span class="number">11</span> <span class="number">12</span>]</span><br><span class="line"> [<span class="number">20</span> <span class="number">21</span> <span class="number">22</span>]</span><br><span class="line"> [<span class="number">30</span> <span class="number">31</span> <span class="number">32</span>]]</span><br></pre></td></tr></table></figure><h3 id="pytorch基础-1">👀PyTorch基础</h3><p>PyTorch是建立在Torch库之上的Python包，旨在加速深度学习应用。它提供一种类似Numpy的抽象方法来表征张量(或多维数组)，可以利用GPU加速训练。PyTorch采用了动态计算图(Dynamic Computational Graph)结构，且基于tape的Autograd系统的深度神经网络。很多框架，比如TensorFlow(TensorFlow2.0也加入动态网络的支持)、Caffe、CNTK、Theano等采用静态计算图。PyTorch通过一种称为反向模式自动微分的技术，可以零延迟或零成本地任意改变你的网络的行为。Torch是PyTorch中的一个重要包，它包含了多维张量的数据结构以及基于其上的多种数学操作。PyTorch由4个主要的包组成：</p><ul><li>torch：类似Numpy的通用数组库，将张量类型转换为torch.cuda.TensorFloat，并在GPU上计算。</li><li>torch.autograd：用于构建计算图形并自动获取梯度的包。</li><li>torch.nn：具有共享层和损失函数的神经网络库。</li><li>torch.optim：具有通用优化算法(如SGD、Adam等)的优化包。</li></ul><h4 id="tensor概述">👁Tensor概述</h4><p>PyTorch的Tensor，它可以是零维(又称为标量或一个数)、一维、二维及多维的数组。Tensor自称为神经网络界的Numpy，它与Numpy相似，二者可以共享内存，且之间的转换非常方便高效。它们最大的区别就是Numpy会把ndarray放在CPU中进行加速运算，而由Torch产生的Tensor会放在GPU中进行加速运算(假设当前环境有GPU)。对Tensor的操作很多，从接口的角度来划分，可以分为两类：</p><ul><li><p>torch.function，如torch.sum、torch.add等；</p></li><li><p>tensor.function，如tensor.view、tensor.add等。</p></li></ul><p>这些操作对大部分Tensor都是等价的，如torch.add(x,y)与x.add(y)等价。在实际使用时，可以根据个人爱好选择。如果从修改方式的角度来划分，可以分为以下两类：</p><ul><li><p>不修改自身数据，如x.add(y)，x的数据不变，返回一个新的Tensor。</p></li><li><p>修改自身数据，如x.add_(y)（运行符带下划线后缀），运算结果存在x中，x被修改。</p></li></ul><h4 id="创建tensor">👁创建Tensor</h4><p>创建Tensor的方法有很多，可以从列表或ndarray等类型进行构建，也可根据指定的形状构建。常见的创建Tensor的方法：</p><table><thead><tr class="header"><th>函数</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>Tensor()</td><td>直接从参数构造一个张量，支持List、Numpy数组</td></tr><tr class="even"><td>eye(row, column)</td><td>创建指定行数、列数的二维单位Tensor</td></tr><tr class="odd"><td>linspace(start, end, steps)</td><td>从start到end，均匀切分成steps份</td></tr><tr class="even"><td>logspace(start, end, steps)</td><td>从10^start，到10^end，均匀切分成steps份</td></tr><tr class="odd"><td>rand/randn(*size)</td><td>生成[0, 1)均匀分布/标准正态分布数据</td></tr><tr class="even"><td>ones(*size)</td><td>返回指定shape的张量，元素初始为1</td></tr><tr class="odd"><td>zeros(*size)</td><td>返回指定shape的张量，元素初始为0</td></tr><tr class="even"><td>ones_like(T)</td><td>返回与T的shape相同的张量，且元素初始为1</td></tr><tr class="odd"><td>zeros_like(T)</td><td>返回与T的shape相同的张量，且元素初始为0</td></tr><tr class="even"><td>arange(start, end, step)</td><td>在区间[start, end)上以间隔step生成一个序列张量</td></tr><tr class="odd"><td>from_Numpy(ndarray)</td><td>从ndarray创建一个Tensor</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据list数据生成Tensor</span></span><br><span class="line">a = torch.Tensor([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>])</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 根据指定形状生成Tensor，随机初始化</span></span><br><span class="line">b = torch.Tensor(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 根据给定的Tensor的形状</span></span><br><span class="line">c = torch.Tensor([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]])</span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line"><span class="comment"># 查看Tensor的形状</span></span><br><span class="line"><span class="built_in">print</span>(c.size())</span><br><span class="line"><span class="comment"># shape与size()等价方式</span></span><br><span class="line"><span class="built_in">print</span>(c.shape)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 根据已有形状创建Tensor，随机初始化</span></span><br><span class="line">d = torch.Tensor(c.size())</span><br><span class="line"><span class="built_in">print</span>(d)</span><br><span class="line"><span class="comment"># 生成一个单位矩阵</span></span><br><span class="line">torch.eye(<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line"><span class="comment"># 自动生成全是0的矩阵</span></span><br><span class="line">torch.zeros(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="comment"># 根据规则生成数据</span></span><br><span class="line">torch.linspace(<span class="number">1</span>, <span class="number">10</span>, <span class="number">4</span>)</span><br><span class="line"><span class="comment"># 生成满足均匀分布随机数</span></span><br><span class="line">torch.rand(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="comment"># 生成满足标准分布随机数</span></span><br><span class="line">torch.randn(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="comment"># 返回所给数据形状相同，值全为0的张量</span></span><br><span class="line">torch.zeros_like(torch.rand(<span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">tensor([<span class="number">1.</span>, <span class="number">2.</span>, <span class="number">3.</span>, <span class="number">4.</span>, <span class="number">5.</span>, <span class="number">6.</span>])</span><br><span class="line">********************</span><br><span class="line">tensor([[<span class="number">7.2564e+24</span>, <span class="number">1.7418e-42</span>, <span class="number">0.0000e+00</span>],</span><br><span class="line">        [<span class="number">0.0000e+00</span>, <span class="number">0.0000e+00</span>, <span class="number">0.0000e+00</span>]])</span><br><span class="line">********************</span><br><span class="line">tensor([[<span class="number">1.</span>, <span class="number">2.</span>, <span class="number">3.</span>],</span><br><span class="line">        [<span class="number">4.</span>, <span class="number">5.</span>, <span class="number">6.</span>]])</span><br><span class="line">torch.Size([<span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">torch.Size([<span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">********************</span><br><span class="line">tensor([[<span class="number">7.2567e+24</span>, <span class="number">1.7418e-42</span>, <span class="number">0.0000e+00</span>],</span><br><span class="line">        [<span class="number">0.0000e+00</span>, <span class="number">0.0000e+00</span>, <span class="number">0.0000e+00</span>]])</span><br></pre></td></tr></table></figure><blockquote><p>注意torch.Tensor与torch.tensor的几点区别：</p><p>1）torch.Tensor是torch.empty和torch.tensor之间的一种混合，但当传入数据时，torch.Tensor使用全局默认dtype(FloatTensor)，而torch.tensor是从数据中推断数据类型。</p><p>2）torch.tensor(1)返回一个固定值1，而torch.Tensor(1)返回一个大小为1的张量，它是<strong>随机初始化</strong>的值。</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line">t1 = torch.Tensor(<span class="number">3</span>)</span><br><span class="line">t2 = torch.Tensor(<span class="number">1</span>)</span><br><span class="line">t3 = torch.tensor(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;t1的值&#123;&#125;,t1的数据类型&#123;&#125;&quot;</span>.<span class="built_in">format</span>(t1, t1.<span class="built_in">type</span>()))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;t2的值&#123;&#125;,t2的数据类型&#123;&#125;&quot;</span>.<span class="built_in">format</span>(t2, t2.<span class="built_in">type</span>()))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;t3的值&#123;&#125;,t3的数据类型&#123;&#125;&quot;</span>.<span class="built_in">format</span>(t3, t3.<span class="built_in">type</span>()))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果1</span></span><br><span class="line">t1的值tensor([<span class="number">7.0406e+13</span>, <span class="number">1.1561e-42</span>, <span class="number">0.0000e+00</span>]),t1的数据类型torch.FloatTensor</span><br><span class="line">t2的值tensor([<span class="number">0.</span>]),t2的数据类型torch.FloatTensor</span><br><span class="line">t3的值<span class="number">1</span>,t3的数据类型torch.LongTensor</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果2</span></span><br><span class="line">t1的值tensor([<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>]),t1的数据类型torch.FloatTensor</span><br><span class="line">t2的值tensor([<span class="number">3.4713e-18</span>]),t2的数据类型torch.FloatTensor</span><br><span class="line">t3的值<span class="number">1</span>,t3的数据类型torch.LongTensor</span><br></pre></td></tr></table></figure><h4 id="修改tensor形状">👁修改Tensor形状</h4><p>在处理数据、构建网络层等过程中，需要了解Tensor的形状、修改Tensor的形状。与修改Numpy的形状类似，修改Tenor的形状也有很多类似函数：</p><table><colgroup><col style="width: 16%" /><col style="width: 83%" /></colgroup><thead><tr class="header"><th>函数</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>size()</td><td>返回张量的shape属性值，与属性shape(0.4版新增)等价</td></tr><tr class="even"><td>numel(input)</td><td>计算Tensor的元素个数</td></tr><tr class="odd"><td>view(*shape)</td><td>修改Tensor的shape，与reshape(0.4版新增)类似，但view返回的对象与源Tensor共享内存，修改一个，另一个同时修改。reshape将生成新的Tensor，而且不要求源Tensor是连续的。view(-1)展平数组</td></tr><tr class="even"><td>resize</td><td>类似于view，但在size超出时会重新分配内存空间</td></tr><tr class="odd"><td>item</td><td>若Tensor为<strong>单(一个)元素</strong>，则返回Python的标量</td></tr><tr class="even"><td>unsqueeze</td><td>扩展维度，在插入维度的索引位置增加维度"1",这里的"1"仅仅起到扩展维度的作用</td></tr><tr class="odd"><td>squeeze</td><td>降低维度，在压缩维度的索引位置减少维度"1"，即将输入张量形状指定位置中的"1"去除并返回</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成一个形状为2x3的矩阵</span></span><br><span class="line">x = torch.randn(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="comment"># 查看矩阵的形状</span></span><br><span class="line"><span class="built_in">print</span>(x.size())</span><br><span class="line"><span class="comment"># 查看x的维度</span></span><br><span class="line"><span class="built_in">print</span>(x.dim())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 把x变为3x2的矩阵</span></span><br><span class="line"><span class="built_in">print</span>(x.view(<span class="number">3</span>, <span class="number">2</span>))</span><br><span class="line"><span class="comment"># 把x展平为1维向量</span></span><br><span class="line">y = x.view(-<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(y.shape)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 添加一个维度</span></span><br><span class="line">z = torch.unsqueeze(y, <span class="number">0</span>)</span><br><span class="line"><span class="comment"># 查看z的形状</span></span><br><span class="line"><span class="built_in">print</span>(z.size())</span><br><span class="line"><span class="comment"># 计算Z的元素个数</span></span><br><span class="line"><span class="built_in">print</span>(z.numel())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># item()的用法</span></span><br><span class="line">a = torch.tensor([<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(a.item())</span><br><span class="line">b = torch.tensor([<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line"><span class="built_in">print</span>(b.tolist())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">torch.Size([<span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="number">2</span></span><br><span class="line">********************</span><br><span class="line">tensor([[-<span class="number">0.4888</span>,  <span class="number">1.4943</span>],</span><br><span class="line">        [-<span class="number">1.6593</span>, -<span class="number">0.6757</span>],</span><br><span class="line">        [-<span class="number">1.9228</span>, -<span class="number">1.0863</span>]])</span><br><span class="line">torch.Size([<span class="number">6</span>])</span><br><span class="line">********************</span><br><span class="line">torch.Size([<span class="number">1</span>, <span class="number">6</span>])</span><br><span class="line"><span class="number">6</span></span><br><span class="line">********************</span><br><span class="line"><span class="number">1</span></span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br></pre></td></tr></table></figure><blockquote><p>torch.view与torch.reshpae的异同</p><p>1）reshape()可由torch.reshape()，也可由torch.Tensor.reshape()调用。但view()只可由torch.Tensor.view()来调用。</p><p>2）对于一个将要被view的Tensor，新的size必须与原来的size与stride兼容。否则，在view之前必须调用contiguous()方法。</p><p>3）返回与input数据量相同，但形状不同的Tensor。若满足view的条件，则不会copy，若不满足，则会copy。</p><p>4）如果只是重塑张量，请使用torch.reshape。如果还关注内存使用情况并希望确保两个张量共享相同的数据，请使用torch.view。</p></blockquote><h4 id="索引操作">👁索引操作</h4><p>Tensor的索引操作与Numpy类似，一般情况下索引结果与源数据共享内存。从Tensor获取元素除了可以通过索引，也可以借助一些函数，常用的选择函数如下：</p><table><thead><tr class="header"><th>函数</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>index_select(input,, dim, index)</td><td>在指定维度上选择行和列</td></tr><tr class="even"><td>nonzero(input)</td><td>获取非0元素的下标</td></tr><tr class="odd"><td>masked_select(input, mask)</td><td>使用二元值进行选择</td></tr><tr class="even"><td>gather(input, dim, index)</td><td>在指定维度上选择数据，输出形状与index(类型是LongTensor)一致</td></tr><tr class="odd"><td>scatter__(dim, index, src)</td><td>为gather的反操作，根据指定索引补充数据</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置一个随机种子</span></span><br><span class="line">torch.manual_seed(<span class="number">100</span>)</span><br><span class="line"><span class="comment"># 生成一个形状为2x3的矩阵</span></span><br><span class="line">x = torch.randn(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line"><span class="comment"># 根据索引获取第1行，所有数据</span></span><br><span class="line"><span class="built_in">print</span>(x[<span class="number">0</span>, :])</span><br><span class="line"><span class="comment"># 获取最后一列数据</span></span><br><span class="line"><span class="built_in">print</span>(x[:, -<span class="number">1</span>])</span><br><span class="line"><span class="comment"># 生成是否大于0的Byter张量</span></span><br><span class="line">mask = x &gt; <span class="number">0</span></span><br><span class="line"><span class="built_in">print</span>(mask)</span><br><span class="line"><span class="comment"># 获取大于0的值</span></span><br><span class="line"><span class="built_in">print</span>(torch.masked_select(x, mask))</span><br><span class="line"><span class="comment"># 获取非0下标,即行，列索引</span></span><br><span class="line"><span class="built_in">print</span>(torch.nonzero(mask))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 获取指定索引对应的值</span></span><br><span class="line">index1 = torch.LongTensor([[<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>]])</span><br><span class="line"><span class="built_in">print</span>(torch.gather(x, <span class="number">0</span>, index1))</span><br><span class="line">index2 = torch.LongTensor([[<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>], [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]])</span><br><span class="line">a = torch.gather(x, <span class="number">1</span>, index2)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="comment"># 把a的值返回到一个2x3的0矩阵中</span></span><br><span class="line">z = torch.zeros(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">z.scatter_(<span class="number">1</span>, index2, a)</span><br><span class="line"><span class="built_in">print</span>(z)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">tensor([[ <span class="number">0.3607</span>, -<span class="number">0.2859</span>, -<span class="number">0.3938</span>],</span><br><span class="line">        [ <span class="number">0.2429</span>, -<span class="number">1.3833</span>, -<span class="number">2.3134</span>]])</span><br><span class="line">tensor([ <span class="number">0.3607</span>, -<span class="number">0.2859</span>, -<span class="number">0.3938</span>])</span><br><span class="line">tensor([-<span class="number">0.3938</span>, -<span class="number">2.3134</span>])</span><br><span class="line">tensor([[ <span class="literal">True</span>, <span class="literal">False</span>, <span class="literal">False</span>],</span><br><span class="line">        [ <span class="literal">True</span>, <span class="literal">False</span>, <span class="literal">False</span>]])</span><br><span class="line">tensor([<span class="number">0.3607</span>, <span class="number">0.2429</span>])</span><br><span class="line">tensor([[<span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">        [<span class="number">1</span>, <span class="number">0</span>]])</span><br><span class="line">********************</span><br><span class="line">tensor([[ <span class="number">0.3607</span>, -<span class="number">1.3833</span>, -<span class="number">2.3134</span>]])</span><br><span class="line">tensor([[ <span class="number">0.3607</span>, -<span class="number">0.2859</span>, -<span class="number">0.2859</span>],</span><br><span class="line">        [-<span class="number">1.3833</span>, -<span class="number">1.3833</span>, -<span class="number">1.3833</span>]])</span><br><span class="line">tensor([[ <span class="number">0.3607</span>, -<span class="number">0.2859</span>,  <span class="number">0.0000</span>],</span><br><span class="line">        [ <span class="number">0.0000</span>, -<span class="number">1.3833</span>,  <span class="number">0.0000</span>]])</span><br></pre></td></tr></table></figure><h4 id="广播机制-1">👁广播机制</h4><p>PyTorch也支持广播机制：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">A = np.arange(<span class="number">0</span>, <span class="number">40</span>, <span class="number">10</span>).reshape(<span class="number">4</span>, <span class="number">1</span>)</span><br><span class="line">B = np.arange(<span class="number">0</span>, <span class="number">3</span>)</span><br><span class="line"><span class="comment"># 把ndarray转换为Tensor</span></span><br><span class="line">A1 = torch.from_numpy(A)  <span class="comment"># 形状为4x1</span></span><br><span class="line">B1 = torch.from_numpy(B)  <span class="comment"># 形状为3</span></span><br><span class="line"><span class="comment"># Tensor自动实现广播</span></span><br><span class="line">C = A1 + B1</span><br><span class="line"><span class="built_in">print</span>(C)</span><br><span class="line"><span class="comment"># 我们可以根据广播机制，手工进行配置</span></span><br><span class="line"><span class="comment"># 根据规则1，B1需要向A1看齐，把B变为（1,3）</span></span><br><span class="line">B2 = B1.unsqueeze(<span class="number">0</span>)  <span class="comment"># B2的形状为1x3</span></span><br><span class="line"><span class="comment"># 使用expand函数重复数组，分别的4x3的矩阵</span></span><br><span class="line">A2 = A1.expand(<span class="number">4</span>, <span class="number">3</span>)</span><br><span class="line">B3 = B2.expand(<span class="number">4</span>, <span class="number">3</span>)</span><br><span class="line"><span class="comment"># 然后进行相加,C1与C结果一致</span></span><br><span class="line">C1 = A2 + B3</span><br><span class="line"><span class="built_in">print</span>(C1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">tensor([[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>],</span><br><span class="line">        [<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>],</span><br><span class="line">        [<span class="number">20</span>, <span class="number">21</span>, <span class="number">22</span>],</span><br><span class="line">        [<span class="number">30</span>, <span class="number">31</span>, <span class="number">32</span>]], dtype=torch.int32)</span><br><span class="line">tensor([[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>],</span><br><span class="line">        [<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>],</span><br><span class="line">        [<span class="number">20</span>, <span class="number">21</span>, <span class="number">22</span>],</span><br><span class="line">        [<span class="number">30</span>, <span class="number">31</span>, <span class="number">32</span>]], dtype=torch.int32)</span><br></pre></td></tr></table></figure><h4 id="逐元素操作">👁逐元素操作</h4><p>与Numpy一样，Tensor也有逐元素操作(Element-Wise)，且操作内容相似，但使用函数可能不尽相同。大部分数学运算都属于逐元素操作，其输入与输出的形状相同。这些操作均会创建新的Tensor，如果需要就地操作，可以使用这些方法的下划线版本，例如abs_。常见的函数如下：</p><table><thead><tr class="header"><th>函数</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>abs/add</td><td>绝对值/加法</td></tr><tr class="even"><td>addcdiv(t, v, t1, t2)</td><td>t1与t2的按元素除后，乘v加t；（可能弹出"UserWarning"）</td></tr><tr class="odd"><td>addcmul(t, v, t1, t2)</td><td>t1与t2的按元素乘后，乘v加t；（可能弹出"UserWarning"）</td></tr><tr class="even"><td>ceil/floor</td><td>向上取整/向下取整</td></tr><tr class="odd"><td>clamp(t, min, max)</td><td>将张量元素限制在指定区间</td></tr><tr class="even"><td>exp/log/pow</td><td>指数/对数/幂</td></tr><tr class="odd"><td>mul(或*)/neg</td><td>逐元素乘法/取反</td></tr><tr class="even"><td>sigmoid/tanh/softmax</td><td>激活函数</td></tr><tr class="odd"><td>sign/sqrt</td><td>取输入张量元素的符号/开根号</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line">t = torch.randn(<span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line">t1 = torch.randn(<span class="number">3</span>, <span class="number">1</span>)</span><br><span class="line">t2 = torch.randn(<span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(t)</span><br><span class="line"><span class="built_in">print</span>(t1)</span><br><span class="line"><span class="built_in">print</span>(t2)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="built_in">print</span>(torch.addcdiv(t, <span class="number">0.1</span>, t1, t2))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 计算sigmoid</span></span><br><span class="line"><span class="built_in">print</span>(torch.sigmoid(t))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 将t限制在[0,1]之间</span></span><br><span class="line"><span class="built_in">print</span>(torch.clamp(t, <span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># t+2进行就地运算</span></span><br><span class="line">t.add_(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(t)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">tensor([[ <span class="number">2.4080</span>,  <span class="number">0.6269</span>, -<span class="number">0.0157</span>]])</span><br><span class="line">tensor([[-<span class="number">0.3307</span>],</span><br><span class="line">        [-<span class="number">0.6533</span>],</span><br><span class="line">        [ <span class="number">0.7257</span>]])</span><br><span class="line">tensor([[ <span class="number">0.6907</span>, -<span class="number">0.8531</span>, -<span class="number">0.8397</span>]])</span><br><span class="line">********************</span><br><span class="line">tensor([[ <span class="number">2.3601</span>,  <span class="number">0.6656</span>,  <span class="number">0.0237</span>],</span><br><span class="line">        [ <span class="number">2.3134</span>,  <span class="number">0.7035</span>,  <span class="number">0.0621</span>],</span><br><span class="line">        [ <span class="number">2.5131</span>,  <span class="number">0.5418</span>, -<span class="number">0.1021</span>]])</span><br><span class="line">********************</span><br><span class="line">tensor([[<span class="number">0.9174</span>, <span class="number">0.6518</span>, <span class="number">0.4961</span>]])</span><br><span class="line">********************</span><br><span class="line">tensor([[<span class="number">1.0000</span>, <span class="number">0.6269</span>, <span class="number">0.0000</span>]])</span><br><span class="line">********************</span><br><span class="line">tensor([[<span class="number">4.4080</span>, <span class="number">2.6269</span>, <span class="number">1.9843</span>]])</span><br></pre></td></tr></table></figure><h4 id="归并操作">👁归并操作</h4><p>归并操作，就是对输入进行归并或合计等操作，这类操作的输入输出形状一般并不相同，而且往往是输入大于输出形状。归并操作可以对整个Tensor，也可以沿着某个维度进行归并。常见的函数如下：</p><table><thead><tr class="header"><th>函数</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>cumprod(t, axis)</td><td>在指定维度对t进行累积</td></tr><tr class="even"><td>cumsum</td><td>在指定维度对t进行累加</td></tr><tr class="odd"><td>dist(a, b, p=2)</td><td>返回a, b之间的p阶范数</td></tr><tr class="even"><td>mean/median</td><td>均值/中位数</td></tr><tr class="odd"><td>std/var</td><td>标准差/方差</td></tr><tr class="even"><td>norm(t, p=2)</td><td>返回t的p阶范数</td></tr><tr class="odd"><td>prod(t)/sum(t)</td><td>返回t所有元素的积/和</td></tr></tbody></table><blockquote><p>归并操作一般涉及一个dim参数，指定沿哪个维进行归并。另一个参数是keepdim，说明输出结果中是否保留维度1，缺省情况是False，即不保留。</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成一个含6个数的向量</span></span><br><span class="line">a = torch.linspace(<span class="number">0</span>, <span class="number">10</span>, <span class="number">6</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 使用view方法，把a变为2x3矩阵</span></span><br><span class="line">a = a.view((<span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 沿y轴方向累加，即dim=0</span></span><br><span class="line">b = a.<span class="built_in">sum</span>(dim=<span class="number">0</span>)  <span class="comment"># b的形状为[3]</span></span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="built_in">print</span>(b.shape)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 沿y轴方向累加，即dim=0,并保留含1的维度</span></span><br><span class="line">b = a.<span class="built_in">sum</span>(dim=<span class="number">0</span>, keepdim=<span class="literal">True</span>)  <span class="comment"># b的形状为[1,3]</span></span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="built_in">print</span>(b.shape)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">tensor([ <span class="number">0.</span>,  <span class="number">2.</span>,  <span class="number">4.</span>,  <span class="number">6.</span>,  <span class="number">8.</span>, <span class="number">10.</span>])</span><br><span class="line">********************</span><br><span class="line">tensor([[ <span class="number">0.</span>,  <span class="number">2.</span>,  <span class="number">4.</span>],</span><br><span class="line">        [ <span class="number">6.</span>,  <span class="number">8.</span>, <span class="number">10.</span>]])</span><br><span class="line">********************</span><br><span class="line">tensor([ <span class="number">6.</span>, <span class="number">10.</span>, <span class="number">14.</span>])</span><br><span class="line">torch.Size([<span class="number">3</span>])</span><br><span class="line">********************</span><br><span class="line">tensor([[ <span class="number">6.</span>, <span class="number">10.</span>, <span class="number">14.</span>]])</span><br><span class="line">torch.Size([<span class="number">1</span>, <span class="number">3</span>])</span><br></pre></td></tr></table></figure><h4 id="比较操作">👁比较操作</h4><p>比较操作一般是进行逐元素比较，有些是按指定方向比较。常见的函数如下：</p><table><thead><tr class="header"><th>函数</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>eq</td><td>比较Tensor是否相等(<strong>逐元素比较</strong>)，支持broadcast</td></tr><tr class="even"><td>equal</td><td>比较Tensor是否有相同的shape与值(<strong>张量比较</strong>)</td></tr><tr class="odd"><td>ge/le/gt/lt</td><td>大于等于/小于等于/大于/小于</td></tr><tr class="even"><td>max/min(t, axis)</td><td>返回最值，若指定axis，则额外返回下标</td></tr><tr class="odd"><td>topk(t, k, axis)</td><td>在指定的axis维上取最高的K个值</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line">x = torch.linspace(<span class="number">0</span>, <span class="number">10</span>, <span class="number">6</span>).view(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 求所有元素的最大值</span></span><br><span class="line"><span class="built_in">print</span>(torch.<span class="built_in">max</span>(x))  <span class="comment"># 结果为10</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 求y轴方向的最大值</span></span><br><span class="line"><span class="built_in">print</span>(torch.<span class="built_in">max</span>(x, dim=<span class="number">0</span>))  <span class="comment"># 结果为[6, 8, 10]</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 求最大的2个元素</span></span><br><span class="line"><span class="comment"># 结果为[6, 8, 10],对应索引为tensor([[1, 1, 1]</span></span><br><span class="line"><span class="built_in">print</span>(torch.topk(x, <span class="number">1</span>, dim=<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">tensor([[ <span class="number">0.</span>,  <span class="number">2.</span>,  <span class="number">4.</span>],</span><br><span class="line">        [ <span class="number">6.</span>,  <span class="number">8.</span>, <span class="number">10.</span>]])</span><br><span class="line">********************</span><br><span class="line">tensor(<span class="number">10.</span>)</span><br><span class="line">********************</span><br><span class="line">torch.return_types.<span class="built_in">max</span>(</span><br><span class="line">values=tensor([ <span class="number">6.</span>,  <span class="number">8.</span>, <span class="number">10.</span>]),</span><br><span class="line">indices=tensor([<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]))</span><br><span class="line">********************</span><br><span class="line">torch.return_types.topk(</span><br><span class="line">values=tensor([[ <span class="number">6.</span>,  <span class="number">8.</span>, <span class="number">10.</span>]]),</span><br><span class="line">indices=tensor([[<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]]))</span><br></pre></td></tr></table></figure><h4 id="矩阵操作">👁矩阵操作</h4><p>机器学习和深度学习中存在大量的矩阵运算，常用的算法有两种：一种是逐元素乘法，另外一种是点积乘法。常见的函数如下：</p><table><thead><tr class="header"><th>函数</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>dot(t1, t2)</td><td>计算张量（1D）的内积或点积</td></tr><tr class="even"><td>mm(mat1, mat2)/bmm(batch1, batch2)</td><td>计算矩阵乘法/含batch的3D矩阵乘法</td></tr><tr class="odd"><td>mv(t1, v1)</td><td>计算矩阵与向量乘法</td></tr><tr class="even"><td>t</td><td>转置</td></tr><tr class="odd"><td>svd(t)</td><td>计算t的SVD分解</td></tr></tbody></table><blockquote><ul><li><p>Torch的dot与Numpy的dot有点不同，Torch中的dot是对两个为1D张量进行点积运算，Numpy中的dot无此限制。</p></li><li><p>mm是对2D的矩阵进行点积，bmm对含batch的3D进行点积运算。</p></li><li><p>转置运算会导致存储空间不连续，需要调用contiguous方法转为连续。</p></li></ul></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line">a = torch.tensor([<span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">b = torch.tensor([<span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"><span class="built_in">print</span>(torch.dot(a, b))    <span class="comment"># 运行结果为18</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">20</span>)</span><br><span class="line">x = torch.randint(<span class="number">10</span>, (<span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line">y = torch.randint(<span class="number">6</span>, (<span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line"><span class="built_in">print</span>(torch.mm(x, y))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">20</span>)</span><br><span class="line">x = torch.randint(<span class="number">10</span>, (<span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line">y = torch.randint(<span class="number">6</span>, (<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line"><span class="built_in">print</span>(torch.bmm(x, y))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">tensor(<span class="number">18</span>)</span><br><span class="line">********************</span><br><span class="line">tensor([[<span class="number">47</span>, <span class="number">20</span>, <span class="number">20</span>, <span class="number">39</span>],</span><br><span class="line">        [<span class="number">55</span>, <span class="number">22</span>, <span class="number">35</span>, <span class="number">27</span>]])</span><br><span class="line">********************</span><br><span class="line">tensor([[[ <span class="number">57</span>,  <span class="number">45</span>,  <span class="number">40</span>,  <span class="number">60</span>],</span><br><span class="line">         [ <span class="number">47</span>,  <span class="number">10</span>,  <span class="number">24</span>,  <span class="number">43</span>]],</span><br><span class="line"></span><br><span class="line">        [[ <span class="number">54</span>, <span class="number">106</span>,  <span class="number">36</span>, <span class="number">104</span>],</span><br><span class="line">         [ <span class="number">34</span>,  <span class="number">42</span>,   <span class="number">4</span>,  <span class="number">50</span>]]])</span><br></pre></td></tr></table></figure><h4 id="pytorch与numpy比较">👁PyTorch与Numpy比较</h4><p>PyTorch与Numpy有很多类似的地方，并且有很多相同的操作函数名称，或虽然函数名称不同但含义相同；当然也有一些虽然函数名称相同，但含义不尽相同。</p><table><colgroup><col style="width: 12%" /><col style="width: 40%" /><col style="width: 47%" /></colgroup><thead><tr class="header"><th>操作类别</th><th>Numpy</th><th>PyTorch</th></tr></thead><tbody><tr class="odd"><td>数据类型</td><td>np.ndarray</td><td>torch.Tensor</td></tr><tr class="even"><td></td><td>np.float32</td><td>torch.float32; torch.float</td></tr><tr class="odd"><td></td><td>np.float64</td><td>torch.float64; torch.double</td></tr><tr class="even"><td></td><td>np.int64</td><td>torch.int64; torch.long</td></tr><tr class="odd"><td>已有数据构建</td><td>np.array([1.3, 1.4], dtype=np.float32)</td><td>torch.tensor([1.3, 1.4], dtype=torch.float32)</td></tr><tr class="even"><td></td><td>x.copy()</td><td>x.clone()</td></tr><tr class="odd"><td></td><td>np.concatenate</td><td>torch.cat</td></tr><tr class="even"><td>线性代数</td><td>np.dot</td><td>torch.mm</td></tr><tr class="odd"><td>属性</td><td>x.ndim</td><td>x.dim()</td></tr><tr class="even"><td></td><td>x.size</td><td>x.nelement()</td></tr><tr class="odd"><td>形状操作</td><td>x.reshape</td><td>x.reshape; x.view</td></tr><tr class="even"><td></td><td>x.flatten</td><td>x.view(-1)</td></tr><tr class="odd"><td>类型转换</td><td>np.floor(x)</td><td>torch.floor(x); x.floor()</td></tr><tr class="even"><td>比较</td><td>np.less</td><td>x.lt</td></tr><tr class="odd"><td></td><td>np.less_equal/np.greater</td><td>x.le/x.gt</td></tr><tr class="even"><td></td><td>np.greater_equal/np.equal/np.not_equal</td><td>x.ge/x.eq/x.ne</td></tr><tr class="odd"><td>随机种子</td><td>np.random.seed</td><td>torch.manual.seed</td></tr></tbody></table><h3 id="tensor与autograd">👀Tensor与Autograd</h3><blockquote><p>神经网络一个重要内容就是进行参数学习，而参数学习离不开求导，那么PyTorch是如何进行求导的呢？</p></blockquote><p>现在大部分深度学习架构都有自动求导的功能，PyTorch也不例外，torch.autograd包就是用来自动求导的。Autograd包为张量上所有的操作提供了自动求导功能，而torch.Tensor和torch.Function为Autograd的两个核心类，它们相互连接并生成一个有向非循环图。为实现对Tensor自动求导，需考虑如下事项：</p><ul><li><p>创建叶子节点(Leaf Node)的Tensor，使用requires_grad参数指定是否记录对其的操作，以便之后利用backward()方法进行梯度求解。requires_grad参数的缺省值为False，如果要对其求导需设置为True，然后与之有依赖关系的节点会自动变为True。</p></li><li><p>可利用requires_grad_()方法修改Tensor的requires_grad属性。可以调用.detach()或with torch.no_grad()，将不再计算张量的梯度，跟踪张量的历史记录。这点在评估模型、测试模型阶段中常常用到。</p></li><li><p>通过运算创建的Tensor（即非叶子节点），会自动被赋予grad_fn属性，该属性表示梯度函数。叶子节点的grad_fn为None。</p></li><li><p>最后得到的Tensor执行backward()函数，此时自动计算各变量的梯度，并将累加结果保存到grad属性中。计算完成后，非叶子节点的梯度自动释放。</p></li><li><p>backward()函数接收参数，该参数应和调用backward()函数的Tensor的维度相同，或者是可broadcast的维度。如果求导的Tensor为标量（即一个数字），则backward中的参数可省略。</p></li><li><p>反向传播的中间缓存会被清空，如果需进行多次反向传播，需指定backward中的参数retain_graph=True。多次反向传播时，梯度是累加的。</p></li><li><p>非叶子节点的梯度backward调用后即被清空。</p></li><li><p>可以通过用torch.no_grad()包裹代码块的形式来阻止autograd去跟踪那些标记为.requesgrad=True的张量的历史记录。这步在测试阶段经常使用。</p></li></ul><blockquote><p><strong>标量反向传播</strong>：当目标张量为标量时，可以调用backward()方法且无须传入参数。目标张量一般都是标量，如我们经常使用的损失值Loss，一般都是一个标量。</p><p><strong>非标量反向传播</strong>：PyTorch规定，不让张量(Tensor)对张量求导，只允许标量对张量求导。因此，如果目标张量对一个非标量调用backward()，则需要传入gradient参数，该参数也是张量，而且需要与调用backward()的张量形状相同。传入这个参数就是为了把张量对张量的求导转换为标量对张量的求导。</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 标量反向传播</span></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义输入张量x</span></span><br><span class="line">x = torch.Tensor([<span class="number">2</span>])</span><br><span class="line"><span class="comment"># 初始化权重参数W,偏移量b、并设置require_grad属性为True，为自动求导</span></span><br><span class="line">w = torch.randn(<span class="number">1</span>, requires_grad=<span class="literal">True</span>)</span><br><span class="line">b = torch.randn(<span class="number">1</span>, requires_grad=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># 实现前向传播</span></span><br><span class="line">y = torch.mul(w, x)  <span class="comment"># 等价于w*x</span></span><br><span class="line">z = torch.add(y, b)  <span class="comment"># 等价于y+b</span></span><br><span class="line"><span class="comment"># 查看x,w，b页子节点的requite_grad属性</span></span><br><span class="line"><span class="comment"># x,w,b的require_grad属性分别为：False,True,True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;x, w, b的require_grad属性分别为：&#123;&#125;,&#123;&#125;,&#123;&#125;&quot;</span>.<span class="built_in">format</span>(x.requires_grad, w.requires_grad, b.requires_grad))</span><br><span class="line"><span class="comment"># 查看非叶子节点的requres_grad属性</span></span><br><span class="line"><span class="comment"># 因与w，b有依赖关系，故y，z的requires_grad属性也是：True,True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;y, z的requires_grad属性分别为：&#123;&#125;,&#123;&#125;&quot;</span>.<span class="built_in">format</span>(y.requires_grad, z.requires_grad))</span><br><span class="line"><span class="comment"># 查看各节点是否为叶子节点</span></span><br><span class="line"><span class="comment"># x，w，b，y，z的是否为叶子节点：True,True,True,False,False</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;x, w, b, y, z的是否为叶子节点：&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;&quot;</span>.<span class="built_in">format</span>(x.is_leaf, w.is_leaf, b.is_leaf, y.is_leaf, z.is_leaf))</span><br><span class="line"><span class="comment"># 查看叶子节点的grad_fn属性</span></span><br><span class="line"><span class="comment"># 因x，w，b为用户创建的，为通过其他张量计算得到，故x，w，b的grad_fn属性：None,None,None</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;x, w, b的grad_fn属性：&#123;&#125;,&#123;&#125;,&#123;&#125;&quot;</span>.<span class="built_in">format</span>(x.grad_fn, w.grad_fn, b.grad_fn))</span><br><span class="line"><span class="comment"># 查看非叶子节点的grad_fn属性</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;y, z的是否为叶子节点：&#123;&#125;,&#123;&#125;&quot;</span>.<span class="built_in">format</span>(y.grad_fn, z.grad_fn))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">x, w, b的require_grad属性分别为：<span class="literal">False</span>,<span class="literal">True</span>,<span class="literal">True</span></span><br><span class="line">y, z的requires_grad属性分别为：<span class="literal">True</span>,<span class="literal">True</span></span><br><span class="line">x, w, b, y, z的是否为叶子节点：<span class="literal">True</span>,<span class="literal">True</span>,<span class="literal">True</span>,<span class="literal">False</span>,<span class="literal">False</span></span><br><span class="line">x, w, b的grad_fn属性：<span class="literal">None</span>,<span class="literal">None</span>,<span class="literal">None</span></span><br><span class="line">y, z的是否为叶子节点：&lt;MulBackward0 <span class="built_in">object</span> at <span class="number">0x000001DCB56E94C0</span>&gt;,&lt;AddBackward0 <span class="built_in">object</span> at <span class="number">0x000001DCB56E92B0</span>&gt;</span><br></pre></td></tr></table></figure><h2 id="pytorch神经网络工具箱">⛄PyTorch神经网络工具箱</h2><p>PyTorch的神经网络工具箱，可以极大简化我们构建模型的任务，设计一个神经网络就像搭积木一样。神经网络核心组件主要包括：</p><ul><li><p>层：神经网络的基本结构，将输入张量转换为输出张量。</p></li><li><p>模型：层构成的网络。</p></li><li><p>损失函数：参数学习的目标函数，通过最小化损失函数来学习各种参数。</p></li><li><p>优化器：如何使损失函数最小，这就涉及优化器。</p></li></ul><p>多个层链接在一起构成一个模型或网络，输入数据通过这个模型转换为预测值，然后损失函数把预测值与真实值进行比较，得到损失值（损失值可以是距离、概率值等），该损失值用于衡量预测值与目标结果的匹配或相似程度，优化器利用损失值更新权重参数，从而使损失值越来越小。这是一个循环过程，当损失值达到一个阀值或循环次数到达指定次数，循环结束。PyTorch构建神经网络使用的主要工具（或类）及相互关系如下图所示：</p><p><a href="https://imgse.com/i/pkJs2pq"><img src="https://s21.ax1x.com/2024/06/04/pkJs2pq.jpg" alt="pkJs2pq.jpg" /></a></p><p>构建网络层可以基于Module类或函数(nn.functional)。nn中的大多数层(Layer)在functional中都有与之对应的函数。nn.functional中函数与nn.Module中的Layer的主要区别是后者继承Module类，会自动提取可学习的参数。而nn.functional更像是纯函数。两者功能相同，且性能也没有很大区别，那么如何选择呢？像卷积层、全连接层、Dropout层等因含有可学习参数，一般使用nn.Module，而激活函数、池化层不含可学习参数，可以使用nn.functional中对应的函数。</p><blockquote><ul><li><strong>构建网络</strong>：使用sequential构建网络，Sequential()函数的功能是将网络的层组合到一起。</li><li><strong>前向传播</strong>：①forward()函数的任务是把输入层、网络层、输出层链接起来，实现信息的前向传导，该函数的参数一般为输入数据，返回值为输出数据。②在forward函数中，有些层来自nn.Module，也可以使用nn.functional定义。来自nn.Module的需要实例化，而使用nn.functional定义的可以直接使用。</li><li><strong>反向传播</strong>：①手工实现反向传播，比较费时；②PyTorch提供了自动反向传播的功能，直接让损失函数调用backward()即可。</li><li><strong>训练模型</strong>：①训练模型时需要使模型处于训练模式，即调用model.train()，会把所有的module设置为训练模式。如果是测试或验证阶段，需要使模型处于验证阶段，即调用model.eval()，会把所有的training属性设置为False。②缺省情况下梯度是累加的，需要调用optimizer.zero_grad()把梯度初始化或清零。③训练过程中，正向传播生成网络的输出，计算输出和实际值之间的损失值，调用loss.backward()自动生成梯度，然后使用optimizer.step()执行优化器，把梯度传播回每个网络。④如果希望用GPU训练，需要把模型、训练数据、测试数据发送到GPU上，即调用.to(device)。如果需要使用多GPU进行处理，可使模型或相关数据引用nn.DataParallel。</li></ul></blockquote><h3 id="nn.module">👀nn.Module</h3><p>nn.Module是nn的一个核心数据结构，它可以是神经网络的某个层(Layer)，也可以是包含多层的神经网络。在实际使用中，最常见的做法是继承nn.Module，生成自己的网络/层。nn中已实现了绝大多数层，包括全连接层、损失层、激活层、卷积层、循环层等，这些层都是nn.Module的子类，能够自动检测到自己的Parameter，并将其作为学习参数，且针对GPU运行进行了cuDNN优化。</p><h3 id="nn.functional">👀nn.functional</h3><p>nn中的层，一类是继承了nn.Module，其命名一般为nn.Xxx(第一个是大写)，如nn.Linear、nn.Conv2d、nn.CrossEntropyLoss等。另一类是nn.functional中的函数，其名称一般为nn.funtional.xxx，如nn.funtional.linear、nn.funtional.conv2d、nn.funtional.cross_entropy等。从功能来说两者相当，基于nn.Moudle能实现的层，使用nn.funtional也可实现，反之亦然，而且性能方面两者也没有太大差异。不过在具体使用时，两者还是有区别，主要区别如下：</p><ul><li><p>nn.Xxx继承于nn.Module，nn.Xxx需要先实例化并传入参数，然后以函数调用的方式调用实例化的对象并传入输入数据。它能够很好地与nn.Sequential结合使用，而nn.functional.xxx无法与nn.Sequential结合使用。</p></li><li><p>nn.Xxx不需要自己定义和管理weight、bias参数；而nn.functional.xxx需要自己定义weight、bias参数，每次调用的时候都需要手动传入weight、bias等参数，不利于代码复用。</p></li><li><p>Dropout操作在训练和测试阶段是有区别的，使用nn.Xxx方式定义Dropout，在调用model.eval()之后，自动实现状态的转换，而使用nn.functional.xxx却无此功能。</p></li></ul><p>总的来说，两种功能都是相同的，但PyTorch官方推荐：具有学习参数的(例如Conv2d、Linear、Batch_norm等)采用nn.Xxx方式。没有学习参数的(例如maxpool、loss func、activation func等)根据个人选择使用nn.Xxx或者nn.functional.xxx方式。</p><h3 id="优化器">👀优化器</h3><p><strong>（1）优化器一般步骤</strong></p><p>PyTorch常用的优化方法都封装在torch.optim里面，其设计很灵活，可以扩展为自定义的优化方法。所有的优化方法都是继承了基类optim.Optimizer，并实现了自己的优化步骤。最常用的优化算法就是梯度下降法及其各种变种，这类优化算法通过使用参数的梯度值更新参数。使用优化器的一般步骤为：</p><ul><li><p><strong>建立优化器实例</strong>：导入optim模块，实例化SGD（以随机梯度下降法为例）优化器。</p></li><li><p><strong>向前传播</strong>：把输入数据传入神经网络Net实例化对象model中，自动执行forward函数，得到out输出值（out = model(img)），然后用out与标记label计算损失值loss。loss = criterion(out, label)</p></li><li><p><strong>清空梯度</strong>：缺省情况梯度是累加的，在梯度反向传播前，先需把梯度清零。optimizer.zero_grad()</p></li><li><p><strong>反向传播</strong>：基于损失值，把梯度进行反向传播。loss.backward()</p></li><li><p><strong>更新参数</strong>：基于当前梯度（存储在参数的.grad属性中）更新参数。optimizer.step()</p></li></ul><blockquote><p>其中向前传播、清空梯度、反向传播、更新参数是在训练模型的for循环中。</p></blockquote><p>动态修改学习率参数：可以通过修改参数optimizer.params_groups或新建optimizer。新建optimizer比较简单，optimizer十分轻量级，所以开销很小。但是新的优化器会初始化动量等状态信息，这对于使用动量的优化器（momentum参数的sgd）可能会造成收敛中的震荡。</p><blockquote><p>optimizer.param_groups：长度1的list；</p><p>optimizer.param_groups[0]：长度为6的字典，包括权重参数、lr、momentum等参数。</p></blockquote><p><strong>（2）优化器种类</strong></p><p>优化器的方法主要可以分为两大类，一大类方法是SGD及其改进（加Momentum），另外一大类是逐参数适应学习率方法，包括AdaGrad、RMSProp、Adam等。<a href="https://blog.csdn.net/qq_36589234/article/details/89330342">参考链接①</a>、<a href="https://blog.csdn.net/m0_62965652/article/details/136969277">参考链接②</a>、<a href="https://blog.csdn.net/qq_42109740/article/details/105401197">参考链接③</a></p><ul><li><p>SGD(Stochastic Gradient Descent, 随机梯度下降)</p></li><li><p>SGD+Momentum动量法</p></li><li><p>NAG(Nesterov Accelerated Gradient)</p></li><li><p>Adagrad自适应学习率优化算法</p></li><li><p>RMSProp自适应学习率优化算法</p></li><li><p>Adam自适应学习率优化算法，本质上是将动量(Momentum)和RMSprop两种思想结合到一种算法中</p></li></ul><h2 id="pytorch数据处理工具箱">⛄PyTorch数据处理工具箱</h2><h3 id="utils.data和torchvision">👀utils.data和Torchvision</h3><p>数据下载和预处理是机器学习、深度学习实际项目中耗时又重要的任务，尤其是数据预处理，关系到数据质量和模型性能，要占据项目的大部分时间。PyTorch为此提供了专门的数据下载、数据处理包，使用这些包可极大地提高开发效率及数据质量。PyTorch涉及数据处理（数据装载、数据预处理、数据增强等）的主要工具包及相互关系如下图所示。</p><p><a href="https://imgse.com/i/pkt5JlF"><img src="https://s21.ax1x.com/2024/06/08/pkt5JlF.jpg" alt="pkt5JlF.jpg" /></a></p><p>torch.utils.data工具包，它包括以下4个类。</p><ul><li><p>Dataset：是一个抽象类，其他数据集需要继承这个类，并且覆写其中的两个方法(getitem、len)。</p></li><li><p>DataLoader：定义一个新的迭代器，实现批量(batch)读取，打乱数据(shuffle)并提供并行加速等功能。</p></li><li><p>random_split：把数据集随机拆分为给定长度的非重叠的新数据集。</p></li><li><p>*sampler：多种采样函数。</p></li></ul><p>Torchvision是PyTorch的一个视觉处理工具包，独立于PyTorch。它包括4个类，主要功能如下(<a href="https://blog.csdn.net/xw555666/article/details/136068651">参考博客①</a>)：</p><ul><li><p>datasets：提供常用的数据集加载，设计上都是继承自torch.utils.data.Dataset，主要包括MMIST、CIFAR10/100、Fashion-MNIST、ImageNet、STL10和COCO等。</p></li><li><p>models：提供深度学习中各种经典的网络结构以及训练好的模型（如果选择pretrained=True），包括AlexNet、VGG系列、ResNet系列、Inception系列等。</p></li><li><p>transforms：常用的数据预处理操作，主要包括对Tensor及PIL Image对象的操作。</p></li><li><p>utils：含两个函数，一个是make_grid，它能将多张图片拼接在一个网格中；另一个是save_img，它能将Tensor保存成图片。</p></li></ul><h3 id="tensorboardx可视化工具">👀tensorboardX可视化工具</h3><p>Tensorboard是Google TensorFlow的可视化工具，它可以记录训练数据、评估数据、网络结构、图像等，并且可以在web上展示，对于观察神经网络训练的过程非常有帮助。PyTorch可以采用tensorboard_logger、visdom等可视化工具，但这些方法比较复杂或不够友好。为解决该问题，人们推出了可用于PyTorch可视化的新的更强大的工具——tensorboardX。tensorboardX功能很强大，支持scalar、image、figure、histogram、audio、text、graph、onnx_graph、embedding、pr_curve and videosummaries等可视化方式。<a href="https://blog.csdn.net/bigbennyguo/article/details/87956434">参考博客①</a>、<a href="https://blog.csdn.net/HowieXue/article/details/105412155">参考博客②</a></p><p>（1）导入tensorboardX，实例化SummaryWriter类，指明记录日志路径等信息</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tensorboardX <span class="keyword">import</span> SummaryWriter</span><br><span class="line"><span class="comment"># 实例化SummaryWriter，并指明日志存放路径。在当前目录没有logs目录将自动创建。</span></span><br><span class="line">writer = SummaryWriter(log_dir=<span class="string">&#x27;logs&#x27;</span>)</span><br><span class="line"><span class="comment"># 调用实例</span></span><br><span class="line">writer.add_xxx()</span><br><span class="line"><span class="comment"># 关闭writer</span></span><br><span class="line">writer.close()</span><br></pre></td></tr></table></figure><p>（2）调用相应的API接口</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">writer.add_xxx(tag-name, <span class="built_in">object</span>, iteration-number)</span><br><span class="line"><span class="comment"># 即add_xxx(标签，记录的对象，迭代次数)</span></span><br></pre></td></tr></table></figure><p>（3）启动tensorboard服务</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tensorboard --logdir=logs --port <span class="number">6006</span></span><br><span class="line"><span class="comment"># 如果是Windows环境，要注意路径解析，如</span></span><br><span class="line"><span class="comment"># tensorboard --logdir=r&#x27;D:\myboard\test\logs&#x27; --port 6006</span></span><br></pre></td></tr></table></figure><p>（4）web展示</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">http://服务器IP或名称:<span class="number">6006</span> <span class="comment"># 如果是本机，服务器名称可以使用localhost</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PyTorch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>辐射传输基础理论详解与LST反演方法</title>
      <link href="/2024/01/20/RS-LST-Method/"/>
      <url>/2024/01/20/RS-LST-Method/</url>
      
        <content type="html"><![CDATA[<h2 id="前言">⛄前言</h2><p>地表温度<code>LST</code>(<code>Land Surface Temperature</code>)是区域和全球尺度上陆地表层系统过程的关键参数，它综合了地表与大气的相互作用以及大气和陆地之间能量交换的结果。地表温度作为众多基础学科和应用领域的一个关键参数，能够提供地表能量平衡状态的时空变化信息，在农业干旱、农作物估产、火灾监测、数值预报、全球环流模式以及区域气候模式等研究领域得到广泛的应用。精确的地表温度不仅有助于评估地表能量与水文平衡、热惯量和土壤湿度，而且有助于获取全球表面温度及掌握其长期的变化。</p><p>长久以来，人们普遍采用地面站点观测的方式获得地表温度。然而，受太阳辐射、地形地貌、地表覆盖、大气环流等因素的影响，地表温度的动态变化性强，因此地面站点观测获取的地表温度区域代表性有限，无法精确表征区域或全球尺度地表温度的时空分布特征，严重制约了地球科学领域某些学科的深入研究与发展。要获取区域和全球尺度上地表温度的时空分布，常规的地面定点观测难以实现，而卫星遥感技术是唯一可能的手段。</p><p>随着科学技术的进步，新兴的热红外遥感（ <code>Thermal Infrared remote sensing</code> ）技术为高时效、高精度获取区域或全球尺度的地表温度带来了曙光。热红外遥感是一种通过热红外谱段对检测物体发射的热辐射进行探测的技术，它利用物体吸收和发射辐射的物理特性，通过测量目标物体发射的红外辐射的强度、分布和光谱等参数，来了解目标物体的热学特性、表面温度分布等信息。热红外遥感对研究全球能量变换和可持续发展具有重要的意义，在地表温度反演、城市热岛效应、林火监测、旱灾监测、探矿、探地热，岩溶区探水等领域都有很广泛的研究。</p><h2 id="辐射物理量基本概念">⛄辐射物理量基本概念</h2><blockquote><p><strong>[1]阎广建,谢天,穆西晗.辐射物理量概念介绍[J].遥感学报,2023,27(10):2445-2448.</strong></p></blockquote><p>定量遥感研究的前提是量化遥感传感器接收的电磁波信息。遥感传感器通过获取从目标物反射和辐射的电磁波能量来得到所需的信息，所以遥感探测通常意义上指的是对电磁波辐射能量的测定。物理学把某个物理量在空间中的分布称为场，如温度场、引力场、电场、磁场等。电磁波辐射能量在空间中的分布被称为辐射场。几乎所有物体都可以作为产生辐射场的辐射源，因为<strong>任何温度大于绝对零度的物体，都以电磁波的形式向周围辐射能量</strong>，并且<strong>几乎所有物体都可以反射外界辐射</strong>。辐射源可以被简单地划分为点源和面源。</p><ul><li><p>点源是一种理想的情况，辐射源的大小可以忽略不计，近似为一个点，点源可以向四面八方发射能量；当辐射源的大小不可忽略不计，不能被近似为一个点时，需要当作面源。</p></li><li><p>整个面源的辐射可以基于微面元的积分得到，每个微面元往往被近似为平面。一个无限大平面可将三维空间分割为两部分，每个部分都是一个半球空间，辐射可以从微面元出射到半球空间，也可以从半球空间入射被微面元所接收。</p></li></ul><p>遥感传感器直接接收的是电磁波的辐射能量，然而这些辐射能量产生的时间长短、空间范围、方向和角度范围并不确定。因此，需要引出一系列辐射物理量，对物体发射或反射电磁波能量的能力统一描述：</p><ol type="1"><li><p>辐射能量<span class="math inline">\(Q\)</span>（<code>Radiant Energy</code>）：电磁波所传输的能量称为辐射能量，国际单位制 （以下简称<code>SI</code>）单位为焦耳 （<span class="math inline">\(J\)</span>）。辐射能量是最基础的辐射物理量，不会随着时间、空间、角度等物理量的积分而改变量纲，也因此在不加限定的情况下单独一个辐射能量数值不能表征电磁波辐射的强弱，于是基于辐射能量进一步定义以下物理量。</p></li><li><p>辐射通量<span class="math inline">\(\Phi\)</span>（<code>Radiant Flux</code>）：单位时间内通过任一平面或曲面的辐射能量，也称为辐射功率，国际单位制的基本单位为瓦特 （<span class="math inline">\(W\)</span>），即焦耳/秒（<span class="math inline">\(J/s\)</span>）。辐射通量定义式为： <span class="math display">\[\Phi=\frac{ {\rm d}Q}{ {\rm d}t}\]</span></p></li><li><p>辐射通量密度 （<code>Radiant Flux Densit</code>y）：单位时间内通过单位平面面积的辐射能量，国际单位制的基本单位为瓦特每平方米 （<span class="math inline">\(W/m^2\)</span>）。根据辐射的方向又可以分成<strong>辐照度</strong>和<strong>辐射出射度</strong>，分别表示<strong>单位面积接收</strong>或<strong>向外</strong>辐射的辐射通量。辐照度和辐射出射度描述的电磁波传输方向相反。此外，不论是平面还是曲面，它们都被划分为无限个微面元，辐照度和辐射出射度均是针对微面元而定义的。要得到整个表面的辐射通量，可以对辐射通量密度在整个表面求积分得到。辐照度和辐射出射度都可以表示为： <span class="math display">\[E,M=\frac{ {\rm d}\Phi}{ {\rm d}A}\]</span></p><ul><li>辐照度<span class="math inline">\(E\)</span>（<code>Irradiance</code>）：物体表面接收的辐射通量密度。</li><li>辐射出射度 <span class="math inline">\(M\)</span> （<code>Radiant Exitance</code>）：面辐射源表面发出的辐射通量密度。</li></ul></li><li><p>辐射强度<span class="math inline">\(I\)</span>（<code>Radiant Intensity</code>）：点源在某一给定方向上单位立体角内发出的辐射通量。国际单位制的基本单位为瓦特每球面度 （<span class="math inline">\(W/sr\)</span>）。辐射强度定义式为：<span class="math inline">\(I={\rm d}\Phi/{\rm d}\Omega\)</span>。式中立体角常用希腊字母<span class="math inline">\(\Omega\)</span>表示。 <span class="math display">\[I=\frac{ {\rm d}\Phi}{ {\rm d}\Omega}\]</span></p><blockquote><p>（1）某立体角的大小可以被简单地定义为该立体角投影到一个以其顶点为球心的球面时，投影的球面面积A与球半径r平方的比值：<span class="math inline">\(\Omega=A/r^2\)</span></p><p>（2）立体角的单位用球面度 （<span class="math inline">\(sr\)</span>） 表示，假设一个球半径为<span class="math inline">\(r\)</span>，其表面积为 <span class="math inline">\(4\pi{r^2}\)</span>，所以整个球面对球心张成的立体角是<span class="math inline">\(4{\pi}\)</span>，而半球空间的立体角为<span class="math inline">\(2{\pi}\)</span>。</p><p>（3）对于一个以<span class="math inline">\(\theta\)</span>为天顶角、<span class="math inline">\(\varphi\)</span>为方位角的立体角微元<span class="math inline">\({\rm d}\Omega\)</span>，它在以其顶点为球心的球面上截得的面积可以近似用矩形的面积求得：<span class="math inline">\({\rm d}\Omega={\rm d}A/r^2=r{\rm d}\theta·r\sin{\theta}{\rm d}\varphi/r^2=\sin{\theta}{\rm d}{\theta}{\rm d}{\varphi}\)</span></p><p>（4）对于面辐射源，定义辐射亮度来描述其在<strong>不同方向的辐射能力</strong>。</p></blockquote></li><li><p>辐射亮度<span class="math inline">\(L\)</span> （<code>Radiance</code>）：简称辐亮度，描述的是面辐射源在某一方向单位立体角单位时间内，垂直于辐射方向单位面积上的辐射能量。国际单位制的基本单位是瓦特每球面度每平方米 （<span class="math inline">\(W·sr^{-1}·m^{-2}\)</span>）。辐亮度定义式为： <span class="math display">\[L=\frac{ {\rm d^2}\Phi}{ {\rm d}\Omega{\rm d}A\cos{\theta} }=\frac{ {\rm d}I}{ {\rm d}A\cos{\theta} }=\frac{ {\rm d}M} { {\rm d}\Omega\cos{\theta} }\]</span> 式中，<span class="math inline">\(\theta\)</span>是辐射方向与辐射面源法线夹角。对于无限大的各向同性面辐射源，辐亮度不随观测角度的变化而变化。</p></li></ol><p>遥感传感器一般不在全部光谱范围内收集能量，而是在特定的波段内接收能量。为描述特定波段内的辐射物理量，在上述辐射物理量的名称前均可加上“光谱”两字，表示单位波长宽度的辐射物理量，对应的表达式需在原有定义式基础上再对波长求导。例如，光谱辐射亮度 （<code>Spectral Radiance</code>）表示的是单位波长宽度的辐射亮度，单位是瓦特每球面度每平方米每微米 （<span class="math inline">\(W·sr^{-1}·m^{-2}·μm^{-1}\)</span>）。</p><p>一般来说，面辐射源向不同方向的辐射能力是不同的，也就是说，观察者在不同方向上测量的辐亮度值不同。特别地，各角度观察到的辐亮度相同的辐射源称为朗伯体 （朗伯源），辐亮度大小和角度有关的辐射源称为非朗伯体。对于朗伯体，根据辐亮度定义，可以计算它在<span class="math inline">\(2{\pi}\)</span>空间内的辐射出射度：<span class="math inline">\(M=\pi{L}\)</span>，可见，朗伯体在<span class="math inline">\(2{\pi}\)</span>空间内的辐射出射度在数值上是辐亮度的<span class="math inline">\({\pi}\)</span>倍。</p><p>辐射能量和辐射通量是相对基础的辐射物理量，在它们的基础上派生的辐照度和辐射出射度，是地表辐射能量平衡计算等应用中常用的关键参量。当被观测表面的尺寸小于像元大小时，适合用辐射强度表征所接收的辐射信号，比如在天文领域。而遥感往往观测的是远大于像元大小的物体表面，适用辐亮度的概念。辐亮度限定了<strong>单位时间</strong>、<strong>单位投影面积</strong>、<strong>单位立体角</strong>的辐射，便于不同传感器接收电磁辐射信号的比较，是辐射传输理论中的常用物理量。实际应用中，传感器先将接收到的电磁波转换为电信号数值，经过辐射定标后可以直接转为辐亮度。</p><blockquote><p><strong>光谱响应曲线</strong>：光谱响应函数是表示传感器性能的一个关键参数，描述了传感器对不同波长的光的响应程度，它反应了传感器的线性度、灵敏度和选择性等特征，在创建和评估传感器的功效时，必须考虑到光谱响应函数。光谱响应函数文件通常由两列组成，一列代表波长或波数，另一列代表波长对应的响应函数值。</p><p><strong>热力学温度</strong>：热力学温度是热力学当中的基本参数之一，又被称为动力学温度，它是温度的一个特殊定义，由热力学第二定律得到，单位是开尔文(<span class="math inline">\(K\)</span>)。热力学温度描述了物体的热状态，表现形式为物质内部分子间能量的传递。热力学温度是世界七大基本物理量之一，热力学温度的最低温度是绝对零度(0<span class="math inline">\(K\)</span>)，即：零点。</p><p><strong>亮度温度</strong>：亮度温度是指黑体辐射的温度，物体的亮度温度等于辐射温度相同的黑体的物理温度。简单来说，亮度温度是一个普通的温度概念，具有温度的量纲，但不具有温度的物理意义。在一定条件下，亮度温度与物体的实际温度有一定的关系，但并不总是一致的，通常情况下，亮度温度与实际温度的偏差来自于表面辐射率和大气的影响。</p></blockquote><h2 id="黑体辐射的基本规律">⛄黑体辐射的基本规律</h2><h3 id="基尔霍夫定律1859年">👀基尔霍夫定律（1859年）</h3><p>基尔霍夫定律表明：任何物体在任意给定的温度（<span class="math inline">\(T\)</span>）和波长（<span class="math inline">\(\lambda\)</span>）条件下，其辐射通量密度<span class="math inline">\(M(T,\lambda)\)</span>和吸收系数<span class="math inline">\(\alpha(T,\lambda)\)</span>之比是一个常数，等于同一温度波长下，绝对黑体的辐射通量密度<span class="math inline">\(M_b(T,\lambda)\)</span>： <span class="math display">\[M_b(T,\lambda)=\frac{M(T,\lambda)}{\alpha(T,\lambda)}\]</span> 因此，物体的吸收率越大，辐射能力就越强，即黑体的辐射能量最大。 发射率是物体辐射能力的度量，其定义为：在同一给定温度（<span class="math inline">\(T\)</span>）和波长（<span class="math inline">\(\lambda\)</span>）下，物体的辐射能力与黑体辐射能力之比。由定义可知，发射率为值在0~1之间无量纲的量，物体的发射率与物体的组成成分、表面状态、物理性质等因素有关。根据定义，发射率的表达式如下： <span class="math display">\[\varepsilon(T,\lambda)=\frac{M(T,\lambda)}{M_b(T,\lambda)}\]</span> 故有：<span class="math inline">\(\varepsilon(T,\lambda)=\alpha(T,\lambda)\)</span>，即<strong>物体的吸收率等于它的发射率</strong>。</p><h3 id="斯特藩-玻尔兹曼定律1879年和1884年">👀斯特藩-玻尔兹曼定律（1879年和1884年）</h3><p>斯特藩定律是现代热力学领域的基本定律，描述了物体的温度与辐射之间的关系。具体来说，当物体的温度不为零时，它会发出电磁辐射，其能量密度与温度有关。1879年物理学家约瑟夫斯特藩经过多年整理各种实验的结果得出了这个定律。1884 年，物理学家、路德维希·玻尔兹曼根据热力学理论，实验性地假设用光能（电磁辐射）代替气体作为电热机的工作介质，最终成功地推导出与斯特藩归纳相同的结论。 斯特藩定律的内容为：一个黑体在单位时间内的黑体<strong>辐射出射度</strong><span class="math inline">\(j^*\)</span>与其本身具有的热力学温度<span class="math inline">\(T\)</span>的四次方呈正比关系，即： <span class="math display">\[j^*=\varepsilon\sigma{T^4}\]</span> 式中，物体的辐射出射度<span class="math inline">\(j^*\)</span>的单位为<span class="math inline">\(W/m^2\)</span>，国际单位制标准单位为：<span class="math inline">\(J/(s·m^2)\)</span>；<span class="math inline">\(T\)</span>为黑体的热力学温度，单位是开尔文（<span class="math inline">\(K\)</span>)；<span class="math inline">\(\varepsilon\)</span>为物体的发射率，黑体的发射率为1；系数<span class="math inline">\(\sigma\)</span>为斯特藩常量，单位为：<span class="math inline">\(W/(m^2·K^4)\)</span>。若一个黑体的温度增加一倍，则它的辐射出射度会增加16倍。 <span class="math display">\[\sigma=\frac{2\pi^5k^4}{15c^2h^3}=5.67032×10^{-8}\]</span> 其中，<span class="math inline">\(h\)</span>为普朗克常数，<span class="math inline">\(h=6.6262×10^{-34}J·s\)</span>；<span class="math inline">\(c\)</span>为光速，<span class="math inline">\(c=2.998×10^8m/s\)</span>；<span class="math inline">\(k\)</span>为玻尔兹曼常数，<span class="math inline">\(k=1.3806×10^{-23}J/K\)</span>。该定律表明：物体的热力学温度越高其辐射的电磁波能量越强；受发射率的影响，当一个物体为黑体时辐射能力最强；具有相同温度的地物，会因为发射率的不同导致完全不同的辐射出射度。</p><h3 id="维恩位移定律1893年">👀维恩位移定律（1893年）</h3><p>维恩位移定律是物理学中的一个基本定律，它解释了黑体辐射中峰值波长与温度之间相关性。1893年，德国物理学家威廉·维恩，通过多年对大量实验数据研究的丰富经验总结，提出了维恩位移定律，该定律研究表明，当一个物体被加热时，其辐射的波长分布会发生变化，峰值波长会随温度的升高而变短，即呈现负相关，它的数学表示为： <span class="math display">\[\lambda_{max}=\frac{b}{T}\]</span> 式中，<span class="math inline">\(\lambda_{max}\)</span>为对应于黑体辐射亮度最大值的波长，单位为<span class="math inline">\(μm\)</span>；<span class="math inline">\(b\)</span>为比例常数，成为维恩位移常数，<span class="math inline">\(b=2897.8μm·K\)</span>；<span class="math inline">\(T\)</span>为黑体的绝对温度，单位为开尔文（<span class="math inline">\(K\)</span>）。维恩定律表明，一个物体的温度越高，其辐射的峰值波长越短。</p><h3 id="普朗克辐射定律1900年">👀普朗克辐射定律（1900年）</h3><p>普朗克定律(<code>Planck’s law</code>)，也被称为黑体辐射定律，是描述黑体辐射的物理定律之一，解释了黑体辐射能量根据一定波长的分布。根据普朗克定律，绝对温度大于0<span class="math inline">\(K\)</span>的任何物体都会向外以电磁波的形式辐射能量。1900年，普朗克引进量子理论并将黑体辐射源视为离散的量子发射，推导出绝对黑体辐射源辐射出射度(<span class="math inline">\(M\)</span>)随着波长(<span class="math inline">\(\lambda\)</span>)和温度(<span class="math inline">\(T\)</span>)的分布函数，并且能够与实验精确的吻合，该分布函数如下：</p><p><span class="math display">\[M(T,\lambda)=\frac{2{\pi}hc^2}{\lambda^5[exp(\frac{ch} {k\lambda{T} })-1]}=\frac{C_1}{\lambda^5[exp(\frac{C_2}{\lambda{T} })-1]}\]</span> 式中，<span class="math inline">\(M\)</span>为<strong>黑体辐射出射度</strong>，单位为<span class="math inline">\(W·m^{-2}·μm^{-1}\)</span>；<span class="math inline">\(h\)</span>为普朗克常数，<span class="math inline">\(h=6.6262×10^{-34}J·s\)</span>；<span class="math inline">\(c\)</span>为光速，<span class="math inline">\(c=2.998×10^8m/s\)</span>；<span class="math inline">\(k\)</span>为玻尔兹曼常数，<span class="math inline">\(k=1.3806×10^{-23}J/K\)</span>；<span class="math inline">\(\lambda\)</span>为波长，单位为<span class="math inline">\(μm\)</span>；<span class="math inline">\(T\)</span>为热力学温度，单位为<span class="math inline">\(K\)</span>；<span class="math inline">\(C_1\)</span>和<span class="math inline">\(C_2\)</span>分别为第一、第二辐射常数，大小分别为：<span class="math inline">\(C_1=2\pi{h}c^2=3.74203×10^8W·m^{-2}·μm^{4}\)</span>，<span class="math inline">\(C_2=ch/k=14388μm·K\)</span>。</p><blockquote><p>注意单位换算的问题：（<strong>这里暂时只考虑单位，不考虑数值</strong>）</p><p><span class="math inline">\(C_1=2\pi{h}c^2=J·s·m^2·s^{-2}=W·m^2\)</span>，注意<span class="math inline">\(M\)</span>的单位用的是<span class="math inline">\(W·m^{-2}·μm^{-1}\)</span>，那么<span class="math inline">\(C_1/\lambda^5\)</span>的单位也必须是<span class="math inline">\(W·m^{-2}·μm^{-1}\)</span>，所以：</p><p><span class="math inline">\(C_1/\lambda^5=\frac{W·m^2} {μm^5}=\frac{W·m^{-2}·m^4} {μm^5}=\frac{10^{24}·W·m^{-2}·μm^4}{μm^5}\)</span>，即<span class="math inline">\(C_1\)</span>的计算结果必须乘以<span class="math inline">\(10^{24}\)</span>。</p><p><span class="math inline">\(C_2=\frac{ch}{k}=\frac{m·s^{-1}·J·s}{J·K^{-1} }=m·K=10^6·μm·K\)</span>，即<span class="math inline">\(C_2\)</span>的计算结果必须乘以<span class="math inline">\(10^6\)</span>。</p></blockquote><h2 id="红外辐射传输基础理论">⛄红外辐射传输基础理论</h2><blockquote><p><strong>[1]李召良,段四波,唐伯惠,等.热红外地表温度遥感反演方法研究进展[J].遥感学报,2016,20(05):899-920</strong></p></blockquote><p>根据普朗克定律(<code>Planck’s law</code>)，绝对温度大于0<span class="math inline">\(K\)</span>的任何物体都会向外以电磁波的形式辐射能量。处于热平衡状态下的黑体在温度<span class="math inline">\(T\)</span>和波长<span class="math inline">\(\lambda\)</span>处的辐射能量可以用普朗克定律表示，即： <span class="math display">\[B_\lambda(T)=\frac{C_1}{\lambda^5[exp(\frac{C_2}{\lambda{T} })-1]}\]</span> 式中，<span class="math inline">\(B_\lambda(T)\)</span>是黑体在温度<span class="math inline">\(T(K)\)</span>和波长<span class="math inline">\(\lambda(μm)\)</span>处的光谱辐亮度（<span class="math inline">\(W·sr^{-1}·m^{-2}·μm^{-1}\)</span>）；<span class="math inline">\(C_1\)</span>和<span class="math inline">\(C_2\)</span>分别是物理常量：<span class="math inline">\(C_1=2{h}c^2=1.19113×10^8W·sr^{-1}·m^{-2}·μm^{4}\)</span>，<span class="math inline">\(C_2=ch/k=1.439×10^4μm·K\)</span>。（小编反复计算后，上下两种方式的<span class="math inline">\(C_1\)</span>是<span class="math inline">\({\pi}\)</span>倍关系）</p><p>由于绝大多数自然地物都是非黑体，它们的热辐射需要在上式中加入地表发射率<span class="math inline">\(\varepsilon\)</span>的影响。地表发射率可定义为地物的实际热辐射与同温同波长下黑体热辐射的比值。自然地物的热辐射可以用地表发射率乘以上式的普朗克函数得到。显然，如果大气对卫星获取的辐亮度信号没有影响，那么在已知地表发射辐射和发射率的情况下，地表温度就能根据上式反演得到。</p><p>黑体在特定温度<span class="math inline">\(T(K)\)</span>下单色辐射强度的极大值所对应的波长<span class="math inline">\(\lambda_{max}\)</span>可以用维恩位移定律表示，根据这一性质，对于温度在(250—330)<span class="math inline">\(K\)</span>的地表来说，其峰值波长<span class="math inline">\(\lambda_{max}\)</span>主要处于热红外波长范围(8.8—11.6)<span class="math inline">\(μm\)</span>，而对于诸如火灾、火山喷发的高温地表，其温度可高于800<span class="math inline">\(K\)</span>，那么它们的峰值波长<span class="math inline">\(\lambda_{max}\)</span>主要处于中红外波长范围(3—5)<span class="math inline">\(μm\)</span>。因此，可以根据不同的需求选择不同的波长范围来探测地表热辐射状况。</p><p>卫星红外传感器能够接收到视线方向上来自地表经大气传输的辐射信息。在局地热平衡的晴空无云条件下，根据辐射传输方程，传感器在大气顶部所接收到的通道辐亮度<span class="math inline">\(I_i\)</span>可以表示为 <span class="math display">\[I_i(\theta,\varphi)=R_i(\theta,\varphi)\tau_i(\theta,\varphi)+R_{a t_i \uparrow}(\theta,\varphi)+R_{s l_i \uparrow}(\theta,\varphi)\]</span> 式中，地表辐亮度<span class="math inline">\(R_i\)</span>可以表示为 <span class="math display">\[\begin{aligned} &amp; R_i(\theta,\varphi)=\varepsilon_i(\theta,\varphi) B_i\left(T_s\right)+\left[1-\varepsilon_i(\theta, \varphi)\right] R_{a t_i \downarrow}+{\left[1-\varepsilon_i(\theta, \varphi)\right] R_{s l_i \downarrow}+\rho_{b i}\left(\theta, \varphi,\theta_s,\varphi_s\right) \times} E_i \cos \left(\theta_s\right) \tau_i\left(\theta_s, \varphi_s\right)\end{aligned}\]</span> 式中，<span class="math inline">\(\theta\)</span>和<span class="math inline">\(\varphi\)</span>分别表示观测天顶角和观测方位角，为简单起见，观测天顶角和方位角在之后公式中将被忽略。<span class="math inline">\(\tau_i\)</span>是通道<span class="math inline">\(i\)</span>的大气等效透过率；<span class="math inline">\(\varepsilon_i\)</span>和<span class="math inline">\(T_s\)</span>分别是通道<span class="math inline">\(i\)</span>地表发射率和地表温度；<span class="math inline">\(R_{a t_i \downarrow}\)</span>是大气下行热辐射，<span class="math inline">\(R_{s l_i \downarrow}\)</span>是大气散射的下行太阳辐射；<span class="math inline">\(\rho_{b i}\)</span>是地表双向反射率，<span class="math inline">\(E_i\)</span>是大气顶部的太阳辐照度，<span class="math inline">\(\theta_s\)</span>和<span class="math inline">\(\varphi_s\)</span>分别是太阳天顶角和方位角。</p><ul><li><p>路径①：<span class="math inline">\(R_i \tau_i\)</span>表示经大气衰减之后的近地表处辐亮度（经大气衰减之后的地表离地辐射）；</p></li><li><p>路径②：<span class="math inline">\(R_{a t_i \uparrow}\)</span>表示大气上行热辐射；</p></li><li><p>路径③：<span class="math inline">\(R_{s l_i \uparrow}\)</span>表示大气散射的上行太阳辐射；</p></li><li><p>路径④：<span class="math inline">\(\varepsilon_i B_i\left(T_S\right)\)</span>；表示地表自身发射的辐亮度；</p></li><li><p>路径⑤和⑥：<span class="math inline">\(\left(1-\varepsilon_i\right) R_{a t_i \downarrow}\)</span>和<span class="math inline">\(\left(1-\varepsilon_i\right) R_{s l_i \downarrow}\)</span>分别表示经地表反射的下行大气热辐射和散射的太阳辐射；</p></li><li><p>路径⑦：<span class="math inline">\(\rho_{b i} E_i \cos \left(\theta_s\right) \tau_i\left(\theta_s, \varphi_s\right)\)</span>表示经地表反射的太阳直射辐射。</p></li></ul><p>由于在8—14<span class="math inline">\(μm\)</span>波谱区的白天和夜间数据和3—5<span class="math inline">\(μm\)</span>波谱区的夜间数据中，大气顶部的太阳辐射可以忽略不计，因此上式中太阳辐射部分(路径③⑥和⑦)均可以忽略，而不会影响精度。</p><p><a href="https://imgse.com/i/pF7IlJ1"><img src="https://s21.ax1x.com/2024/04/01/pF7IlJ1.jpg" alt="pF7IlJ1.jpg" /></a></p><p>为了方便和数学简写起见，大气顶部辐亮度<span class="math inline">\(I_i\)</span>和地表辐亮度<span class="math inline">\(R_i\)</span>一般用亮度温度来表示，即发射率为1。大气顶部亮温<span class="math inline">\(T_i\)</span>和地表亮温<span class="math inline">\(T_{gi}\)</span>定义为：<span class="math inline">\(B_i\left(T_i\right)=I_i\)</span>，<span class="math inline">\(B_i\left(T_{g i}\right)=R_i\)</span></p><p>值得注意的是，上式中除了角度变量<span class="math inline">\((\theta, \varphi,\theta_s,\varphi_s)\)</span>，其他的变量和参数都是通道等效值。大多数的卫星传感器都只能探测有限光谱带宽的辐射信号。各参数的通道等效值通过加权平均计算，表达式为： <span class="math display">\[X_i=\frac{\int_{\lambda_1}^{\lambda_2}\,g_i(\lambda)X_\lambda{\rm d}{\lambda}}{\int_{\lambda_1}^{\lambda_2}\,g_i(\lambda){\rm d}{\lambda}}\]</span> 式中，<span class="math inline">\(g_i(\lambda)\)</span>是通道<span class="math inline">\(i\)</span>的光谱响应函数，<span class="math inline">\(\lambda_1\)</span>和<span class="math inline">\(\lambda_2\)</span>分别是通道<span class="math inline">\(i\)</span>的波长下边界和上边界，<span class="math inline">\(X\)</span>代表<span class="math inline">\(B(T)\)</span>，<span class="math inline">\(I\)</span>，<span class="math inline">\(R\)</span>，<span class="math inline">\(R_{a t_i \uparrow}\)</span>，<span class="math inline">\(R_{s l_i \uparrow}\)</span>，<span class="math inline">\(R_{a t_i \downarrow}\)</span>，<span class="math inline">\(R_{s l_i \downarrow}\)</span>，<span class="math inline">\(E\)</span>，<span class="math inline">\(\varepsilon\)</span>，<span class="math inline">\(\tau\)</span>和<span class="math inline">\(\rho_b\)</span>。</p><h2 id="热红外辐射传输方程">⛄热红外辐射传输方程</h2><p>地表热辐射传输方程是描述热辐射传播通过介质时与介质发生相互作用( 吸收、散射、发射等)而使热辐射能按一定规律传输的方程。遥感器所接受到的热辐射主要有由地表热辐射经大气衰减后被遥感器接受的热辐射( 即被测目标本身的热辐射) 、大气向上的热辐射( 大气直接热辐射) 和大气向下热辐射( 大气向地面的热辐射) 经地表反射后又被大气衰减最终被遥感器接受的热辐射3部分。</p><p><a href="https://imgse.com/i/pkSq9r8"><img src="https://s21.ax1x.com/2024/04/20/pkSq9r8.jpg" alt="pkSq9r8.jpg" /></a></p><p>上图展示了热红外辐射的传输过程，地物和大气最主要的辐射来源是太阳，太阳光穿透大气到达地面后，地表吸收太阳辐射能开始升温，然后，将吸收的太阳能转换为自身热能后再向外发射能量，最后，地面发射的能量经过大气的散射、吸收和发射后到达传感器。大气不仅是削弱热红外辐射的介质，大气本身也会向外发射辐射，因此传感器不仅会接收到大气自身的上行辐射，还会接收到经过大气衰减的地面反射的大气下行辐射。</p><p>大气热红外辐射的性质很复杂，大气中最主要的吸收物质是水汽，水汽在6.3<span class="math inline">\(μm\)</span>有一个较强的吸收带，占有较宽的谱段；大气在14<span class="math inline">\(μm\)</span>以上可近似看作黑体，14<span class="math inline">\(μm\)</span>以上的热红外辐射无法穿透大气。因此在地-气辐射传输过程中，地表热辐射可以通过3-5<span class="math inline">\(μm\)</span>和8-14<span class="math inline">\(μm\)</span>两个大气窗口，<code>MODTRAN</code>的中纬度夏季模型对应的大气透过率如下图：</p><p><a href="https://imgse.com/i/pkSO13R"><img src="https://s21.ax1x.com/2024/04/20/pkSO13R.jpg" alt="pkSO13R.jpg" /></a></p><p>在局地热平衡及地表对大气热辐射具有朗伯体性质的假设下，根据辐射传输理论，在晴空大气下，热红外大气辐射传输方程可以表示为： <span class="math display">\[L_{sen}=B_\lambda(T_i)=\tau_\lambda(\theta)·[\varepsilon_\lambda·B_\lambda(T_s)+(1-\varepsilon_\lambda)·L_\lambda\downarrow]+L_\lambda\uparrow\]</span> 式中，<span class="math inline">\(L_{sen}\)</span>为星上辐亮度（<span class="math inline">\(W·sr^{-1}·m^{-2}·μm^{-1}\)</span>）；<span class="math inline">\(B\)</span>为普朗克函数；<span class="math inline">\(B_\lambda(T_i)\)</span>是遥感传感器在每个波长<span class="math inline">\(\lambda\)</span>上所接收到的辐射强度（<span class="math inline">\(W·sr^{-1}·m^{-2}·μm^{-1}\)</span>）；<span class="math inline">\(T_i\)</span>为通道<span class="math inline">\(i\)</span>的亮度温度（星上亮温（<span class="math inline">\(K\)</span>)）；<span class="math inline">\(B_\lambda(T_s)\)</span>是在地表温度为<span class="math inline">\(T_s\)</span>时黑体辐射强度；<span class="math inline">\(T_s\)</span>表示地表温度（<span class="math inline">\(K\)</span>）；<span class="math inline">\(\tau_\lambda(\theta)\)</span>波长<span class="math inline">\(\lambda\)</span>在遥感器视角为<span class="math inline">\(\theta\)</span>下从地面到遥感器的大气透射率；<span class="math inline">\(L_\lambda\uparrow\)</span>和<span class="math inline">\(L_\lambda\downarrow\)</span>为波长<span class="math inline">\(\lambda\)</span>上的大气上行辐射和大气下行辐射（<span class="math inline">\(W·sr^{-1}·m^{-2}·μm^{-1}\)</span>）；<span class="math inline">\(\varepsilon_\lambda\)</span>为波长<span class="math inline">\(\lambda\)</span>上的地表发射率（地表比辐射率）。大多数卫星传感器探测到的光谱带宽的辐射信号是有限的，每个参数的谱段等效值可以通过积分表示为： <span class="math display">\[X_i=\frac{\int_{\lambda_1}^{\lambda_2}\,g_i(\lambda)X_\lambda{\rm d}{\lambda}}{\int_{\lambda_1}^{\lambda_2}\,g_i(\lambda){\rm d}{\lambda}}\]</span> 式中，<span class="math inline">\(g_i(\lambda)\)</span>是通道<span class="math inline">\(i\)</span>的光谱响应函数，<span class="math inline">\(\lambda_1\)</span>和<span class="math inline">\(\lambda_2\)</span>分别是通道<span class="math inline">\(i\)</span>的波长下边界和上边界，<span class="math inline">\(X\)</span>代表<span class="math inline">\(B(T)\)</span>，<span class="math inline">\(\varepsilon\)</span>，<span class="math inline">\(\tau\)</span>，<span class="math inline">\(L_\lambda\uparrow\)</span>，<span class="math inline">\(L_\lambda\downarrow\)</span>。辐射传输方程作为热红外数据陆表面温度反演的基础，各种温度反演算法的发展都是基于对辐射传输方程的不同假设和近似。</p><h2 id="热红外地表温度遥感反演方法">⛄热红外地表温度遥感反演方法</h2><blockquote><p><strong>[1]段四波,茹晨,李召良,等.Landsat卫星热红外数据地表温度遥感反演研究进展[J].遥感学报,2021,25(08):1591-1617.</strong></p><p><strong>[2]李召良,段四波,唐伯惠,等.热红外地表温度遥感反演方法研究进展[J].遥感学报,2016,20(05):899-920.</strong></p><p><strong>[3]肖尧,马明国,闻建光,等.复杂地表地表温度反演研究进展[J].遥感技术与应用,2021,36(01):33-43.</strong></p><p><strong>[4]奉澜博.林火多源遥感监测中地表温度反演标准化研究[D].中南林业科技大学,2022.</strong></p><p><strong>[5]徐林.多谱段遥感数据地表温度反演方法研究[D].大连海事大学,2023.</strong></p></blockquote><table><colgroup><col style="width: 18%" /><col style="width: 81%" /></colgroup><thead><tr class="header"><th style="text-align: center;">反演算法</th><th>特点</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">单通道算法</td><td>对单个红外通道进行建模，需要输入地表发射率、大气传输模型、精确大气廓线。</td></tr><tr class="even"><td style="text-align: center;">多通道算法</td><td>对多个红外通道进行建模，无需大气廓线数据，反演精度较高，地表发射率具有不确定性，对算法结果影响较大。</td></tr><tr class="odd"><td style="text-align: center;">多角度算法</td><td>根据特定通道在不同角度的亮温差异来消除大气的影响，无需大气廓线数据，数据源稀缺。</td></tr><tr class="even"><td style="text-align: center;">多时相算法</td><td>基于地表发射率不随时间变化的假设，无需输入地表发射率，结果对传感器噪声、大气校正误差和影像配准精度敏感，现在主要应用于MODIS地表温度反演。</td></tr><tr class="odd"><td style="text-align: center;">高光谱反演算法</td><td>利用地表发射率固有的光谱特征，无需输入地表发射率，需要精确大气校正。</td></tr><tr class="even"><td style="text-align: center;">统计模型</td><td>（单通道回归/多通道回归）算法简单，模型回归需要大量实验数据，模型系数具有较强局地性。</td></tr><tr class="odd"><td style="text-align: center;">物理模型</td><td>（微波辐射传输方程/基于发射率求解/基于发射率不变）具有物理意义，且反演精度较经验模型高，过于依赖输入参数和假设条件的准确性。</td></tr><tr class="even"><td style="text-align: center;">神经网络模型</td><td>方法简单易行，但不具有实际物理意义，通过输入有代表性的训练样本建立数学公式推导结果，对训练样本的依赖性较大。</td></tr></tbody></table><h3 id="单通道算法">👀单通道算法</h3><p>单通道算法主要应用卫星单一热红外谱段观测数据，首先假设地表发射率是已知的，然后使用大气廓线数据（即大气透过率、大气下行辐射和大气上行辐射）对大气进行校正，然后，使用大气辐射传输方程结合校正后的大气数据反演得到地表温度。 常用的单通道算法包括：</p><p><strong>（1）基于辐射传输方程的算法</strong></p><p>该算法是最早发展起来的一种地表温度反演算法。Sobrino等(2004)基于热红外辐射传输方程，去除辐射传输过程中大气对热辐射的影响，从而较为精确地获得地表温度。该算法具有广泛的适用性，能够被应用于任何传感器上的热红外遥感数据。总的来看，基于辐射传输方程的算法不仅具有坚实的物理基础，且计算精度较高。但是该算法计算过程复杂，难以获取实时的大气廓线数据(包括不同高度的温度、湿度等)。而使用标准大气廓线数据替代实时的大气廓线数据则会影响大气对地表辐射的模拟，从而降低地表温度的反演精度。</p><p><strong>（2）单窗算法</strong></p><p>为了减少对大气廓线的依赖，Qin等(2001)通过引入大气平均作用温度，提出了一种基于Landsat 5 TM第6波段数据的单窗算法。该算法将大气和地表的影响直接包含在反演公式中，只需要大气平均作用温度和大气透过率两个大气参数，估算得到地表温度。总的来看，单窗算法既考虑了地表比辐射率的影响，也考虑了大气辐射的影响。在地表温度反演过程中所需要的大气参数比传统的辐射传输方程要少，且反演精度较高，普适性较强。</p><p><strong>（3）普适性单通道算法</strong></p><p>Jiménez-Muñoz和Sobrino(2003)针对Landsat5 TM数据提出一种反演地表温度的普适性单通道算法。该算法假设地表比辐射率已知，根据辐射传输方程对普朗克函数进行一阶泰勒级数展开，仅需通过大气水汽含量反演地表温度。JiménezMuñoz等(2009)对普适性单通道算法进行改进，并扩展到Landsat4、5 TM和Landsat7 ETM+。Jiménez-Muñoz等(2014)和Cristóbal等(2018)提出了针对Landsat 8 TIRS数据的单通道算法。总的来看，普适性单通道算法既考虑了地表比辐射率的影响，也考虑了大气辐射的影响，适用于任何带宽约为1<span class="math inline">\(μm\)</span>的热红外传感器，并且因为其需要的实时大气参数较少而被广泛使用。</p><p><strong>（4）实用单通道算法</strong></p><p>针对现有单通道算法中线性化普朗克函数和大气参数系数求解引入的误差，Wang等 (2019)提出了实用单通道算法PSC(Practical SingleChannel)。实用单通道算法直接构建地表黑体辐射亮度与星上辐射亮度之间的关系，避免线性化普朗克函数带来的误差。通过分析大气参数构建最优大气参数估算模型，并基于全局拟合方法求解大气参数模型的系数，规避多个大气参数误差的叠加。实用单通道算法包含两种形式：①基于大气水汽含量的实用单通道算法 ；②基于大气水汽含量和近地表气温的实用单通道算法。实用单通道算法对输入参数误差的敏感性比普适性单通道算法弱，具有更好的稳定性；与普适性单通道算法相比，实用单通道算法地表温度反演精度提升了0.47<span class="math inline">\(K\)</span>。</p><blockquote><p>需要注意的是，单通道算法是对辐射传输方程的简单变形，前提是地表发射率和大气廓线已知。这些方法虽然在理论上能够精确反演地表温度，但高精度的地表发射率在实际应用中很难获取。</p></blockquote><h3 id="多通道算法">👀多通道算法</h3><p><strong>（1）昼夜法</strong></p><p>昼夜法是专门为MODIS传感器研发的反演地表温度的算法。该算法利用MODIS七个热红外通道分别在白天和夜间观测到的数据获取地表发射率，然后利用分裂窗算法反演地表温度。该算法是针对MODIS传感器开发的，在其他传感器中应用较少。其反演精度可保证在0.5<span class="math inline">\(K\)</span>之内，最大误差为3<span class="math inline">\(K\)</span>。目前，该算法己成为MODIS温度产品的官方算法之一。</p><p><strong>（2）温度/发射率分离法(Temperature/Emissivity Separation, TES)</strong></p><p>温度发射分离法是Gillespie A.等人根据Terra ASTER ５个热红外波段的特点，专门提出的一种温度发射率分离算法，但使用TES算法会造成由于波段间高度相关性引起的不稳定问题。张猛在其文中已详细地描述了目前己经发展的各种TES算法。相关数值模拟实验表明，该算法的温度反演精度为±1.5<span class="math inline">\(K\)</span>，地表发射率的反演精度为±0.015，该算法已经成为ASTER温度产品的官方算法。</p><h3 id="分裂窗算法">👀分裂窗算法</h3><p>劈窗算法也称分裂窗算法，主要是利用在一个大气窗口内具有不同大气吸收特性的两个相邻热红外通道表面的不同线性组合来消除大气影响，反演地表温度。该算法是目前热红外遥感反演地表温度中最成熟、最精确的地表温度反演算法。</p><ul><li>基于NOAA/AVHRR数据的劈窗算法</li><li>基于MODIS/TERRA数据的劈窗算法</li><li>基于FY-4A/AGRI数据的劈窗算法</li><li>基于Himawari-8/AHI数据的劈窗算法</li><li>基于Landsat-8/OLI-TIRS数据的劈窗算法</li></ul><blockquote><p>详细的劈窗算法技术流程，大家可以调研相关论文进行学习。</p></blockquote><h3 id="多角度算法">👀多角度算法</h3><p>多角度算法是建立在同一物体由于从不同角度观测时所经过的大气路径不同而产生的大气吸收不同的基础上。由于大气吸收体的相对光学物理特性在不同观测角度下保持不变，大气透过率仅随角度的变化而变化。与分裂窗算法的基本原理类似，大气的作用可以通过特定通道在不同角度观测下所获得亮温的线性组合来消除。这种算法主要基于第一代双角度模式卫星，即搭载在第一代欧洲遥感卫星(ERS-1)上的沿轨扫描辐射计(ATSR)发展而来。双角度算法应用于卫星数据时有几个实际困难：</p><ul><li><p>多角度算法中的一个重要现象是发射率的角度相关性，因为在卫星空间分辨率尺度下，自然地表的角度效应是未知的，如裸土和岩石。</p></li><li><p>地表温度的角度相关性也是一个问题。除了需要大气晴空无云并且水平均一，还必须要求在不同斜程路径下的多角度测量有明显差异。否则，不同角度下的测量会高度相关，导致算法不稳定，并对仪器噪声极其敏感。</p></li><li><p>在不同观测角度下对同一目标地物进行观测会覆盖不同的传感器区域(即像元)。即使可能会观测到同样的像元大小，但由于地物的3维结构，在不同观测角度下观测到的地物仍可能明显不同。</p></li><li><p>不同观测角度像元的配准不好会导致地表温度反演结果的巨大误差。</p></li></ul><p>所以，多角度算法仅适用于理想大气条件下的均质区域(如海洋表面或浓密森林植被)，而不适用于非均质地表。</p><h3 id="多时相算法">👀多时相算法</h3><p>多时相算法是在假定地表发射率不随时间变化的前提下利用不同时间的测量结果来反演地表温度和发射率的，比较有代表性的是两温法(Watson,1992)和日夜双时相多通道物理反演法(Wan和Li,1997)。</p><p><strong>（1）两温法</strong></p><p>两温法的思路是通过多次观测来减少未知数的个数。假设热红外通道已经经过精确的大气校正并且发射率不随时间而发生变化，那么如果地表被N个通道两次观测，2N次测量将会有N+2个未知数(N个通道的发射率以及2个地表温度)。因此，当N≥2时，这N个地表发射率和2个地表温度可以从2N个方程中同时得到(Watson，1992)。注意到地表发射率不随时间而变化的假设暗示地表是均匀的并且有相对稳定的土壤湿度，所以首先是要减小由于像元大小和观测角度带来的地表发射率的变动，其次要避免地表发射率随土壤湿度的变化而变化，比如要考虑降雨和露水的发生。两温法的主要优势是它对地表发射率的光谱形状没有作出假设，只是假定发射率是不随时间而变化的。存在的问题如下：</p><ul><li><p>虽然这一方法有一个简单直接的公式，但是由于这2N个方程是高度相关的，因此方程的解可能不稳定，并且对传感器噪声和大气校正产生的误差非常敏感(Caselles等,1997；Gillespie等,1996；Watson,1992)。</p></li><li><p>由于在没有实测大气廓线数据的情况下，很难进行非常精确的大气校正，因此在反演地表温度和发射率时使用近似的廓线可能导致比较大的误差。</p></li><li><p>Peres和DaCamara(2004)发现增加观测的次数和(或)温差可以提高反演的精度，但是这种提高会受到热红外测量高相关性的限制。</p></li><li><p>这一方法还需要在两个不同的时间点对影像进行精确的几何配准(Gillespie等,1996；Watson,1992)。对于下垫面均匀的区域，不精确配准带来的地表温度和发射率误差较小，但对于下垫面不均匀的区域，这一误差将较大(Wan,1999)。</p></li><li><p>卫星观测天顶角的改变会引起地表发射率的改变，因此违背了地表发射率不随时间改变的假设，导致两温法的精度降低(Li等,2013)。</p></li></ul><p><strong>（2）日夜双时相多通道物理反演法（昼夜法）</strong></p><p>Wan和Li(1997)受到日夜温度无关波谱指数法和两温法的启发，进一步提出了日夜物理反演法，即通过结合白天和晚上的中红外以及热红外数据来同时反演地表温度和发射率。这一方法假定从白天到夜晚地表发射率不会发生太大的改变，并且在中红外波段感兴趣范围角度形式因子的变化很小(＜2%)，以此减少未知数的个数，从而使反演更加稳定。通常来讲，日夜物理反演法是之前提到的使用两次观测的两温法的发展，与之前提到的两温法和日夜温度无关波谱指数法相比，日夜算法在以下几个方面较为突出：</p><ul><li><p>对于中红外通道，白天太阳辐射的存在会显著地减小方程之间的相关性，从而使方程的解更加稳定和精确。</p></li><li><p>通过考虑初始大气廓线带来的误差，引入两个变量(大气底层的空气温度：<span class="math inline">\(T_a\)</span>、大气水汽含量：<span class="math inline">\(WV\)</span>)后，地表温度和发射率的反演精度得到很大的提高。</p></li><li><p>日夜算法不需要12小时间隔的测量(白天和夜晚)，只要地表发射率不发生大的改变，几天内获得的白天和夜晚的数据也同样可用。</p></li></ul><p>但是，和其他的多时相反演方法类似，日夜算法同样面临着几何配准精度低以及观测天顶角变化等关键问题。</p><h3 id="高光谱反演算法">👀高光谱反演算法</h3><p>高光谱反演算法依靠的是地表发射率固有的光谱特性而不是时相信息，其中比较有代表性的是迭代光谱平滑温度发射率分离法(Borel,2008)和线性发射率约束法(Wang等,2011)。在一些合理的假设和约束下，通过减少未知数的个数或者增加方程的数量，利用这些方法可以使用经过大气校正后的辐射值反演出地表温度和发射率。</p><h2 id="复杂地表温度反演的局限性">⛄复杂地表温度反演的局限性</h2><p><strong>（1）病态反演问题</strong></p><p>无论是热红外辐射传输模型还是被动微波传输模型，反演过程始终是个病态问题，即方程未知数个数总是比方程个数多。因此在反演过程中，各种模型的建立都基于一定的约束条件和假设，使方程可解。但是约束方程和条件不确定性往往是反演算法的重要误差来源。</p><p><strong>（2）地表复杂性</strong></p><p>相比平坦均一的地表，山区地形更为复杂，景观破碎度和空间异质性更强，对地表发射率的估算带来更大困难。</p><ul><li>复杂的地形对土壤物理性质、水分分布和地表植被类型存在影响。①不同土壤类型对辐射的吸收、反射、透射不同，影响地表能量通量变化和地表发射率、反射率和吸收率；②山地水分分布受地形和海拔高度的影响，地表起伏使气流抬升或下沉，山体遮挡阻止水汽移动，使山地地表水分的水平和垂直方向分布表现出异质性。地表水分分布不均，影响土壤湿度和植被生长，同种土壤或同种植被可能有不同的发射率；③植被对地表温度有冷却和保温的作用，可以抑制地表温度剧烈改变，现有地表发射率的估算多基于地表植被与土壤比例或植被覆盖度分级阈值，对于植被类型丰富、地形起伏的复杂地表，以单一的发射率估算方法不能有效解决发射率精度问题。复杂地表区域，下垫面破碎，水分、土壤和植被复杂多变，因子间相互影响，由此地表发射率的估算必须考虑环境因素。输入参数多源且不确定性大，是复杂地表地表温度反演难度大的主要影响因素。</li><li>山区地表具有复杂三维结构，热辐射与地表存在复杂的相互作用。研究山区热辐射传输过程，必须考虑地表方向性，近年来国内外专家学者构建了许多热红外模型，包括辐射传输模型、几何光学模型、3D模型、混合模型和参数模型等。模型的发展需要考虑方向性、地形因素和热力因素，目前的模型多建立于条件可控的实验场或小区域试验区，应用于复杂多变的山区地表温度建模仍存在着挑战性。在坡度、坡向和地形不断变化和相互遮蔽的山区，地表接收到的太阳入射辐射能量，包括直接辐射、散射辐射和邻近地形的反射辐射，辐射间差异显著。坡度、坡向和地形直接影响地表辐射的分布，地形的遮蔽作用同样使温度在空间分布上存在差异。对山地热辐射建模，不仅需要考虑复杂的地形因素，还需要考虑能量平衡和流体力学等影响。山地地形条件直接影响地表辐射收支和能量平衡，提高复杂地区地表温度反演精度，还需要进一步建立统一且普适性强的模型。提高山区地表温度反演精度，需要考虑地形因素对发射率的影响、邻近效应、能量平衡等，优化复杂地表辐射传输模型、动力模型、核驱动模型，并结合地面多角度观测数据对模型进行修订。</li></ul><p><strong>（3）水汽与云的影响</strong></p><p>水汽是大气中重要的吸收气体，其吸收系数与频率、大气温度、大气压强和水汽密度相关，并在时间空间上都有很大变化。云中包含液态水和各种微粒能吸收和散射辐射。当天空晴朗无云时，消光系数主要是水汽和氧气的吸收，在云雨天气，云的存在致使热红外信号失真，使用热红外反演方法无法获取地面温度信息。微波虽然能穿透云层，但是在云中传播还应考虑到液态水的瑞利散射。云覆盖区下不同地表类型，云对其有不同程度的影响；对于像元的位置而言，位于云边缘像元影响程度小于位于云覆盖中心的像元；云覆盖时间越长，对地表温度影响越大；云阴影与云遮挡的地区，云覆盖对其影响也不一样。现有的地表温度反演算法主要是针对晴空像元，云下地表温度反演仍是一个难题。水汽和云是复杂地表温度反演重要障碍，热红外波段的重建、对不同厚度云像元的识别、云遮挡区域数据填补等问题还有待进一步深入研究。</p><p><strong>（4）真实性验证的不确定性</strong></p><p>遥感反演的真实性检验，包含对算法可行性和精度进行检验，对温度产品的精度、稳定性、适用性、生产效能进行检验，以及算法应用是否满足地球科学应用需求的检验。对于地形复杂、地表破碎的复杂地表区域，反演的温度像元与地面观测值存在尺度差异，单个像元值难以反映地面实际状况，有效的检验方法和尺度转换是提高检验可信性的基本要求。目前用于复杂地表的地表温度检验方法还是常规地表温度真实性检验方法，主要有基于温度方法、基于辐射的方法、交叉验证以及时间序列分析4种典型的检验方法。</p><table><thead><tr class="header"><th>检验方法</th><th>参考对象</th><th>适用范围</th><th>特点</th></tr></thead><tbody><tr class="odd"><td>基于温度检验</td><td>地表实测温度</td><td>下垫面均一，地势平坦地区</td><td>简单直接，对站点数据质量要求高，不适用于无站点和地物破碎区域</td></tr><tr class="even"><td>基于辐射检验</td><td>辐射传输方程模拟辐射值</td><td>无地面监测站点地区</td><td>需要输入实测大气廓线和地表发射率，复杂地表区域参数获取困难</td></tr><tr class="odd"><td>交叉验证</td><td>设为真值的温度产品</td><td>无实测温度和模拟参数情况</td><td>对参考产品要求高，山区和云覆盖区产品精度无保证；产品匹配问题影响验证结果</td></tr><tr class="even"><td>时间序列验证</td><td>目标物长序列变化</td><td>传感器本身监测</td><td>传感器运行时间较长，对异常值敏感，不适用于地表温度检验</td></tr></tbody></table><p>地表温度真实性检验方法不断被改进，并在复杂地形区开展应用，但是仍存在以下问题：①空间异质性问题，地表破碎区同温像元内部存在较大差异，缺少绝对均一的地表，真实性检验标准存在不确定性。②辐射方向性问题，复杂地表地物多样，地势起伏，地表方向亮温角度差异大，制约地表温度反演精度和长波估算精度。③时空、角度不匹配问题，卫星数据反演的地表温度是卫星过境的瞬时温度，而地面是不断变化的，参考值和比较值间存在着差异性，尤其是对站点分布少的山地区域，得到与卫星过境同时段的高质量观测值更加困难。④仪器观测不确定性，仪器获取数据存在不确定性，站点的布设不均一。复杂地表区域站点数过少，山地区域仪器维护困难，数据质量和参数完整性不能得到有效保障。</p>]]></content>
      
      
      <categories>
          
          <category> 遥感数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LST </tag>
            
            <tag> 辐射传输方程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python/Matlab/IDL之文件读写操作【CSV/Excel/JSON/XML/TXT】</title>
      <link href="/2023/11/28/Files-ReadWrite/"/>
      <url>/2023/11/28/Files-ReadWrite/</url>
      
        <content type="html"><![CDATA[<h2 id="⛄前言"><a href="#⛄前言" class="headerlink" title="⛄前言"></a>⛄前言</h2><p><code>CSV</code>（<code>Comma-Separated Values</code>，逗号分隔值，有时也称为<strong>字符分隔值</strong>，因为分隔字符也可以不是逗号），其文件以纯文本形式存储表格数据（数字和文本）。纯文本意味着该文件是一个字符序列，不含必须像二进制数字那样被解读的数据。<code>CSV</code>文件由任意数目的记录组成，记录间以某种换行符分隔；每条记录由字段组成，字段间的分隔符是其它字符或字符串，最常见的是逗号或制表符。<code>CSV</code>文件通常以 <code>.csv</code> 作为文件扩展名。</p><p><code>XLS</code>就是<code>Microsoft Excel</code>工作表，是一种非常常用的电子表格格式。<code>xls</code>文件可以使用<code>Microsoft Excel</code>打开，另外微软为那些没有安装<code>Excel</code>的用户开发了专门的查看器<code>Excel Viewer</code>。使用<code>Microsoft Excel</code>可以将<code>XLS</code>格式的表格转换为多种格式：<code>XML</code>表格、<code>XML</code>数据、网页、使用制表符分割的文本文件（<code>.txt</code>）、使用逗号分隔的文本文件(<code>.csv</code>)等。</p><p><code>XLSX</code>是<code>Microsoft Office EXCEL 2007/.../2019</code>文档及以上的扩展名。其基于<code>Office Open XML</code>标准的压缩文件格式取代以前专有的默认文件格式，在传统文件名扩展名后面添加字母”<code>x</code>“（即<code>.docx</code>取代<code>.doc</code>、<code>.xlsx</code>取代<code>.xls</code>、<code>.pptx</code>取代<code>.ppt</code>）。任何能够打开<code>.xlsx</code>文件的文字处理软件都可以将该文档转换为<code>.xls</code>文件，<code>.xlsx</code>文件比<code>.xls</code>文件所占用空间更小。</p><blockquote><p><code>xlsx</code>格式文档文件无法被<code>EXCEL2003</code>及以下版本<code>EXCEL</code>软件直接打开编辑，安装<code>OFFICE2007</code>兼容包后可以打开查看。手动将<code>XLSX</code>文件后缀修改为<code>XLS</code>无法改变文档文件的本质属性，是不能被<code>EXCEL2003</code>等低版本<code>EXCEL</code>直接打开编辑的。用户可在<code>EXCEL</code>软件成功打开<code>EXCEL2007</code>专有<code>XLSX</code>格式文档的前提下，采用另存为方式将其转换为<code>EXCEL97—2003</code>格式文档的<code>XLS</code>文件这样可与旧的版本兼容，但一些<code>EXCEL2007</code>文档专有的特性格式可能丢失。<code>Excel xls</code>和<code>xlsx</code>的详细区别如下：</p><ul><li><strong>文件格式不同</strong>：<code>xls</code>是一个特有的<a href="https://www.zhihu.com/search?q=%E4%BA%8C%E8%BF%9B%E5%88%B6&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2685933475%7D">二进制</a>格式，其核心结构是复合文档类型的结构，而<code>xlsx</code>的核心结构是<code>XML</code>类型的结构，采用的是基于<code>XML</code>的压缩方式，使其占用的空间更小。<code>xlsx</code>中最后一个<code>x</code>的意义就在于此。</li><li><strong>版本不同</strong>：<code>xls</code>是<code>excel2003</code>及以前版本生成的文件格式，不管有没有宏程序的话都是<code>xls</code>文件，而<code>xlsx</code>是<code>excel2007</code>及以后版本生成的文件格式，从<code>2007</code>开始做了区分，<code>XLSM</code>文件和<code>XLSX</code>文件都是<code>excel2007</code>及其以后的文件，但前者是含有宏启用，<code>Excel</code>中默认情况下不自动启用宏，默认是<code>XLSX</code>。<code>VBA</code>中，如果不想保存代码，可以保存为<code>xlsx</code>，即可自动删除其中<code>VBA</code>代码，反之则保存为<code>XLSM</code>文件。</li><li><strong>兼容性不同</strong>：<code>xlsx</code>格式是向下兼容的，可兼容<code>xls</code>格式。07版的<code>Office Excel</code>，能打开编辑07版（后缀<code>.xlsx</code>）的<code>Excel</code>文件，也能打开编辑03版（后缀<code>.xls</code>）的<code>Excel</code>文件，都不会出现乱码或者卡死的情况。03版的<code>Office Excel</code>，就只能打开编辑03版（后缀<code>.xls</code>）的<code>Excel</code>文件；如果打开编辑07版（后缀<code>.xlsx</code>）的<code>Excel</code>文件，则可能出现乱码或者开始能操作到最后就卡死，以后一打开就卡死。</li><li><strong>默认保存方式上</strong>：<code>xls</code>是03版<code>Microsoft Office Excel</code> 工作表的格式，用03版Office，新建<code>Excel</code>默认保存的<code>Excel</code>文件格式的后缀是<code>.xls</code>；<code>xlsx</code>是07版<code>Microsoft Office Excel</code> 工作表的格式，用07版Office，新建<code>Excel</code>默认保存的的<code>Excel</code>文件格式后缀是<code>.xlsx</code>。</li><li><strong>容量不同</strong>：<code>xls</code>只有65536行、256列；<code>xlsx</code>可以有1048576行、16384列</li></ul></blockquote><p><code>JSON</code>（<code>JavaScript Object Notation</code>, <code>JS</code>对象简谱）是一种轻量级的数据交换格式。它基于 <a href="https://baike.baidu.com/item/ECMAScript?fromModule=lemma_inlink">ECMAScript</a>（欧洲计算机协会制定的<code>js</code>规范）的一个子集，采用完全独立于编程语言的文本格式来存储和表示数据。简洁和清晰的层次结构使得<code>JSON</code>成为理想的数据交换语言。 易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。</p><p><code>XML</code> (<code>Extensible Markup Language</code>, 可扩展标记语言) ，<a href="https://baike.baidu.com/item/%E6%A0%87%E5%87%86%E9%80%9A%E7%94%A8%E6%A0%87%E8%AE%B0%E8%AF%AD%E8%A8%80/6805073?fromModule=lemma_inlink">标准通用标记语言</a>的子集，可以用来标记数据、定义数据类型，是一种允许用户对自己的标记语言进行定义的源语言。 <code>XML</code>是标准通用标记语言可扩展性良好，内容与形式分离，遵循严格的语法要求，保值性良好等优点。</p><p><code>TXT</code>文件是微软在操作系统上附带的一种文本格式，是最常见的一种文件格式，早在<a href="https://baike.baidu.com/item/DOS/32025?fromModule=lemma_inlink">DOS</a>时代应用就很多，主要存储文本信息，即为文字信息，现在的操作系统大多使用记事本等程序保存，大多数软件可以查看，如记事本，浏览器等等。</p><h2 id="⛄Python之读写文件"><a href="#⛄Python之读写文件" class="headerlink" title="⛄Python之读写文件"></a>⛄Python之读写文件</h2><h3 id="👀CSV"><a href="#👀CSV" class="headerlink" title="👀CSV"></a>👀CSV</h3><h4 id="（1）CSV库读取"><a href="#（1）CSV库读取" class="headerlink" title="（1）CSV库读取"></a><strong>（1）CSV库读取</strong></h4><p><code>csv.reader</code>：以列表的形式返回读取的数据；<br><code>csv.writer</code>：以列表的形式写入数据；<br><code>csv.DictReader</code>：以字典的形式返回读取的数据；<br><code>csv.DictWriter</code>：以字典的形式写入数据。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">r&quot;D:\Desktop\data.csv&quot;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    reader = csv.reader(file)</span><br><span class="line">    <span class="built_in">print</span>(reader)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">20</span>)</span><br><span class="line">    <span class="comment"># 用next()函数读取文件时：如果只执行一次默认读取第一行。</span></span><br><span class="line">    headers = <span class="built_in">next</span>(reader)</span><br><span class="line">    <span class="built_in">print</span>(headers)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">20</span>)</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> reader:</span><br><span class="line">        <span class="built_in">print</span>(row)</span><br><span class="line">        <span class="built_in">print</span>(row[<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">&lt;_csv.reader <span class="built_in">object</span> at <span class="number">0x000001D6B95F1668</span>&gt;</span><br><span class="line">********************</span><br><span class="line">[<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;gender&#x27;</span>, <span class="string">&#x27;age&#x27;</span>, <span class="string">&#x27;hobby&#x27;</span>]</span><br><span class="line">********************</span><br><span class="line">[<span class="string">&#x27;小红&#x27;</span>, <span class="string">&#x27;女&#x27;</span>, <span class="string">&#x27;20&#x27;</span>, <span class="string">&#x27;跑步&#x27;</span>]</span><br><span class="line"><span class="number">20</span></span><br><span class="line">[<span class="string">&#x27;小汤&#x27;</span>, <span class="string">&#x27;男&#x27;</span>, <span class="string">&#x27;22&#x27;</span>, <span class="string">&#x27;篮球&#x27;</span>]</span><br><span class="line"><span class="number">22</span></span><br><span class="line">[<span class="string">&#x27;小李&#x27;</span>, <span class="string">&#x27;男&#x27;</span>, <span class="string">&#x27;24&#x27;</span>, <span class="string">&#x27;足球&#x27;</span>]</span><br><span class="line"><span class="number">24</span></span><br></pre></td></tr></table></figure><p><strong><code>namedtuple</code></strong>(具名元组)，因为元组的局限性：不能为元组内部的数据进行命名，所以往往我们并不知道一个元组所要表达的意义，在这里引入了<code>collections.namedtuple</code> 这个工厂函数，来构造一个带字段名的元组。具名元组的实例和普通元组消耗的内存一样多，因为字段名都被存在对应的类里面。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 获取一行数据中的某一列数据</span></span><br><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">r&quot;D:\Desktop\data.csv&quot;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    reader = csv.reader(file)</span><br><span class="line">    <span class="built_in">print</span>(reader)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">20</span>)</span><br><span class="line">    headers = <span class="built_in">next</span>(reader)</span><br><span class="line">    <span class="comment"># namedtuple(具名元组)返回一个具名元组子类 typename</span></span><br><span class="line">    Row = namedtuple(<span class="string">&#x27;Row&#x27;</span>, headers)</span><br><span class="line">    <span class="built_in">print</span>(headers)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">20</span>)</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> reader:</span><br><span class="line">        <span class="comment"># 列表或元组前面加星号作用是将列表解开成两个独立的参数;</span></span><br><span class="line">        <span class="comment"># 字典前面加两个星号,是将字典的值解开成独立的元素作为形参。</span></span><br><span class="line">        row = Row(*row)</span><br><span class="line">        <span class="comment"># 获取一行数据中的某一列数据。</span></span><br><span class="line">        <span class="built_in">print</span>(row.name,row.age)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">&lt;_csv.reader <span class="built_in">object</span> at <span class="number">0x000001D6B95F1128</span>&gt;</span><br><span class="line">********************</span><br><span class="line">[<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;gender&#x27;</span>, <span class="string">&#x27;age&#x27;</span>, <span class="string">&#x27;hobby&#x27;</span>]</span><br><span class="line">********************</span><br><span class="line">小红 <span class="number">20</span></span><br><span class="line">小汤 <span class="number">22</span></span><br><span class="line">小李 <span class="number">24</span></span><br></pre></td></tr></table></figure><p>简单使用<code>csv.DictReader</code></p><blockquote><p>可以深入了解该函数的参数：</p><ul><li><code>csv.DictReader()</code>之<code>fieldnames</code>参数</li><li><code>csv.DictReader()</code>之<code>restkey</code>参数</li><li><code>csv.DictReader()</code>之<code>restval</code>参数</li></ul></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">r&quot;D:\Desktop\data.csv&quot;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    # 如果没有字段名，参数fieldnames</span></span><br><span class="line"><span class="string">    reader = csv.DictReader(file,fieldnames = [&#x27;name&#x27;,&#x27;gender&#x27;,&#x27;age&#x27;,&#x27;hobby&#x27;])</span></span><br><span class="line"><span class="string">    # next()方法用于移动指针</span></span><br><span class="line"><span class="string">    head_row = next(reader)</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    reader = csv.DictReader(file)</span><br><span class="line">    <span class="built_in">print</span>(reader)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">20</span>)</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> reader:</span><br><span class="line">        <span class="comment"># OrderedDict是一种长相类似于列表的数据类型，该列表中嵌套着元组；</span></span><br><span class="line">        <span class="comment"># 每个元组中的第一个元素为键，第二个元素为值（类似于字典）</span></span><br><span class="line">        <span class="built_in">print</span>(row)</span><br><span class="line">        <span class="built_in">print</span>(row[<span class="string">&quot;name&quot;</span>],row[<span class="string">&quot;hobby&quot;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">&lt;csv.DictReader <span class="built_in">object</span> at <span class="number">0x000001D6B95F0388</span>&gt;</span><br><span class="line">********************</span><br><span class="line">OrderedDict([(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;小红&#x27;</span>), (<span class="string">&#x27;gender&#x27;</span>, <span class="string">&#x27;女&#x27;</span>), (<span class="string">&#x27;age&#x27;</span>, <span class="string">&#x27;20&#x27;</span>), (<span class="string">&#x27;hobby&#x27;</span>, <span class="string">&#x27;跑步&#x27;</span>)])</span><br><span class="line">小红 跑步</span><br><span class="line">OrderedDict([(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;小汤&#x27;</span>), (<span class="string">&#x27;gender&#x27;</span>, <span class="string">&#x27;男&#x27;</span>), (<span class="string">&#x27;age&#x27;</span>, <span class="string">&#x27;22&#x27;</span>), (<span class="string">&#x27;hobby&#x27;</span>, <span class="string">&#x27;篮球&#x27;</span>)])</span><br><span class="line">小汤 篮球</span><br><span class="line">OrderedDict([(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;小李&#x27;</span>), (<span class="string">&#x27;gender&#x27;</span>, <span class="string">&#x27;男&#x27;</span>), (<span class="string">&#x27;age&#x27;</span>, <span class="string">&#x27;24&#x27;</span>), (<span class="string">&#x27;hobby&#x27;</span>, <span class="string">&#x27;足球&#x27;</span>)])</span><br><span class="line">小李 足球</span><br></pre></td></tr></table></figure><h4 id="（2）CSV库写入"><a href="#（2）CSV库写入" class="headerlink" title="（2）CSV库写入"></a><strong>（2）CSV库写入</strong></h4><p><code>csv.reader</code>：以列表的形式返回读取的数据；<br><code>csv.writer</code>：以列表的形式写入数据；<br><code>csv.DictReader</code>：以字典的形式返回读取的数据；<br><code>csv.DictWriter</code>：以字典的形式写入数据。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="comment"># 1. 创建文件对象（指定文件名，模式，编码方式）,指定下次写入在这次的下一行</span></span><br><span class="line"><span class="comment"># 注意引入newline=&quot;&quot;，不然加入的数据会空一行</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">r&quot;D:\Desktop\data.csv&quot;</span>, <span class="string">&quot;a+&quot;</span>, encoding=<span class="string">&quot;gbk&quot;</span>, newline=<span class="string">&quot;&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="comment"># 2. 基于文件对象构建 csv写入对象</span></span><br><span class="line">    csv_writer = csv.writer(f)</span><br><span class="line">    <span class="comment"># 3. 构建列表头</span></span><br><span class="line">    <span class="comment"># name = [&#x27;name&#x27;,&#x27;gender&#x27;,&#x27;age&#x27;,&#x27;hobby&#x27;]</span></span><br><span class="line">    <span class="comment"># csv_writer.writerow(name)</span></span><br><span class="line">    <span class="comment"># 4. 写入csv文件内容</span></span><br><span class="line">    z = [[<span class="string">&quot;小ai&quot;</span>, <span class="string">&quot;男&quot;</span>, <span class="number">21</span>, <span class="string">&quot;篮球&quot;</span>],[<span class="string">&quot;小张&quot;</span>, <span class="string">&quot;男&quot;</span>, <span class="number">25</span>, <span class="string">&quot;篮球&quot;</span>]]</span><br><span class="line">    csv_writer.writerows(z)</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">r&quot;D:\Desktop\data.csv&quot;</span>, <span class="string">&quot;r+&quot;</span>, encoding=<span class="string">&quot;gbk&quot;</span>, newline=<span class="string">&quot;&quot;</span>) <span class="keyword">as</span> f:   </span><br><span class="line">    reader = csv.reader(f)</span><br><span class="line">    headers = <span class="built_in">next</span>(reader)</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> reader:</span><br><span class="line">        <span class="built_in">print</span>(row)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[<span class="string">&#x27;小红&#x27;</span>, <span class="string">&#x27;女&#x27;</span>, <span class="string">&#x27;20&#x27;</span>, <span class="string">&#x27;跑步&#x27;</span>]</span><br><span class="line">[<span class="string">&#x27;小汤&#x27;</span>, <span class="string">&#x27;男&#x27;</span>, <span class="string">&#x27;22&#x27;</span>, <span class="string">&#x27;篮球&#x27;</span>]</span><br><span class="line">[<span class="string">&#x27;小李&#x27;</span>, <span class="string">&#x27;男&#x27;</span>, <span class="string">&#x27;24&#x27;</span>, <span class="string">&#x27;足球&#x27;</span>]</span><br><span class="line">[<span class="string">&#x27;小ai&#x27;</span>, <span class="string">&#x27;男&#x27;</span>, <span class="string">&#x27;21&#x27;</span>, <span class="string">&#x27;篮球&#x27;</span>]</span><br><span class="line">[<span class="string">&#x27;小张&#x27;</span>, <span class="string">&#x27;男&#x27;</span>, <span class="string">&#x27;25&#x27;</span>, <span class="string">&#x27;篮球&#x27;</span>]</span><br></pre></td></tr></table></figure><blockquote><p>如果<code>csvfile</code>是文件对象，则打开它时应使用<code>newline=&quot;&quot;</code>。如果没有指定<code>newline=&quot;&quot;</code>，则嵌入引号中的换行符将无法正确解析，并且在写入时，使用<code>\r\n</code>换行的平台会有多余的<code>\r</code>写入。由于<code>csv</code>模块会执行自己的（通用）换行符处理，因此指定<code>newline=&quot;&quot;</code>应该总是安全的。</p><p><code>open()</code>完成后必须调用<code>close()</code>方法关闭文件，因为文件对象会占用操作系统资源，并且操作系统同一时间能打开的文件数量也是有限的。由于文件读写时有可能产生<code>IOError</code>，一旦出错，后面的<code>f.close()</code>就不会调用。<code>with open()</code>则可以避免这样的情况。</p></blockquote><table><thead><tr><th align="center">模式</th><th>描述</th></tr></thead><tbody><tr><td align="center"><code>t</code></td><td>以<strong>文本格式</strong>打开文件（默认）。一般用于文本文件，如：<code>txt</code>。</td></tr><tr><td align="center"><code>b</code></td><td>以<strong>二进制格式</strong>打开文件。一般用于非文本文件，如：图片。</td></tr><tr><td align="center"><code>r</code></td><td>以<strong>只读</strong>方式打开文件（默认模式）。文件的指针将会放在文件的开头，如果文件不存在会<strong>报错</strong>。</td></tr><tr><td align="center"><code>w</code></td><td>以<strong>只写</strong>方式打开文件。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，则创建新文件。</td></tr><tr><td align="center"><code>a</code></td><td>以<strong>追加</strong>方式打开文件，同样是只写，不允许进行读操作。如果文件已存在，文件指针将会放在文件的结尾，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。</td></tr><tr><td align="center"><code>r+</code></td><td>打开一个文件用于读写。如果文件存在，则打开文件，将文件指针定位在文件头，新写入的内容在原有内容的前面；如果文件不存在会报错。</td></tr><tr><td align="center"><code>w+</code></td><td>打开一个文件用于读写。如果文件存在，则打开文件，清空原有内容，进入编辑模式；如果文件不存在，则创建一个新文件进行读写操作。</td></tr><tr><td align="center"><code>a+</code></td><td>以追加模式打开一个文件用于读写。如果文件存在，则打开文件，将文件指针定位在文件尾，新写入的内容在原有内容的后面；如果文件不存在，则创建一个新文件用于读写。</td></tr><tr><td align="center"><code>rb</code></td><td>以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。这是默认模式。一般用于非文本文件如图片等。</td></tr><tr><td align="center"><code>wb</code></td><td>以二进制格式打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。</td></tr><tr><td align="center"><code>ab</code></td><td>以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。</td></tr><tr><td align="center"><code>rb+</code></td><td>以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。一般用于非文本文件如图片等。</td></tr><tr><td align="center"><code>wb+</code></td><td>以二进制格式打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。</td></tr><tr><td align="center"><code>ab+</code></td><td>以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。</td></tr></tbody></table><blockquote><p><code>csv</code>库常见的问题</p><ul><li><code>csv.DictWriter()</code>：该函数返回的结果遍历一次之后，再次遍历返回的结果是空列表。</li><li><code>csv.reader()</code>：返回的结果是结构体，需要<code>for</code>循环才能调用，不能像<code>list</code>那样直接选取特定单元格。</li><li>通过列名来查找指定列的操作麻烦。</li></ul></blockquote><h4 id="（3）pandas库读取"><a href="#（3）pandas库读取" class="headerlink" title="（3）pandas库读取"></a><strong>（3）pandas库读取</strong></h4><blockquote><p>使用<code>pandas</code>读取<code>csv</code>文件的优势：</p><ul><li>方便，有专门支持读取<code>csv</code>文件的<code>pd.read_csv()</code>函数；</li><li>将<code>csv</code>转换成二维列表形式；</li><li>支持通过列名查找特定列；</li><li>相比<code>csv</code>库，事半功倍。</li></ul></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pandas.read_csv(filepath_or_buffer, sep=, delimiter=<span class="literal">None</span>, header=‘infer’, names=<span class="literal">None</span>, index_col=<span class="literal">None</span>, usecols=<span class="literal">None</span>, squeeze=<span class="literal">False</span>, prefix=<span class="literal">None</span>, mangle_dupe_cols=<span class="literal">True</span>, dtype=<span class="literal">None</span>, engine=<span class="literal">None</span>, converters=<span class="literal">None</span>, true_values=<span class="literal">None</span>, false_values=<span class="literal">None</span>, skipinitialspace=<span class="literal">False</span>, skiprows=<span class="literal">None</span>, skipfooter=<span class="number">0</span>, nrows=<span class="literal">None</span>, na_values=<span class="literal">None</span>, keep_default_na=<span class="literal">True</span>, na_filter=<span class="literal">True</span>, verbose=<span class="literal">False</span>, skip_blank_lines=<span class="literal">True</span>, parse_dates=<span class="literal">False</span>, infer_datetime_format=<span class="literal">False</span>, keep_date_col=<span class="literal">False</span>, date_parser=<span class="literal">None</span>, dayfirst=<span class="literal">False</span>, cache_dates=<span class="literal">True</span>, iterator=<span class="literal">False</span>, chunksize=<span class="literal">None</span>, compression=‘infer’, thousands=<span class="literal">None</span>, decimal=’.’, lineterminator=<span class="literal">None</span>, quotechar=<span class="string">&#x27;&quot;&#x27;</span>, quoting=<span class="number">0</span>, doublequote=<span class="literal">True</span>, escapechar=<span class="literal">None</span>, comment=<span class="literal">None</span>, encoding=<span class="literal">None</span>, dialect=<span class="literal">None</span>, error_bad_lines=<span class="literal">True</span>, warn_bad_lines=<span class="literal">True</span>, delim_whitespace=<span class="literal">False</span>, low_memory=<span class="literal">True</span>, memory_map=<span class="literal">False</span>, float_precision=<span class="literal">None</span>, storage_options=<span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 常用参数详解</span></span><br><span class="line">（<span class="number">1</span>）filepath_or_buffer：必须有的参数，其它都是按需求选用的。文件所在处的路径。</span><br><span class="line">（<span class="number">2</span>）sep：指定分隔符，默认为逗号<span class="string">&#x27;,&#x27;</span>。</span><br><span class="line">（<span class="number">3</span>）delimiter：<span class="built_in">str</span>/default/<span class="literal">None</span>，定界符，备选分隔符（如果指定该参数，则sep参数失效）</span><br><span class="line">（<span class="number">4</span>）header：<span class="built_in">int</span> <span class="keyword">or</span> <span class="built_in">list</span> of ints, default ‘infer’，指定哪一行作为表头。默认设置为<span class="number">0</span>（即第一行作为表头），如果没有表头的话，要修改参数，设置header=<span class="literal">None</span>。</span><br><span class="line">（<span class="number">5</span>）names：指定列的名称，用列表表示。一般我们没有表头，即header=<span class="literal">None</span>时，这个用来添加列名就很有用啦。</span><br><span class="line">（<span class="number">6</span>）index_col：指定哪一列数据作为行索引，可以是一列，也可以多列。多列的话，会看到一个分层索引。</span><br><span class="line">（<span class="number">7</span>）squeeze：布尔值，默认为<span class="literal">False</span>。如果解析的数据仅包含一列，则返回一个Series。</span><br><span class="line">（<span class="number">8</span>）prefix：给列名添加前缀。如prefix=<span class="string">&quot;x&quot;</span>,会出来<span class="string">&quot;x1&quot;</span>、<span class="string">&quot;x2&quot;</span>、<span class="string">&quot;x3&quot;</span>。</span><br><span class="line">（<span class="number">9</span>）nrows：<span class="built_in">int</span>, default <span class="literal">None</span>。需要读取的行数（从文件头开始算起）。</span><br><span class="line">（<span class="number">10</span>）encoding：编码方式。</span><br><span class="line">（<span class="number">11</span>）skiprows：<span class="built_in">list</span>-like <span class="keyword">or</span> integer, default <span class="literal">None</span>。在文件开始处要跳过的行号（索引为<span class="number">0</span>）或要跳过的行数（整数）。</span><br><span class="line">......</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">df = pd.read_csv(<span class="string">r&quot;D:\Desktop\data.csv&quot;</span>,encoding=<span class="string">&quot;gbk&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(df) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="built_in">print</span>(df.index.values)</span><br><span class="line"><span class="built_in">print</span>(df.columns.values)</span><br><span class="line"><span class="built_in">print</span>(df.values)</span><br><span class="line"><span class="comment"># 通过位置选取</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;=&quot;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="built_in">print</span>(df.iloc[:,<span class="number">0</span>:<span class="number">3</span>].values)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(df.iloc[:,<span class="number">0</span>:<span class="number">3</span>].values))</span><br><span class="line"><span class="built_in">print</span>(df.iloc[:,<span class="number">0</span>:<span class="number">3</span>].values.tolist())</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(df.iloc[:,<span class="number">0</span>:<span class="number">3</span>].values.tolist()))</span><br><span class="line"><span class="comment"># 通过标签选取</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;-&quot;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="built_in">print</span>(df.loc[[<span class="number">0</span>,<span class="number">3</span>],[<span class="string">&quot;name&quot;</span>,<span class="string">&quot;hobby&quot;</span>]].values)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">  name gender  age hobby</span><br><span class="line"><span class="number">0</span>   小红      女   <span class="number">20</span>    跑步</span><br><span class="line"><span class="number">1</span>   小汤      男   <span class="number">22</span>    篮球</span><br><span class="line"><span class="number">2</span>   小李      男   <span class="number">24</span>    足球</span><br><span class="line"><span class="number">3</span>  小ai      男   <span class="number">21</span>    篮球</span><br><span class="line"><span class="number">4</span>   小张      男   <span class="number">25</span>    篮球</span><br><span class="line">********************</span><br><span class="line">[<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>]</span><br><span class="line">[<span class="string">&#x27;name&#x27;</span> <span class="string">&#x27;gender&#x27;</span> <span class="string">&#x27;age&#x27;</span> <span class="string">&#x27;hobby&#x27;</span>]</span><br><span class="line">[[<span class="string">&#x27;小红&#x27;</span> <span class="string">&#x27;女&#x27;</span> <span class="number">20</span> <span class="string">&#x27;跑步&#x27;</span>]</span><br><span class="line"> [<span class="string">&#x27;小汤&#x27;</span> <span class="string">&#x27;男&#x27;</span> <span class="number">22</span> <span class="string">&#x27;篮球&#x27;</span>]</span><br><span class="line"> [<span class="string">&#x27;小李&#x27;</span> <span class="string">&#x27;男&#x27;</span> <span class="number">24</span> <span class="string">&#x27;足球&#x27;</span>]</span><br><span class="line"> [<span class="string">&#x27;小ai&#x27;</span> <span class="string">&#x27;男&#x27;</span> <span class="number">21</span> <span class="string">&#x27;篮球&#x27;</span>]</span><br><span class="line"> [<span class="string">&#x27;小张&#x27;</span> <span class="string">&#x27;男&#x27;</span> <span class="number">25</span> <span class="string">&#x27;篮球&#x27;</span>]]</span><br><span class="line">====================</span><br><span class="line">[[<span class="string">&#x27;小红&#x27;</span> <span class="string">&#x27;女&#x27;</span> <span class="number">20</span>]</span><br><span class="line"> [<span class="string">&#x27;小汤&#x27;</span> <span class="string">&#x27;男&#x27;</span> <span class="number">22</span>]</span><br><span class="line"> [<span class="string">&#x27;小李&#x27;</span> <span class="string">&#x27;男&#x27;</span> <span class="number">24</span>]</span><br><span class="line"> [<span class="string">&#x27;小ai&#x27;</span> <span class="string">&#x27;男&#x27;</span> <span class="number">21</span>]</span><br><span class="line"> [<span class="string">&#x27;小张&#x27;</span> <span class="string">&#x27;男&#x27;</span> <span class="number">25</span>]]</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;numpy.ndarray&#x27;</span>&gt;</span><br><span class="line">[[<span class="string">&#x27;小红&#x27;</span>, <span class="string">&#x27;女&#x27;</span>, <span class="number">20</span>], [<span class="string">&#x27;小汤&#x27;</span>, <span class="string">&#x27;男&#x27;</span>, <span class="number">22</span>], [<span class="string">&#x27;小李&#x27;</span>, <span class="string">&#x27;男&#x27;</span>, <span class="number">24</span>], [<span class="string">&#x27;小ai&#x27;</span>, <span class="string">&#x27;男&#x27;</span>, <span class="number">21</span>], [<span class="string">&#x27;小张&#x27;</span>, <span class="string">&#x27;男&#x27;</span>, <span class="number">25</span>]]</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;list&#x27;</span>&gt;</span><br><span class="line">--------------------</span><br><span class="line">[[<span class="string">&#x27;小红&#x27;</span> <span class="string">&#x27;跑步&#x27;</span>]</span><br><span class="line"> [<span class="string">&#x27;小ai&#x27;</span> <span class="string">&#x27;篮球&#x27;</span>]]</span><br></pre></td></tr></table></figure><h4 id="（4）pandas库写入"><a href="#（4）pandas库写入" class="headerlink" title="（4）pandas库写入"></a><strong>（4）pandas库写入</strong></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">DataFrame.to_csv(path_or_buf=<span class="literal">None</span>, sep=<span class="string">&#x27;,&#x27;</span>, na_rep=<span class="string">&#x27;&#x27;</span>, float_format=<span class="literal">None</span>, columns=<span class="literal">None</span>, header=<span class="literal">True</span>, index=<span class="literal">True</span>, index_label=<span class="literal">None</span>, mode=<span class="string">&#x27;w&#x27;</span>, encoding=<span class="literal">None</span>, compression=<span class="string">&#x27;infer&#x27;</span>, quoting=<span class="literal">None</span>, quotechar=<span class="string">&#x27;&quot;&#x27;</span>, lineterminator=<span class="literal">None</span>, chunksize=<span class="literal">None</span>, date_format=<span class="literal">None</span>, doublequote=<span class="literal">True</span>, escapechar=<span class="literal">None</span>, decimal=<span class="string">&#x27;.&#x27;</span>, errors=<span class="string">&#x27;strict&#x27;</span>, storage_options=<span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 常用参数详解</span></span><br><span class="line">（<span class="number">1</span>）path_or_buf：字符串，放文件名、相对路径、文件流等。</span><br><span class="line">（<span class="number">2</span>）sep：字符串，分隔符，跟read_csv()的一个意思。</span><br><span class="line">（<span class="number">3</span>）na_rep：字符串，将NaN转换为特定值。</span><br><span class="line">（<span class="number">4</span>）columns：列表，指定哪些列写进去。</span><br><span class="line">（<span class="number">5</span>）header：默认header=<span class="number">0</span>，如果没有表头，设置header=<span class="literal">None</span>，表示我没有表头呀！</span><br><span class="line">（<span class="number">6</span>）index：关于索引的，默认<span class="literal">True</span>,写入索引</span><br><span class="line">（<span class="number">7</span>）mode：&#123;‘w’, ‘x’, ‘a’&#125;, default ‘w’，写入方式。</span><br><span class="line">（<span class="number">8</span>）encoding：编码方式。</span><br><span class="line">......</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">name = [<span class="string">&quot;小小&quot;</span>,<span class="string">&quot;小耿&quot;</span>]</span><br><span class="line">gender = [<span class="string">&quot;男&quot;</span>,<span class="string">&quot;男&quot;</span>]</span><br><span class="line">age = [<span class="number">20</span>,<span class="number">25</span>]</span><br><span class="line">hobby = [<span class="string">&quot;跳绳&quot;</span>,<span class="string">&quot;羽毛球&quot;</span>]</span><br><span class="line"></span><br><span class="line">dict_data = &#123;<span class="string">&quot;name&quot;</span>:name,<span class="string">&quot;gender&quot;</span>:gender,<span class="string">&quot;age&quot;</span>:age,<span class="string">&quot;hobby&quot;</span>:hobby&#125;</span><br><span class="line">df1 = pd.DataFrame(dict_data)</span><br><span class="line"><span class="comment"># mode = &quot;a&quot;为追加数据,index为每行的索引序号,header为标题</span></span><br><span class="line">df1.to_csv(<span class="string">&quot;D:\Desktop\data.csv&quot;</span>,mode=<span class="string">&quot;a&quot;</span>,index=<span class="literal">False</span>,header=<span class="literal">False</span>,encoding=<span class="string">&quot;gbk&quot;</span>)</span><br><span class="line">df2 = pd.read_csv(<span class="string">r&quot;D:\Desktop\data.csv&quot;</span>,encoding=<span class="string">&quot;gbk&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(df2) </span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">  name gender  age hobby</span><br><span class="line"><span class="number">0</span>   小红      女   <span class="number">20</span>    跑步</span><br><span class="line"><span class="number">1</span>   小汤      男   <span class="number">22</span>    篮球</span><br><span class="line"><span class="number">2</span>   小李      男   <span class="number">24</span>    足球</span><br><span class="line"><span class="number">3</span>  小ai      男   <span class="number">21</span>    篮球</span><br><span class="line"><span class="number">4</span>   小张      男   <span class="number">25</span>    篮球</span><br><span class="line"><span class="number">5</span>   小小      男   <span class="number">20</span>    跳绳</span><br><span class="line"><span class="number">6</span>   小耿      男   <span class="number">25</span>   羽毛球</span><br></pre></td></tr></table></figure><h3 id="👀Excel"><a href="#👀Excel" class="headerlink" title="👀Excel"></a>👀Excel</h3><p><code>python</code>用于读写<code>excel</code>文件的库有很多，除了前面提到的<code>pandas</code>，还有<code>xlrd</code>、<code>xlwt</code>、<code>openpyxl</code>、<code>xlwings</code>等等。<strong>这里以<code>pandas</code>库为例对<code>Excel</code>进行操作</strong>。</p><ul><li><code>xlrd</code>库：从<code>excel</code>中读取数据，支持<code>xls</code>、<code>xlsx</code>；</li><li><code>xlwt</code>库：对<code>excel</code>进行修改操作，不支持对<code>xlsx</code>格式的修改；</li><li><code>xlutils</code>库：在<code>xlw</code>和<code>xlrd</code>中，对一个已存在的文件进行修改；</li><li><code>openpyxl</code>库：主要针对<code>xlsx</code>格式的<code>excel</code>进行读取和编辑；</li><li><code>xlwings</code>库：对<code>xlsx</code>、<code>xls</code>、<code>xlsm</code>格式文件进行读写、格式修改等操作；</li><li><code>xlsxwriter</code>库：用来生成<code>excel</code>表格，插入数据、插入图标等表格操作，不支持读取；</li><li><code>Microsoft Excel API</code>：需安装<code>pywin32</code>，直接与<code>Excel</code>进程通信，可以做任何在<code>Excel</code>里可以做的事情，但比较慢。</li></ul><h4 id="（1）读取Excel文件"><a href="#（1）读取Excel文件" class="headerlink" title="（1）读取Excel文件"></a><strong>（1）读取Excel文件</strong></h4><p><code>read_excel()</code>读取<code>xlsx</code>文件：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pd.read_excel(io, sheet_name=<span class="number">0</span>, header=<span class="number">0</span>, names=<span class="literal">None</span>, index_col=<span class="literal">None</span>, usecols=<span class="literal">None</span>, squeeze=<span class="literal">False</span>,dtype=<span class="literal">None</span>, engine=<span class="literal">None</span>, converters=<span class="literal">None</span>, true_values=<span class="literal">None</span>, false_values=<span class="literal">None</span>, skiprows=<span class="literal">None</span>, nrows=<span class="literal">None</span>, na_values=<span class="literal">None</span>, parse_dates=<span class="literal">False</span>, date_parser=<span class="literal">None</span>, thousands=<span class="literal">None</span>, comment=<span class="literal">None</span>, skipfooter=<span class="number">0</span>, convert_float=<span class="literal">True</span>, **kwds)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 常见参数详解</span></span><br><span class="line">（<span class="number">1</span>）io:文件的路径。</span><br><span class="line">（<span class="number">2</span>）sheet_name:读取的工作表的名称；可以是整型数字、列表名，如果读取多个sheet，也可以是它们组成的列表；以<span class="number">0</span>为起始点。</span><br><span class="line">（<span class="number">3</span>）header:指定哪几行做列名；默认header为<span class="number">0</span>，如果设置为[<span class="number">0</span>,<span class="number">1</span>]，则表示将前两行作为多重索引。</span><br><span class="line">（<span class="number">4</span>）names:自定义列名；长度必须和excel的列大小相同；如果缺少列名，使用names指定列名字，会替代原来的列表头。</span><br><span class="line">（<span class="number">5</span>）index_col:用作索引的列；可以是某列的名字，也可以是整型数字或列表。</span><br><span class="line">（<span class="number">6</span>）usecols:指定读取的列；列从<span class="number">0</span>开始，可以是列表，也可以使用Excel的列名，如<span class="string">&#x27;A&#x27;</span>，<span class="string">&#x27;B&#x27;</span>等字母。</span><br><span class="line">（<span class="number">7</span>）squeeze:一列数据时，返回Series还是DataFrame。仅当Excel只有一列的时候起作用，squeeze为<span class="literal">True</span>时，返回Series，反之返回DataFrame。</span><br><span class="line">（<span class="number">8</span>）skiprows:跳过指定行；skiprows=n，跳过前n行；skiprows=[a,b,c]，跳过第a+<span class="number">1</span>,b+<span class="number">1</span>,c+<span class="number">1</span>行（索引从<span class="number">0</span>开始）；使用skiprows后，可能会跳过行首，也就是列名。</span><br><span class="line">（<span class="number">9</span>）nrows:需要读取的行数，表示只读取excel的前nrows行，包括表头。</span><br><span class="line">（<span class="number">10</span>）skipfooter:跳过末尾n行。</span><br><span class="line">......</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取xlsx,设置sheet位置,详细参数解释可以检索该函数</span></span><br><span class="line">data = pd.read_excel(<span class="string">r&quot;D:\Desktop\data.xlsx&quot;</span>,sheet_name=<span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(data)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(data))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="built_in">print</span>(data.iloc[:,[<span class="number">0</span>,<span class="number">1</span>,<span class="number">3</span>]].values)</span><br><span class="line"><span class="built_in">print</span>(data.iloc[:,[<span class="number">0</span>,<span class="number">1</span>,<span class="number">3</span>]].values.tolist())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">  name gender  age hobby</span><br><span class="line"><span class="number">0</span>   小红      女   <span class="number">20</span>    跑步</span><br><span class="line"><span class="number">1</span>   小汤      男   <span class="number">22</span>    篮球</span><br><span class="line"><span class="number">2</span>   小李      男   <span class="number">24</span>    足球</span><br><span class="line"><span class="number">3</span>  小ai      男   <span class="number">21</span>    篮球</span><br><span class="line"><span class="number">4</span>   小张      男   <span class="number">25</span>    篮球</span><br><span class="line"><span class="number">5</span>   小小      男   <span class="number">20</span>    跳绳</span><br><span class="line"><span class="number">6</span>   小耿      男   <span class="number">25</span>   羽毛球</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;pandas.core.frame.DataFrame&#x27;</span>&gt;</span><br><span class="line">********************</span><br><span class="line">[[<span class="string">&#x27;小红&#x27;</span> <span class="string">&#x27;女&#x27;</span> <span class="string">&#x27;跑步&#x27;</span>]</span><br><span class="line"> [<span class="string">&#x27;小汤&#x27;</span> <span class="string">&#x27;男&#x27;</span> <span class="string">&#x27;篮球&#x27;</span>]</span><br><span class="line"> [<span class="string">&#x27;小李&#x27;</span> <span class="string">&#x27;男&#x27;</span> <span class="string">&#x27;足球&#x27;</span>]</span><br><span class="line"> [<span class="string">&#x27;小ai&#x27;</span> <span class="string">&#x27;男&#x27;</span> <span class="string">&#x27;篮球&#x27;</span>]</span><br><span class="line"> [<span class="string">&#x27;小张&#x27;</span> <span class="string">&#x27;男&#x27;</span> <span class="string">&#x27;篮球&#x27;</span>]</span><br><span class="line"> [<span class="string">&#x27;小小&#x27;</span> <span class="string">&#x27;男&#x27;</span> <span class="string">&#x27;跳绳&#x27;</span>]</span><br><span class="line"> [<span class="string">&#x27;小耿&#x27;</span> <span class="string">&#x27;男&#x27;</span> <span class="string">&#x27;羽毛球&#x27;</span>]]</span><br><span class="line">[[<span class="string">&#x27;小红&#x27;</span>, <span class="string">&#x27;女&#x27;</span>, <span class="string">&#x27;跑步&#x27;</span>], [<span class="string">&#x27;小汤&#x27;</span>, <span class="string">&#x27;男&#x27;</span>, <span class="string">&#x27;篮球&#x27;</span>], [<span class="string">&#x27;小李&#x27;</span>, <span class="string">&#x27;男&#x27;</span>, <span class="string">&#x27;足球&#x27;</span>], [<span class="string">&#x27;小ai&#x27;</span>, <span class="string">&#x27;男&#x27;</span>, <span class="string">&#x27;篮球&#x27;</span>], [<span class="string">&#x27;小张&#x27;</span>, <span class="string">&#x27;男&#x27;</span>, <span class="string">&#x27;篮球&#x27;</span>], [<span class="string">&#x27;小小&#x27;</span>, <span class="string">&#x27;男&#x27;</span>, <span class="string">&#x27;跳绳&#x27;</span>], [<span class="string">&#x27;小耿&#x27;</span>, <span class="string">&#x27;男&#x27;</span>, <span class="string">&#x27;羽毛球&#x27;</span>]]</span><br></pre></td></tr></table></figure><h4 id="（2）写入Excel文件"><a href="#（2）写入Excel文件" class="headerlink" title="（2）写入Excel文件"></a><strong>（2）写入Excel文件</strong></h4><p><code>to.excel()</code>保存<code>xlsx</code>文件：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">DataFrame.to_excel(excel_writer, sheet_name=<span class="string">&#x27;Sheet1&#x27;</span>, na_rep=<span class="string">&#x27;&#x27;</span>, float_format=<span class="literal">None</span>, columns=<span class="literal">None</span>, header=<span class="literal">True</span>, index=<span class="literal">True</span>, index_label=<span class="literal">None</span>, startrow=<span class="number">0</span>, startcol=<span class="number">0</span>, engine=<span class="literal">None</span>, merge_cells=<span class="literal">True</span>, encoding=<span class="literal">None</span>, inf_rep=<span class="string">&#x27;inf&#x27;</span>, verbose=<span class="literal">True</span>, freeze_panes=<span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 参数详解</span></span><br><span class="line">（<span class="number">1</span>）excel_writer:字符串或ExcelWriter对象；文件路径或现有的ExcelWriter。</span><br><span class="line">（<span class="number">2</span>）sheet_name:字符串，默认<span class="string">&quot;Sheet1&quot;</span>将包含DataFrame的表的名称。</span><br><span class="line">（<span class="number">3</span>）na_rep:字符串，默认<span class="string">&#x27;&#x27;</span>缺失数据表示方式。</span><br><span class="line">（<span class="number">4</span>）float_format:字符串，默认<span class="literal">None</span>格式化浮点数的字符串。</span><br><span class="line">（<span class="number">5</span>）columns:序列，可选要编写的列。</span><br><span class="line">（<span class="number">6</span>）header:布尔或字符串列表，默认为Ture。写出列名。如果给定字符串列表，则假定它是列名称的别名。</span><br><span class="line">（<span class="number">7</span>）index:布尔，默认的Ture写行名（索引）。</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p><code>ExcelWriter()</code>可以向同一个<code>excel</code>的不同<code>sheet</code>中写入对应的表格数据，首先需要实例化一个<code>writer</code>对象，传入的主要参数为已存在容器表格的路径及文件名称。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 用于将DataFrame对象写入Excel工作表的类。默认值是对xls使用xlwt，对xlsx使用openpyxl。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">pandas</span>.ExcelWriter(path, engine=<span class="literal">None</span>, date_format=<span class="literal">None</span>, datetime_format=<span class="literal">None</span>, mode=<span class="string">&#x27;w&#x27;</span>, **engine_kwargs)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 参数详解</span></span><br><span class="line">（<span class="number">1</span>）path：<span class="built_in">str</span>，xls或xlsx文件的路径。</span><br><span class="line">（<span class="number">2</span>）engine：<span class="built_in">str</span> (可选参数)，用于编写的引擎，常见的引擎有<span class="string">&quot;openpyxl&quot;</span>和<span class="string">&quot;xlsxwriter&quot;</span>。如果为无，则默认为xlsxwriter，但是<span class="string">&quot;xlsxwriter&quot;</span>模块不支持追加操作，需要追加新的sheet操作选择<span class="string">&quot;openpyxl&quot;</span>参数，否则会报错。注意：只能作为关键字参数传递。</span><br><span class="line">（<span class="number">3</span>）date_format：<span class="built_in">str</span>，默认为<span class="literal">None</span>，格式字符串，用于写入Excel文件的日期(例如<span class="string">&quot;YYYY-MM-DD&quot;</span>)。</span><br><span class="line">（<span class="number">4</span>）datetime_format：<span class="built_in">str</span>，默认为<span class="literal">None</span>，写入Excel文件的日期时间对象的格式字符串。(例如<span class="string">&quot;YYYY-MM-DD HH:MM:SS&quot;</span>)。</span><br><span class="line">（<span class="number">5</span>）mode：&#123;<span class="string">&quot;w&quot;</span>,<span class="string">&quot;a&quot;</span>&#125;，默认为<span class="string">&quot;w&quot;</span>，要使用的文件模式(写或追加)。</span><br><span class="line">（<span class="number">6</span>）if_sheet_exists：&#123;<span class="string">&#x27;error&#x27;</span>,<span class="string">&#x27;new&#x27;</span>,<span class="string">&#x27;replace&#x27;</span>,<span class="string">&#x27;overlay&#x27;</span>&#125;，默认<span class="string">&#x27;error&#x27;</span>，写入的sheet name已存在时代码操作。默认<span class="string">&#x27;error&#x27;</span>表示报错；<span class="string">&#x27;new&#x27;</span>表示engine自动创建新的其他sheet name；<span class="string">&#x27;replace&#x27;</span>表示覆盖原sheet数据，在写入之前删除工作表的内容；<span class="string">&#x27;overlay&#x27;</span>表示将内容写入现有工作表而不删除旧内容。</span><br><span class="line"></span><br><span class="line">为了与CSV编写器兼容，ExcelWriter在写入之前将列表和字典序列化为字符串。</span><br></pre></td></tr></table></figure><blockquote><p>在使用<code>pd.ExcelWriter()</code>的时候可能会出现问题：<strong>if_sheet_exists&#x3D;’overlay’ 不起作用</strong></p><p>查阅资料：<code>if_sheet_exists&#123;&#39;error&#39;, &#39;new&#39;, &#39;replace&#39;, &#39;overlay&#39;&#125;</code>，如果<code>pandas</code>的版本过低，是没有<code>overlay</code>参数的，需要升级<code>pandas</code>版本。我的版本：<code>pandas-2.0.1</code></p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 追加数据</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">name = [<span class="string">&quot;小伟&quot;</span>,<span class="string">&quot;小猪&quot;</span>]</span><br><span class="line">gender = [<span class="string">&quot;男&quot;</span>,<span class="string">&quot;男&quot;</span>]</span><br><span class="line">age = [<span class="number">20</span>,<span class="number">18</span>]</span><br><span class="line">hobby = [<span class="string">&quot;跳绳&quot;</span>,<span class="string">&quot;台球&quot;</span>]</span><br><span class="line">dict_data = &#123;<span class="string">&quot;name&quot;</span>:name,<span class="string">&quot;gender&quot;</span>:gender,<span class="string">&quot;age&quot;</span>:age,<span class="string">&quot;hobby&quot;</span>:hobby&#125;</span><br><span class="line">df = pd.DataFrame(dict_data)</span><br><span class="line"><span class="keyword">with</span> pd.ExcelWriter(<span class="string">r&quot;D:\Desktop\data.xlsx&quot;</span>, engine=<span class="string">&#x27;openpyxl&#x27;</span>, mode=<span class="string">&#x27;a&#x27;</span>,if_sheet_exists=<span class="string">&#x27;overlay&#x27;</span>) <span class="keyword">as</span> writer:</span><br><span class="line">df1 = pd.DataFrame(pd.read_excel(<span class="string">r&quot;D:\Desktop\data.xlsx&quot;</span>, sheet_name=<span class="string">&#x27;data&#x27;</span>)) </span><br><span class="line">df_rows = df1.shape[<span class="number">0</span>] <span class="comment">#获取原数据的行数</span></span><br><span class="line"><span class="comment"># 将数据df写入excel中的sheet1表,从第一个空行开始写</span></span><br><span class="line"><span class="comment"># 为了避免覆盖现有内容，要告诉to_excel方法从新的一行开始写，参数startrow设为&quot;原行数+1&quot;</span></span><br><span class="line">df.to_excel(writer, sheet_name=<span class="string">&#x27;data&#x27;</span>,startrow=df_rows+<span class="number">1</span>, index=<span class="literal">False</span>, header=<span class="literal">False</span>)</span><br><span class="line">df2 = pd.read_excel(<span class="string">r&quot;D:\Desktop\data.xlsx&quot;</span>,sheet_name=<span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(df2) </span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">  name gender  age hobby</span><br><span class="line"><span class="number">0</span>   小红      女   <span class="number">20</span>    跑步</span><br><span class="line"><span class="number">1</span>   小汤      男   <span class="number">22</span>    篮球</span><br><span class="line"><span class="number">2</span>   小李      男   <span class="number">24</span>    足球</span><br><span class="line"><span class="number">3</span>  小ai      男   <span class="number">21</span>    篮球</span><br><span class="line"><span class="number">4</span>   小张      男   <span class="number">25</span>    篮球</span><br><span class="line"><span class="number">5</span>   小小      男   <span class="number">20</span>    跳绳</span><br><span class="line"><span class="number">6</span>   小耿      男   <span class="number">25</span>   羽毛球</span><br><span class="line"><span class="number">7</span>   小伟      男   <span class="number">20</span>    跳绳</span><br><span class="line"><span class="number">8</span>   小猪      男   <span class="number">18</span>    台球</span><br></pre></td></tr></table></figure><p>写入<code>Excel</code>的几种情形与方式（覆盖、新增、追加、对齐），具体细节见：<a href="https://blog.csdn.net/m0_46419189/article/details/123111493">参考博客①</a>、<a href="https://blog.csdn.net/HJ_xing/article/details/112390297">参考博客②</a></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">s1 = pd.DataFrame(np.array([[<span class="string">&#x27;s1&#x27;</span>, <span class="string">&#x27;s1&#x27;</span>, <span class="string">&#x27;s1&#x27;</span>, <span class="string">&#x27;s1&#x27;</span>]]), columns=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>])</span><br><span class="line">s2 = pd.DataFrame(np.array([[<span class="string">&#x27;s2&#x27;</span>, <span class="string">&#x27;s2&#x27;</span>, <span class="string">&#x27;s2&#x27;</span>, <span class="string">&#x27;s2&#x27;</span>]]), columns=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># （1）删除文件原有数据,只保留s2一份数据(最后一份)</span></span><br><span class="line"><span class="comment"># s1.to_excel(r&quot;D:\Desktop\test.xlsx&quot;, sheet_name=&quot;111&quot;, index=False)</span></span><br><span class="line"><span class="comment"># s2.to_excel(r&quot;D:\Desktop\test.xlsx&quot;, sheet_name=&quot;222&quot;, index=False)</span></span><br><span class="line"><span class="keyword">with</span> pd.ExcelWriter(<span class="string">r&quot;D:\Desktop\test2.xlsx&quot;</span>) <span class="keyword">as</span> writer:</span><br><span class="line">    <span class="comment"># (2) 删除文件原有数据,同时保留s1和s2两份数据</span></span><br><span class="line">    s1.to_excel(writer, sheet_name=<span class="string">&quot;111&quot;</span>, index=<span class="literal">False</span>)</span><br><span class="line">    s2.to_excel(writer, sheet_name=<span class="string">&quot;222&quot;</span>, index=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><h3 id="👀JSON"><a href="#👀JSON" class="headerlink" title="👀JSON"></a>👀JSON</h3><p>常见的处理<code>JSON</code>文件的第三方库（<strong>速度不同</strong>）包括：<code>json</code>、<code>simplejson</code>、<code>ujson</code>、<code>orjson</code>、<code>simdjson</code>、<code>rapidjson</code>。一般情况下的<code>json</code>文件，存储的是<code>python</code>中的一个<code>dict</code>。这里以<code>map.geojson</code>文件和<strong>CPython</strong> 本身的<code>json</code>模块为例，源文件内容如下。<a href="https://blog.csdn.net/qq_46293423/article/details/105785007">参考博客①</a>、<a href="https://zhuanlan.zhihu.com/p/360368839">参考博客②</a></p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;FeatureCollection&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;features&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Feature&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;geometry&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;coordinates&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">[</span><span class="punctuation">[</span><span class="number">116.3591064789793</span><span class="punctuation">,</span> <span class="number">40.0611769097348</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="punctuation">[</span><span class="number">116.35882714532096</span><span class="punctuation">,</span> <span class="number">40.06035824493355</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="punctuation">[</span><span class="number">116.3588680234169</span><span class="punctuation">,</span> <span class="number">40.06017052423036</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="punctuation">[</span><span class="number">116.3592154872361</span><span class="punctuation">,</span> <span class="number">40.05968557668524</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="punctuation">[</span><span class="number">116.35964470724883</span><span class="punctuation">,</span> <span class="number">40.05949263960517</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="punctuation">[</span><span class="number">116.36125939205749</span><span class="punctuation">,</span> <span class="number">40.05968557668524</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="punctuation">[</span><span class="number">116.36073478982053</span><span class="punctuation">,</span> <span class="number">40.06143241456951</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="punctuation">[</span><span class="number">116.3591064789793</span><span class="punctuation">,</span> <span class="number">40.0611769097348</span><span class="punctuation">]</span><span class="punctuation">]</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Polygon&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Feature&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;geometry&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;coordinates&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="number">116.35838429946176</span><span class="punctuation">,</span> <span class="number">40.0595499993847</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Point&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Feature&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;geometry&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;coordinates&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="number">116.36078873507478</span><span class="punctuation">,</span> <span class="number">40.06152377992771</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Point&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>使用<code>JSON</code>函数需要导入<code>json</code>库：<code>import json</code></p><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td><code>json.loads()</code></td><td>将已编码的<code>JSON</code>字符串解码为<code>Python</code>对象</td></tr><tr><td><code>json.dumps()</code></td><td>将<code>Python</code>对象编码成<code>JSON</code>字符串</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">json.loads(s, *, cls=<span class="literal">None</span>, object_hook=<span class="literal">None</span>, parse_float=<span class="literal">None</span>, parse_int=<span class="literal">None</span>, parse_constant=<span class="literal">None</span>, object_pairs_hook=<span class="literal">None</span>, **kw)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 参数详解</span></span><br><span class="line">（<span class="number">1</span>）s：要解码的JSON字符串。</span><br><span class="line">（<span class="number">2</span>）cls：指定用于解码JSON字符串的自定义类。</span><br><span class="line">（<span class="number">3</span>）object_hook：指定一个回调函数，将解码后的JSON对象转换成其他Python对象。</span><br><span class="line">（<span class="number">4</span>）parse_float：指定一个回调函数，将解码后的JSON浮点数转换成Python浮点数。</span><br><span class="line">（<span class="number">5</span>）parse_int：指定一个回调函数，将解码后的JSON整数转换成Python整数。</span><br><span class="line">（<span class="number">6</span>）parse_constant：指定一个回调函数，用于解析JSON中的常量（例如null，true，false）。</span><br><span class="line">（<span class="number">7</span>）object_pairs_hook：指定一个回调函数，将解码后的JSON对象返回为Python的键值对。</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">json.dumps(obj, *, skipkeys=<span class="literal">False</span>, ensure_ascii=<span class="literal">True</span>, check_circular=<span class="literal">True</span>, allow_nan=<span class="literal">True</span>, cls=<span class="literal">None</span>, indent=<span class="literal">None</span>, separators=<span class="literal">None</span>, default=<span class="literal">None</span>, sort_keys=<span class="literal">False</span>, **kw)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 参数详解</span></span><br><span class="line">（<span class="number">1</span>）obj：转化成json的对象。</span><br><span class="line">（<span class="number">2</span>）skipkeys：是否跳过无法被JSON序列化的key（包括<span class="built_in">str</span>, <span class="built_in">int</span>, <span class="built_in">float</span>, <span class="built_in">bool</span>, <span class="literal">None</span>）。</span><br><span class="line">（<span class="number">3</span>）ensure_ascii：输出保证将所有输入的非ASCII字符转义。</span><br><span class="line">（<span class="number">4</span>）check_circular：是否检查循环引用。</span><br><span class="line">（<span class="number">5</span>）allow_nan：是否允许JSON规范外的<span class="built_in">float</span>数据(nan, inf, -inf)。</span><br><span class="line">（<span class="number">6</span>）indent：是一个正整数, 代表序列化后的缩进。</span><br><span class="line">（<span class="number">7</span>）separators：是一个格式为 (item_separator, key_separator) 的元组, 默认取值为 (<span class="string">&#x27;,&#x27;</span>,<span class="string">&#x27;:&#x27;</span>)。</span><br><span class="line">（<span class="number">8</span>）default：是一个函数, 当某个value无法被序列化时, 对其调用该函数。</span><br><span class="line">（<span class="number">9</span>）sort_keys：是否对数据按照key进行排序。</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 读取json</span></span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">r&quot;D:\Desktop\map.geojson&quot;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    content = f.read()</span><br><span class="line">    a = json.loads(content)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">type</span>(a))</span><br><span class="line">    <span class="built_in">print</span>(a)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">20</span>)</span><br><span class="line">    <span class="built_in">print</span>(a[<span class="string">&quot;features&quot;</span>][<span class="number">2</span>][<span class="string">&quot;geometry&quot;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;dict&#x27;</span>&gt;</span><br><span class="line">&#123;<span class="string">&#x27;type&#x27;</span>: <span class="string">&#x27;FeatureCollection&#x27;</span>, <span class="string">&#x27;features&#x27;</span>: [&#123;<span class="string">&#x27;type&#x27;</span>: <span class="string">&#x27;Feature&#x27;</span>, <span class="string">&#x27;properties&#x27;</span>: &#123;&#125;, <span class="string">&#x27;geometry&#x27;</span>: &#123;<span class="string">&#x27;coordinates&#x27;</span>: [[[<span class="number">116.3591064789793</span>, <span class="number">40.0611769097348</span>], [<span class="number">116.35882714532096</span>, <span class="number">40.06035824493355</span>], [<span class="number">116.3588680234169</span>, <span class="number">40.06017052423036</span>], [<span class="number">116.3592154872361</span>, <span class="number">40.05968557668524</span>], [<span class="number">116.35964470724883</span>, <span class="number">40.05949263960517</span>], [<span class="number">116.36125939205749</span>, <span class="number">40.05968557668524</span>], [<span class="number">116.36073478982053</span>, <span class="number">40.06143241456951</span>], [<span class="number">116.3591064789793</span>, <span class="number">40.0611769097348</span>]]], <span class="string">&#x27;type&#x27;</span>: <span class="string">&#x27;Polygon&#x27;</span>&#125;&#125;, &#123;<span class="string">&#x27;type&#x27;</span>: <span class="string">&#x27;Feature&#x27;</span>, <span class="string">&#x27;properties&#x27;</span>: &#123;&#125;, <span class="string">&#x27;geometry&#x27;</span>: &#123;<span class="string">&#x27;coordinates&#x27;</span>: [<span class="number">116.35838429946176</span>, <span class="number">40.0595499993847</span>], <span class="string">&#x27;type&#x27;</span>: <span class="string">&#x27;Point&#x27;</span>&#125;&#125;, &#123;<span class="string">&#x27;type&#x27;</span>: <span class="string">&#x27;Feature&#x27;</span>, <span class="string">&#x27;properties&#x27;</span>: &#123;&#125;, <span class="string">&#x27;geometry&#x27;</span>: &#123;<span class="string">&#x27;coordinates&#x27;</span>: [<span class="number">116.36078873507478</span>, <span class="number">40.06152377992771</span>], <span class="string">&#x27;type&#x27;</span>: <span class="string">&#x27;Point&#x27;</span>&#125;&#125;]&#125;</span><br><span class="line">********************</span><br><span class="line">&#123;<span class="string">&#x27;coordinates&#x27;</span>: [<span class="number">116.36078873507478</span>, <span class="number">40.06152377992771</span>], <span class="string">&#x27;type&#x27;</span>: <span class="string">&#x27;Point&#x27;</span>&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将字典保存成json</span></span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line">a = &#123;</span><br><span class="line">     <span class="string">&quot;type&quot;</span>: <span class="string">&quot;Feature&quot;</span>,</span><br><span class="line">     <span class="string">&quot;properties&quot;</span>: &#123;&#125;,</span><br><span class="line">     <span class="string">&quot;geometry&quot;</span>: &#123;</span><br><span class="line">         <span class="string">&quot;coordinates&quot;</span>: [<span class="number">116.36078873507478</span>, <span class="number">40.06152377992771</span>],</span><br><span class="line">         <span class="string">&quot;type&quot;</span>: <span class="string">&quot;Point&quot;</span></span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">b_str = json.dumps(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(b_str))</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">r&quot;D:\Desktop\new_json.json&quot;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(b_str)</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">r&quot;D:\Desktop\new_json.json&quot;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    content = f.read()</span><br><span class="line">    a = json.loads(content)</span><br><span class="line">    <span class="built_in">print</span>(a)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;str&#x27;</span>&gt;</span><br><span class="line">&#123;<span class="string">&#x27;type&#x27;</span>: <span class="string">&#x27;Feature&#x27;</span>, <span class="string">&#x27;properties&#x27;</span>: &#123;&#125;, <span class="string">&#x27;geometry&#x27;</span>: &#123;<span class="string">&#x27;coordinates&#x27;</span>: [<span class="number">116.36078873507478</span>, <span class="number">40.06152377992771</span>], <span class="string">&#x27;type&#x27;</span>: <span class="string">&#x27;Point&#x27;</span>&#125;&#125;</span><br></pre></td></tr></table></figure><h3 id="👀XML"><a href="#👀XML" class="headerlink" title="👀XML"></a>👀XML</h3><p>在<code>Python</code>中，有多个库可以用来读取和处理<code>XML</code>文档。以下是其中一些常用的库：</p><ul><li><code>xml.etree.ElementTree（</code>内置库）：这是<code>Python</code>标准库中的一个模块，提供了基本的<code>XML</code>文档解析和操作功能。它具有简单的API和高效的性能，适合处理小型到中型的<code>XML</code>文档。</li><li><code>lxml</code>：<code>lxml</code>是<code>Python</code>中一个功能强大的<code>XML/HTML</code>解析库，基于<code>libxml2</code>和<code>libxslt</code>库。它提供了与<code>ElementTree</code>相似的<code>API</code>，但具有更好的性能和更多的功能。<code>lxml</code>支持<code>XPath</code>、<code>XSLT</code>、<code>XML Schema</code>等高级特性，适用于处理大型和复杂的<code>XML</code>文档。</li><li><code>xmltodict</code>：<code>xmltodict</code>库可以将<code>XML</code>文档解析为<code>Python</code>字典，使<code>XML</code>数据的处理更加简便。它提供了一个简单的<code>API</code>，将<code>XML</code>数据转换为<code>Python</code>数据结构，便于数据的操作和处理。</li><li><code>minidom</code>：<code>xml.dom.minidom</code>是<code>Python</code>标准库中的一个模块，提供了基本的<code>DOM</code>（文档对象模型）接口来解析和操作<code>XML</code>文档。尽管它的<code>API</code>相对较复杂，但它具有更多的功能和灵活性，适用于需要更高级控制的场景。</li></ul><blockquote><p>这些库都有各自的优点和适用场景。在选择库时，可以考虑以下因素：</p><ul><li>对于简单的<code>XML</code>操作和小型文档，内置库<code>xml.etree.ElementTree</code>是一个轻量级且易于使用的选择。</li><li>如果需要更好的性能、更多的功能和高级特性（如<code>XPath</code>、<code>XSLT</code>），可以选择<code>lxml</code>库。</li><li>如果希望将<code>XML</code>数据解析为<code>Python</code>字典以便于处理，可以使用<code>xmltodict</code>库。</li><li>如果对<code>DOM</code>接口熟悉并且需要更多的灵活性和控制能力，可以考虑使用<code>minidom</code>库。</li></ul></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 说明</span></span><br><span class="line"><span class="comment"># 加载和读取xml文件，获取xml文档对象</span></span><br><span class="line"><span class="keyword">from</span> xml.dom <span class="keyword">import</span> minidom  </span><br><span class="line">doc = minidom.parse(xmlfile)</span><br><span class="line"><span class="comment"># 获取xml文档根节点</span></span><br><span class="line">root = doc.documentElement</span><br><span class="line"><span class="comment"># 节点属性</span></span><br><span class="line">root.nodeName<span class="comment"># 每个节点都有它的nodeName，nodeValue，nodeType属性</span></span><br><span class="line">root.nodeValue<span class="comment"># nodeValue是节点的值，只对本节点有效</span></span><br><span class="line">root.nodeType<span class="comment"># 节点类型；</span></span><br><span class="line">root.ELEMENT_NODE</span><br><span class="line"><span class="comment"># 属性值的获取、修改、删除</span></span><br><span class="line">root.getAttribute(attributeName)<span class="comment"># 获取xml节点属性值</span></span><br><span class="line">root.setAttribute(attributeName, value)<span class="comment"># 修改或添加xml节点属性值</span></span><br><span class="line">root.getElementsByTagName(TagName)<span class="comment"># 根据标签获取xml节点对象集合</span></span><br><span class="line">root.removeAttribute(attributeName)<span class="comment"># 删除xml节点属性值</span></span><br><span class="line"><span class="comment"># 子节点的访问</span></span><br><span class="line">root.childNodes  <span class="comment"># 获取子节点列表</span></span><br><span class="line">root.childNodes[index].nodeValue<span class="comment"># 获取xml节点值</span></span><br><span class="line">root.firstChild<span class="comment"># 访问第一个节点（相当于root.childNodes[0]）</span></span><br><span class="line">root.childNodes[<span class="number">0</span>].data<span class="comment"># 获得文本值</span></span><br><span class="line"><span class="comment"># 删除子节点</span></span><br><span class="line">node.removeChild(childnode_in_node)<span class="comment"># 删除node节点下面的子节点childnode_in_node</span></span><br><span class="line"><span class="comment"># 生成节点</span></span><br><span class="line">node.createElement(<span class="string">&#x27;activity&#x27;</span>)<span class="comment"># 生成节点  # 文本节点.createTextNode(&#x27;xxxxx&#x27;)</span></span><br></pre></td></tr></table></figure><h4 id="（1）读取XML"><a href="#（1）读取XML" class="headerlink" title="（1）读取XML"></a><strong>（1）读取XML</strong></h4><p><code>XML</code>示例文件：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;ISO-8859-1&quot;</span>?&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Edited by XMLSpyÂ® --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">breakfast_menu</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">food</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>Belgian Waffles<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">price</span>&gt;</span>$5.95<span class="tag">&lt;/<span class="name">price</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">calories</span>&gt;</span>650<span class="tag">&lt;/<span class="name">calories</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">cropRegion</span> <span class="attr">x</span>=<span class="string">&quot;0&quot;</span> <span class="attr">y</span>=<span class="string">&quot;0&quot;</span> <span class="attr">width</span>=<span class="string">&quot;0000&quot;</span> <span class="attr">height</span>=<span class="string">&quot;1234&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">food</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">food</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>Strawberry Belgian Waffles<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">price</span>&gt;</span>$7.95<span class="tag">&lt;/<span class="name">price</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">calories</span>&gt;</span>900<span class="tag">&lt;/<span class="name">calories</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">cropRegion</span> <span class="attr">x</span>=<span class="string">&quot;1&quot;</span> <span class="attr">y</span>=<span class="string">&quot;1&quot;</span> <span class="attr">width</span>=<span class="string">&quot;1111&quot;</span> <span class="attr">height</span>=<span class="string">&quot;2345&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">food</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">food</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>Berry-Berry Belgian Waffles<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">price</span>&gt;</span>$8.95<span class="tag">&lt;/<span class="name">price</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">calories</span>&gt;</span>900<span class="tag">&lt;/<span class="name">calories</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">cropRegion</span> <span class="attr">x</span>=<span class="string">&quot;2&quot;</span> <span class="attr">y</span>=<span class="string">&quot;2&quot;</span> <span class="attr">width</span>=<span class="string">&quot;2222&quot;</span> <span class="attr">height</span>=<span class="string">&quot;3456&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">food</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">food</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>French Toast<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">price</span>&gt;</span>$4.50<span class="tag">&lt;/<span class="name">price</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">calories</span>&gt;</span>600<span class="tag">&lt;/<span class="name">calories</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">cropRegion</span> <span class="attr">x</span>=<span class="string">&quot;3&quot;</span> <span class="attr">y</span>=<span class="string">&quot;3&quot;</span> <span class="attr">width</span>=<span class="string">&quot;3333&quot;</span> <span class="attr">height</span>=<span class="string">&quot;4567&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">food</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">food</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>Homestyle Breakfast<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">price</span>&gt;</span>$6.95<span class="tag">&lt;/<span class="name">price</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">calories</span>&gt;</span>950<span class="tag">&lt;/<span class="name">calories</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">cropRegion</span> <span class="attr">x</span>=<span class="string">&quot;4&quot;</span> <span class="attr">y</span>=<span class="string">&quot;4&quot;</span> <span class="attr">width</span>=<span class="string">&quot;4444&quot;</span> <span class="attr">height</span>=<span class="string">&quot;5678&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">food</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">breakfast_menu</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>DOM</code>解析<code>XML</code>文件</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> xml.dom <span class="keyword">import</span> minidom</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解析xml文件(句柄或文件路径)</span></span><br><span class="line">doc = minidom.parse(<span class="string">r&quot;D:\Desktop\simple.xml&quot;</span>)</span><br><span class="line"><span class="comment"># doc = minidom.parseString()  # 解析xml字符串</span></span><br><span class="line"><span class="built_in">print</span>(doc)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 获得根节点</span></span><br><span class="line">root_node = doc.documentElement  </span><br><span class="line"><span class="built_in">print</span>(root_node)</span><br><span class="line"><span class="comment"># 节点名称</span></span><br><span class="line"><span class="built_in">print</span>(root_node.nodeName)</span><br><span class="line"><span class="comment"># 节点类型（元素节点，文本节点，属性节点）</span></span><br><span class="line"><span class="built_in">print</span>(root_node.nodeType)</span><br><span class="line"><span class="comment"># 所有子节点，为列表</span></span><br><span class="line"><span class="built_in">print</span>(root_node.childNodes)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 通过节点名称寻找节点，返回列表</span></span><br><span class="line">filename_node = root_node.getElementsByTagName(<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(filename_node)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 子节点为文本节点，文本节点有data属性即为文本值</span></span><br><span class="line">filename = filename_node[<span class="number">1</span>].childNodes[<span class="number">0</span>].data</span><br><span class="line"><span class="built_in">print</span>(filename)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 读取指定属性值,root.setAttribute(attributeName, value)更新修改属性值</span></span><br><span class="line">cropRegion_node = root_node.getElementsByTagName(<span class="string">&#x27;cropRegion&#x27;</span>)</span><br><span class="line">width = cropRegion_node[<span class="number">1</span>].getAttribute(<span class="string">&quot;width&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(width)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">&lt;xml.dom.minidom.Document <span class="built_in">object</span> at <span class="number">0x0000016F45D0EDC0</span>&gt;</span><br><span class="line">********************</span><br><span class="line">&lt;DOM Element: breakfast_menu at <span class="number">0x16f45d011f0</span>&gt;</span><br><span class="line">breakfast_menu</span><br><span class="line"><span class="number">1</span></span><br><span class="line">[&lt;DOM Text node <span class="string">&quot;&#x27;\n\t&#x27;&quot;</span>&gt;, &lt;DOM Element: food at <span class="number">0x16f45d01f70</span>&gt;, &lt;DOM Text node <span class="string">&quot;&#x27;\n\t&#x27;&quot;</span>&gt;, &lt;DOM Element: food at <span class="number">0x16f45d01b80</span>&gt;, &lt;DOM Text node <span class="string">&quot;&#x27;\n\t&#x27;&quot;</span>&gt;, &lt;DOM Element: food at <span class="number">0x16f45ccddc0</span>&gt;, &lt;DOM Text node <span class="string">&quot;&#x27;\n\t&#x27;&quot;</span>&gt;, &lt;DOM Element: food at <span class="number">0x16f458e0dc0</span>&gt;, &lt;DOM Text node <span class="string">&quot;&#x27;\n\t&#x27;&quot;</span>&gt;, &lt;DOM Element: food at <span class="number">0x16f45cf05e0</span>&gt;, &lt;DOM Text node <span class="string">&quot;&#x27;\n&#x27;&quot;</span>&gt;]</span><br><span class="line">********************</span><br><span class="line">[&lt;DOM Element: name at <span class="number">0x16f45d01dc0</span>&gt;, &lt;DOM Element: name at <span class="number">0x16f45d018b0</span>&gt;, &lt;DOM Element: name at <span class="number">0x16f45ccdd30</span>&gt;, &lt;DOM Element: name at <span class="number">0x16f45cf0af0</span>&gt;, &lt;DOM Element: name at <span class="number">0x16f45cf0280</span>&gt;]</span><br><span class="line">********************</span><br><span class="line">Strawberry Belgian Waffles</span><br><span class="line">********************</span><br><span class="line"><span class="number">1111</span></span><br></pre></td></tr></table></figure><h4 id="（2）写入XML"><a href="#（2）写入XML" class="headerlink" title="（2）写入XML"></a><strong>（2）写入XML</strong></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 写入文件</span></span><br><span class="line">DOM树对象.writexml(fh,indent=<span class="string">&#x27;&#x27;</span>,addindent=<span class="string">&#x27;\t&#x27;</span>,newl=<span class="string">&#x27;\n&#x27;</span>,encoding=<span class="string">&#x27;UTF-8&#x27;</span>)</span><br><span class="line"><span class="comment"># writexml()第一个参数是目标文件对象，第二个参数是根节点的缩进格式，第三个参数是其他子节点的缩进格式，第四个参数制定了换行格式，第五个参数制定了xml内容的编码。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># zip()函数用于将可迭代的对象作为参数，将对象中对应的元素打包成一个个元组，然后返回由这些元组组成的列表。如果各个迭代器的元素个数不一致，则返回列表长度与最短的对象相同，利用 * 号操作符，可以将元组解压为列表。</span></span><br><span class="line"><span class="comment"># zip()方法在Python2和Python3中的不同：在Python3.x中为了减少内存，zip()返回的是一个对象。如需展示列表，需手动list()转换。</span></span><br><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">b = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">c = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>]</span><br><span class="line"><span class="comment"># 返回一个对象</span></span><br><span class="line">zipped = <span class="built_in">zip</span>(a,b)</span><br><span class="line"><span class="built_in">print</span>(zipped)</span><br><span class="line"><span class="comment"># list()转换为列表</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(zipped))</span><br><span class="line"><span class="comment"># 元素个数与最短的列表一致</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(<span class="built_in">zip</span>(a,c)))</span><br><span class="line"><span class="comment"># 与zip相反，*zip()函数是zip()函数的逆过程，将zip对象变成原先组合前的数据</span></span><br><span class="line">a1 = <span class="built_in">zip</span>(*<span class="built_in">zip</span>(a,b))</span><br><span class="line"><span class="built_in">print</span>(a1)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(a1))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">&lt;<span class="built_in">zip</span> <span class="built_in">object</span> at <span class="number">0x0000016F45CD6200</span>&gt;</span><br><span class="line">[(<span class="number">1</span>, <span class="number">4</span>), (<span class="number">2</span>, <span class="number">5</span>), (<span class="number">3</span>, <span class="number">6</span>)]</span><br><span class="line">[(<span class="number">1</span>, <span class="number">4</span>), (<span class="number">2</span>, <span class="number">5</span>), (<span class="number">3</span>, <span class="number">6</span>)]</span><br><span class="line">&lt;<span class="built_in">zip</span> <span class="built_in">object</span> at <span class="number">0x0000016F45CD0FC0</span>&gt;</span><br><span class="line">[(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>), (<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)]</span><br></pre></td></tr></table></figure><p><code>DOM</code>写<code>XML</code>文件</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 写入XML文件</span></span><br><span class="line"><span class="keyword">from</span> xml.dom <span class="keyword">import</span> minidom</span><br><span class="line"><span class="comment"># (1)创建DOM树对象</span></span><br><span class="line">dom = minidom.Document()</span><br><span class="line"><span class="comment"># (2)创建根节点，每次都要用DOM对象来创建任何节点</span></span><br><span class="line">root_node = dom.createElement(<span class="string">&quot;people&quot;</span>)</span><br><span class="line"><span class="comment"># (3)用DOM对象添加根节点</span></span><br><span class="line">dom.appendChild(root_node)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用DOM对象创建元素字节点</span></span><br><span class="line">name_node = dom.createElement(<span class="string">&quot;name&quot;</span>)</span><br><span class="line"><span class="comment"># 用父节点对象添加元素子节点</span></span><br><span class="line">root_node.appendChild(name_node)</span><br><span class="line"><span class="comment"># 设置该节点的属性</span></span><br><span class="line">name_node.setAttribute(<span class="string">&quot;sex&quot;</span>,<span class="string">&quot;男&quot;</span>)</span><br><span class="line">name_node.setAttribute(<span class="string">&quot;height&quot;</span>,<span class="string">&quot;180&quot;</span>)</span><br><span class="line"><span class="comment"># 用DOM创建文本节点，把文本节点（文字内容）看成子节点</span></span><br><span class="line">name_text = dom.createTextNode(<span class="string">&quot;小汤&quot;</span>)</span><br><span class="line"><span class="comment"># 用添加了文本的节点对象（看成文本节点的父节点）添加文本节点</span></span><br><span class="line">name_node.appendChild(name_text)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用DOM对象创建元素字节点</span></span><br><span class="line">hobby_node = dom.createElement(<span class="string">&quot;hobby&quot;</span>)</span><br><span class="line"><span class="comment"># 用父节点对象添加元素子节点</span></span><br><span class="line">root_node.appendChild(hobby_node)</span><br><span class="line"><span class="comment"># 用添加了文本的节点对象（看成文本节点的父节点）添加文本节点</span></span><br><span class="line">hobby_node.appendChild(dom.createTextNode(<span class="string">&quot;篮球&quot;</span>))</span><br><span class="line"></span><br><span class="line">score_node = dom.createElement(<span class="string">&quot;score&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> item, value <span class="keyword">in</span> <span class="built_in">zip</span>([<span class="string">&quot;语文&quot;</span>, <span class="string">&quot;数学&quot;</span>, <span class="string">&quot;英语&quot;</span>, <span class="string">&quot;理综&quot;</span>], [<span class="number">150</span>, <span class="number">150</span>, <span class="number">150</span>, <span class="number">300</span>]):</span><br><span class="line">        elem = dom.createElement(item)</span><br><span class="line">        elem.appendChild(dom.createTextNode(<span class="built_in">str</span>(value)))</span><br><span class="line">        score_node.appendChild(elem)</span><br><span class="line">root_node.appendChild(score_node)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">r&quot;D:\Desktop\write.xml&quot;</span>,<span class="string">&#x27;w&#x27;</span>,encoding=<span class="string">&#x27;UTF-8&#x27;</span>) <span class="keyword">as</span> fh:</span><br><span class="line">        <span class="comment"># dom.writexml()第一个参数是目标文件对象，第二个参数是根节点的缩进格式，第三个参数是其他子节点的缩进格式，</span></span><br><span class="line">        <span class="comment"># 第四个参数制定了换行格式，第五个参数制定了xml内容的编码。</span></span><br><span class="line">        dom.writexml(fh, indent=<span class="string">&#x27;&#x27;</span>, addindent=<span class="string">&#x27;\t&#x27;</span>, newl=<span class="string">&#x27;\n&#x27;</span>, encoding=<span class="string">&#x27;UTF-8&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;OK&#x27;</span>)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> err:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;错误：&#123;err&#125;&#x27;</span>.<span class="built_in">format</span>(err=err))</span><br></pre></td></tr></table></figure><p>输出的<code>XML</code>文件内容如下：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">people</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span> <span class="attr">sex</span>=<span class="string">&quot;男&quot;</span> <span class="attr">height</span>=<span class="string">&quot;180&quot;</span>&gt;</span>小汤<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hobby</span>&gt;</span>篮球<span class="tag">&lt;/<span class="name">hobby</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">score</span>&gt;</span></span><br><span class="line">&lt;语文&gt;150&lt;/语文&gt;</span><br><span class="line">&lt;数学&gt;150&lt;/数学&gt;</span><br><span class="line">&lt;英语&gt;150&lt;/英语&gt;</span><br><span class="line">&lt;理综&gt;300&lt;/理综&gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">score</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">people</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="👀TXT"><a href="#👀TXT" class="headerlink" title="👀TXT"></a>👀TXT</h3><h4 id="（1）读取TXT"><a href="#（1）读取TXT" class="headerlink" title="（1）读取TXT"></a><strong>（1）读取TXT</strong></h4><p>源数据<code>data.txt</code>内容如下：</p><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">namegenderagehobby</span><br><span class="line">小红女20跑步</span><br><span class="line">小汤男22篮球</span><br><span class="line">小李男24足球</span><br><span class="line">小ai男21篮球</span><br><span class="line">小张男25篮球</span><br><span class="line">小小男20跳绳</span><br><span class="line">小耿男25羽毛球</span><br></pre></td></tr></table></figure><p>操作<code>txt</code>文件，<code>read()</code>、<code>readline()</code>、<code>readlines()</code>、以及获取某一列内容，代码示例如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># (1)read()一次性读取所有文本</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">r&quot;D:\Desktop\data.txt&quot;</span>, <span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> f:  <span class="comment">#打开文本</span></span><br><span class="line">    data1 = f.read()   <span class="comment">#读取文本</span></span><br><span class="line">    <span class="built_in">print</span>(data1)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># (2)readline()读取第一行的内容</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">r&quot;D:\Desktop\data.txt&quot;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    data2 = f.readline()</span><br><span class="line">    <span class="built_in">print</span>(data2)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># (3)readlines()读取全部内容，以列表的格式返回结果</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">r&quot;D:\Desktop\data.txt&quot;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    data3 = f.readlines()</span><br><span class="line">    <span class="built_in">print</span>(data3)</span><br><span class="line">    <span class="keyword">for</span> ann <span class="keyword">in</span> data3:</span><br><span class="line">        <span class="comment"># 去除文本中的换行符</span></span><br><span class="line">        ann = ann.strip(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(ann)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># (4)读取txt某一列数据，第一种方法</span></span><br><span class="line"><span class="comment"># 要读取第i列数据则可以读取每行的第i个数据再将其拼接起来</span></span><br><span class="line">column_list = []</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">r&quot;D:\Desktop\data.txt&quot;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    data = f.readlines()</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> data:</span><br><span class="line">        <span class="comment"># 去除文本中的换行符</span></span><br><span class="line">        ann = line.strip(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        a = ann.split(<span class="string">&quot;\t&quot;</span>)</span><br><span class="line">        column_list.append(a[<span class="number">3</span>])</span><br><span class="line"><span class="built_in">print</span>(column_list)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># (5)读取txt某一列数据，第二种方法</span></span><br><span class="line">column_list2 = []</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">r&quot;D:\Desktop\data.txt&quot;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="comment"># 以行的形式进行读取文件</span></span><br><span class="line">    line2 = f.readline()</span><br><span class="line">    <span class="keyword">while</span> line2:</span><br><span class="line">        ann2 = line2.strip(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        aa = ann2.split(<span class="string">&quot;\t&quot;</span>)</span><br><span class="line">        column_list2.append(aa[<span class="number">2</span>])</span><br><span class="line">        line2 = f.readline()</span><br><span class="line"><span class="built_in">print</span>(column_list2)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># (6)读取txt某一列数据，第三种方法</span></span><br><span class="line"><span class="keyword">import</span> codecs</span><br><span class="line">column_list3 = []</span><br><span class="line"><span class="keyword">with</span> codecs.<span class="built_in">open</span>(<span class="string">r&quot;D:\Desktop\data.txt&quot;</span>, mode = <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="comment"># 以行的形式进行读取文件</span></span><br><span class="line">    line3 = f.readline()</span><br><span class="line">    <span class="keyword">while</span> line3:</span><br><span class="line">        ann3 = line3.strip(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        aaa = ann3.split(<span class="string">&quot;\t&quot;</span>)</span><br><span class="line">        column_list3.append(aaa[<span class="number">1</span>])</span><br><span class="line">        line3 = f.readline()</span><br><span class="line"><span class="built_in">print</span>(column_list3)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">namegenderagehobby</span><br><span class="line">小红女<span class="number">20</span>跑步</span><br><span class="line">小汤男<span class="number">22</span>篮球</span><br><span class="line">小李男<span class="number">24</span>足球</span><br><span class="line">小ai男<span class="number">21</span>篮球</span><br><span class="line">小张男<span class="number">25</span>篮球</span><br><span class="line">小小男<span class="number">20</span>跳绳</span><br><span class="line">小耿男<span class="number">25</span>羽毛球</span><br><span class="line"></span><br><span class="line">********************</span><br><span class="line">namegenderagehobby</span><br><span class="line"></span><br><span class="line">********************</span><br><span class="line">[<span class="string">&#x27;name\tgender\tage\thobby\n&#x27;</span>, <span class="string">&#x27;小红\t女\t20\t跑步\n&#x27;</span>, <span class="string">&#x27;小汤\t男\t22\t篮球\n&#x27;</span>, <span class="string">&#x27;小李\t男\t24\t足球\n&#x27;</span>, <span class="string">&#x27;小ai\t男\t21\t篮球\n&#x27;</span>, <span class="string">&#x27;小张\t男\t25\t篮球\n&#x27;</span>, <span class="string">&#x27;小小\t男\t20\t跳绳\n&#x27;</span>, <span class="string">&#x27;小耿\t男\t25\t羽毛球\n&#x27;</span>]</span><br><span class="line">namegenderagehobby</span><br><span class="line">小红女<span class="number">20</span>跑步</span><br><span class="line">小汤男<span class="number">22</span>篮球</span><br><span class="line">小李男<span class="number">24</span>足球</span><br><span class="line">小ai男<span class="number">21</span>篮球</span><br><span class="line">小张男<span class="number">25</span>篮球</span><br><span class="line">小小男<span class="number">20</span>跳绳</span><br><span class="line">小耿男<span class="number">25</span>羽毛球</span><br><span class="line">********************</span><br><span class="line">[<span class="string">&#x27;hobby&#x27;</span>, <span class="string">&#x27;跑步&#x27;</span>, <span class="string">&#x27;篮球&#x27;</span>, <span class="string">&#x27;足球&#x27;</span>, <span class="string">&#x27;篮球&#x27;</span>, <span class="string">&#x27;篮球&#x27;</span>, <span class="string">&#x27;跳绳&#x27;</span>, <span class="string">&#x27;羽毛球&#x27;</span>]</span><br><span class="line">********************</span><br><span class="line">[<span class="string">&#x27;age&#x27;</span>, <span class="string">&#x27;20&#x27;</span>, <span class="string">&#x27;22&#x27;</span>, <span class="string">&#x27;24&#x27;</span>, <span class="string">&#x27;21&#x27;</span>, <span class="string">&#x27;25&#x27;</span>, <span class="string">&#x27;20&#x27;</span>, <span class="string">&#x27;25&#x27;</span>]</span><br><span class="line">********************</span><br><span class="line">[<span class="string">&#x27;gender&#x27;</span>, <span class="string">&#x27;女&#x27;</span>, <span class="string">&#x27;男&#x27;</span>, <span class="string">&#x27;男&#x27;</span>, <span class="string">&#x27;男&#x27;</span>, <span class="string">&#x27;男&#x27;</span>, <span class="string">&#x27;男&#x27;</span>, <span class="string">&#x27;男&#x27;</span>]</span><br></pre></td></tr></table></figure><h4 id="（2）写入TXT"><a href="#（2）写入TXT" class="headerlink" title="（2）写入TXT"></a><strong>（2）写入TXT</strong></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 写入txt</span></span><br><span class="line">hobby =[<span class="string">&quot;hobby&quot;</span>, <span class="string">&quot;跑步&quot;</span>, <span class="string">&quot;篮球&quot;</span>, <span class="string">&quot;足球&quot;</span>, <span class="string">&quot;篮球&quot;</span>, <span class="string">&quot;篮球&quot;</span>, <span class="string">&quot;跳绳&quot;</span>, <span class="string">&quot;羽毛球&quot;</span>]</span><br><span class="line">name = [<span class="string">&quot;name&quot;</span>, <span class="string">&quot;小红&quot;</span>, <span class="string">&quot;小汤&quot;</span>, <span class="string">&quot;小李&quot;</span>, <span class="string">&quot;小ai&quot;</span>, <span class="string">&quot;小张&quot;</span>, <span class="string">&quot;小小&quot;</span>, <span class="string">&quot;小耿&quot;</span>]</span><br><span class="line">age = [<span class="string">&quot;age&quot;</span>, <span class="string">&quot;20&quot;</span>, <span class="string">&quot;22&quot;</span>, <span class="string">&quot;24&quot;</span>, <span class="string">&quot;21&quot;</span>, <span class="string">&quot;25&quot;</span>, <span class="string">&quot;30&quot;</span>, <span class="string">&quot;25&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">r&quot;D:\Desktop\writeTXT.txt&quot;</span>,<span class="string">&quot;a&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    length = <span class="built_in">len</span>(age)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length):</span><br><span class="line">        line = [hobby[i], name[i], age[i]]</span><br><span class="line">        lines = <span class="string">&quot;\t&quot;</span>.join(line)</span><br><span class="line">        <span class="comment"># lines = hobby[i] + &quot;\t&quot; + name[i] + &quot;\t&quot; + age[i]</span></span><br><span class="line">        <span class="built_in">print</span>(lines)</span><br><span class="line">        f.write(lines + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">column_list = []</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">r&quot;D:\Desktop\writeTXT.txt&quot;</span>,<span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    data = f.readlines()</span><br><span class="line">    <span class="comment"># print(data)</span></span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> data:</span><br><span class="line">        <span class="comment"># 去除文本中的换行符</span></span><br><span class="line">        ann = line.strip(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        a = ann.split(<span class="string">&quot;\t&quot;</span>)</span><br><span class="line">        column_list.append(a[<span class="number">2</span>])</span><br><span class="line"><span class="built_in">print</span>(column_list)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">hobbynameage</span><br><span class="line">跑步小红<span class="number">20</span></span><br><span class="line">篮球小汤<span class="number">22</span></span><br><span class="line">足球小李<span class="number">24</span></span><br><span class="line">篮球小ai<span class="number">21</span></span><br><span class="line">篮球小张<span class="number">25</span></span><br><span class="line">跳绳小小<span class="number">30</span></span><br><span class="line">羽毛球小耿<span class="number">25</span></span><br><span class="line">[<span class="string">&#x27;age&#x27;</span>, <span class="string">&#x27;20&#x27;</span>, <span class="string">&#x27;22&#x27;</span>, <span class="string">&#x27;24&#x27;</span>, <span class="string">&#x27;21&#x27;</span>, <span class="string">&#x27;25&#x27;</span>, <span class="string">&#x27;30&#x27;</span>, <span class="string">&#x27;25&#x27;</span>]</span><br></pre></td></tr></table></figure><h2 id="⛄Matlab之读写文件"><a href="#⛄Matlab之读写文件" class="headerlink" title="⛄Matlab之读写文件"></a>⛄Matlab之读写文件</h2><blockquote><p><strong>使用过程中注意<code>MATLAB</code>版本差异问题。</strong></p><p><code>MATLAB</code>每一条语句后加分号与否的区别：</p><ul><li><p>代码后加分号，运行结果不会显示在命令窗口；</p></li><li><p>代码后不加分号，当点击回车时，运行结果会立即在命令窗口（<code>window command</code>）显示。</p></li></ul></blockquote><h3 id="👀CSV-1"><a href="#👀CSV-1" class="headerlink" title="👀CSV"></a>👀CSV</h3><h4 id="（1）csvread-不推荐"><a href="#（1）csvread-不推荐" class="headerlink" title="（1）csvread()(不推荐)"></a><strong>（1）<code>csvread()</code>(不推荐)</strong></h4><p><code>CSV</code>文件源数据：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">name,gender,age,语文,数学,英语</span><br><span class="line">小红,女,20,130,140,135</span><br><span class="line">小汤,男,22,131,141,136</span><br><span class="line">小李,男,24,132,142,137</span><br><span class="line">小ai,男,21,133,143,138</span><br><span class="line">小张,男,25,134,144,139</span><br><span class="line">小小,男,20,135,145,140</span><br><span class="line">小耿,男,25,136,146,141</span><br></pre></td></tr></table></figure><p>利用<code>csvread</code>读取<code>CSV</code>文件</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% 读取逗号分隔值格式的文件名，结果直接返回给result，CSV文件只能包含数值。</span></span><br><span class="line">result = csvread(<span class="string">&quot;filename&quot;</span>)</span><br><span class="line"><span class="comment">% 从CSV文件中读取数据（从R行和C列开始）</span></span><br><span class="line">result = csvread(<span class="string">&quot;filename&quot;</span>, R, C)</span><br><span class="line"><span class="comment">% 只读取由range=[R1 C1 R2 C2]指定的范围，其中(R1，C1)是要读取数据的左上角，(R2，C2)是右下角。也可以使用电子表格表示法指定RNG，如range=&quot;A1..B7&quot;，而非[0 0 6 1]。</span></span><br><span class="line">result = csvread(<span class="string">&quot;filename&quot;</span>,R1,C1,[R1 C1 R2 C2])</span><br></pre></td></tr></table></figure><p><code>MATLAB</code>代码：<code>CTRL+R</code>（注释）、<code>CTRL+T</code>（取消注释）</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clc</span><br><span class="line">clear all</span><br><span class="line">result1 = csvread(<span class="string">&#x27;D:\Desktop\data1.csv&#x27;</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">result2 = csvread(<span class="string">&#x27;D:\Desktop\data1.csv&#x27;</span>, <span class="number">1</span>, <span class="number">2</span>, [<span class="number">1</span> <span class="number">2</span> <span class="number">6</span> <span class="number">4</span>])</span><br><span class="line">result3 = csvread(<span class="string">&#x27;D:\Desktop\data1.csv&#x27;</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="string">&quot;C2..F8&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">% 命令行窗口输出</span></span><br><span class="line">result1 =</span><br><span class="line">    <span class="number">20</span>   <span class="number">130</span>   <span class="number">140</span>   <span class="number">135</span></span><br><span class="line">    <span class="number">22</span>   <span class="number">131</span>   <span class="number">141</span>   <span class="number">136</span></span><br><span class="line">    <span class="number">24</span>   <span class="number">132</span>   <span class="number">142</span>   <span class="number">137</span></span><br><span class="line">    <span class="number">21</span>   <span class="number">133</span>   <span class="number">143</span>   <span class="number">138</span></span><br><span class="line">    <span class="number">25</span>   <span class="number">134</span>   <span class="number">144</span>   <span class="number">139</span></span><br><span class="line">    <span class="number">20</span>   <span class="number">135</span>   <span class="number">145</span>   <span class="number">140</span></span><br><span class="line">    <span class="number">25</span>   <span class="number">136</span>   <span class="number">146</span>   <span class="number">141</span></span><br><span class="line">result2 =</span><br><span class="line">    <span class="number">20</span>   <span class="number">130</span>   <span class="number">140</span></span><br><span class="line">    <span class="number">22</span>   <span class="number">131</span>   <span class="number">141</span></span><br><span class="line">    <span class="number">24</span>   <span class="number">132</span>   <span class="number">142</span></span><br><span class="line">    <span class="number">21</span>   <span class="number">133</span>   <span class="number">143</span></span><br><span class="line">    <span class="number">25</span>   <span class="number">134</span>   <span class="number">144</span></span><br><span class="line">    <span class="number">20</span>   <span class="number">135</span>   <span class="number">145</span></span><br><span class="line">result3 =</span><br><span class="line">    <span class="number">20</span>   <span class="number">130</span>   <span class="number">140</span>   <span class="number">135</span></span><br><span class="line">    <span class="number">22</span>   <span class="number">131</span>   <span class="number">141</span>   <span class="number">136</span></span><br><span class="line">    <span class="number">24</span>   <span class="number">132</span>   <span class="number">142</span>   <span class="number">137</span></span><br><span class="line">    <span class="number">21</span>   <span class="number">133</span>   <span class="number">143</span>   <span class="number">138</span></span><br><span class="line">    <span class="number">25</span>   <span class="number">134</span>   <span class="number">144</span>   <span class="number">139</span></span><br><span class="line">    <span class="number">20</span>   <span class="number">135</span>   <span class="number">145</span>   <span class="number">140</span></span><br><span class="line">    <span class="number">25</span>   <span class="number">136</span>   <span class="number">146</span>   <span class="number">141</span></span><br></pre></td></tr></table></figure><blockquote><p><code>MATLAB</code>帮助中心已经不推荐使用 <code>csvread</code>，请改用 <code>readmatrix</code>。</p></blockquote><h4 id="（2）readmatrix"><a href="#（2）readmatrix" class="headerlink" title="（2）readmatrix()"></a><strong>（2）<code>readmatrix()</code></strong></h4><blockquote><p><strong>参数详解见<code>MATLAB</code>帮助中心。</strong></p><ul><li>从文本文件中读取矩阵</li><li>从电子表格文件中读取矩阵</li><li>使用导入选项从指定的工作表和范围中读取矩阵</li><li>从指定的工作表和范围中读取矩阵</li></ul></blockquote><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% （1）通过从文件中读取列向数据来创建数组，readmatrix函数可自动检测文件的导入参数。</span></span><br><span class="line"><span class="comment">% readmatrix基于文件的扩展名确定文件格式：</span></span><br><span class="line"><span class="comment">% .txt、.dat或.csv（带分隔符的文本文件）</span></span><br><span class="line"><span class="comment">% .xls、.xlsb、.xlsm、.xlsx、.xltm、.xltx或.ods（电子表格文件）</span></span><br><span class="line"><span class="comment">% 对于包含数值和文本混合数据的文件，默认情况下，readmatrix将数据作为数值数组导入。</span></span><br><span class="line">result = readmatrix(filename)</span><br><span class="line"><span class="comment">% （2）还使用导入选项opts</span></span><br><span class="line">result = readmatrix(filename,opts)</span><br><span class="line"><span class="comment">% （3）基于文件创建一个数组，并通过一个或多个名称-值对组参数指定其他选项。需要在输入参数之后指定名称-值对组。</span></span><br><span class="line"><span class="comment">% 要为数据设置特定的导入选项，您可以使用opts对象，也可以指定名称-值对组。当您指定除opts之外的名称-值对组时，readmatrix仅支持下列名称-值对组：</span></span><br><span class="line"><span class="comment">% 文本文件：DateLocale、Encoding</span></span><br><span class="line"><span class="comment">% 电子表格文件：Sheet、UseExcel</span></span><br><span class="line">A = readmatrix(___,Name,Value)</span><br></pre></td></tr></table></figure><p>利用<code>readmatrix()</code>读取<code>CSV</code>文件：</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clc</span><br><span class="line">clear all</span><br><span class="line"><span class="comment">% readmatrix第一个参数是文件名。第二个参数指输出类型。如果不带这个参数，那字符串那一列的输出结果是Nan值</span></span><br><span class="line"><span class="comment">% 加上之后，则全部输出文本类型，后面再把要作为数值型的内容转换数据类型。</span></span><br><span class="line">result4 = readmatrix(<span class="string">&#x27;D:\Desktop\data1.csv&#x27;</span>)</span><br><span class="line">result5 = readmatrix(<span class="string">&#x27;D:\Desktop\data1.csv&#x27;</span>, <span class="string">&#x27;OutputType&#x27;</span>, <span class="string">&#x27;string&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">% 命令行窗口输出</span></span><br><span class="line">result4 =</span><br><span class="line">   NaN   NaN    <span class="number">20</span>   <span class="number">130</span>   <span class="number">140</span>   <span class="number">135</span></span><br><span class="line">   NaN     <span class="number">7</span>    <span class="number">22</span>   <span class="number">131</span>   <span class="number">141</span>   <span class="number">136</span></span><br><span class="line">   NaN     <span class="number">7</span>    <span class="number">24</span>   <span class="number">132</span>   <span class="number">142</span>   <span class="number">137</span></span><br><span class="line">   NaN     <span class="number">7</span>    <span class="number">21</span>   <span class="number">133</span>   <span class="number">143</span>   <span class="number">138</span></span><br><span class="line">   NaN     <span class="number">7</span>    <span class="number">25</span>   <span class="number">134</span>   <span class="number">144</span>   <span class="number">139</span></span><br><span class="line">   NaN     <span class="number">7</span>    <span class="number">20</span>   <span class="number">135</span>   <span class="number">145</span>   <span class="number">140</span></span><br><span class="line">   NaN     <span class="number">7</span>    <span class="number">25</span>   <span class="number">136</span>   <span class="number">146</span>   <span class="number">141</span></span><br><span class="line">result5 = </span><br><span class="line">  <span class="number">7</span>×<span class="number">6</span> string 数组</span><br><span class="line">    <span class="string">&quot;小红&quot;</span>    <span class="string">&quot;女&quot;</span>    <span class="string">&quot;20&quot;</span>    <span class="string">&quot;130&quot;</span>    <span class="string">&quot;140&quot;</span>    <span class="string">&quot;135&quot;</span></span><br><span class="line">    <span class="string">&quot;小汤&quot;</span>    <span class="string">&quot;男&quot;</span>    <span class="string">&quot;22&quot;</span>    <span class="string">&quot;131&quot;</span>    <span class="string">&quot;141&quot;</span>    <span class="string">&quot;136&quot;</span></span><br><span class="line">    <span class="string">&quot;小李&quot;</span>    <span class="string">&quot;男&quot;</span>    <span class="string">&quot;24&quot;</span>    <span class="string">&quot;132&quot;</span>    <span class="string">&quot;142&quot;</span>    <span class="string">&quot;137&quot;</span></span><br><span class="line">    <span class="string">&quot;小ai&quot;</span>    <span class="string">&quot;男&quot;</span>    <span class="string">&quot;21&quot;</span>    <span class="string">&quot;133&quot;</span>    <span class="string">&quot;143&quot;</span>    <span class="string">&quot;138&quot;</span></span><br><span class="line">    <span class="string">&quot;小张&quot;</span>    <span class="string">&quot;男&quot;</span>    <span class="string">&quot;25&quot;</span>    <span class="string">&quot;134&quot;</span>    <span class="string">&quot;144&quot;</span>    <span class="string">&quot;139&quot;</span></span><br><span class="line">    <span class="string">&quot;小小&quot;</span>    <span class="string">&quot;男&quot;</span>    <span class="string">&quot;20&quot;</span>    <span class="string">&quot;135&quot;</span>    <span class="string">&quot;145&quot;</span>    <span class="string">&quot;140&quot;</span></span><br><span class="line">    <span class="string">&quot;小耿&quot;</span>    <span class="string">&quot;男&quot;</span>    <span class="string">&quot;25&quot;</span>    <span class="string">&quot;136&quot;</span>    <span class="string">&quot;146&quot;</span>    <span class="string">&quot;141&quot;</span></span><br></pre></td></tr></table></figure><h4 id="（3）importdata"><a href="#（3）importdata" class="headerlink" title="（3）importdata()"></a><strong>（3）<code>importdata()</code></strong></h4><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% （1）将数据加载到数组A中</span></span><br><span class="line">A = importdata(filename)</span><br><span class="line"><span class="comment">% （2）从系统剪贴板而不是文件加载数据。</span></span><br><span class="line">A = importdata(<span class="string">&#x27;-pastespecial&#x27;</span>)</span><br><span class="line"><span class="comment">% （3）将delimiterIn解释为ASCII文件filename或剪贴板数据中的列分隔符。您可以将delimiterIn与以上语法中的任何输入参数结合使用。</span></span><br><span class="line">A = importdata(___,delimiterIn)</span><br><span class="line"><span class="comment">% （4）从ASCII文件filename或剪贴板加载数据，并读取从第headerlinesIn+1 开始的数值数据。</span></span><br><span class="line">A = importdata(___,delimiterIn,headerlinesIn)</span><br><span class="line"><span class="comment">% （5）支持上述语法中的任何输入参数，并在delimiterOut中额外返回检测到的输入ASCII文件中的分隔符，以及在headerlinesOut中返回检测到的标题行数。</span></span><br><span class="line">[A,delimiterOut,headerlinesOut] = importdata(___)</span><br></pre></td></tr></table></figure><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clc</span><br><span class="line">clear all</span><br><span class="line"><span class="comment">% 返回一个struct类型，默认将文本与数值分开</span></span><br><span class="line"><span class="comment">% 此方法虽然简便，但是貌似对数据量过大的数据不太友好</span></span><br><span class="line"><span class="comment">% matlab实现输出的几种方式（disp函数、fprintf函数、print函数）</span></span><br><span class="line">result6 = importdata(<span class="string">&#x27;D:\Desktop\data1.csv&#x27;</span>)</span><br><span class="line"><span class="built_in">disp</span>(result6)</span><br><span class="line">data = result6.data</span><br><span class="line">textdata = result6.textdata</span><br><span class="line"></span><br><span class="line"><span class="comment">% 命令行窗口输出</span></span><br><span class="line">        data: [<span class="number">7</span>×<span class="number">4</span> double]</span><br><span class="line">    textdata: &#123;<span class="number">8</span>×<span class="number">6</span> cell&#125;</span><br><span class="line">data =</span><br><span class="line">    <span class="number">20</span>   <span class="number">130</span>   <span class="number">140</span>   <span class="number">135</span></span><br><span class="line">    <span class="number">22</span>   <span class="number">131</span>   <span class="number">141</span>   <span class="number">136</span></span><br><span class="line">    <span class="number">24</span>   <span class="number">132</span>   <span class="number">142</span>   <span class="number">137</span></span><br><span class="line">    <span class="number">21</span>   <span class="number">133</span>   <span class="number">143</span>   <span class="number">138</span></span><br><span class="line">    <span class="number">25</span>   <span class="number">134</span>   <span class="number">144</span>   <span class="number">139</span></span><br><span class="line">    <span class="number">20</span>   <span class="number">135</span>   <span class="number">145</span>   <span class="number">140</span></span><br><span class="line">    <span class="number">25</span>   <span class="number">136</span>   <span class="number">146</span>   <span class="number">141</span></span><br><span class="line">textdata =</span><br><span class="line">  <span class="number">8</span>×<span class="number">6</span> cell 数组</span><br><span class="line">    &#123;<span class="string">&#x27;name&#x27;</span>&#125;    &#123;<span class="string">&#x27;gender&#x27;</span>&#125;    &#123;<span class="string">&#x27;age&#x27;</span>   &#125;    &#123;<span class="string">&#x27;语文&#x27;</span>  &#125;    &#123;<span class="string">&#x27;数学&#x27;</span>  &#125;    &#123;<span class="string">&#x27;英语&#x27;</span>  &#125;</span><br><span class="line">    &#123;<span class="string">&#x27;小红&#x27;</span>&#125;    &#123;<span class="string">&#x27;女&#x27;</span>    &#125;    &#123;<span class="number">0</span>×<span class="number">0</span> char&#125;    &#123;<span class="number">0</span>×<span class="number">0</span> char&#125;    &#123;<span class="number">0</span>×<span class="number">0</span> char&#125;    &#123;<span class="number">0</span>×<span class="number">0</span> char&#125;</span><br><span class="line">    &#123;<span class="string">&#x27;小汤&#x27;</span>&#125;    &#123;<span class="string">&#x27;男&#x27;</span>    &#125;    &#123;<span class="number">0</span>×<span class="number">0</span> char&#125;    &#123;<span class="number">0</span>×<span class="number">0</span> char&#125;    &#123;<span class="number">0</span>×<span class="number">0</span> char&#125;    &#123;<span class="number">0</span>×<span class="number">0</span> char&#125;</span><br><span class="line">    &#123;<span class="string">&#x27;小李&#x27;</span>&#125;    &#123;<span class="string">&#x27;男&#x27;</span>    &#125;    &#123;<span class="number">0</span>×<span class="number">0</span> char&#125;    &#123;<span class="number">0</span>×<span class="number">0</span> char&#125;    &#123;<span class="number">0</span>×<span class="number">0</span> char&#125;    &#123;<span class="number">0</span>×<span class="number">0</span> char&#125;</span><br><span class="line">    &#123;<span class="string">&#x27;小ai&#x27;</span>&#125;    &#123;<span class="string">&#x27;男&#x27;</span>    &#125;    &#123;<span class="number">0</span>×<span class="number">0</span> char&#125;    &#123;<span class="number">0</span>×<span class="number">0</span> char&#125;    &#123;<span class="number">0</span>×<span class="number">0</span> char&#125;    &#123;<span class="number">0</span>×<span class="number">0</span> char&#125;</span><br><span class="line">    &#123;<span class="string">&#x27;小张&#x27;</span>&#125;    &#123;<span class="string">&#x27;男&#x27;</span>    &#125;    &#123;<span class="number">0</span>×<span class="number">0</span> char&#125;    &#123;<span class="number">0</span>×<span class="number">0</span> char&#125;    &#123;<span class="number">0</span>×<span class="number">0</span> char&#125;    &#123;<span class="number">0</span>×<span class="number">0</span> char&#125;</span><br><span class="line">    &#123;<span class="string">&#x27;小小&#x27;</span>&#125;    &#123;<span class="string">&#x27;男&#x27;</span>    &#125;    &#123;<span class="number">0</span>×<span class="number">0</span> char&#125;    &#123;<span class="number">0</span>×<span class="number">0</span> char&#125;    &#123;<span class="number">0</span>×<span class="number">0</span> char&#125;    &#123;<span class="number">0</span>×<span class="number">0</span> char&#125;</span><br><span class="line">    &#123;<span class="string">&#x27;小耿&#x27;</span>&#125;    &#123;<span class="string">&#x27;男&#x27;</span>    &#125;    &#123;<span class="number">0</span>×<span class="number">0</span> char&#125;    &#123;<span class="number">0</span>×<span class="number">0</span> char&#125;    &#123;<span class="number">0</span>×<span class="number">0</span> char&#125;    &#123;<span class="number">0</span>×<span class="number">0</span> char&#125;</span><br></pre></td></tr></table></figure><h4 id="（4）readtable"><a href="#（4）readtable" class="headerlink" title="（4）readtable()"></a><strong>（4）<code>readtable()</code></strong></h4><blockquote><p><strong>参数详解见<code>MATLAB</code>帮助中心。</strong></p><ul><li>基于文本文件创建表</li><li>忽略标题并填充缺失值</li><li>基于文本文件创建表，无列标题</li><li>基于文本文件创建格式表</li><li>从文本文件读取外语日期</li><li>基于包含行名称的电子表格创建表</li><li>从电子表格中读取特定范围的数据</li><li>检测并使用针对文本文件的导入选项</li><li>检测并使用针对电子表格文件的导入选项</li><li>读取包含任意变量名称的表格数据</li><li>从文件中读取十六进制和二进制数字</li><li>为<code>XML</code>文件创建<code>XML</code>导入选项</li><li>注册自定义<code>XML</code>命名空间前缀</li><li>从<code>Microsoft Word</code>文档中读取特定表</li><li>从<code>HTML</code>网页读取表</li></ul></blockquote><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% (1)通过从文件中读取列向数据来创建表。</span></span><br><span class="line"><span class="comment">% readtable基于文件的扩展名确定文件格式：</span></span><br><span class="line"><span class="comment">% .txt、.dat或.csv（带分隔符的文本文件）</span></span><br><span class="line"><span class="comment">% .xls、.xlsb、.xlsm、.xlsx、.xltm、.xltx或.ods（电子表格文件）</span></span><br><span class="line"><span class="comment">% .xml（可扩展标记语言(XML)文件）</span></span><br><span class="line"><span class="comment">% .docx（Microsoft® Word文档文件）</span></span><br><span class="line"><span class="comment">% .html、.xhtml或.htm（超文本标记语言(HTML)文件）</span></span><br><span class="line"><span class="comment">% 对于文本和电子表格文件，readtable为该文件中的每列在T中创建一个变量并从文件的第一行中读取变量名称。对于XML文件，readtable在T中为检测为表变量的每个元素或属性节点创建一个变量。变量名称对应于元素和属性名称。对于 Microsoft Word文档文件，默认情况下readtable从文档中的第一个表导入数据，为该文件中的每列在T中创建一个变量并从该表的第一行中读取变量名称。对于HTML文件，默认情况下readtable从第一个&lt;TABLE&gt;元素导入数据，为该文件中的每列在T中创建一个变量并从该表的第一行中读取变量名称。</span></span><br><span class="line"><span class="comment">% 默认情况下，readtable会根据在输入文件的每列中检测到的数据值来创建具有适当数据类型的变量。</span></span><br><span class="line">T = <span class="built_in">readtable</span>(filename)</span><br><span class="line"><span class="comment">% （2）使用导入选项opts创建表。</span></span><br><span class="line">T = <span class="built_in">readtable</span>(filename,opts)</span><br><span class="line"><span class="comment">% （3）基于文件创建一个表，并通过一个或多个名称-值对组参数指定其他选项。例如，您可以指定readtable是将文件的第一行读取为变量名称还是数据。</span></span><br><span class="line"><span class="comment">% 要为数据设置特定的导入选项，您可以使用opts对象，也可以指定名称-值对组。当您指定除opts之外的名称-值对组时，readtable仅支持下列名称-值对组：</span></span><br><span class="line"><span class="comment">% 文本和电子表格参数 -ReadVariableNames、ReadRowNames</span></span><br><span class="line"><span class="comment">% 仅文本参数 -DateLocale、Encoding</span></span><br><span class="line"><span class="comment">% 仅电子表格参数 -Sheet、UseExcel</span></span><br><span class="line">T = <span class="built_in">readtable</span>(___,Name,Value)</span><br></pre></td></tr></table></figure><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clc</span><br><span class="line">clear all</span><br><span class="line">result7 = <span class="built_in">readtable</span>(<span class="string">&#x27;D:\Desktop\data1.csv&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">% 命令行窗口输出</span></span><br><span class="line">result7 =</span><br><span class="line">  <span class="number">7</span>×<span class="number">6</span> <span class="built_in">table</span></span><br><span class="line">     name     gender    age    x__    x___1    x___2</span><br><span class="line">    ______    ______    ___    ___    _____    _____</span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;小红&#x27;</span>     <span class="string">&#x27;女&#x27;</span>      <span class="number">20</span>     <span class="number">130</span>     <span class="number">140</span>      <span class="number">135</span> </span><br><span class="line">    <span class="string">&#x27;小汤&#x27;</span>     <span class="string">&#x27;男&#x27;</span>      <span class="number">22</span>     <span class="number">131</span>     <span class="number">141</span>      <span class="number">136</span> </span><br><span class="line">    <span class="string">&#x27;小李&#x27;</span>     <span class="string">&#x27;男&#x27;</span>      <span class="number">24</span>     <span class="number">132</span>     <span class="number">142</span>      <span class="number">137</span> </span><br><span class="line">    <span class="string">&#x27;小ai&#x27;</span>     <span class="string">&#x27;男&#x27;</span>     <span class="number">21</span>     <span class="number">133</span>     <span class="number">143</span>      <span class="number">138</span> </span><br><span class="line">    <span class="string">&#x27;小张&#x27;</span>     <span class="string">&#x27;男&#x27;</span>      <span class="number">25</span>     <span class="number">134</span>     <span class="number">144</span>      <span class="number">139</span> </span><br><span class="line">    <span class="string">&#x27;小小&#x27;</span>     <span class="string">&#x27;男&#x27;</span>      <span class="number">20</span>     <span class="number">135</span>     <span class="number">145</span>      <span class="number">140</span> </span><br><span class="line">    <span class="string">&#x27;小耿&#x27;</span>     <span class="string">&#x27;男&#x27;</span>      <span class="number">25</span>     <span class="number">136</span>     <span class="number">146</span>      <span class="number">141</span> </span><br></pre></td></tr></table></figure><h4 id="（5）csvwrite-不推荐"><a href="#（5）csvwrite-不推荐" class="headerlink" title="（5）csvwrite()(不推荐)"></a><strong>（5）<code>csvwrite()</code>(不推荐)</strong></h4><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% 可查看帮助中心函数说明</span></span><br><span class="line"><span class="comment">% 将矩阵M以逗号分隔值形式写入文件filename。</span></span><br><span class="line">csvwrite(filename,M)</span><br><span class="line"><span class="comment">% 从指定的行和列偏移量开始将矩阵M写入文件filename。行和列参数从0开始，因此row=0和col=0指定文件中的第一个值。</span></span><br><span class="line">csvwrite(filename,M,row,col)</span><br></pre></td></tr></table></figure><blockquote><ul><li>对于字符串类型<code>csvwrite</code>可能不支持；</li><li><strong>帮助中心</strong>：不推荐使用<code>csvwrite</code>，请改用<code>writematrix</code>。</li></ul></blockquote><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clc</span><br><span class="line">clear all</span><br><span class="line"></span><br><span class="line">csv_data = importdata(<span class="string">&#x27;D:\Desktop\data1.csv&#x27;</span>)</span><br><span class="line">data = csv_data.data;</span><br><span class="line">textdata = csv_data.textdata;</span><br><span class="line">csvwrite(<span class="string">&#x27;D:\Desktop\output.csv&#x27;</span>,data, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"><span class="comment">% 输出结果为double</span></span><br><span class="line">res1 = readmatrix(<span class="string">&#x27;D:\Desktop\output.csv&#x27;</span>)</span><br><span class="line"><span class="comment">% 输出结果为string</span></span><br><span class="line">res2 = readmatrix(<span class="string">&#x27;D:\Desktop\output.csv&#x27;</span>, <span class="string">&#x27;OutputType&#x27;</span>, <span class="string">&#x27;string&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">% 命令行窗口输出结果</span></span><br><span class="line">csv_data = </span><br><span class="line">  包含以下字段的 struct:</span><br><span class="line">        data: [<span class="number">7</span>×<span class="number">4</span> double]</span><br><span class="line">    textdata: &#123;<span class="number">8</span>×<span class="number">6</span> cell&#125;</span><br><span class="line">res1 =</span><br><span class="line">    <span class="number">20</span>   <span class="number">130</span>   <span class="number">140</span>   <span class="number">135</span></span><br><span class="line">    <span class="number">22</span>   <span class="number">131</span>   <span class="number">141</span>   <span class="number">136</span></span><br><span class="line">    <span class="number">24</span>   <span class="number">132</span>   <span class="number">142</span>   <span class="number">137</span></span><br><span class="line">    <span class="number">21</span>   <span class="number">133</span>   <span class="number">143</span>   <span class="number">138</span></span><br><span class="line">    <span class="number">25</span>   <span class="number">134</span>   <span class="number">144</span>   <span class="number">139</span></span><br><span class="line">    <span class="number">20</span>   <span class="number">135</span>   <span class="number">145</span>   <span class="number">140</span></span><br><span class="line">    <span class="number">25</span>   <span class="number">136</span>   <span class="number">146</span>   <span class="number">141</span></span><br><span class="line">res2 = </span><br><span class="line">  <span class="number">7</span>×<span class="number">4</span> string 数组</span><br><span class="line">    <span class="string">&quot;20&quot;</span>    <span class="string">&quot;130&quot;</span>    <span class="string">&quot;140&quot;</span>    <span class="string">&quot;135&quot;</span></span><br><span class="line">    <span class="string">&quot;22&quot;</span>    <span class="string">&quot;131&quot;</span>    <span class="string">&quot;141&quot;</span>    <span class="string">&quot;136&quot;</span></span><br><span class="line">    <span class="string">&quot;24&quot;</span>    <span class="string">&quot;132&quot;</span>    <span class="string">&quot;142&quot;</span>    <span class="string">&quot;137&quot;</span></span><br><span class="line">    <span class="string">&quot;21&quot;</span>    <span class="string">&quot;133&quot;</span>    <span class="string">&quot;143&quot;</span>    <span class="string">&quot;138&quot;</span></span><br><span class="line">    <span class="string">&quot;25&quot;</span>    <span class="string">&quot;134&quot;</span>    <span class="string">&quot;144&quot;</span>    <span class="string">&quot;139&quot;</span></span><br><span class="line">    <span class="string">&quot;20&quot;</span>    <span class="string">&quot;135&quot;</span>    <span class="string">&quot;145&quot;</span>    <span class="string">&quot;140&quot;</span></span><br><span class="line">    <span class="string">&quot;25&quot;</span>    <span class="string">&quot;136&quot;</span>    <span class="string">&quot;146&quot;</span>    <span class="string">&quot;141&quot;</span></span><br></pre></td></tr></table></figure><h4 id="（6）writematrix"><a href="#（6）writematrix" class="headerlink" title="（6）writematrix()"></a><strong>（6）<code>writematrix()</code></strong></h4><blockquote><p><strong>参数详解见<code>MATLAB</code>帮助中心。</strong></p><ul><li>将矩阵写入到文本文件</li><li>将矩阵写入电子表格文件</li><li>将矩阵写入指定的工作表和范围</li><li>将数据追加到电子表格</li><li>将矩阵数据追加到文本文件</li></ul></blockquote><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% writematrix()将矩阵写入文件，自R2019a起</span></span><br><span class="line"><span class="comment">% （1）将同构数组A写入以逗号分隔的文本文件。文件名为数组的工作区变量名称，附加扩展名.txt。如果writematrix无法根据数组名称构造文件名，那么它会写入matrix.txt文件中。A中每个变量的每一列都将成为输出文件中的列。writematrix函数会覆盖任何现有文件。</span></span><br><span class="line">writematrix(A)</span><br><span class="line"><span class="comment">% （2）写入具有filename指定的名称和扩展名的文件。</span></span><br><span class="line"><span class="comment">% writematrix 根据指定扩展名确定文件格式。扩展名必须是下列格式之一：</span></span><br><span class="line"><span class="comment">% .txt、.dat或.csv（带分隔符的文本文件）</span></span><br><span class="line"><span class="comment">% .xls、.xlsm或.xlsx（适用于Excel® 电子表格文件）</span></span><br><span class="line"><span class="comment">% .xlsb（适用于安装了Windows® Excel的系统上支持的Excel电子表格文件）</span></span><br><span class="line">writematrix(A,filename)</span><br><span class="line"><span class="comment">% （3）支持上述语法中的任何输入参数，且可使用一个或多个Name,Value对组参数指定其他选项将数组写入文件中。</span></span><br><span class="line">writematrix(___,Name,Value)</span><br></pre></td></tr></table></figure><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clc</span><br><span class="line">clear all</span><br><span class="line"></span><br><span class="line">csv_data = readmatrix(<span class="string">&#x27;D:\Desktop\data1.csv&#x27;</span>, <span class="string">&#x27;OutputType&#x27;</span>, <span class="string">&#x27;string&#x27;</span>)</span><br><span class="line"><span class="comment">% 没有标题,可以根据自己创建的矩阵添加标题</span></span><br><span class="line">writematrix(csv_data,<span class="string">&#x27;D:\Desktop\output1.csv&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">% 命令行窗口输出结果</span></span><br><span class="line">csv_data = </span><br><span class="line">  <span class="number">7</span>×<span class="number">6</span> string 数组</span><br><span class="line">    <span class="string">&quot;小红&quot;</span>    <span class="string">&quot;女&quot;</span>    <span class="string">&quot;20&quot;</span>    <span class="string">&quot;130&quot;</span>    <span class="string">&quot;140&quot;</span>    <span class="string">&quot;135&quot;</span></span><br><span class="line">    <span class="string">&quot;小汤&quot;</span>    <span class="string">&quot;男&quot;</span>    <span class="string">&quot;22&quot;</span>    <span class="string">&quot;131&quot;</span>    <span class="string">&quot;141&quot;</span>    <span class="string">&quot;136&quot;</span></span><br><span class="line">    <span class="string">&quot;小李&quot;</span>    <span class="string">&quot;男&quot;</span>    <span class="string">&quot;24&quot;</span>    <span class="string">&quot;132&quot;</span>    <span class="string">&quot;142&quot;</span>    <span class="string">&quot;137&quot;</span></span><br><span class="line">    <span class="string">&quot;小ai&quot;</span>    <span class="string">&quot;男&quot;</span>    <span class="string">&quot;21&quot;</span>    <span class="string">&quot;133&quot;</span>    <span class="string">&quot;143&quot;</span>    <span class="string">&quot;138&quot;</span></span><br><span class="line">    <span class="string">&quot;小张&quot;</span>    <span class="string">&quot;男&quot;</span>    <span class="string">&quot;25&quot;</span>    <span class="string">&quot;134&quot;</span>    <span class="string">&quot;144&quot;</span>    <span class="string">&quot;139&quot;</span></span><br><span class="line">    <span class="string">&quot;小小&quot;</span>    <span class="string">&quot;男&quot;</span>    <span class="string">&quot;20&quot;</span>    <span class="string">&quot;135&quot;</span>    <span class="string">&quot;145&quot;</span>    <span class="string">&quot;140&quot;</span></span><br><span class="line">    <span class="string">&quot;小耿&quot;</span>    <span class="string">&quot;男&quot;</span>    <span class="string">&quot;25&quot;</span>    <span class="string">&quot;136&quot;</span>    <span class="string">&quot;146&quot;</span>    <span class="string">&quot;141&quot;</span></span><br></pre></td></tr></table></figure><h4 id="（7）dlmwrite-不推荐"><a href="#（7）dlmwrite-不推荐" class="headerlink" title="（7）dlmwrite()(不推荐)"></a><strong>（7）<code>dlmwrite()</code>(不推荐)</strong></h4><blockquote><p>帮助中心：不推荐使用<code>dlmwrite</code>，请改用<code>writematrix</code>。</p><p><code>dlmwrite</code>支持数值数据，不支持字符串类型。具体参数解释可以查看<code>MATLAB</code>帮助中心文档。</p></blockquote><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% (1)将数组M中的数值数据写入一个ASCII格式的文件filename，并使用默认分隔符(,)分隔各数组元素。如果文件filename已存在，则dlmwrite将覆盖该文件。</span></span><br><span class="line">dlmwrite(filename,M)</span><br><span class="line"><span class="comment">% (2)将数据追加到现有文件filename的末尾。</span></span><br><span class="line">dlmwrite(filename,M,<span class="string">&#x27;-append&#x27;</span>)</span><br><span class="line"><span class="comment">% (3)使用一个或多个名称-值对组参数另外指定分隔符、换行符、偏移量和精度选项。</span></span><br><span class="line">dlmwrite(___,Name,Value)</span><br><span class="line"><span class="comment">% (4)将数组M写入文件filename，并使用指定分隔符delimiter分隔各数组元素。</span></span><br><span class="line">dlmwrite(filename,M,delimiter)</span><br><span class="line"><span class="comment">% (5)从目标文件中指定的第row行和第col列开始写入数组。前导行和列用delimiter分隔的空元素填充。</span></span><br><span class="line">dlmwrite(filename,M,delimiter,row,col)</span><br></pre></td></tr></table></figure><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clc</span><br><span class="line">clear all</span><br><span class="line"></span><br><span class="line"><span class="comment">% 支持数值型</span></span><br><span class="line">csv_data = importdata(<span class="string">&#x27;D:\Desktop\data1.csv&#x27;</span>)</span><br><span class="line">data = csv_data.data</span><br><span class="line"><span class="comment">% 添加到csv中，并且以逗号为分隔符</span></span><br><span class="line">dlmwrite(<span class="string">&#x27;D:\Desktop\output2.csv&#x27;</span>,data,<span class="string">&#x27;delimiter&#x27;</span>,<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line"><span class="comment">% 添加到csv中，并且从行后添加</span></span><br><span class="line">dlmwrite(<span class="string">&#x27;D:\Desktop\output2.csv&#x27;</span>,data,<span class="string">&#x27;delimiter&#x27;</span>,<span class="string">&#x27;,&#x27;</span>,<span class="string">&#x27;-append&#x27;</span>)</span><br><span class="line"><span class="comment">% 添加到csv中，并且以相对于已有数据偏移的方式</span></span><br><span class="line">dlmwrite(<span class="string">&#x27;D:\Desktop\output2.csv&#x27;</span>,data,<span class="string">&#x27;delimiter&#x27;</span>,<span class="string">&#x27;,&#x27;</span>,<span class="string">&#x27;-append&#x27;</span>,<span class="string">&#x27;roffset&#x27;</span>,<span class="number">2</span>,<span class="string">&#x27;coffset&#x27;</span>,<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">% 命令行窗口输出结果</span></span><br><span class="line">csv_data = </span><br><span class="line">  包含以下字段的 struct:</span><br><span class="line">        data: [<span class="number">7</span>×<span class="number">4</span> double]</span><br><span class="line">    textdata: &#123;<span class="number">8</span>×<span class="number">6</span> cell&#125;</span><br><span class="line">data =</span><br><span class="line">    <span class="number">20</span>   <span class="number">130</span>   <span class="number">140</span>   <span class="number">135</span></span><br><span class="line">    <span class="number">22</span>   <span class="number">131</span>   <span class="number">141</span>   <span class="number">136</span></span><br><span class="line">    <span class="number">24</span>   <span class="number">132</span>   <span class="number">142</span>   <span class="number">137</span></span><br><span class="line">    <span class="number">21</span>   <span class="number">133</span>   <span class="number">143</span>   <span class="number">138</span></span><br><span class="line">    <span class="number">25</span>   <span class="number">134</span>   <span class="number">144</span>   <span class="number">139</span></span><br><span class="line">    <span class="number">20</span>   <span class="number">135</span>   <span class="number">145</span>   <span class="number">140</span></span><br><span class="line">    <span class="number">25</span>   <span class="number">136</span>   <span class="number">146</span>   <span class="number">141</span></span><br></pre></td></tr></table></figure><h4 id="（8）writetable"><a href="#（8）writetable" class="headerlink" title="（8）writetable()"></a><strong>（8）<code>writetable()</code></strong></h4><blockquote><p><strong>参数详解见<code>MATLAB</code>帮助中心</strong>。也可实现：</p><ul><li>将表写入到<strong>文本文件</strong></li><li>将表写入空格分隔的文本文件</li><li>将表写入包含行名称的文本文件</li><li>将外语日期写入文本文件</li><li>将外语字符写入文本文件</li><li>将引用文本写入**<code>CSV</code>文件**</li><li>将表写入到电子表格中特定的工作表和范围</li><li>写入包含任意变量名称的表格数据</li><li>将数据追加到表的底部</li><li>保留现有列宽（将数据追加到文件底部时，保留电子表格文件的现有列宽）</li><li>修改现有单元格格式</li><li>将表写入**<code>XML</code>文件**</li></ul></blockquote><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% (1)将表T写入逗号分隔的文本文件。文件名为表的工作区变量名称，附加扩展名.txt。如果writetable无法根据输入表名称构造文件名，那么它会写入table.txt 文件中。</span></span><br><span class="line"><span class="comment">% 对于文本文件和电子表格文件，T中每个变量的每列都成为输出文件中的一列。T的变量名称将成为文件第一行的列标题。</span></span><br><span class="line"><span class="comment">% 对于XML文件，T中的每列都成为输出文件中的一个XML节点。T的变量名称成为输出XML文件中元素节点的名称。</span></span><br><span class="line"><span class="built_in">writetable</span>(T)</span><br><span class="line"><span class="comment">% (2)写入具有filename指定的名称和扩展名的文件。</span></span><br><span class="line"><span class="comment">% writetable根据指定扩展名确定文件格式。扩展名必须是下列格式之一：</span></span><br><span class="line"><span class="comment">% .txt、.dat或.csv（带分隔符的文本文件）</span></span><br><span class="line"><span class="comment">% .xls、.xlsm或.xlsx（适用于Excel®电子表格文件）</span></span><br><span class="line"><span class="comment">% .xlsb（适用于安装了Windows® Excel的系统上支持的Excel电子表格文件）</span></span><br><span class="line"><span class="comment">% .xml（可扩展标记语言(XML)文件）</span></span><br><span class="line"><span class="built_in">writetable</span>(T,filename)</span><br><span class="line"><span class="comment">% (3)通过一个或多个Name,Value对组参数指定的其他选项将表写入文件中，并且可以包含以前语法中的任何输入参数。例如，您可以指定是否将变量名称写入为输出文件中的列标题。</span></span><br><span class="line"><span class="built_in">writetable</span>(___,Name,Value)</span><br></pre></td></tr></table></figure><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clc</span><br><span class="line">clear all</span><br><span class="line"></span><br><span class="line">LastName = &#123;<span class="string">&#x27;Sanchez&#x27;</span>;<span class="string">&#x27;Johnson&#x27;</span>;<span class="string">&#x27;Li&#x27;</span>;<span class="string">&#x27;Diaz&#x27;</span>;<span class="string">&#x27;Brown&#x27;</span>&#125;</span><br><span class="line">Age = [<span class="number">38</span>;<span class="number">43</span>;<span class="number">38</span>;<span class="number">40</span>;<span class="number">49</span>]</span><br><span class="line">Smoker = logical([<span class="number">1</span>;<span class="number">0</span>;<span class="number">1</span>;<span class="number">0</span>;<span class="number">1</span>])</span><br><span class="line">Height = [<span class="number">71</span>;<span class="number">69</span>;<span class="number">64</span>;<span class="number">67</span>;<span class="number">64</span>]</span><br><span class="line">Weight = [<span class="number">176</span>;<span class="number">163</span>;<span class="number">131</span>;<span class="number">133</span>;<span class="number">119</span>]</span><br><span class="line">BloodPressure = [<span class="number">124</span> <span class="number">93</span>; <span class="number">109</span> <span class="number">77</span>; <span class="number">125</span> <span class="number">83</span>; <span class="number">117</span> <span class="number">75</span>; <span class="number">122</span> <span class="number">80</span>]</span><br><span class="line">table_csv = <span class="built_in">table</span>(LastName,Age,Smoker,Height,Weight,BloodPressure)</span><br><span class="line"><span class="comment">% 自定义列索引和行索引</span></span><br><span class="line">table_csv.Properties.VariableNames = &#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;f&#x27;</span>&#125;</span><br><span class="line">table_csv.Properties.RowNames = &#123;<span class="string">&#x27;g&#x27;</span>,<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;i&#x27;</span>,<span class="string">&#x27;j&#x27;</span>,<span class="string">&#x27;k&#x27;</span>&#125;</span><br><span class="line"><span class="built_in">writetable</span>(table_csv,<span class="string">&quot;D:\Desktop\output3.csv&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="👀Excel-1"><a href="#👀Excel-1" class="headerlink" title="👀Excel"></a>👀Excel</h3><blockquote><p>函数详解见上，或者<code>MATLAB</code>帮助中心。</p><p><strong>读取全部内容</strong>、<strong>读取特定部分内容</strong>、<strong>追加内容</strong>……</p></blockquote><h4 id="（1）xlsread-不推荐"><a href="#（1）xlsread-不推荐" class="headerlink" title="（1）xlsread()(不推荐)"></a><strong>（1）<code>xlsread()</code>(不推荐)</strong></h4><blockquote><ul><li>将工作表读取到数值矩阵</li><li>读取元胞的范围</li><li>读取列</li><li>请求数值、文本和原始数据</li><li>对工作表执行函数</li><li>请求自定义输出</li></ul></blockquote><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% （1）读取名为filename的 Microsoft®Excel®电子表格工作表中的第一个工作表，并在一个矩阵中返回数值数据。</span></span><br><span class="line">num = xlsread(filename)</span><br><span class="line"><span class="comment">% （2）读取指定的工作表。</span></span><br><span class="line">num = xlsread(filename,sheet)</span><br><span class="line"><span class="comment">% （3）从工作簿的第一个工作表的指定范围内读取数据。使用Excel范围语法，例如&#x27;A1:C3&#x27;。</span></span><br><span class="line">num = xlsread(filename,xlRange)</span><br><span class="line"><span class="comment">% （4）读取指定的工作表和范围。</span></span><br><span class="line">num = xlsread(filename,sheet,xlRange)</span><br><span class="line"><span class="comment">% （5）在basic导入模式下读取电子表格中的数据。如果您的计算机未安装Windows®版 Excel或者您正在使用MATLAB®Online™，xlsread会自动在basic导入模式下运行，该模式支持XLS、XLSX、XLSM、XLTX和XLTM文件。</span></span><br><span class="line"><span class="comment">% 如果不指定所有参数，请使用空字符向量&#x27;&#x27;作为占位符，例如，num=xlsread(filename,&#x27;&#x27;,&#x27;&#x27;,&#x27;basic&#x27;)。</span></span><br><span class="line">num = xlsread(filename,sheet,xlRange,<span class="string">&#x27;basic&#x27;</span>)</span><br><span class="line"><span class="comment">% （6）支持上述语法中的任何输入参数，且可在元胞数组txt中返回文本字段，在元胞数组raw中返回数值数据和文本数据。</span></span><br><span class="line">[num,txt,raw] = xlsread(___)</span><br><span class="line"><span class="comment">% （7）打开一个Excel窗口以便按交互方式来选择数据。选择工作表，将鼠标拖放到所需范围上，然后点击确定。只有安装了Microsoft Excel软件的Windows计算机才支持此语法。</span></span><br><span class="line">___ = xlsread(filename,<span class="number">-1</span>)</span><br><span class="line"><span class="comment">% （8）读取电子表格，对数据调用processFcn，并在数组num中以数值数据的形式返回最终结果。xlsread函数在元胞数组txt中返回文本字段、在元胞数组raw中返回数值和文本数据，并在数组custom中返回processFcn的第二个输出。xlsread函数不会更改电子表格中存储的数据。只有安装了Excel软件的Windows计算机才支持此语法。</span></span><br><span class="line"><span class="comment">% （其中processFcn是函数句柄）</span></span><br><span class="line">[num,txt,raw,custom] = xlsread(filename,sheet,xlRange,<span class="string">&#x27;&#x27;</span>,processFcn)</span><br></pre></td></tr></table></figure><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clc</span><br><span class="line">clear all</span><br><span class="line"></span><br><span class="line">values = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> ; <span class="number">4</span>, <span class="number">5</span>, <span class="string">&#x27;x&#x27;</span> ; <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;</span><br><span class="line">headers = &#123;<span class="string">&#x27;First&#x27;</span>,<span class="string">&#x27;Second&#x27;</span>,<span class="string">&#x27;Third&#x27;</span>&#125;</span><br><span class="line">xlswrite(<span class="string">&#x27;D:\Desktop\myExample.xlsx&#x27;</span>,[headers; values])</span><br><span class="line">filename = <span class="string">&#x27;D:\Desktop\myExample.xlsx&#x27;</span></span><br><span class="line">data = xlsread(filename)</span><br><span class="line"></span><br><span class="line"><span class="comment">% 命令行窗口输出结果</span></span><br><span class="line">values =</span><br><span class="line">  <span class="number">3</span>×<span class="number">3</span> cell 数组</span><br><span class="line">    &#123;[<span class="number">1</span>]&#125;    &#123;[<span class="number">2</span>]&#125;    &#123;[<span class="number">3</span>]&#125;</span><br><span class="line">    &#123;[<span class="number">4</span>]&#125;    &#123;[<span class="number">5</span>]&#125;    &#123;<span class="string">&#x27;x&#x27;</span>&#125;</span><br><span class="line">    &#123;[<span class="number">7</span>]&#125;    &#123;[<span class="number">8</span>]&#125;    &#123;[<span class="number">9</span>]&#125;</span><br><span class="line">headers =</span><br><span class="line">  <span class="number">1</span>×<span class="number">3</span> cell 数组</span><br><span class="line">    &#123;<span class="string">&#x27;First&#x27;</span>&#125;    &#123;<span class="string">&#x27;Second&#x27;</span>&#125;    &#123;<span class="string">&#x27;Third&#x27;</span>&#125;</span><br><span class="line">data =</span><br><span class="line">     <span class="number">1</span>     <span class="number">2</span>     <span class="number">3</span></span><br><span class="line">     <span class="number">4</span>     <span class="number">5</span>   NaN</span><br><span class="line">     <span class="number">7</span>     <span class="number">8</span>     <span class="number">9</span></span><br></pre></td></tr></table></figure><h4 id="（2）readmatrix-1"><a href="#（2）readmatrix-1" class="headerlink" title="（2）readmatrix()"></a><strong>（2）<code>readmatrix()</code></strong></h4><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clc</span><br><span class="line">clear all</span><br><span class="line"><span class="comment">% readmatrix第一个参数是文件名。第二个参数指输出类型。如果不带这个参数，那么字符串那一列的输出结果是Nan值</span></span><br><span class="line"><span class="comment">% 加上之后，则全部输出文本类型，后面再把要作为数值型的内容转换数据类型。</span></span><br><span class="line">data1 = readmatrix(<span class="string">&#x27;D:\Desktop\data2.xlsx&#x27;</span>, <span class="string">&#x27;OutputType&#x27;</span>, <span class="string">&#x27;string&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">% 命令行窗口输出结果</span></span><br><span class="line">data1 = </span><br><span class="line">  <span class="number">7</span>×<span class="number">6</span> string 数组</span><br><span class="line">    <span class="string">&quot;小红&quot;</span>    <span class="string">&quot;女&quot;</span>    <span class="string">&quot;20&quot;</span>    <span class="string">&quot;130&quot;</span>    <span class="string">&quot;140&quot;</span>    <span class="string">&quot;135&quot;</span></span><br><span class="line">    <span class="string">&quot;小汤&quot;</span>    <span class="string">&quot;男&quot;</span>    <span class="string">&quot;22&quot;</span>    <span class="string">&quot;131&quot;</span>    <span class="string">&quot;141&quot;</span>    <span class="string">&quot;136&quot;</span></span><br><span class="line">    <span class="string">&quot;小李&quot;</span>    <span class="string">&quot;男&quot;</span>    <span class="string">&quot;24&quot;</span>    <span class="string">&quot;132&quot;</span>    <span class="string">&quot;142&quot;</span>    <span class="string">&quot;137&quot;</span></span><br><span class="line">    <span class="string">&quot;小ai&quot;</span>    <span class="string">&quot;男&quot;</span>    <span class="string">&quot;21&quot;</span>    <span class="string">&quot;133&quot;</span>    <span class="string">&quot;143&quot;</span>    <span class="string">&quot;138&quot;</span></span><br><span class="line">    <span class="string">&quot;小张&quot;</span>    <span class="string">&quot;男&quot;</span>    <span class="string">&quot;25&quot;</span>    <span class="string">&quot;134&quot;</span>    <span class="string">&quot;144&quot;</span>    <span class="string">&quot;139&quot;</span></span><br><span class="line">    <span class="string">&quot;小小&quot;</span>    <span class="string">&quot;男&quot;</span>    <span class="string">&quot;20&quot;</span>    <span class="string">&quot;135&quot;</span>    <span class="string">&quot;145&quot;</span>    <span class="string">&quot;140&quot;</span></span><br><span class="line">    <span class="string">&quot;小耿&quot;</span>    <span class="string">&quot;男&quot;</span>    <span class="string">&quot;25&quot;</span>    <span class="string">&quot;136&quot;</span>    <span class="string">&quot;146&quot;</span>    <span class="string">&quot;141&quot;</span></span><br></pre></td></tr></table></figure><h4 id="（3）readtable"><a href="#（3）readtable" class="headerlink" title="（3）readtable()"></a><strong>（3）<code>readtable()</code></strong></h4><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clc</span><br><span class="line">clear all</span><br><span class="line">data2 = <span class="built_in">readtable</span>(<span class="string">&#x27;D:\Desktop\data2.xlsx&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">% 命令行窗口输出结果</span></span><br><span class="line">data2 =</span><br><span class="line">  <span class="number">7</span>×<span class="number">6</span> <span class="built_in">table</span></span><br><span class="line">     name     gender    age    x__    x___1    x___2</span><br><span class="line">    ______    ______    ___    ___    _____    _____</span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;小红&#x27;</span>     <span class="string">&#x27;女&#x27;</span>      <span class="number">20</span>     <span class="number">130</span>     <span class="number">140</span>      <span class="number">135</span> </span><br><span class="line">    <span class="string">&#x27;小汤&#x27;</span>     <span class="string">&#x27;男&#x27;</span>      <span class="number">22</span>     <span class="number">131</span>     <span class="number">141</span>      <span class="number">136</span> </span><br><span class="line">    <span class="string">&#x27;小李&#x27;</span>     <span class="string">&#x27;男&#x27;</span>      <span class="number">24</span>     <span class="number">132</span>     <span class="number">142</span>      <span class="number">137</span> </span><br><span class="line">    <span class="string">&#x27;小ai&#x27;</span>     <span class="string">&#x27;男&#x27;</span>     <span class="number">21</span>     <span class="number">133</span>     <span class="number">143</span>      <span class="number">138</span> </span><br><span class="line">    <span class="string">&#x27;小张&#x27;</span>     <span class="string">&#x27;男&#x27;</span>      <span class="number">25</span>     <span class="number">134</span>     <span class="number">144</span>      <span class="number">139</span> </span><br><span class="line">    <span class="string">&#x27;小小&#x27;</span>     <span class="string">&#x27;男&#x27;</span>      <span class="number">20</span>     <span class="number">135</span>     <span class="number">145</span>      <span class="number">140</span> </span><br><span class="line">    <span class="string">&#x27;小耿&#x27;</span>     <span class="string">&#x27;男&#x27;</span>      <span class="number">25</span>     <span class="number">136</span>     <span class="number">146</span>      <span class="number">141</span> </span><br></pre></td></tr></table></figure><h4 id="（4）xlswrite-不推荐"><a href="#（4）xlswrite-不推荐" class="headerlink" title="（4）xlswrite()(不推荐)"></a><strong>（4）<code>xlswrite()</code>(不推荐)</strong></h4><blockquote><ul><li>将向量写入电子表格</li><li>写入电子表格的特定工作表和范围</li></ul></blockquote><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% （1）将矩阵A写入Microsoft®Excel®电子表格工作簿filename中的第一个工作表，从单元格A1开始写入。</span></span><br><span class="line">xlswrite(filename,A)</span><br><span class="line"><span class="comment">% （2）将数据写入指定的工作表。</span></span><br><span class="line">xlswrite(filename,A,sheet)</span><br><span class="line"><span class="comment">% （3）将数据写入工作簿的第一个工作表中由xlRange指定的矩形区域内。使用Excel范围语法，例如&#x27;A1:C3&#x27;。</span></span><br><span class="line">xlswrite(filename,A,xlRange)</span><br><span class="line"><span class="comment">% （4）将数据写入指定的工作表和范围。</span></span><br><span class="line">xlswrite(filename,A,sheet,xlRange)</span><br><span class="line"><span class="comment">% （5）使用先前语法中的任何输入参数返回写入操作的状态。当操作成功时，status为1。否则，status为0。</span></span><br><span class="line">status = xlswrite(___)</span><br><span class="line"><span class="comment">% （6）还在结构体message中返回写入操作生成的任何警告或错误消息。</span></span><br><span class="line">[status,message] = xlswrite(___)</span><br></pre></td></tr></table></figure><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clc</span><br><span class="line">clear all</span><br><span class="line"></span><br><span class="line"><span class="comment">% 写入电子表格的特定工作表和范围</span></span><br><span class="line">A = &#123;<span class="string">&#x27;Time&#x27;</span>,<span class="string">&#x27;Temperature&#x27;</span>; <span class="number">12</span>,<span class="number">98</span>; <span class="number">13</span>,<span class="number">99</span>; <span class="number">14</span>,<span class="number">97</span>&#125;</span><br><span class="line">sheet = <span class="number">2</span></span><br><span class="line">xlRange = <span class="string">&#x27;E1&#x27;</span></span><br><span class="line">xlswrite(<span class="string">&#x27;D:\Desktop\mytest.xlsx&#x27;</span>,A,sheet,xlRange)</span><br></pre></td></tr></table></figure><h4 id="（5）writematrix"><a href="#（5）writematrix" class="headerlink" title="（5）writematrix()"></a><strong>（5）<code>writematrix()</code></strong></h4><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clc</span><br><span class="line">clear all</span><br><span class="line"></span><br><span class="line">Excel_data = readmatrix(<span class="string">&#x27;D:\Desktop\data2.xlsx&#x27;</span>, <span class="string">&#x27;OutputType&#x27;</span>, <span class="string">&#x27;string&#x27;</span>)</span><br><span class="line">writematrix(Excel_data,<span class="string">&#x27;D:\Desktop\output2.xlsx&#x27;</span>)</span><br><span class="line"><span class="comment">% 我的MATLAB版本是R2019a,追加时显示参数名称 WriteMode无效</span></span><br><span class="line"><span class="comment">% writematrix(Excel_data,&#x27;D:\Desktop\output2.xlsx&#x27;,&#x27;WriteMode&#x27;,&#x27;append&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 命令行窗口输出结果</span></span><br><span class="line">Excel_data = </span><br><span class="line">  <span class="number">7</span>×<span class="number">6</span> string 数组</span><br><span class="line">    <span class="string">&quot;小红&quot;</span>    <span class="string">&quot;女&quot;</span>    <span class="string">&quot;20&quot;</span>    <span class="string">&quot;130&quot;</span>    <span class="string">&quot;140&quot;</span>    <span class="string">&quot;135&quot;</span></span><br><span class="line">    <span class="string">&quot;小汤&quot;</span>    <span class="string">&quot;男&quot;</span>    <span class="string">&quot;22&quot;</span>    <span class="string">&quot;131&quot;</span>    <span class="string">&quot;141&quot;</span>    <span class="string">&quot;136&quot;</span></span><br><span class="line">    <span class="string">&quot;小李&quot;</span>    <span class="string">&quot;男&quot;</span>    <span class="string">&quot;24&quot;</span>    <span class="string">&quot;132&quot;</span>    <span class="string">&quot;142&quot;</span>    <span class="string">&quot;137&quot;</span></span><br><span class="line">    <span class="string">&quot;小ai&quot;</span>    <span class="string">&quot;男&quot;</span>    <span class="string">&quot;21&quot;</span>    <span class="string">&quot;133&quot;</span>    <span class="string">&quot;143&quot;</span>    <span class="string">&quot;138&quot;</span></span><br><span class="line">    <span class="string">&quot;小张&quot;</span>    <span class="string">&quot;男&quot;</span>    <span class="string">&quot;25&quot;</span>    <span class="string">&quot;134&quot;</span>    <span class="string">&quot;144&quot;</span>    <span class="string">&quot;139&quot;</span></span><br><span class="line">    <span class="string">&quot;小小&quot;</span>    <span class="string">&quot;男&quot;</span>    <span class="string">&quot;20&quot;</span>    <span class="string">&quot;135&quot;</span>    <span class="string">&quot;145&quot;</span>    <span class="string">&quot;140&quot;</span></span><br><span class="line">    <span class="string">&quot;小耿&quot;</span>    <span class="string">&quot;男&quot;</span>    <span class="string">&quot;25&quot;</span>    <span class="string">&quot;136&quot;</span>    <span class="string">&quot;146&quot;</span>    <span class="string">&quot;141&quot;</span></span><br></pre></td></tr></table></figure><h4 id="（6）writetable"><a href="#（6）writetable" class="headerlink" title="（6）writetable()"></a><strong>（6）<code>writetable()</code></strong></h4><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clc</span><br><span class="line">clear all</span><br><span class="line"></span><br><span class="line">LastName = &#123;<span class="string">&#x27;Sanchez&#x27;</span>;<span class="string">&#x27;Johnson&#x27;</span>;<span class="string">&#x27;Li&#x27;</span>;<span class="string">&#x27;Diaz&#x27;</span>;<span class="string">&#x27;Brown&#x27;</span>&#125;</span><br><span class="line">Age = [<span class="number">38</span>;<span class="number">43</span>;<span class="number">38</span>;<span class="number">40</span>;<span class="number">49</span>]</span><br><span class="line">Smoker = logical([<span class="number">1</span>;<span class="number">0</span>;<span class="number">1</span>;<span class="number">0</span>;<span class="number">1</span>])</span><br><span class="line">Height = [<span class="number">71</span>;<span class="number">69</span>;<span class="number">64</span>;<span class="number">67</span>;<span class="number">64</span>]</span><br><span class="line">Weight = [<span class="number">176</span>;<span class="number">163</span>;<span class="number">131</span>;<span class="number">133</span>;<span class="number">119</span>]</span><br><span class="line">BloodPressure = [<span class="number">124</span> <span class="number">93</span>; <span class="number">109</span> <span class="number">77</span>; <span class="number">125</span> <span class="number">83</span>; <span class="number">117</span> <span class="number">75</span>; <span class="number">122</span> <span class="number">80</span>]</span><br><span class="line">table_csv = <span class="built_in">table</span>(LastName,Age,Smoker,Height,Weight,BloodPressure)</span><br><span class="line"><span class="comment">% 自定义列索引和行索引</span></span><br><span class="line">table_csv.Properties.VariableNames = &#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;f&#x27;</span>&#125;</span><br><span class="line">table_csv.Properties.RowNames = &#123;<span class="string">&#x27;g&#x27;</span>,<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;i&#x27;</span>,<span class="string">&#x27;j&#x27;</span>,<span class="string">&#x27;k&#x27;</span>&#125;</span><br><span class="line"><span class="built_in">writetable</span>(table_csv,<span class="string">&quot;D:\Desktop\output3.xlsx&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">% 命令行窗口输出结果</span></span><br><span class="line">table_csv =</span><br><span class="line">  <span class="number">5</span>×<span class="number">6</span> <span class="built_in">table</span></span><br><span class="line">             a        b       c      d      e         f     </span><br><span class="line">         _________    __    _____    __    ___    __________</span><br><span class="line">    g    <span class="string">&#x27;Sanchez&#x27;</span>    <span class="number">38</span>    <span class="built_in">true</span>     <span class="number">71</span>    <span class="number">176</span>    <span class="number">124</span>     <span class="number">93</span></span><br><span class="line">    h    <span class="string">&#x27;Johnson&#x27;</span>    <span class="number">43</span>    <span class="built_in">false</span>    <span class="number">69</span>    <span class="number">163</span>    <span class="number">109</span>     <span class="number">77</span></span><br><span class="line">    <span class="built_in">i</span>    <span class="string">&#x27;Li&#x27;</span>         <span class="number">38</span>    <span class="built_in">true</span>     <span class="number">64</span>    <span class="number">131</span>    <span class="number">125</span>     <span class="number">83</span></span><br><span class="line">    <span class="built_in">j</span>    <span class="string">&#x27;Diaz&#x27;</span>       <span class="number">40</span>    <span class="built_in">false</span>    <span class="number">67</span>    <span class="number">133</span>    <span class="number">117</span>     <span class="number">75</span></span><br><span class="line">    k    <span class="string">&#x27;Brown&#x27;</span>      <span class="number">49</span>    <span class="built_in">true</span>     <span class="number">64</span>    <span class="number">119</span>    <span class="number">122</span>     <span class="number">80</span></span><br></pre></td></tr></table></figure><h3 id="👀JSON-1"><a href="#👀JSON-1" class="headerlink" title="👀JSON"></a>👀JSON</h3><blockquote><p><code>MATLAB</code>读取<code>JSON</code>的方式利用<a href="https://github.com/fangq/jsonlab"><strong><code>JSONlab</code>工具箱</strong></a></p><p>①将下载的工具箱安装包解压缩放入<code>MATLAB</code>安装目录下的<code>toolbox</code>文件夹下；</p><p>②打开<code>MATLAB</code>，选择”主页“→”设置路径“，将工具箱所在文件夹导入。</p></blockquote><p><code>JSON</code>源文件</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;FeatureCollection&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;features&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Feature&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;geometry&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;coordinates&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">[</span><span class="punctuation">[</span><span class="number">116.3591064789793</span><span class="punctuation">,</span> <span class="number">40.0611769097348</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="punctuation">[</span><span class="number">116.35882714532096</span><span class="punctuation">,</span> <span class="number">40.06035824493355</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="punctuation">[</span><span class="number">116.3588680234169</span><span class="punctuation">,</span> <span class="number">40.06017052423036</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="punctuation">[</span><span class="number">116.3592154872361</span><span class="punctuation">,</span> <span class="number">40.05968557668524</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="punctuation">[</span><span class="number">116.35964470724883</span><span class="punctuation">,</span> <span class="number">40.05949263960517</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="punctuation">[</span><span class="number">116.36125939205749</span><span class="punctuation">,</span> <span class="number">40.05968557668524</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="punctuation">[</span><span class="number">116.36073478982053</span><span class="punctuation">,</span> <span class="number">40.06143241456951</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="punctuation">[</span><span class="number">116.3591064789793</span><span class="punctuation">,</span> <span class="number">40.0611769097348</span><span class="punctuation">]</span><span class="punctuation">]</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Polygon&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Feature&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;geometry&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;coordinates&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="number">116.35838429946176</span><span class="punctuation">,</span> <span class="number">40.0595499993847</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Point&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Feature&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;geometry&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;coordinates&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="number">116.36078873507478</span><span class="punctuation">,</span> <span class="number">40.06152377992771</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Point&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>利用<code>Matlab</code>读取<code>JSON</code></p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clc</span><br><span class="line">clear all</span><br><span class="line"></span><br><span class="line"><span class="comment">% 读取json需要导入JSONlab工具箱</span></span><br><span class="line">jsonData = loadjson(<span class="string">&#x27;D:\Desktop\map.geojson&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">% 命令行窗口输出结果</span></span><br><span class="line">jsonData = </span><br><span class="line">  包含以下字段的 struct:</span><br><span class="line">        <span class="built_in">type</span>: <span class="string">&#x27;FeatureCollection&#x27;</span></span><br><span class="line">    features: [<span class="number">1</span>×<span class="number">3</span> struct]</span><br></pre></td></tr></table></figure><p>利用<code>Matlab</code>写入<code>JSON</code></p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clc</span><br><span class="line">clear all</span><br><span class="line"></span><br><span class="line"><span class="comment">% 创建结构体变量</span></span><br><span class="line">data.<span class="built_in">type</span> = <span class="string">&#x27;Feature&#x27;</span></span><br><span class="line">data.<span class="keyword">properties</span> = &#123;&#125;</span><br><span class="line">data.geometry.coordinates = [<span class="number">116.36078873507478</span>, <span class="number">40.06152377992771</span>]</span><br><span class="line">data.geometry.<span class="built_in">type</span> = <span class="string">&#x27;Point&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 将结构体变量写入JSON文件</span></span><br><span class="line">savejson(<span class="string">&#x27;&#x27;</span>, data, <span class="string">&#x27;D:\Desktop\test.json&#x27;</span>)</span><br><span class="line"><span class="comment">% 从JSON文件中读取数据</span></span><br><span class="line">jsonData = loadjson(<span class="string">&#x27;D:\Desktop\test.json&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">% 命令行窗口输出结果</span></span><br><span class="line">data = </span><br><span class="line">  包含以下字段的 struct:</span><br><span class="line">    <span class="built_in">type</span>: <span class="string">&#x27;Feature&#x27;</span></span><br><span class="line">data = </span><br><span class="line">  包含以下字段的 struct:</span><br><span class="line">          <span class="built_in">type</span>: <span class="string">&#x27;Feature&#x27;</span></span><br><span class="line">    <span class="keyword">properties</span>: &#123;&#125;</span><br><span class="line">data = </span><br><span class="line">  包含以下字段的 struct:</span><br><span class="line">          <span class="built_in">type</span>: <span class="string">&#x27;Feature&#x27;</span></span><br><span class="line">    <span class="keyword">properties</span>: &#123;&#125;</span><br><span class="line">      geometry: [<span class="number">1</span>×<span class="number">1</span> struct]</span><br><span class="line">data = </span><br><span class="line">  包含以下字段的 struct:</span><br><span class="line">          <span class="built_in">type</span>: <span class="string">&#x27;Feature&#x27;</span></span><br><span class="line">    <span class="keyword">properties</span>: &#123;&#125;</span><br><span class="line">      geometry: [<span class="number">1</span>×<span class="number">1</span> struct]</span><br><span class="line">jsonData = </span><br><span class="line">  包含以下字段的 struct:</span><br><span class="line">          <span class="built_in">type</span>: <span class="string">&#x27;Feature&#x27;</span></span><br><span class="line">    <span class="keyword">properties</span>: &#123;<span class="number">0</span>×<span class="number">1</span> cell&#125;</span><br><span class="line">      geometry: [<span class="number">1</span>×<span class="number">1</span> struct]</span><br></pre></td></tr></table></figure><h3 id="👀XML-1"><a href="#👀XML-1" class="headerlink" title="👀XML"></a>👀XML</h3><blockquote><p><strong>参数详解见<code>MATLAB</code>帮助中心。</strong></p><p><code>xmlread()</code>读取<code>XML</code>文档并返回文档对象模型节点</p><ul><li><p>将<code>XML</code>文件读入文档对象模型 (<code>DOM</code>) 节点中</p></li><li><p>将该<code>XML</code>文件读入<code>MATLAB®</code>结构体数组中</p></li></ul><p><code>xmlwrite()</code>写入<code>XML</code>文档对象模型节点</p><ul><li><p>创建<code>XML</code>文件</p></li><li><p>以串行化文本形式获取文档对象模型 (<code>DOM</code>) 节点</p></li></ul></blockquote><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% （1）读取指定的XML文件并返回一个Apache®Xerces-J文档对象，该对象表示该XML文件的解析版本。Apache Xerces-J实现用于XML处理的Java®API(JAXP)。使用JAXP函数来操作此文档对象。有关Apache Xerces-J的详细信息，请参阅https://xerces.apache.org/xerces-j/apiDocs/。</span></span><br><span class="line">DOMnode = xmlread(filename)</span><br><span class="line"><span class="comment">% （2）还指定是否允许DOCTYPE声明。如果tf为false，则读取包含DOCTYPE声明的输入XML文件会导致错误。如果为true，xmlread则会为XML文件返回输出DOMnode。tf的默认值是true。</span></span><br><span class="line">DOMnode = xmlread(filename,<span class="string">&#x27;AllowDoctype&#x27;</span>,tf)</span><br></pre></td></tr></table></figure><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% （1）将文档对象模型(DOM)节点DOMnode写入到文件filename。使用xmlwrite要求您使用用于XML处理的Java® API(JAXP)。有关详细信息，请参阅https://docs.oracle.com/javase/7/docs/api。</span></span><br><span class="line">xmlwrite(filename,DOMnode)</span><br><span class="line"><span class="comment">% （2）以字符向量形式返回串行化DOM节点。</span></span><br><span class="line">chr = xmlwrite(DOMnode)</span><br></pre></td></tr></table></figure><h4 id="（1）读取XML-1"><a href="#（1）读取XML-1" class="headerlink" title="（1）读取XML"></a><strong>（1）读取XML</strong></h4><p><code>XML</code>源文件：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;ISO-8859-1&quot;</span>?&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Edited by XMLSpyÂ® --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">breakfast_menu</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">food</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>Belgian Waffles<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">price</span>&gt;</span>$5.95<span class="tag">&lt;/<span class="name">price</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">calories</span>&gt;</span>650<span class="tag">&lt;/<span class="name">calories</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">cropRegion</span> <span class="attr">x</span>=<span class="string">&quot;0&quot;</span> <span class="attr">y</span>=<span class="string">&quot;0&quot;</span> <span class="attr">width</span>=<span class="string">&quot;0000&quot;</span> <span class="attr">height</span>=<span class="string">&quot;1234&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">food</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">food</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>Strawberry Belgian Waffles<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">price</span>&gt;</span>$7.95<span class="tag">&lt;/<span class="name">price</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">calories</span>&gt;</span>900<span class="tag">&lt;/<span class="name">calories</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">cropRegion</span> <span class="attr">x</span>=<span class="string">&quot;1&quot;</span> <span class="attr">y</span>=<span class="string">&quot;1&quot;</span> <span class="attr">width</span>=<span class="string">&quot;1111&quot;</span> <span class="attr">height</span>=<span class="string">&quot;2345&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">food</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">food</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>Berry-Berry Belgian Waffles<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">price</span>&gt;</span>$8.95<span class="tag">&lt;/<span class="name">price</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">calories</span>&gt;</span>900<span class="tag">&lt;/<span class="name">calories</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">cropRegion</span> <span class="attr">x</span>=<span class="string">&quot;2&quot;</span> <span class="attr">y</span>=<span class="string">&quot;2&quot;</span> <span class="attr">width</span>=<span class="string">&quot;2222&quot;</span> <span class="attr">height</span>=<span class="string">&quot;3456&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">food</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">food</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>French Toast<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">price</span>&gt;</span>$4.50<span class="tag">&lt;/<span class="name">price</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">calories</span>&gt;</span>600<span class="tag">&lt;/<span class="name">calories</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">cropRegion</span> <span class="attr">x</span>=<span class="string">&quot;3&quot;</span> <span class="attr">y</span>=<span class="string">&quot;3&quot;</span> <span class="attr">width</span>=<span class="string">&quot;3333&quot;</span> <span class="attr">height</span>=<span class="string">&quot;4567&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">food</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">food</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>Homestyle Breakfast<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">price</span>&gt;</span>$6.95<span class="tag">&lt;/<span class="name">price</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">calories</span>&gt;</span>950<span class="tag">&lt;/<span class="name">calories</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">cropRegion</span> <span class="attr">x</span>=<span class="string">&quot;4&quot;</span> <span class="attr">y</span>=<span class="string">&quot;4&quot;</span> <span class="attr">width</span>=<span class="string">&quot;4444&quot;</span> <span class="attr">height</span>=<span class="string">&quot;5678&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">food</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">breakfast_menu</span>&gt;</span></span><br></pre></td></tr></table></figure><p>利用<code>xmlread()</code>读取<code>XML</code>，同时利用函数 <code>parseXML()</code>将该<code>XML</code>文件读入<code>MATLAB</code>®结构体数组中：</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% 创建一个解析函数以将一个XML文件读入MATLAB®结构体中，然后将一个示例XML文件读入MATLAB工作区中。要创建函数parseXML，请将以下代码复制并粘贴到m文件parseXML.m中。parseXML函数将一个XML文件中的数据解析为一个MATLAB结构体数组，该数组包含字段Name、Attributes、Data和Children。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">theStruct</span> = <span class="title">parseXML</span><span class="params">(filename)</span></span></span><br><span class="line"><span class="comment">% PARSEXML Convert XML file to a MATLAB structure.</span></span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">   tree = xmlread(filename);</span><br><span class="line"><span class="keyword">catch</span></span><br><span class="line">   error(<span class="string">&#x27;Failed to read XML file %s.&#x27;</span>,filename);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% Recurse over child nodes. This could run into problems </span></span><br><span class="line"><span class="comment">% with very deeply nested trees.</span></span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">   theStruct = parseChildNodes(tree);</span><br><span class="line"><span class="keyword">catch</span></span><br><span class="line">   error(<span class="string">&#x27;Unable to parse XML file %s.&#x27;</span>,filename);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">% ----- Local function PARSECHILDNODES -----</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">children</span> = <span class="title">parseChildNodes</span><span class="params">(theNode)</span></span></span><br><span class="line"><span class="comment">% Recurse over node children.</span></span><br><span class="line">children = [];</span><br><span class="line"><span class="keyword">if</span> theNode.hasChildNodes</span><br><span class="line">   childNodes = theNode.getChildNodes;</span><br><span class="line">   numChildNodes = childNodes.getLength;</span><br><span class="line">   allocCell = cell(<span class="number">1</span>, numChildNodes);</span><br><span class="line"></span><br><span class="line">   children = struct(             ...</span><br><span class="line">      <span class="string">&#x27;Name&#x27;</span>, allocCell, <span class="string">&#x27;Attributes&#x27;</span>, allocCell,    ...</span><br><span class="line">      <span class="string">&#x27;Data&#x27;</span>, allocCell, <span class="string">&#x27;Children&#x27;</span>, allocCell);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> count = <span class="number">1</span>:numChildNodes</span><br><span class="line">        theChild = childNodes.item(count<span class="number">-1</span>);</span><br><span class="line">        children(count) = makeStructFromNode(theChild);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% ----- Local function MAKESTRUCTFROMNODE -----</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">nodeStruct</span> = <span class="title">makeStructFromNode</span><span class="params">(theNode)</span></span></span><br><span class="line"><span class="comment">% Create structure of node info.</span></span><br><span class="line"></span><br><span class="line">nodeStruct = struct(                        ...</span><br><span class="line">   <span class="string">&#x27;Name&#x27;</span>, char(theNode.getNodeName),       ...</span><br><span class="line">   <span class="string">&#x27;Attributes&#x27;</span>, parseAttributes(theNode),  ...</span><br><span class="line">   <span class="string">&#x27;Data&#x27;</span>, <span class="string">&#x27;&#x27;</span>,                              ...</span><br><span class="line">   <span class="string">&#x27;Children&#x27;</span>, parseChildNodes(theNode));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> any(strcmp(<span class="keyword">methods</span>(theNode), <span class="string">&#x27;getData&#x27;</span>))</span><br><span class="line">   nodeStruct.Data = char(theNode.getData); </span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   nodeStruct.Data = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% ----- Local function PARSEATTRIBUTES -----</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">attributes</span> = <span class="title">parseAttributes</span><span class="params">(theNode)</span></span></span><br><span class="line"><span class="comment">% Create attributes structure.</span></span><br><span class="line"></span><br><span class="line">attributes = [];</span><br><span class="line"><span class="keyword">if</span> theNode.hasAttributes</span><br><span class="line">   theAttributes = theNode.getAttributes;</span><br><span class="line">   numAttributes = theAttributes.getLength;</span><br><span class="line">   allocCell = cell(<span class="number">1</span>, numAttributes);</span><br><span class="line">   attributes = struct(<span class="string">&#x27;Name&#x27;</span>, allocCell, <span class="string">&#x27;Value&#x27;</span>, ...</span><br><span class="line">                       allocCell);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> count = <span class="number">1</span>:numAttributes</span><br><span class="line">      attrib = theAttributes.item(count<span class="number">-1</span>);</span><br><span class="line">      attributes(count).Name = char(attrib.getName);</span><br><span class="line">      attributes(count).Value = char(attrib.getValue);</span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clc</span><br><span class="line">clear all</span><br><span class="line"></span><br><span class="line">sampleXMLfile = <span class="string">&#x27;D:\Desktop\simple.xml&#x27;</span>;</span><br><span class="line"><span class="comment">% 显示simple.xml文件内容</span></span><br><span class="line"><span class="built_in">type</span>(sampleXMLfile)</span><br><span class="line"><span class="comment">% 将该XML文件读入DOM节点中</span></span><br><span class="line"><span class="comment">% DOMnode = xmlread(sampleXMLfile)</span></span><br><span class="line"><span class="comment">% 使用parseXML函数将示例文件info.xml解析为一个MATLAB结构体。</span></span><br><span class="line">mlStruct = parseXML(sampleXMLfile)</span><br><span class="line"></span><br><span class="line"><span class="comment">% 命令行窗口输出结果</span></span><br><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;ISO-8859-1&quot;</span>?&gt;</span><br><span class="line">&lt;!-- Edited by XMLSpy庐 --&gt;</span><br><span class="line">&lt;breakfast_menu&gt;</span><br><span class="line">&lt;food&gt;</span><br><span class="line">&lt;name&gt;Belgian Waffles&lt;/name&gt;</span><br><span class="line">&lt;price&gt;$<span class="number">5.95</span>&lt;/price&gt;</span><br><span class="line">&lt;calories&gt;<span class="number">650</span>&lt;/calories&gt;</span><br><span class="line">&lt;cropRegion x=<span class="string">&quot;0&quot;</span> y=<span class="string">&quot;0&quot;</span> width=<span class="string">&quot;0000&quot;</span> height=<span class="string">&quot;1234&quot;</span>/&gt;</span><br><span class="line">&lt;/food&gt;</span><br><span class="line">&lt;food&gt;</span><br><span class="line">&lt;name&gt;Strawberry Belgian Waffles&lt;/name&gt;</span><br><span class="line">&lt;price&gt;$<span class="number">7.95</span>&lt;/price&gt;</span><br><span class="line">&lt;calories&gt;<span class="number">900</span>&lt;/calories&gt;</span><br><span class="line">&lt;cropRegion x=<span class="string">&quot;1&quot;</span> y=<span class="string">&quot;1&quot;</span> width=<span class="string">&quot;1111&quot;</span> height=<span class="string">&quot;2345&quot;</span>/&gt;</span><br><span class="line">&lt;/food&gt;</span><br><span class="line">&lt;food&gt;</span><br><span class="line">&lt;name&gt;Berry-Berry Belgian Waffles&lt;/name&gt;</span><br><span class="line">&lt;price&gt;$<span class="number">8.95</span>&lt;/price&gt;</span><br><span class="line">&lt;calories&gt;<span class="number">900</span>&lt;/calories&gt;</span><br><span class="line">&lt;cropRegion x=<span class="string">&quot;2&quot;</span> y=<span class="string">&quot;2&quot;</span> width=<span class="string">&quot;2222&quot;</span> height=<span class="string">&quot;3456&quot;</span>/&gt;</span><br><span class="line">&lt;/food&gt;</span><br><span class="line">&lt;food&gt;</span><br><span class="line">&lt;name&gt;French Toast&lt;/name&gt;</span><br><span class="line">&lt;price&gt;$<span class="number">4.50</span>&lt;/price&gt;</span><br><span class="line">&lt;calories&gt;<span class="number">600</span>&lt;/calories&gt;</span><br><span class="line">&lt;cropRegion x=<span class="string">&quot;3&quot;</span> y=<span class="string">&quot;3&quot;</span> width=<span class="string">&quot;3333&quot;</span> height=<span class="string">&quot;4567&quot;</span>/&gt;</span><br><span class="line">&lt;/food&gt;</span><br><span class="line">&lt;food&gt;</span><br><span class="line">&lt;name&gt;Homestyle Breakfast&lt;/name&gt;</span><br><span class="line">&lt;price&gt;$<span class="number">6.95</span>&lt;/price&gt;</span><br><span class="line">&lt;calories&gt;<span class="number">950</span>&lt;/calories&gt;</span><br><span class="line">&lt;cropRegion x=<span class="string">&quot;4&quot;</span> y=<span class="string">&quot;4&quot;</span> width=<span class="string">&quot;4444&quot;</span> height=<span class="string">&quot;5678&quot;</span>/&gt;</span><br><span class="line">&lt;/food&gt;</span><br><span class="line">&lt;/breakfast_menu&gt;</span><br><span class="line"></span><br><span class="line">mlStruct = </span><br><span class="line">  包含以下字段的 <span class="number">1</span>×<span class="number">2</span> struct 数组:</span><br><span class="line">    Name</span><br><span class="line">    Attributes</span><br><span class="line">    Data</span><br><span class="line">    Children</span><br></pre></td></tr></table></figure><h4 id="（2）写入XML-1"><a href="#（2）写入XML-1" class="headerlink" title="（2）写入XML"></a><strong>（2）写入XML</strong></h4><blockquote><p>分两步编写<code>XML</code>文件：</p><p>①创建一个包含<code>XML</code>数据的文档对象模型 (<code>DOM</code>) 节点；</p><p>②将该<code>DOM</code>节点写入一个<code>XML</code>文件。</p></blockquote><p>要实现的写入内容：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">toc</span> <span class="attr">version</span>=<span class="string">&quot;2.0&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tocitem</span> <span class="attr">target</span>=<span class="string">&quot;upslope_product_page.html&quot;</span>&gt;</span>Upslope Area Toolbox<span class="comment">&lt;!-- Functions --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tocitem</span> <span class="attr">target</span>=<span class="string">&quot;demFlow_help.html&quot;</span>&gt;</span>demFlow<span class="tag">&lt;/<span class="name">tocitem</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tocitem</span> <span class="attr">target</span>=<span class="string">&quot;facetFlow_help.html&quot;</span>&gt;</span>facetFlow<span class="tag">&lt;/<span class="name">tocitem</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tocitem</span> <span class="attr">target</span>=<span class="string">&quot;flowMatrix_help.html&quot;</span>&gt;</span>flowMatrix<span class="tag">&lt;/<span class="name">tocitem</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tocitem</span> <span class="attr">target</span>=<span class="string">&quot;pixelFlow_help.html&quot;</span>&gt;</span>pixelFlow<span class="tag">&lt;/<span class="name">tocitem</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tocitem</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">toc</span>&gt;</span></span><br></pre></td></tr></table></figure><p>利用<code>xmlwrite()</code>写入<code>XML</code>文档：</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clc</span><br><span class="line">clear all</span><br><span class="line"></span><br><span class="line"><span class="comment">% 创建DOM节点对象和根元素，然后根据XML数据填充节点元素和节点属性。</span></span><br><span class="line">docNode = com.mathworks.xml.XMLUtils.createDocument(<span class="string">&#x27;toc&#x27;</span>);</span><br><span class="line"><span class="comment">% 确定根元素并设置version属性。</span></span><br><span class="line">toc = docNode.getDocumentElement;</span><br><span class="line">toc.setAttribute(<span class="string">&#x27;version&#x27;</span>,<span class="string">&#x27;2.0&#x27;</span>);</span><br><span class="line"><span class="comment">% 添加tocitem元素。此文件中的每个tocitem元素都有一个target属性和一个子文本节点。</span></span><br><span class="line">product = docNode.createElement(<span class="string">&#x27;tocitem&#x27;</span>);</span><br><span class="line">product.setAttribute(<span class="string">&#x27;target&#x27;</span>,<span class="string">&#x27;upslope_product_page.html&#x27;</span>);</span><br><span class="line">product.appendChild(docNode.createTextNode(<span class="string">&#x27;Upslope Area Toolbox&#x27;</span>));</span><br><span class="line">toc.appendChild(product);</span><br><span class="line"><span class="comment">% 添加注释</span></span><br><span class="line">product.appendChild(docNode.createComment(<span class="string">&#x27; Functions &#x27;</span>));</span><br><span class="line"><span class="comment">% 为每个函数添加一个tocitem元素</span></span><br><span class="line">functions = &#123;<span class="string">&#x27;demFlow&#x27;</span>,<span class="string">&#x27;facetFlow&#x27;</span>,<span class="string">&#x27;flowMatrix&#x27;</span>,<span class="string">&#x27;pixelFlow&#x27;</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> idx = <span class="number">1</span>:<span class="built_in">numel</span>(functions)</span><br><span class="line">    curr_node = docNode.createElement(<span class="string">&#x27;tocitem&#x27;</span>);</span><br><span class="line">    </span><br><span class="line">    curr_file = [functions&#123;idx&#125; <span class="string">&#x27;_help.html&#x27;</span>]; </span><br><span class="line">    curr_node.setAttribute(<span class="string">&#x27;target&#x27;</span>,curr_file);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">% Child text is the function name.</span></span><br><span class="line">    curr_node.appendChild(docNode.createTextNode(functions&#123;idx&#125;));</span><br><span class="line">    product.appendChild(curr_node);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">% 将DOM节点导出到名为infoUAT.xml的XML文件中，并使用type函数查看该文件</span></span><br><span class="line">xmlwrite(<span class="string">&#x27;D:\Desktop\infoUAT.xml&#x27;</span>,docNode);</span><br><span class="line"><span class="built_in">type</span>(<span class="string">&#x27;D:\Desktop\infoUAT.xml&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 命令行窗口输出结果</span></span><br><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="line">&lt;toc version=<span class="string">&quot;2.0&quot;</span>&gt;</span><br><span class="line">   &lt;tocitem target=<span class="string">&quot;upslope_product_page.html&quot;</span>&gt;Upslope Area Toolbox&lt;!-- Functions --&gt;  &lt;tocitem target=<span class="string">&quot;demFlow_help.html&quot;</span>&gt;demFlow&lt;/tocitem&gt;</span><br><span class="line">      &lt;tocitem target=<span class="string">&quot;facetFlow_help.html&quot;</span>&gt;facetFlow&lt;/tocitem&gt;</span><br><span class="line">      &lt;tocitem target=<span class="string">&quot;flowMatrix_help.html&quot;</span>&gt;flowMatrix&lt;/tocitem&gt;</span><br><span class="line">      &lt;tocitem target=<span class="string">&quot;pixelFlow_help.html&quot;</span>&gt;pixelFlow&lt;/tocitem&gt;</span><br><span class="line">   &lt;/tocitem&gt;</span><br><span class="line">&lt;/toc&gt;</span><br></pre></td></tr></table></figure><h3 id="👀TXT（函数例举）"><a href="#👀TXT（函数例举）" class="headerlink" title="👀TXT（函数例举）"></a>👀TXT（函数例举）</h3><blockquote><ul><li><p><code>textread()</code></p></li><li><p><code>textscan()</code></p></li><li><p><code>readmatrix()</code></p></li><li><p><code>writematrix()</code></p></li><li><p><code>readtable()</code></p></li><li><p><code>writetable()</code></p></li><li><p><code>load()</code></p></li><li><p><code>dlmread()</code></p></li><li><p><code>dlmwrite()</code></p></li><li><p><code>importdata()</code></p></li><li><p><code>save()</code></p></li><li><p>……</p></li></ul></blockquote><h2 id="⛄IDL之读写文件"><a href="#⛄IDL之读写文件" class="headerlink" title="⛄IDL之读写文件"></a>⛄IDL之读写文件</h2><p><code>IDL</code>从磁盘上的文件读写数据，必须首先把一个逻辑设备号连接到一个特定的文件，然后进行文件操作如打开、关闭和读取等。<code>IDL</code>中的逻辑设备号范围是<code>-2—128</code>，其中<code>1-99</code>是可以用户任意指定的，<code>100-128</code>是根据<code>get_lun</code>和<code>free_lun</code>来管理的，其他是特殊函数专用的。<code>IDL</code>中文件操作的函数列表：</p><table><thead><tr><th>函数名字</th><th>作用</th></tr></thead><tbody><tr><td><code>OpenR</code></td><td>以只读方式打开已存在文件；</td></tr><tr><td><code>OpenW</code></td><td>创建一个可以读写的新文件；</td></tr><tr><td><code>OpenU</code></td><td>以更新模式打开已存在文件；</td></tr><tr><td><code>File_Search()</code></td><td>对文件名进行特定的查找；</td></tr><tr><td><code>Dialog_Pickfile()</code></td><td>对话框方式选择文件；</td></tr><tr><td><code>Fstat()</code></td><td>返回一个已打开文件的信息；</td></tr><tr><td><code>EOF()</code></td><td>检测是否到文件末；</td></tr><tr><td><code>CLOSE</code></td><td>关闭一个文件；</td></tr><tr><td><code>Free_Lun</code></td><td>释放一个逻辑设备号并关闭文件；</td></tr></tbody></table><p><code>IDL</code>在读写该文件分为有两种格式化文件：自由文件格式和确定的文件格式。</p><p>自由文件格式是用逗号或空白（<code>tab</code>键和空格键）分开文件中的每个元素的<code>ASCII</code>文件。确定的格式文件是用格式说明按照给定的规范进行编排的。二者相比后者比前者更正规一些。</p><p><strong>读写自由文件格式：</strong><code>IDL</code>下用<code>ReadF</code>从文件中读入自由格式数据，<code>Printf</code>写入自由格式数据到文件中。<code>IDL</code>中读写自由格式文件遵循下面的几个规则：</p><ul><li><p>如果读入到字符串变量中，那么，在当前行剩下的所有字符都将读入该变量中；</p></li><li><p>输入数据必须用逗号或空白分隔（空格键或 tab 键）；</p></li><li><p>输入通过数字变量完成。数组和结构都可作为数字变量的集合；</p></li><li><p>如果当前读入行是空的，并且还有变量要求输入，则读取另一行；</p></li><li><p>如果当前读入行不是空的，但是没有变量要求输入，则忽略此行剩下的数；</p></li><li><p>尽量将数据转换为变量所希望的数据类型；</p></li><li><p>复数数据必须有实数和虚数两部分，用逗号分隔，并用括号括起来。</p></li></ul><p><strong>读写确定的文件格式：</strong>读写确定文件格式可同样用<code>ReadF</code>和<code>PrintF</code>命令，它们刚才已用于自由格式文件，但现在文件格式已由<code>Format</code>关键字明确声明。（在读写标准输入和输出时，也可将<code>Format</code>关键字用于<code>Read</code>和<code>Print</code>令）。</p><h3 id="👀CSV-2"><a href="#👀CSV-2" class="headerlink" title="👀CSV"></a>👀CSV</h3><p><code>CSV</code>示例源文件：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lon,lat,area</span><br><span class="line">101,50,20</span><br><span class="line">102,51,22</span><br><span class="line">103,52,24</span><br><span class="line">104,53,21</span><br><span class="line">105,54,25</span><br><span class="line">106,55,20</span><br><span class="line">107,56,25</span><br><span class="line">108,57,20</span><br><span class="line">109,58,18</span><br><span class="line">110,59,20.58333333</span><br><span class="line">111,60,20.36666667</span><br><span class="line">112,61,20.15</span><br><span class="line">113,62,19.93333333</span><br><span class="line">114,63,19.71666667</span><br><span class="line">115,64,19.5</span><br><span class="line">116,65,19.28333333</span><br></pre></td></tr></table></figure><p>读取<code>CSV</code>文件：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pro Demo02</span><br><span class="line">  ; 打开csv文件</span><br><span class="line">  csv_file = &#x27;D:\Desktop\data_p2.csv&#x27;</span><br><span class="line">  ; 读取文件</span><br><span class="line">  ; 第一行是索引,参数par_name(无论需不需要第一行索引数据，read_csv()函数默认都不会去读取第一行的数据)</span><br><span class="line">  data_csv = Read_csv(csv_file, header=par_name)</span><br><span class="line">  ; 查看data的类型,是一个结构体</span><br><span class="line">  ; Help, data_csv</span><br><span class="line">  ; 输出第一列数据</span><br><span class="line">  Print, data_csv.(0)</span><br><span class="line">  ; 输出第一行的索引数据</span><br><span class="line">  Print, par_name</span><br><span class="line">  ; 输出列索引是lat的数据(第一种方法可以数它所在的列号按上面的方式进行读取并输出，也可按下面这种方法)</span><br><span class="line">  lon = Where(par_name EQ &#x27;lat&#x27;)</span><br><span class="line">  Print, data_csv.(lon) </span><br><span class="line">END</span><br><span class="line"></span><br><span class="line">; IDL控制台输出结果（结果样式与控制台的宽度有关）</span><br><span class="line">% Compiled module: DEMO02.</span><br><span class="line">         101         102         103         104         105</span><br><span class="line">         106         107         108         109         110</span><br><span class="line">         111         112         113         114         115</span><br><span class="line">         116</span><br><span class="line">lon lat area</span><br><span class="line">          50          51          52          53          54</span><br><span class="line">          55          56          57          58          59</span><br><span class="line">          60          61          62          63          64</span><br><span class="line">          65</span><br></pre></td></tr></table></figure><p>写入<code>CSV</code>文件：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pro Demo04_csv</span><br><span class="line">    ; 打开csv文件,获取数据</span><br><span class="line">    csv_file = &#x27;D:\Desktop\data_p2.csv&#x27;</span><br><span class="line">    ; 读取文件</span><br><span class="line">    ; 第一行的索引给了,参数par_name(但是无论你需不需要第一行索引数据，read_csv()函数默认都不会去读取第一行的数据)</span><br><span class="line">    data_csv = Read_csv(csv_file, header=par_name)</span><br><span class="line">    ; 查看data的类型,是一个结构体</span><br><span class="line">    ; Help, data_csv</span><br><span class="line">    ; 输出第一列数据</span><br><span class="line">    Print, data_csv.(0)</span><br><span class="line">    ; 输出第一行的索引数据</span><br><span class="line">    Print, par_name</span><br><span class="line">    ; 输出列索引是lat的数据(第一种方法你可以自己去数它所在的列号按上面的方式进行读取并输出，也可以按下面这种方法)</span><br><span class="line">    lon = Where(par_name EQ &#x27;lat&#x27;)</span><br><span class="line">    Print, data_csv.(lon)</span><br><span class="line">    </span><br><span class="line">    ; 写入csv文件</span><br><span class="line">    save_file = &#x27;D:\Desktop\data_p3.csv&#x27;</span><br><span class="line">    data_size = size(data_csv.(2))</span><br><span class="line">    length = data_size[-1]</span><br><span class="line">    data_box = fltarr(3,length)</span><br><span class="line">    data_box[0,*] = data_csv.(0)</span><br><span class="line">    data_box[1,*] = data_csv.(1)</span><br><span class="line">    data_box[2,*] = data_csv.(2)</span><br><span class="line">    print,data_box</span><br><span class="line">    Write_csv, save_file, data_box</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">; IDL控制台输出结果</span><br><span class="line">% Compiled module: DEMO04_CSV.</span><br><span class="line">         101         102         103</span><br><span class="line">         104         105         106</span><br><span class="line">         107         108         109</span><br><span class="line">         110         111         112</span><br><span class="line">         113         114         115</span><br><span class="line">         116</span><br><span class="line">lon lat area</span><br><span class="line">          50          51          52</span><br><span class="line">          53          54          55</span><br><span class="line">          56          57          58</span><br><span class="line">          59          60          61</span><br><span class="line">          62          63          64</span><br><span class="line">          65</span><br><span class="line">      101.000      50.0000      20.0000</span><br><span class="line">      102.000      51.0000      22.0000</span><br><span class="line">      103.000      52.0000      24.0000</span><br><span class="line">      104.000      53.0000      21.0000</span><br><span class="line">      105.000      54.0000      25.0000</span><br><span class="line">      106.000      55.0000      20.0000</span><br><span class="line">      107.000      56.0000      25.0000</span><br><span class="line">      108.000      57.0000      20.0000</span><br><span class="line">      109.000      58.0000      18.0000</span><br><span class="line">      110.000      59.0000      20.5833</span><br><span class="line">      111.000      60.0000      20.3667</span><br><span class="line">      112.000      61.0000      20.1500</span><br><span class="line">      113.000      62.0000      19.9333</span><br><span class="line">      114.000      63.0000      19.7167</span><br><span class="line">      115.000      64.0000      19.5000</span><br><span class="line">      116.000      65.0000      19.2833</span><br><span class="line">% Compiled module: WRITE_CSV.</span><br></pre></td></tr></table></figure><h3 id="👀XML-2"><a href="#👀XML-2" class="headerlink" title="👀XML"></a>👀XML</h3><p><code>XML</code>示例源文件：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;ISO-8859-1&quot;</span>?&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Edited by XMLSpyÂ® --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">breakfast_menu</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">food</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>Belgian Waffles<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">price</span>&gt;</span>$5.95<span class="tag">&lt;/<span class="name">price</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">calories</span>&gt;</span>650<span class="tag">&lt;/<span class="name">calories</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">cropRegion</span> <span class="attr">x</span>=<span class="string">&quot;0&quot;</span> <span class="attr">y</span>=<span class="string">&quot;0&quot;</span> <span class="attr">width</span>=<span class="string">&quot;0000&quot;</span> <span class="attr">height</span>=<span class="string">&quot;1234&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">food</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">food</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>Strawberry Belgian Waffles<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">price</span>&gt;</span>$7.95<span class="tag">&lt;/<span class="name">price</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">calories</span>&gt;</span>900<span class="tag">&lt;/<span class="name">calories</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">cropRegion</span> <span class="attr">x</span>=<span class="string">&quot;1&quot;</span> <span class="attr">y</span>=<span class="string">&quot;1&quot;</span> <span class="attr">width</span>=<span class="string">&quot;1111&quot;</span> <span class="attr">height</span>=<span class="string">&quot;2345&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">food</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">food</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>Berry-Berry Belgian Waffles<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">price</span>&gt;</span>$8.95<span class="tag">&lt;/<span class="name">price</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">calories</span>&gt;</span>900<span class="tag">&lt;/<span class="name">calories</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">cropRegion</span> <span class="attr">x</span>=<span class="string">&quot;2&quot;</span> <span class="attr">y</span>=<span class="string">&quot;2&quot;</span> <span class="attr">width</span>=<span class="string">&quot;2222&quot;</span> <span class="attr">height</span>=<span class="string">&quot;3456&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">food</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">food</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>French Toast<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">price</span>&gt;</span>$4.50<span class="tag">&lt;/<span class="name">price</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">calories</span>&gt;</span>600<span class="tag">&lt;/<span class="name">calories</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">cropRegion</span> <span class="attr">x</span>=<span class="string">&quot;3&quot;</span> <span class="attr">y</span>=<span class="string">&quot;3&quot;</span> <span class="attr">width</span>=<span class="string">&quot;3333&quot;</span> <span class="attr">height</span>=<span class="string">&quot;4567&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">food</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">food</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>Homestyle Breakfast<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">price</span>&gt;</span>$6.95<span class="tag">&lt;/<span class="name">price</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">calories</span>&gt;</span>950<span class="tag">&lt;/<span class="name">calories</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">cropRegion</span> <span class="attr">x</span>=<span class="string">&quot;4&quot;</span> <span class="attr">y</span>=<span class="string">&quot;4&quot;</span> <span class="attr">width</span>=<span class="string">&quot;4444&quot;</span> <span class="attr">height</span>=<span class="string">&quot;5678&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">food</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">breakfast_menu</span>&gt;</span></span><br></pre></td></tr></table></figure><p>读取<code>XML</code>文件：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pro Demo02</span><br><span class="line">  XML_file = &#x27;D:\Desktop\simple.xml&#x27;</span><br><span class="line">  XML = IDLffXMLDOMDocument(filename = XML_file)</span><br><span class="line">  name = XML.Getelementsbytagname(&#x27;name&#x27;)</span><br><span class="line">  name = name.item(4)</span><br><span class="line">  print,(name.getfirstchild()).getnodevalue()</span><br><span class="line">  ; 获取属性值</span><br><span class="line">  cropRegion = XML.Getelementsbytagname(&#x27;cropRegion&#x27;)</span><br><span class="line">  cropRegion = cropRegion.Item(4)</span><br><span class="line">  print,cropRegion.GetAttribute(&#x27;height&#x27;)</span><br><span class="line">  ; 销毁对象</span><br><span class="line">  Obj_destroy, name</span><br><span class="line">  Obj_destroy, XML</span><br><span class="line">END</span><br><span class="line"></span><br><span class="line">; IDL控制台输出结果</span><br><span class="line">% Compiled module: DEMO02.</span><br><span class="line">Homestyle Breakfast</span><br><span class="line">5678</span><br></pre></td></tr></table></figure><h3 id="👀TXT-1"><a href="#👀TXT-1" class="headerlink" title="👀TXT"></a>👀TXT</h3><p><code>TXT</code>示例源文件：</p><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">lonlatarea</span><br><span class="line">1015020</span><br><span class="line">1025122</span><br><span class="line">1035224</span><br><span class="line">1045321</span><br><span class="line">1055425</span><br><span class="line">1065520</span><br><span class="line">1075625</span><br><span class="line">1085720</span><br><span class="line">1095818</span><br><span class="line">1105920.58333333</span><br><span class="line">1116020.36666667</span><br><span class="line">1126120.15</span><br><span class="line">1136219.93333333</span><br><span class="line">1146319.71666667</span><br><span class="line">1156419.5</span><br><span class="line">1166519.28333333</span><br></pre></td></tr></table></figure><p>读取<code>TXT</code>文件：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pro Demo02</span><br><span class="line">  ; 文件路径 </span><br><span class="line">  fn = &#x27;D:\Desktop\data_p1.txt&#x27;</span><br><span class="line">  ; （1）第一种方法，打开txt文件</span><br><span class="line">  ; 如果你只是读文件openr就可以了，openw既可以读也可以写(会覆盖原来的文件，慎用)</span><br><span class="line">  ; 第一个lun用来表示这个文件的内存地址,第二个fn是该文件的路径，第三个/get_lun动态获取地址</span><br><span class="line">  openr, lun, fn, /get_lun</span><br><span class="line">  ; 由于第一行是索引，索引是文字，索引下面是数字， 两者类型不一致，不能放在一个数组里面存储，所以需要跳过</span><br><span class="line">  ; 第一个lun表示文件的编号或者说是内存地址的代称，第二个1表示需要跳过的行数，这里只跳过第一行，所以是1，第三个表示第二个参数的单位是行而不是列</span><br><span class="line">  skip_lun, lun, 1, /lines</span><br><span class="line">  ; 创建存储的数组</span><br><span class="line">  ; 通过记事本打开该文件事先查看到该文件的数据的行列数(共有3列17行，但是第一行跳过所以只需要16行)</span><br><span class="line">  data = fltarr(3,16)</span><br><span class="line">  ; 获取文件的数据</span><br><span class="line">  readf, lun, data</span><br><span class="line">  ; 检验一下，获取某一个数据</span><br><span class="line">  print, data[2, -1]</span><br><span class="line">  ; 关闭文件</span><br><span class="line">  free_lun,lun</span><br><span class="line">  </span><br><span class="line">  ; （2）第二种方法，打开txt文件</span><br><span class="line">  openr, lun, fn, /get_lun</span><br><span class="line">  ; 获得第一行的索引数据，也是有用的(获取列数)</span><br><span class="line">  ; 预先有一个str变量存储</span><br><span class="line">  str = &#x27;&#x27;</span><br><span class="line">  ; readf是秉承着有多少给多少，现在str是一个字符串，默认输出一行，如果你是数组，那么根据数组的行列数有多少给多少</span><br><span class="line">  ; 对得到的存储有第一行索引数据的str变量进行分析，通过该字符串分析出整个数据有多少列</span><br><span class="line">  Readf, lun, str</span><br><span class="line">  ; 默认以空格作为该字符串的分隔符  </span><br><span class="line">  son_str_array = Strsplit(str, /extract)</span><br><span class="line">  ; son_str_array里面有几个元素，那么整个数据就有几列</span><br><span class="line">  column = N_elements(son_str_array)</span><br><span class="line">  ; 现在获取行数,第一行是索引,所以需要减去1</span><br><span class="line">  row = File_lines(fn) - 1</span><br><span class="line">  ; 创建存储的数组</span><br><span class="line">  box_data = Fltarr(column, row)</span><br><span class="line">  ; 获取数据（这里行数是从第二行开头开始的，因为前面已经readf, lun, str，文件指针已经指到第二行开头处）</span><br><span class="line">  Readf, lun, box_data</span><br><span class="line">  ; 检验一下，获取某一个数据</span><br><span class="line">  Print, box_data[2, -1]</span><br><span class="line">  ; 关闭文件</span><br><span class="line">  Free_lun, 1</span><br><span class="line">  </span><br><span class="line">  ; （3）第三种方法，打开txt文件</span><br><span class="line">  Openr, lun, fn, /get_lun</span><br><span class="line">  skip_lun, lun, 1, /lines</span><br><span class="line">  ; 读取文件的行数</span><br><span class="line">  row = File_lines(fn) - 1</span><br><span class="line">  ; 创建存储的列表,列数是通过txt记事本打开看到的</span><br><span class="line">  ; 相对来说，列数比较固定，行数不确定</span><br><span class="line">  box_data2 = Fltarr(5, row)</span><br><span class="line">  Readf, lun, box_data</span><br><span class="line">  ; 检验一下</span><br><span class="line">  Print, box_data[2, -1]</span><br><span class="line">  ; 关闭文件</span><br><span class="line">  Free_lun, lun</span><br><span class="line">END</span><br><span class="line"></span><br><span class="line">; IDL控制台输出结果</span><br><span class="line">% Compiled module: DEMO02.</span><br><span class="line">      19.2833</span><br><span class="line">      19.2833</span><br><span class="line">      19.2833</span><br></pre></td></tr></table></figure><p>写入<code>TXT</code>文件：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pro print_test</span><br><span class="line">  ;  写入txt</span><br><span class="line">  outfilepath=&#x27;D:\Desktop\&#x27;</span><br><span class="line">  outfilename = STRCOMPRESS(outfilepath+&#x27;navi_route.txt&#x27;,/remove_all)</span><br><span class="line">  openw,var_lun,outfilename,/get_lun</span><br><span class="line">  for i=1,365 do begin</span><br><span class="line">      z=i/2</span><br><span class="line">      if z gt 10 then begin</span><br><span class="line">        z=1024</span><br><span class="line">      endif else begin</span><br><span class="line">        z=150+i</span><br><span class="line">      endelse</span><br><span class="line">      printf,var_lun,FORMAT=&#x27;(I3,I10)&#x27;,i,z</span><br><span class="line">  endfor</span><br><span class="line">  close,var_lun</span><br><span class="line">  free_lun,var_lun</span><br><span class="line">  </span><br><span class="line">  ; 读取对应txt</span><br><span class="line">  infilepath=&#x27;D:\Desktop\&#x27;</span><br><span class="line">  Cd,infilepath</span><br><span class="line">  thesefiles = File_search(&#x27;navi_route.txt&#x27;)</span><br><span class="line">  result=Intarr(2,365)</span><br><span class="line">  Openr,lun,thesefiles[0],/get_lun</span><br><span class="line">  FOR i=0,365-1 DO BEGIN</span><br><span class="line">    Readf,lun,FORMAT=&#x27;(I3,I10)&#x27;,day,value</span><br><span class="line">    result[0,i]=Long(day)</span><br><span class="line">    result[1,i]=Long(value)</span><br><span class="line">  ENDFOR</span><br><span class="line">  Free_lun,lun</span><br><span class="line">  Print,result</span><br><span class="line">END</span><br><span class="line"></span><br><span class="line">; IDL控制台输出结果</span><br><span class="line">% Compiled module: PRINT_TEST.</span><br><span class="line">       1     151</span><br><span class="line">       2     152</span><br><span class="line">       3     153</span><br><span class="line">       4     154</span><br><span class="line">       5     155</span><br><span class="line">       6     156</span><br><span class="line">       7     157</span><br><span class="line">       8     158</span><br><span class="line">       9     159</span><br><span class="line">      10     160</span><br><span class="line">      11     161</span><br><span class="line">      ... ...</span><br><span class="line">     358    1024</span><br><span class="line"> 359    1024</span><br><span class="line">     360    1024</span><br><span class="line">     361    1024</span><br><span class="line">     362    1024</span><br><span class="line">     363    1024</span><br><span class="line">     364    1024</span><br><span class="line">     365    1024</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> IDL </category>
          
          <category> Matlab </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文件读写 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>哨兵系列数据下载地址及流程更新【202310】</title>
      <link href="/2023/10/28/Sentinel-Download/"/>
      <url>/2023/10/28/Sentinel-Download/</url>
      
        <content type="html"><![CDATA[<p>﻿<strong>哨兵系列卫星</strong>作为哥白尼计划的一部分，主要目标便是对地球的观测任务。哥白尼计划由三部分组成：</p><ul><li>空间部分（<strong>哨兵系列</strong>太空任务与其他太空机构任务）</li><li>测量部分（提供海洋、大陆表面和大气信息的陆基和机载数据收集网络）</li><li>数据管理与全球共享</li></ul><table><thead><tr><th>卫星名</th><th>发射时间</th><th>终止时间</th><th>卫星定位</th></tr></thead><tbody><tr><td>Sentinel-1A</td><td>2014.04.03</td><td>在轨运行，预期寿命7年</td><td>雷达</td></tr><tr><td>Sentinel-1B</td><td>2016.04.25</td><td>在轨运行，预期寿命7年</td><td>雷达</td></tr><tr><td>Sentinel-2A</td><td>2015.06.23</td><td>在轨运行，预期寿命7年</td><td>高分辨率光学</td></tr><tr><td>Sentinel-2B</td><td>2017.03.07</td><td>在轨运行，预期寿命7年</td><td>高分辨率光学</td></tr><tr><td>Sentinel-3A</td><td>2016.02.16</td><td>在轨运行，预期寿命7年</td><td>包含雷达、光学、定位等7类传感器</td></tr><tr><td>Sentinel-3B</td><td>2018.04.25</td><td>在轨运行，预期寿命7年</td><td>包含雷达、光学、定位等7类传感器</td></tr><tr><td>Sentinel-5P</td><td>2017.10.13</td><td>在轨运行，预期寿命7年</td><td>大气污染观测</td></tr><tr><td>…</td><td>…</td><td>…</td><td>…</td></tr></tbody></table><h2 id="⛄Sentinel数据下载问题及新服务"><a href="#⛄Sentinel数据下载问题及新服务" class="headerlink" title="⛄Sentinel数据下载问题及新服务"></a>⛄Sentinel数据下载问题及新服务</h2><p>当前，在<a href="https://scihub.copernicus.eu/">欧空局官网</a>下载哨兵数据时，筛选合适的数据（包括<code>online</code>和<code>Offline</code>两种形式数据）添加到购物车，申请<code>offline</code>状态的数据再次上线，等待半天或者一天仍然申请失败。通过查询<a href="https://scihub.copernicus.eu/">欧空局官网</a>的<a href="https://scihub.copernicus.eu/news/News01242">最新消息</a>可知：</p><blockquote><p><strong>Copernicus Open Access Hub is closing at the end of October 2023. Copernicus Sentinel Data Access is now fully available in the Copernicus Data Space Ecosystem</strong></p><p>As previously announced in <a href="https://scihub.copernicus.eu/news/News01146">January</a> the Copernicus Open Access Hub service continued its full operations until the end of June 2023, followed up by a gradual ramp-down phase until September 2023. The Copernicus Open Access Hub will be exceptionally extended for another month and will cease operations at the end of October 2023. To continue accessing Copernicus Sentinel data users will need to <a href="https://documentation.dataspace.copernicus.eu/Registration.html">self-register</a> on the new <a href="https://dataspace.copernicus.eu/">Copernicus Data Space Ecosystem</a>. A guide for migration is available <a href="https://dataspace.copernicus.eu/news/2023-7-13-accessing-sentinel-mission-data-new-copernicus-data-space-ecosystem-apis">here</a>.</p><p>The new service offers access to a wide range of Earth observation data and services as well as new <a href="https://dataspace.copernicus.eu/analyse">tools</a>, <a href="https://dataspace.copernicus.eu/browser/">GUI</a> and <a href="https://documentation.dataspace.copernicus.eu/APIs.html">APIs</a> to help users explore and analyse satellite imagery. Discover more about the Copernicus Data Space Ecosystem at <a href="https://dataspace.copernicus.eu/">https://dataspace.copernicus.eu</a></p><p>17 Oct 2023 - 13:18 UTC</p></blockquote><p>哥白尼开放访问中心将于2023年10月底关闭，哥白尼哨兵数据访问现在在哥白尼数据空间生态系统中完全可用。</p><p>正如之前在1月份宣布的那样，哥白尼开放访问中心服务将继续全面运营至2023年6月底，随后逐步减少，直到2023年9月。哥白尼开放访问中心将特别延长一个月，并将于2023年10月底停止运营。为了继续访问哥白尼哨兵数据，用户需要在新的哥白尼数据空间生态系统上自我注册。</p><p>新服务提供广泛的地球观测数据和服务，以及新的工具、<code>GUI</code>和<code>api</code>，以帮助用户探索和分析卫星图像。了解更多关于哥白尼数据空间生态系统的信息，请访问<a href="https://dataspace.copernicus.eu/">https://dataspace.copernicus.eu</a></p><h2 id="⛄Sentinel数据下载流程"><a href="#⛄Sentinel数据下载流程" class="headerlink" title="⛄Sentinel数据下载流程"></a>⛄Sentinel数据下载流程</h2><p><a href="https://dataspace.copernicus.eu/">哥白尼数据空间生态系统</a>（<a href="https://dataspace.copernicus.eu/">https://dataspace.copernicus.eu/</a>）</p><h3 id="👀打开网址"><a href="#👀打开网址" class="headerlink" title="👀打开网址"></a>👀打开<a href="https://dataspace.copernicus.eu/">网址</a></h3><p><a href="https://imgse.com/i/pieQouD"><img src="https://z1.ax1x.com/2023/10/28/pieQouD.jpg" alt="pieQouD.jpg"></a></p><h3 id="👀登录账户（自行注册：教程）"><a href="#👀登录账户（自行注册：教程）" class="headerlink" title="👀登录账户（自行注册：教程）"></a>👀登录账户（自行注册：<a href="https://documentation.dataspace.copernicus.eu/Registration.html">教程</a>）</h3><p><a href="https://imgse.com/i/pieQ4gK"><img src="https://z1.ax1x.com/2023/10/28/pieQ4gK.jpg" alt="pieQ4gK.jpg"></a></p><h3 id="👀打开下载界面"><a href="#👀打开下载界面" class="headerlink" title="👀打开下载界面"></a>👀打开<a href="https://dataspace.copernicus.eu/browser/">下载界面</a></h3><blockquote><p>主界面：<code>EXPLORE DATA</code>→<code>Copernicus Browser</code></p></blockquote><p><a href="https://imgse.com/i/pieQR41"><img src="https://z1.ax1x.com/2023/10/28/pieQR41.jpg" alt="pieQR41.jpg"></a><br><a href="https://imgse.com/i/pieQ2NR"><img src="https://z1.ax1x.com/2023/10/28/pieQ2NR.jpg" alt="pieQ2NR.jpg"></a></p><h3 id="👀哨兵数据筛选和添加"><a href="#👀哨兵数据筛选和添加" class="headerlink" title="👀哨兵数据筛选和添加"></a>👀哨兵数据筛选和添加</h3><blockquote><p>（1）目前支持：<code>Sentinel-1</code>、<code>Sentinel-2</code>、<code>Sentinel-3</code>、<code>Sentinel-5P</code></p><p>（2）对于少量数据可以直接点击下载；对于大量数据可以添加至工作空间。</p></blockquote><ul><li>点击”<code>SEARCH</code>“一栏，选择对应数据源和区域，设置时间，点击”<code>Search</code>“</li></ul><p><a href="https://imgse.com/i/pieQf9x"><img src="https://z1.ax1x.com/2023/10/28/pieQf9x.jpg" alt="pieQf9x.jpg"></a></p><ul><li>查看数据属性，筛选符合要求的数据源，添加到工作空间”<code>Add to workspace</code>“</li></ul><p><a href="https://imgse.com/i/pieQTDe"><img src="https://z1.ax1x.com/2023/10/28/pieQTDe.jpg" alt="pieQTDe.jpg"></a></p><h3 id="👀下载数据"><a href="#👀下载数据" class="headerlink" title="👀下载数据"></a>👀下载数据</h3><ul><li>打开工作空间：界面上方账户名（下箭头）→”<code>Workspace</code>“</li></ul><p><a href="https://imgse.com/i/pieQ5jO"><img src="https://z1.ax1x.com/2023/10/28/pieQ5jO.jpg" alt="pieQ5jO.jpg"></a><br><a href="https://imgse.com/i/pie1Tkd"><img src="https://z1.ax1x.com/2023/10/28/pie1Tkd.jpg" alt="pie1Tkd.jpg"></a></p><ul><li>勾选需要下载的数据，点击”<code>Download</code>“</li></ul><p><a href="https://imgse.com/i/pie1ITH"><img src="https://z1.ax1x.com/2023/10/28/pie1ITH.jpg" alt="pie1ITH.jpg"></a><br><a href="https://imgse.com/i/pieQ7HH"><img src="https://z1.ax1x.com/2023/10/28/pieQ7HH.jpg" alt="pieQ7HH.jpg"></a><br>多谢！多谢！<br>笔者不才，请多交流！！！</p>]]></content>
      
      
      <categories>
          
          <category> 遥感数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Sentinel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Himawari8-9数据下载和预处理教程</title>
      <link href="/2023/04/09/RS-Data-Process01/"/>
      <url>/2023/04/09/RS-Data-Process01/</url>
      
        <content type="html"><![CDATA[<p><code>Himawari-8</code>是2015年7月7日凌晨2点（<code>UTC</code>）发射并投入运行，<code>Himawari-9</code>是2016年11月2日发射的，于2017年3月开始后备作业。这两个卫星都计划运行到2029年。早期阶段，<code>Himawari-8</code>号将主要用于观测，而<code>Himawari-9</code>号将起到辅助作用。他们的运行将在2022年进行切换，将<code>Himawari-9</code>号置于主要观测角色，并以<code>Himawari-8</code>号为后备。</p><p><code>Himawari-8/9</code>的<code>AHIS</code>有16个观测波段(3个为可见光，3个为近红外，10个为红外)，全盘观测时间间隔为10分钟。<code>Himawari-8/9</code>的可见光波段分辨率为0.5-1公里，近红外和红外波段分辨率为1-2公里。</p><h2 id="⛄Himawari8-x2F-9数据下载"><a href="#⛄Himawari8-x2F-9数据下载" class="headerlink" title="⛄Himawari8&#x2F;9数据下载"></a>⛄Himawari8&#x2F;9数据下载</h2><h3 id="👀前期准备"><a href="#👀前期准备" class="headerlink" title="👀前期准备"></a>👀前期准备</h3><p>①进入<strong>Himawari8-9</strong>官网，<a href="https://www.eorc.jaxa.jp/ptree/index.html">JAXA Himawari Monitor</a>，<a href="https://www.eorc.jaxa.jp/ptree/registration_top.html">注册新用户</a>（已有请忽略）</p><p>②在注册的邮箱里面收到邮件，包括：<code>Address</code>、<code>UID</code>、<code>PW</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Arrress:ftp.ptree.jaxa.jp</span><br><span class="line">UID:**********</span><br><span class="line">PW:**********</span><br></pre></td></tr></table></figure><h3 id="👀FileZilla-Client方式下载"><a href="#👀FileZilla-Client方式下载" class="headerlink" title="👀FileZilla Client方式下载"></a>👀FileZilla Client方式下载</h3><p>①安装<code>FileZilla Client</code>；</p><p>②在“站点管理器”里面创建“新站点”，输入主机名称，即<code>Address</code>；输入用户，即<code>UID</code>；输入密码，即<code>PW</code>；</p><p>③连接远程站点，下载所需数据；</p><p>④文件夹和文件描述。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/jma/：Himawari标准数据(Himawari Standard Data)</span><br><span class="line">/pub/：Himawari地球物理参数数据(Himawari Geophysical Parameter Data)，基本实时可用</span><br></pre></td></tr></table></figure><h3 id="👀-x2F-jma-x2F-hsd"><a href="#👀-x2F-jma-x2F-hsd" class="headerlink" title="👀&#x2F;jma&#x2F;hsd"></a>👀&#x2F;jma&#x2F;hsd</h3><p><strong>（标准格式）数据描述，文件命名格式</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">********************************************************************************</span><br><span class="line"></span><br><span class="line"># Available Himawari Standard Data</span><br><span class="line"></span><br><span class="line">## Full-disk</span><br><span class="line"> Observation area: Full-disk</span><br><span class="line"> Temporal resolution: 10-minutes</span><br><span class="line"> Spatial resolution: 0.5km (band 3), 1km (band 1,2,4), 2km (band 5-16)</span><br><span class="line"></span><br><span class="line">## Japan Area</span><br><span class="line"> Observation area: Japan area (Region 1 &amp; 2)</span><br><span class="line"> Temporal resolution: 2.5-minutes</span><br><span class="line"> Spatial resolution: 0.5km (band 3), 1km (band 1,2,4), 2km (band 5-16)</span><br><span class="line"></span><br><span class="line">## Target Area</span><br><span class="line"> Observation area: Target area (Region 3)</span><br><span class="line"> Temporal resolution: 2.5-minutes</span><br><span class="line"> Spatial resolution: 0.5km (band 3), 1km (band 1,2,4), 2km (band 5-16)</span><br><span class="line"></span><br><span class="line">## Color Image Data</span><br><span class="line"> png images of Full-disk, Japan area and Target area, compositing three visible</span><br><span class="line"> bands (blue: 0.47 micron; green: 0.51 micron; red: 0.64 micron).</span><br><span class="line"></span><br><span class="line">********************************************************************************</span><br><span class="line"></span><br><span class="line"># TOP FTP Directory</span><br><span class="line"></span><br><span class="line"> /jma/</span><br><span class="line"></span><br><span class="line">********************************************************************************</span><br><span class="line"></span><br><span class="line"># Structure of FTP Directories</span><br><span class="line"></span><br><span class="line"> /jma/hsd</span><br><span class="line">       +---/[YYYYMM]</span><br><span class="line">              +---/[DD]</span><br><span class="line">                     +---/[hh]</span><br><span class="line"></span><br><span class="line"> where YYYY: 4-digit year of observation start time (timeline);</span><br><span class="line">       MM: 2-digit month of timeline;</span><br><span class="line">       DD: 2-digit day of timeline; and</span><br><span class="line">       hh: 2-digit hour of timeline.</span><br><span class="line"></span><br><span class="line">********************************************************************************</span><br><span class="line"></span><br><span class="line"># File Naming Convention</span><br><span class="line"></span><br><span class="line">## Full-disk</span><br><span class="line"> HS_Hnn_YYYYMMDD_hhmm_Bbb_FLDK_Rjj_Skkll.DAT</span><br><span class="line"></span><br><span class="line"> where nn: 2-digit number of Himawari satellite;</span><br><span class="line">         08: Himawari-8</span><br><span class="line">         09: Himawari-9</span><br><span class="line">       YYYY: 4-digit year of observation start time (timeline);</span><br><span class="line">       MM: 2-digit month of timeline;</span><br><span class="line">       DD: 2-digit day of timeline;</span><br><span class="line">       hh: 2-digit hour of timeline;</span><br><span class="line">       mm: 2-gidit minutes of timeline;</span><br><span class="line">       bb: 2-digit band number (varies from &quot;01&quot; to &quot;16&quot;);</span><br><span class="line">       jj: spatial resolution (&quot;05&quot;: 0.5km, &quot;10&quot;: 1.0km, &quot;20&quot;: 2.0km);</span><br><span class="line">       kk: segment number (varies from &quot;01&quot; to &quot;10&quot;); and</span><br><span class="line">       ll: total number of segments (fixed to &quot;10&quot;).</span><br><span class="line"></span><br><span class="line"> example: HS_H08_20150728_2200_B01_FLDK_R10_S0110.DAT</span><br><span class="line"></span><br><span class="line">## Japan Area</span><br><span class="line"> HS_Hnn_YYYYMMDD_hhmm_Bbb_JPee_Rjj_S0101.DAT</span><br><span class="line"></span><br><span class="line"> where nn: 2-digit number of Himawari satellite;</span><br><span class="line">         08: Himawari-8</span><br><span class="line">         09: Himawari-9</span><br><span class="line">       YYYY: 4-digit year of observation start time (timeline);</span><br><span class="line">       MM: 2-digit month of timeline;</span><br><span class="line">       DD: 2-digit day of timeline;</span><br><span class="line">       hh: 2-digit hour of timeline;</span><br><span class="line">       mm: 2-gidit minutes of timeline;</span><br><span class="line">       bb: 2-digit band number (varies from &quot;01&quot; to &quot;16&quot;);</span><br><span class="line">       ee: observation number on the timeline (varies from &quot;01&quot; to &quot;04&quot;); and</span><br><span class="line">       jj: spatial resolution (&quot;05&quot;: 0.5km, &quot;10&quot;: 1.0km, &quot;20&quot;: 2.0km);</span><br><span class="line"></span><br><span class="line"> example: HS_H08_20150728_2200_B01_JP01_R10_S0101.DAT</span><br><span class="line"></span><br><span class="line">## Target Area</span><br><span class="line"> HS_Hnn_YYYYMMDD_hhmm_Bbb_R3ee_Rjj_S0101.DAT</span><br><span class="line"></span><br><span class="line"> where nn: 2-digit number of Himawari satellite;</span><br><span class="line">         08: Himawari-8</span><br><span class="line">         09: Himawari-9</span><br><span class="line">       YYYY: 4-digit year of observation start time (timeline);</span><br><span class="line">       MM: 2-digit month of timeline;</span><br><span class="line">       DD: 2-digit day of timeline;</span><br><span class="line">       hh: 2-digit hour of timeline;</span><br><span class="line">       mm: 2-gidit minutes of timeline;</span><br><span class="line">       bb: 2-digit band number (varies from &quot;01&quot; to &quot;16&quot;);</span><br><span class="line">       ee: observation number on the timeline (varies from &quot;01&quot; to &quot;04&quot;); and</span><br><span class="line">       jj: spatial resolution (&quot;05&quot;: 0.5km, &quot;10&quot;: 1.0km, &quot;20&quot;: 2.0km);</span><br><span class="line"></span><br><span class="line"> example: HS_H08_20150728_2200_B01_R301_R10_S0101.DAT</span><br><span class="line"></span><br><span class="line">## Color Image Data</span><br><span class="line"> PI_Hnn_YYYYMMDD_hhmm_TRC_FLDK_Rjj_PGPDF,png (Full-disk)</span><br><span class="line"> PI_Hnn_YYYYMMDD_hhmm_TRC_JPee_Rjj_PLLJP.png (Japan Area)</span><br><span class="line"> PI_Hnn_YYYYMMDD_hhmm_TRC_R3ee_Rjj_PLLTG.png (Target Area)</span><br><span class="line"></span><br><span class="line"> where nn: 2-digit number of Himawari satellite;</span><br><span class="line">         08: Himawari-8</span><br><span class="line">         09: Himawari-9</span><br><span class="line">       YYYY: 4-digit year of observation start time (timeline);</span><br><span class="line">       MM: 2-digit month of timeline;</span><br><span class="line">       DD: 2-digit day of timeline;</span><br><span class="line">       hh: 2-digit hour of timeline;</span><br><span class="line">       mm: 2-gidit minutes of timeline;</span><br><span class="line">       ee: observation number on the timeline (varies from &quot;01&quot; to &quot;04&quot;); and</span><br><span class="line">       jj: spatial resolution (&quot;05&quot;: 0.5km, &quot;10&quot;: 1.0km, &quot;20&quot;: 2.0km);</span><br><span class="line"></span><br><span class="line"> example: PI_H08_20150728_2200_TRC_FLDK_R10_PGPFD.png (Full-disk)</span><br><span class="line">          PI_H08_20150728_2200_TRC_JP01_R10_PLLJP.png (Japan Area)</span><br><span class="line">          PI_H08_20150728_2200_TRC_R301_R10_PLLTG.png (Target Area)</span><br><span class="line"></span><br><span class="line">********************************************************************************</span><br><span class="line"></span><br><span class="line"># Format</span><br><span class="line"></span><br><span class="line"> All data is in Himawari Standard Data (HSD) format and compressed with bzip2, </span><br><span class="line"> except the Color Image Data which is archived in png format.</span><br><span class="line"></span><br><span class="line">********************************************************************************</span><br></pre></td></tr></table></figure><h3 id="👀-x2F-jma-x2F-netcdf"><a href="#👀-x2F-jma-x2F-netcdf" class="headerlink" title="👀&#x2F;jma&#x2F;netcdf"></a>👀&#x2F;jma&#x2F;netcdf</h3><p><strong>（NC格式）数据描述，文件命名格式</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">********************************************************************************</span><br><span class="line"></span><br><span class="line"># Available Himawari  L1 Gridded Data </span><br><span class="line"></span><br><span class="line">## Full-disk</span><br><span class="line"> Projection: EQR</span><br><span class="line"> Observation area: 60S-60N, 80E-160W</span><br><span class="line"> Temporal resolution: 10-minutes</span><br><span class="line"> Spatial resolution: 5km (Pixel number: 2401, Line number: 2401)</span><br><span class="line">                     2km (Pixel number: 6001, Line number: 6001)</span><br><span class="line"> Data: albedo(reflectance*cos(SOZ) of band01~band06)</span><br><span class="line">       Brightness temperature of band07~band16</span><br><span class="line">       satellite zenith angle, satellite azimuth angle, </span><br><span class="line">       solar zenith angle, solar azimuth angle, observation hours (UT)</span><br><span class="line"></span><br><span class="line">## Japan Area</span><br><span class="line"> Projection: EQR</span><br><span class="line"> Observation area: 24N-50N, 123E-150E</span><br><span class="line"> Temporal resolution: 10-minutes</span><br><span class="line"> Spatial resolution: 1km (Pixel number: 2701, Line number: 2601)</span><br><span class="line"> Data: albedo(reflectance*cos(SOZ) of band01~band06)</span><br><span class="line">       Brightness temperature of band07, 14, 15</span><br><span class="line">       satellite zenith angle, satellite azimuth angle, </span><br><span class="line">       solar zenith angle, solar azimuth angle, observation hours (UT)</span><br><span class="line"></span><br><span class="line">********************************************************************************</span><br><span class="line"></span><br><span class="line"># TOP FTP Directory</span><br><span class="line"></span><br><span class="line"> /jma/</span><br><span class="line"></span><br><span class="line">********************************************************************************</span><br><span class="line"></span><br><span class="line"># Structure of FTP Directories</span><br><span class="line"></span><br><span class="line"> /jma/netcdf</span><br><span class="line">       +---/[YYYYMM]</span><br><span class="line">              +---/[DD]</span><br><span class="line">                     +---/[hh]</span><br><span class="line"></span><br><span class="line"> where YYYY: 4-digit year of observation start time (timeline);</span><br><span class="line">       MM: 2-digit month of timeline;</span><br><span class="line">       DD: 2-digit day of timeline; and</span><br><span class="line">       hh: 2-digit hour of timeline.</span><br><span class="line"></span><br><span class="line">********************************************************************************</span><br><span class="line"></span><br><span class="line"># File Naming Convention</span><br><span class="line"></span><br><span class="line">## Full-disk</span><br><span class="line"> NC_Hnn_YYYYMDD_hhmm_Rbb_FLDK.xxxxx_yyyyy.nc</span><br><span class="line"></span><br><span class="line"> where nn: 2-digit number of Himawari satellite;</span><br><span class="line">         08: Himawari-8</span><br><span class="line">         09: Himawari-9</span><br><span class="line">       YYYY: 4-digit year of observation start time (timeline);</span><br><span class="line">       MM: 2-digit month of timeline;</span><br><span class="line">       DD: 2-digit day of timeline;</span><br><span class="line">       hh: 2-digit hour of timeline;</span><br><span class="line">       mm: 2-gidit minutes of timeline;</span><br><span class="line">       bb: 2-digit band number (varies from &quot;01&quot; to &quot;16&quot;);</span><br><span class="line">       xxxxx: pixel number; (&quot;2401&quot;: 5km resolution, </span><br><span class="line">                             &quot;6001&quot;: 2km resolution, )</span><br><span class="line">       yyyyy: line number; (&quot;2401&quot;: 5km resolution, </span><br><span class="line">                             &quot;6001&quot;: 2km resolution, )</span><br><span class="line"></span><br><span class="line"> Example: </span><br><span class="line">   NC_H08_20160831_0000_R21_FLDK.02401_02401.nc</span><br><span class="line">   NC_H08_20160831_0000_R21_FLDK.06001_06001.nc</span><br><span class="line"></span><br><span class="line">## Japan Area</span><br><span class="line"> NC_Hnn_YYYYMMDD_hhmm_rbb_FLDK.xxxxx_yyyyy.nc</span><br><span class="line"></span><br><span class="line"> where nn: 2-digit number of Himawari satellite;</span><br><span class="line">         08: Himawari-8</span><br><span class="line">         09: Himawari-9</span><br><span class="line">       YYYY: 4-digit year of observation start time (timeline);</span><br><span class="line">       MM: 2-digit month of timeline;</span><br><span class="line">       DD: 2-digit day of timeline;</span><br><span class="line">       hh: 2-digit hour of timeline;</span><br><span class="line">       mm: 2-gidit minutes of timeline;</span><br><span class="line">       bb: 2-digit band number (fixed to &quot;14&quot;);</span><br><span class="line">       xxxxx: pixel number; (fixed to &quot;2701&quot; : 1km resolution)</span><br><span class="line">       yyyyy: line number; (fixed to &quot;2601&quot; : 1km resolution)</span><br><span class="line"></span><br><span class="line"> Example: </span><br><span class="line">   NC_H08_20160831_0000_r14_FLDK.02701_02601.nc</span><br><span class="line"></span><br><span class="line">********************************************************************************</span><br><span class="line"></span><br><span class="line"># Format</span><br><span class="line"></span><br><span class="line"> All data is netCDF4 format.</span><br><span class="line"></span><br><span class="line">********************************************************************************</span><br></pre></td></tr></table></figure><h3 id="👀-x2F-pub-x2F-Himawari"><a href="#👀-x2F-pub-x2F-Himawari" class="headerlink" title="👀&#x2F;pub&#x2F;Himawari"></a>👀&#x2F;pub&#x2F;Himawari</h3><p><strong>（1）产品数据介绍</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">## Level 2 (every 10 minutes)</span><br><span class="line">    Aerosol Property (ARP)</span><br><span class="line">    Sea Surface Temperature (SST)(near-real-time)</span><br><span class="line">    Short Wave Radiation(SWR)</span><br><span class="line">    Photosynthetically Available Radiation(PAR)</span><br><span class="line">    Cloud Property (CLP)</span><br><span class="line">    Wild Fire (WLF)</span><br><span class="line">## Level 3 (hourly, daily, monthly)</span><br><span class="line">    Aerosol Property</span><br><span class="line">    Sea Surface Temperature (SST)(near-real-time)</span><br><span class="line">    Nighttime Sea Surface Temperature (SST)(near-real-time)</span><br><span class="line">    Short Wave Radiation(SWR)</span><br><span class="line">    Photosynthetically Available Radiation(PAR)</span><br><span class="line">    Chlorophyll-a (CHL)</span><br><span class="line">    Wild Fire (WLF)</span><br><span class="line"></span><br><span class="line">## 2级(每10分钟一次)</span><br><span class="line">    气溶胶特性(ARP)</span><br><span class="line">    海面温度(SST)(近实时)</span><br><span class="line">    短波辐射</span><br><span class="line">    光合有效辐射(PAR)</span><br><span class="line">    云属性(CLP)</span><br><span class="line">    野火(WLF)</span><br><span class="line">## 3级(每小时、每天、每月)</span><br><span class="line">    气溶胶特性</span><br><span class="line">    海面温度(SST)(近实时)</span><br><span class="line">    夜间海面温度(近实时)</span><br><span class="line">    短波辐射</span><br><span class="line">    光合有效辐射(PAR)</span><br><span class="line">    叶绿素a(CHL)</span><br><span class="line">    野火(WLF)</span><br></pre></td></tr></table></figure><p><strong>（2）数据描述，文件命名格式</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">********************************************************************************</span><br><span class="line"></span><br><span class="line"># Available Geophysical Parameters</span><br><span class="line"></span><br><span class="line">## Aerosol Property (day-time only)</span><br><span class="line"> Latest version: Version 3.1 (Level 2), Version 3.1 (Level 3)</span><br><span class="line"> Observation area: Full-disk</span><br><span class="line"> Temporal resolution: 10-minutes (Level 2),1-hour (Level 3), </span><br><span class="line">                      1-day (Level 3), 1-month (Level 3)</span><br><span class="line"> Spatial resolution: 5km (Pixel number: 2401, Line number: 2401)</span><br><span class="line"> NOTE: Angstrom exponent included this product is under validation. </span><br><span class="line">       Users should keep in mind that the data is NOT quality assured. </span><br><span class="line">       Improvement in Version 3.1:</span><br><span class="line">        Updated error covariance of aerosol model used for a priori estimate or retrieval.</span><br><span class="line">        Updated alternative calibration coefficients for Himawari-9.</span><br><span class="line"></span><br><span class="line">## Sea Surface Temperature (SST)</span><br><span class="line"> Latest version: Version 2.1</span><br><span class="line"> Observation area: Full-disk</span><br><span class="line"> Temporal resolution: 10-minutes (Level 2), 1-hour (Level 3),</span><br><span class="line">                      1-day (Level 3), 1-month (Level 3)</span><br><span class="line"> Spatial resolution: 2km (Pixel number: 6001, Line number: 6001)</span><br><span class="line"></span><br><span class="line"> NOTE: Hourly data (Level 3 with temporal resolution of 1-hour) is calculated </span><br><span class="line">       from 10-minute data (Level 2) with quality level 5. Daily data (Level 3 </span><br><span class="line">       with temporal resolution of 1-day) is &quot;daily minimum SST&quot; calculated from </span><br><span class="line">       hourly data. Monthly data (Level 3 with temporal resolution of 1-month) </span><br><span class="line">       is &quot;monthly mean SST&quot; calculated from hourly data at each pixel.</span><br><span class="line">  </span><br><span class="line">       File version index (fv):</span><br><span class="line">        Himawari SST product file has a file version index (fvXX) in the filename to describe </span><br><span class="line">        the number of processing times. File version index will be updated for example when </span><br><span class="line">        the L3 product file will be re-generated due to L1 missing or delay. </span><br><span class="line">        The P-tree system distributes the newest product file regarding the file version index.</span><br><span class="line"></span><br><span class="line">       Improvement in Version 2.0:</span><br><span class="line">         The SST method has been updated with an improved optimal estimation scheme and some minor changes.</span><br><span class="line">         Cloud masking has been updated with additional use of visible and short wavelength infrared data </span><br><span class="line">         and a new test to detect clouds with the cloud top temperature higher than SST. </span><br><span class="line">         In the update, some tests were modified based on the cloud masking developed for SGLI SST.</span><br><span class="line"></span><br><span class="line">       Improvement in Version 2.1:</span><br><span class="line">         Small changes were made for Himawari-9 data processing.</span><br><span class="line">         The Bi-Spectral Filter (DOI: 10.1175/JTECH-D-22-0051.1) is applied for denoising the AHI infrared data.</span><br><span class="line"></span><br><span class="line">## Nighttime Sea Surface Temperature</span><br><span class="line"> Latest version: Version 2.1</span><br><span class="line"> Observation area: Full-disk</span><br><span class="line"> Temporal resolution: 1-hour (Level 3)</span><br><span class="line"> Spatial resolution: 2km (Pixel number: 6001, Line number: 6001)</span><br><span class="line"></span><br><span class="line">## Short Wave Radiation / Photosynthetically Available Radiation</span><br><span class="line"> Latest version: Version 2.1 </span><br><span class="line"> Observation area: Full-disk</span><br><span class="line"> Temporal resolution: 10-minutes (Level 2), 1-hour (Level 3), </span><br><span class="line">                      1-day (Level 3), 1-month (Level 3)</span><br><span class="line"> Spatial resolution: 5km (Pixel number: 2401, Line number: 2401)</span><br><span class="line">                     1km Japan* (Pixel number: 2701, Line number: 2601)</span><br><span class="line">                     * This area coverd 24N-50N, 123E-150E.</span><br><span class="line"> NOTE: This product is a beta version and is intended to show the</span><br><span class="line">       preliminary result from Himawari-8. Users should keep in mind </span><br><span class="line">       that the data is NOT quality assured.</span><br><span class="line"></span><br><span class="line">       Ver. 2.0:</span><br><span class="line">        Vicarious calibration coefficients are updated by considering their temporal change.</span><br><span class="line">        Ancillary ozone data source is changed to JMA global chemical transport model data (MRI-CCM2).</span><br><span class="line"></span><br><span class="line">       Ver. 2.1:</span><br><span class="line">        Vicarious calibration coefficients are updated.</span><br><span class="line"></span><br><span class="line">## Chlorophyll-a</span><br><span class="line"> Latest version: 2.1 </span><br><span class="line"> Observation area: Full-disk</span><br><span class="line"> Temporal resolution: 1-hour (Level 3), 1-day (Level 3), 1-month (Level 3)</span><br><span class="line"> Spatial resolution: 5km (Pixel number: 2401, Line number: 2401)</span><br><span class="line">                     1km Japan* (Pixel number: 2701, Line number: 2601)</span><br><span class="line"> NOTE: This product is a beta version and is intended to show the</span><br><span class="line">       preliminary result from Himawari-8. Users should keep in mind </span><br><span class="line">       that the data is NOT quality assured.</span><br><span class="line"></span><br><span class="line">       Ver. 2.0:</span><br><span class="line">        Vicarious calibration coefficients are updated by considering their temporal change.</span><br><span class="line">        Ancillary ozone data source is changed to JMA global chemical transport model data (MRI-CCM2).</span><br><span class="line"></span><br><span class="line">       Ver. 2.1:</span><br><span class="line">        Vicarious calibration coefficients are updated.</span><br><span class="line"></span><br><span class="line">## Cloud Property (day-time only)</span><br><span class="line"> Latest version: 1.0 </span><br><span class="line"> Observation area: Full-disk</span><br><span class="line"> Temporal resolution: 10-minutes (Level 2)</span><br><span class="line"> Spatial resolution: 5km (Pixel number: 2401, Line number: 2401)</span><br><span class="line"></span><br><span class="line">## Wild Fire</span><br><span class="line"> Latest version: 1.0</span><br><span class="line"> Observation area: Full-disk</span><br><span class="line"> Temporal resolution: 10-minutes (Level 2), 1-hour (Level 3),</span><br><span class="line">                      1-day (Level 3), 1-month (Level 3)</span><br><span class="line"> Spatial resolution: 2km (10-minutes, 1-hour, 1-day), 0.25 degree (1-month) </span><br><span class="line"></span><br><span class="line">********************************************************************************</span><br><span class="line"></span><br><span class="line"># TOP FTP Directory</span><br><span class="line"></span><br><span class="line"> /pub/</span><br><span class="line"></span><br><span class="line">********************************************************************************</span><br><span class="line"></span><br><span class="line"># Structure of FTP Directories</span><br><span class="line"></span><br><span class="line">## Level 2 (every 10 minutes)</span><br><span class="line">### Aerosol Property (ARP) Level 2</span><br><span class="line"> /pub/himawari</span><br><span class="line">       +---/L2</span><br><span class="line">             +---/ARP</span><br><span class="line">                   +---/[VER]</span><br><span class="line">                          +---/[YYYYMM]</span><br><span class="line">                                 +---/[DD]</span><br><span class="line">                                        +---/[hh]</span><br><span class="line"></span><br><span class="line">### Sea Surface Temperature (SST) Level 2 (near-real-time)</span><br><span class="line"> /pub/himawari</span><br><span class="line">       +---/L2</span><br><span class="line">             +---/SST</span><br><span class="line">                   +---/[VER]_nc4_normal_nrt</span><br><span class="line">                          +---/[YYYYMM]</span><br><span class="line">                                 +---/[DD]</span><br><span class="line"></span><br><span class="line">### Short Wave Radiation(SWR)/Photosynthetically Available Radiation(PAR) Level 2</span><br><span class="line"> /pub/himawari</span><br><span class="line">       +---/L2</span><br><span class="line">             +---/PAR</span><br><span class="line">                   +---/[VER]</span><br><span class="line">                          +---/[YYYYMM]</span><br><span class="line">                                 +---/[DD]</span><br><span class="line"></span><br><span class="line">### Cloud Property (CLP) Level 2</span><br><span class="line"> /pub/himawari</span><br><span class="line">       +---/L2</span><br><span class="line">             +---/CLP</span><br><span class="line">                   +---/[VER]</span><br><span class="line">                          +---/[YYYYMM]</span><br><span class="line">                                 +---/[DD]</span><br><span class="line">                                        +---/[hh]</span><br><span class="line"></span><br><span class="line">### Wild Fire (WLF) Level 2</span><br><span class="line"> /pub/himawari</span><br><span class="line">       +---/L2</span><br><span class="line">             +---/WLF</span><br><span class="line">                   +---/[VER]</span><br><span class="line">                          +---/[YYYYMM]</span><br><span class="line">                                 +---/[DD]</span><br><span class="line">                                        +---/[hh]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## Level 3 (hourly, daily, monthly)</span><br><span class="line">### Aerosol Property Level 3</span><br><span class="line"> /pub/himawari</span><br><span class="line">       +---/L3</span><br><span class="line">             +---/ARP</span><br><span class="line">                   +---/[VER]</span><br><span class="line">                          +---/[YYYYMM]</span><br><span class="line">                                 +---/[DD]</span><br><span class="line">                                 +---/[daily]</span><br><span class="line">                                 +---/[monthly]</span><br><span class="line"></span><br><span class="line">### Sea Surface Temperature (SST) Level 3 (near-real-time)</span><br><span class="line"> /pub/himawari</span><br><span class="line">       +---/L3</span><br><span class="line">             +---/SST</span><br><span class="line">                   +---/[VER]_nc4_normal_nrt</span><br><span class="line">                          +---/[YYYYMM]</span><br><span class="line">                                 +---/[DD]</span><br><span class="line">                   +---/[VER]_nc4_normal_nrt_daily</span><br><span class="line">                          +---/[YYYYMM]</span><br><span class="line">                                 +---/[DD]</span><br><span class="line">                   +---/[VER]_nc4_normal_nrt_monthly</span><br><span class="line">                          +---/[YYYYMM]</span><br><span class="line"></span><br><span class="line">### Nighttime Sea Surface Temperature (SST) Level 3 (near-real-time)</span><br><span class="line"> /pub/himawari</span><br><span class="line">       +---/L3</span><br><span class="line">             +---/SST</span><br><span class="line">                   +---/[VER]_nc4_nightt_nrt</span><br><span class="line">                          +---/[YYYYMM]</span><br><span class="line">                                 +---/[DD]</span><br><span class="line"></span><br><span class="line">### Short Wave Radiation(SWR)/Photosynthetically Available Radiation(PAR) Level 3</span><br><span class="line"> /pub/himawari</span><br><span class="line">       +---/L3</span><br><span class="line">             +---/PAR</span><br><span class="line">                   +---/[VER]</span><br><span class="line">                          +---/[YYYYMM]</span><br><span class="line">                                 +---/[DD]</span><br><span class="line">                                 +---/[daily]</span><br><span class="line">                                 +---/[monthly]</span><br><span class="line"></span><br><span class="line">### Chlorophyll-a (CHL) Level 3</span><br><span class="line"> /pub/himawari</span><br><span class="line">       +---/L3</span><br><span class="line">             +---/CHL</span><br><span class="line">                   +---/[VER]</span><br><span class="line">                          +---/[YYYYMM]</span><br><span class="line">                                 +---/[DD]</span><br><span class="line">                                 +---/[daily]</span><br><span class="line">                                 +---/[monthly]</span><br><span class="line"></span><br><span class="line">### Wild Fire (WLF) Level 3</span><br><span class="line"> /pub/himawari</span><br><span class="line">       +---/L3</span><br><span class="line">             +---/WLF</span><br><span class="line">                   +---/[VER]</span><br><span class="line">                          +---/[YYYYMM]</span><br><span class="line">                                 +---/[DD]</span><br><span class="line">                                 +---/[daily]</span><br><span class="line">                                 +---/[monthly]</span><br><span class="line"></span><br><span class="line"> where VER: algorithm version;</span><br><span class="line">       YYYY: 4-digit year observation start time (timeline);</span><br><span class="line">       MM: 2-digit month of timeline;</span><br><span class="line">       DD: 2-digit day of timeline; and</span><br><span class="line">       hh: 2-digit hour of timeline.</span><br><span class="line"></span><br><span class="line">********************************************************************************</span><br><span class="line"></span><br><span class="line"># File Naming Convention</span><br><span class="line"></span><br><span class="line">## Level 2</span><br><span class="line">### Aerosol Property</span><br><span class="line"> NC_Hnn_YYYYMMDD_hhmm_L2ARPVER_FLDK.xxxxx_yyyyy.nc</span><br><span class="line"></span><br><span class="line"> where nn: 2-digit number of Himawari satellite;</span><br><span class="line">         08: Himawari-8</span><br><span class="line">         09: Himawari-9</span><br><span class="line">       YYYY: 4-digit year of observation start time (timeline);</span><br><span class="line">       MM: 2-digit month of timeline;</span><br><span class="line">       DD: 2-digit day of timeline;</span><br><span class="line">       hh: 2-digit hour of timeline;</span><br><span class="line">       mm: 2-digit minutes of timeline;</span><br><span class="line">       VER: version;</span><br><span class="line">       xxxxx: pixel number; and</span><br><span class="line">       yyyyy: line number.</span><br><span class="line"></span><br><span class="line"> Example: H08_20150727_0800_L2ARP030_FLDK.02401_02401.nc</span><br><span class="line"></span><br><span class="line">### Sea Surface Temperature</span><br><span class="line"> YYYYMMDDhhmmss-JAXA-L2P_GHRSST-SSTskin-Hnn_AHI-vVER-v02.0-fvFVER.nc</span><br><span class="line"></span><br><span class="line"> where YYYY: 4-digit year of observation start time (timeline);</span><br><span class="line">       MM: 2-digit month of timeline;</span><br><span class="line">       DD: 2-digit day of timeline;</span><br><span class="line">       hh: 2-digit hour of timeline;</span><br><span class="line">       mm: 2-digit minutes of timeline;</span><br><span class="line">       ss: 2-digit seconds (fixed to &quot;00&quot;);</span><br><span class="line">       nn: 2-digit number of Himawari satellite;</span><br><span class="line">         08: Himawari-8</span><br><span class="line">         09: Himawari-9</span><br><span class="line">       VER: algorithm version; and</span><br><span class="line">       FVER: file version;.</span><br><span class="line"></span><br><span class="line"> Example: </span><br><span class="line"> 20150728081000-JAXA-L2P_GHRSST-SSTskin-H08_AHI-v2.0-v02.0-fv01.0.nc</span><br><span class="line"></span><br><span class="line">### Short Wave Radiation/Photosynthetically Available Radiation</span><br><span class="line"> Hnn_YYYYMMDD_hhmm_RFLVER_FLDK_xxxxx_yyyyy.nc (5km)</span><br><span class="line"> Hnn_YYYYMMDD_hhmm_rFLVER_FLDK_xxxxx_yyyyy.nc (1km)</span><br><span class="line"></span><br><span class="line"> where nn: 2-digit number of Himawari satellite;</span><br><span class="line">         08: Himawari-8</span><br><span class="line">         09: Himawari-9</span><br><span class="line">       YYYY: 4-digit year of observation start time (timeline);</span><br><span class="line">       MM: 2-digit month of timeline;</span><br><span class="line">       DD: 2-digit day of timeline;</span><br><span class="line">       hh: 2-digit hour of timeline;</span><br><span class="line">       mm: 2-digit minutes of timeline;</span><br><span class="line">       VER: algorithm version; </span><br><span class="line">       xxxxx: pixel number; and</span><br><span class="line">       yyyyy: line number.</span><br><span class="line"></span><br><span class="line"> Example: NC_H08_20150727_0800_RFL001_FLDK_02401_02401.nc</span><br><span class="line"></span><br><span class="line">### Cloud Property</span><br><span class="line"> NC_Hnn_YYYYMMDD_hhmm_L2CLPVER_FLDK.xxxxx_yyyyy.nc</span><br><span class="line"></span><br><span class="line"> where nn: 2-digit number of Himawari satellite;</span><br><span class="line">         08: Himawari-8</span><br><span class="line">         09: Himawari-9</span><br><span class="line">       YYYY: 4-digit year of observation start time (timeline);</span><br><span class="line">       MM: 2-digit month of timeline;</span><br><span class="line">       DD: 2-digit day of timeline;</span><br><span class="line">       hh: 2-digit hour of timeline;</span><br><span class="line">       mm: 2-digit minutes of timeline;</span><br><span class="line">       VER: version;</span><br><span class="line">       xxxxx: pixel number; and</span><br><span class="line">       yyyyy: line number.</span><br><span class="line"></span><br><span class="line"> Example: H08_20150727_0800_L2CLPbet_FLDK.02401_02401.nc</span><br><span class="line"></span><br><span class="line">### Wildfire</span><br><span class="line"> NC_Hnn_YYYYMMDD_hhmm_L2WLFVER_FLDK.xxxxx_yyyyy.csv</span><br><span class="line"></span><br><span class="line"> where nn: 2-digit number of Himawari satellite;</span><br><span class="line">         08: Himawari-8</span><br><span class="line">         09: Himawari-9YYYY: 4-digit year of observation start time (timeline);</span><br><span class="line">       MM: 2-digit month of timeline;</span><br><span class="line">       DD: 2-digit day of timeline;</span><br><span class="line">       hh: 2-digit hour of timeline;</span><br><span class="line">       mm: 2-digit minutes of timeline;</span><br><span class="line">       VER: version;</span><br><span class="line">       xxxxx: pixel number; and</span><br><span class="line">       yyyyy: line number.</span><br><span class="line"></span><br><span class="line"> Example: H08_20150727_0800_L2WLF010_FLDK.06001_06001.csv</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## Level 3</span><br><span class="line">### Aerosol Property</span><br><span class="line"> Hnn_YYYYMMDD_hhmm_LL_ARPVER_FLDK.xxxxx_yyyyy.nc (5km)</span><br><span class="line"></span><br><span class="line"> where nn: 2-digit number of Himawari satellite;</span><br><span class="line">         08: Himawari-8</span><br><span class="line">         09: Himawari-9YYYY: 4-digit year of observation start time (timeline);</span><br><span class="line">       MM: 2-digit month of timeline;</span><br><span class="line">       DD: 2-digit day of timeline;</span><br><span class="line">       hh: 2-digit hour of timeline;</span><br><span class="line">       mm: 2-digit minutes of timeline;</span><br><span class="line">       LL: 2-digit temporal resolution (L3:hourly, 1D:daily, 1M:monthly) </span><br><span class="line">       VER: algorithm version; </span><br><span class="line">       xxxxx: pixel number; and</span><br><span class="line">       yyyyy: line number.</span><br><span class="line"></span><br><span class="line"> Example: H08_20150727_0800_1H_ARP031_FLDK.02401_02401.nc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### Sea Surface Temperature</span><br><span class="line"> YYYYMMDDhhmmss-JAXA-L3C_GHRSST-SSTskin-Hnn_AHI-vVER-v02.0-fvFVER.nc (hourly)</span><br><span class="line"> YYYYMMDDhhmmss-JAXA-L3C_GHRSST-SSTskin-Hnn_AHI-vVER_daily-v02.0-fvFVER.nc (daily)</span><br><span class="line"> Hnn_YYYYMMDD_HHMM_1MSSTVER_FLDK.xxxxx_yyyyy.nc  (monthly)</span><br><span class="line"></span><br><span class="line"> where YYYY: 4-digit year of observation start time (timeline);</span><br><span class="line">       MM: 2-digit month of timeline;</span><br><span class="line">       DD: 2-digit day of timeline;</span><br><span class="line">       hh: 2-digit hour of timeline;</span><br><span class="line">       mm: 2-digit minutes of timeline (fixed to &quot;00&quot;);</span><br><span class="line">       ss: 2-digit seconds of timeline (fixed to &quot;00&quot;);</span><br><span class="line">       nn: 2-digit number of Himawari satellite;</span><br><span class="line">         08: Himawari-8</span><br><span class="line">         09: Himawari-9</span><br><span class="line">       VER: algorithm version;</span><br><span class="line">       FVER: file version;</span><br><span class="line">       xxxxx: pixel number; and</span><br><span class="line">       yyyyy: line number.</span><br><span class="line"></span><br><span class="line"> Example:</span><br><span class="line"> 20180804000000-JAXA-L3C_GHRSST-SSTskin-H08_AHI-v2.0-v02.0-fv01.0.nc (hourly)</span><br><span class="line"> 20180804000000-JAXA-L3C_GHRSST-SSTskin-H08_AHI-v2.0_daily-v02.0-fv01.0.nc (daily)</span><br><span class="line"> H08_20180701_0000_1MSST200_FLDK.06001_06001.nc (monthly)</span><br><span class="line"></span><br><span class="line">### Nighttime Sea Surface Temperature</span><br><span class="line"> YYYYMMDDhhmmss-JAXA-L3C_GHRSST-SSTskin-Hnn_AHI-vVER_nighttime-v02.0-fvFVER.nc</span><br><span class="line"></span><br><span class="line"> where YYYY: 4-digit year observation start time (timeline);</span><br><span class="line">       MM: 2-digit month of timeline;</span><br><span class="line">       DD: 2-digit day of timeline;</span><br><span class="line">       hh: 2-digit hour of timeline;</span><br><span class="line">       mm: 2-digit minutes of timeline(fixed to &quot;00&quot;);</span><br><span class="line">       ss: 2-digit seconds of timeline(fixed to &quot;00&quot;);</span><br><span class="line">       nn: 2-digit number of Himawari satellite;</span><br><span class="line">         08: Himawari-8</span><br><span class="line">         09: Himawari-9</span><br><span class="line">       VER: algorithm version; and</span><br><span class="line">       FVER: file version;.</span><br><span class="line"></span><br><span class="line"> Example: </span><br><span class="line"> 20150728080000-JAXA-L3C_GHRSST-SSTskin-H08_AHI-v2.0_nighttime-v02.0-fv01.0.nc</span><br><span class="line"></span><br><span class="line">### Short Wave Radiation/Photosynthetically Available Radiation</span><br><span class="line"> Hnn_YYYYMMDD_hhmm_LL_RFLVER_FLDK.xxxxx_yyyyy.nc (5km)</span><br><span class="line"> Hnn_YYYYMMDD_hhmm_LL_rFLVER_FLDK.xxxxx_yyyyy.nc (1km)</span><br><span class="line"></span><br><span class="line"> where nn: 2-digit number of Himawari satellite;</span><br><span class="line">         08: Himawari-8</span><br><span class="line">         09: Himawari-9</span><br><span class="line">       YYYY: 4-digit year of observation start time (timeline);</span><br><span class="line">       MM: 2-digit month of timeline;</span><br><span class="line">       DD: 2-digit day of timeline;</span><br><span class="line">       hh: 2-digit hour of timeline;</span><br><span class="line">       mm: 2-digit minutes of timeline;</span><br><span class="line">       LL: 2-digit temporal resolution (L3:hourly, 1D:daily, 1M:monthly) </span><br><span class="line">       VER: algorithm version; </span><br><span class="line">       xxxxx: pixel number; and</span><br><span class="line">       yyyyy: line number.</span><br><span class="line"></span><br><span class="line"> Example: H08_20150727_0800_1H_RFL001_FLDK.02401_02401.nc</span><br><span class="line"></span><br><span class="line">### Chlorophyll-a</span><br><span class="line"> Hnn_YYYYMMDD_hhmm_LL_ROCVER_FLDK.xxxxx_yyyyy.nc (5km)</span><br><span class="line"> Hnn_YYYYMMDD_hhmm_LL_rOCVER_FLDK.xxxxx_yyyyy.nc (1km)</span><br><span class="line"></span><br><span class="line"> where nn: 2-digit number of Himawari satellite;</span><br><span class="line">         08: Himawari-8</span><br><span class="line">         09: Himawari-9YYYY: 4-digit year of observation start time (timeline);</span><br><span class="line">       MM: 2-digit month of timeline;</span><br><span class="line">       DD: 2-digit day of timeline;</span><br><span class="line">       hh: 2-digit hour of timeline;</span><br><span class="line">       mm: 2-digit minutes of timeline;</span><br><span class="line">       LL: 2-digit temporal resolution (1H:hourly, 1D:daily, 1M:monthly) </span><br><span class="line">       VER: algorithm version; </span><br><span class="line">       xxxxx: pixel number; and</span><br><span class="line">       yyyyy: line number.</span><br><span class="line"></span><br><span class="line"> Example: H08_20150727_0800_1H_ROC001_FLDK.02401_02401.nc</span><br><span class="line"></span><br><span class="line">### Wild Fire </span><br><span class="line"> Hnn_YYYYMMDD_hhmm_LLWLFVER_FLDK.xxxxx_yyyyy.csv</span><br><span class="line"></span><br><span class="line"> where nn: 2-digit number of Himawari satellite;</span><br><span class="line">         08: Himawari-8</span><br><span class="line">         09: Himawari-9</span><br><span class="line">       YYYY: 4-digit year of observation start time (timeline);</span><br><span class="line">       MM: 2-digit month of timeline;</span><br><span class="line">       DD: 2-digit day of timeline;</span><br><span class="line">       hh: 2-digit hour of timeline;</span><br><span class="line">       mm: 2-digit minutes of timeline;</span><br><span class="line">       LL: 2-digit temporal resolution (L3:hourly, 1D:daily, 1M:monthly) </span><br><span class="line">       VER: algorithm version; </span><br><span class="line">       xxxxx: pixel number; and</span><br><span class="line">       yyyyy: line number.</span><br><span class="line"></span><br><span class="line"> Example: H08_20180501_0000_L3WLF010_FLDK.06001_06001.csv</span><br><span class="line"></span><br><span class="line">********************************************************************************</span><br><span class="line"></span><br><span class="line"># Format</span><br><span class="line"></span><br><span class="line">  All data except for Wild Fire is in NetCDF4 format and compressed with gzip.</span><br><span class="line">  Please note that NetCDF format of SST (except monthly product) follows</span><br><span class="line">  the GHRSST Data Specification (GDS) 2.0. Details of GDS2.0, see the Group of </span><br><span class="line">  High Resolution Sea Surface Temperature (GHRSST) web site</span><br><span class="line">  (https://www.ghrsst.org/). </span><br><span class="line"></span><br><span class="line">  File format of Wild Fire product is CSV. Please see following file</span><br><span class="line">  (H8_WLF_format.txt) for more details. </span><br><span class="line"></span><br><span class="line">********************************************************************************</span><br></pre></td></tr></table></figure><h3 id="👀-x2F-pub-x2F-model"><a href="#👀-x2F-pub-x2F-model" class="headerlink" title="👀&#x2F;pub&#x2F;model"></a>👀&#x2F;pub&#x2F;model</h3><p><strong>（1）产品数据介绍</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">### Level 4 (model parameters)</span><br><span class="line">    Model Aerosol Property</span><br><span class="line">    Model Sea Surface Temperature</span><br><span class="line">    Ensemble ocean analysis product &quot;LORA&quot;</span><br><span class="line"></span><br><span class="line">## 4级(模型参数)</span><br><span class="line">    模型气溶胶特性</span><br><span class="line">    海面温度模型</span><br><span class="line">    集成海洋分析产品“LORA”</span><br></pre></td></tr></table></figure><p><strong>（2）数据描述，文件命名格式</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">********************************************************************************</span><br><span class="line"></span><br><span class="line"># Model Outputs</span><br><span class="line"> </span><br><span class="line">## Model Aerosol Property by MRI/JMA</span><br><span class="line"> Latest version: Beta Version</span><br><span class="line"> Area: Global</span><br><span class="line"> Temporal resolution: 1-hour (Level 4)</span><br><span class="line"> Spatial resolution: Longitude 0.375 deg., Latitude 0.37147 to 0.37461 deg. (Gaussian)</span><br><span class="line"> (Pixel number: 960, Line number: 480)</span><br><span class="line"> NOTE: This product is the forecast (every one hour) of aerosol properties by</span><br><span class="line">       the MRI/JMA global aerosol model called Model of Aerosol Species IN the Global</span><br><span class="line">       AtmospheRe (MASINGAR). This product is assimilated by Himawari L3 aerosol</span><br><span class="line">       optical depth at 00, 03, 06, and 09UTC. The opposite side of the Himawari</span><br><span class="line">       observation area is assimilated at 12 and 18UTC using MODIS/Terra+Aqua L3</span><br><span class="line">       Value-added Aerosol Optical Depth - NRT dataset due to lack of aerosol</span><br><span class="line">       retrievals by Himawari.(As for the image on the top page, there are cases</span><br><span class="line">       where preliminary forecast is displayed that was derived by assimilating</span><br><span class="line">       observation data before the previous day.)</span><br><span class="line">       Please refer to the reference below for the assimilation method etc. </span><br><span class="line">       The aerosol data assimilation system based on MASINGER was developed </span><br><span class="line">       by Meteorological Research Institute and Kyushu University. </span><br><span class="line">       The products are produced at Meteorological Research Institute, and provided </span><br><span class="line">       by JAXA P-Tree System, Japan Aerospace Exploration Agency (JAXA). </span><br><span class="line"></span><br><span class="line"> Acknowledgements: </span><br><span class="line">    MODIS/Terra+Aqua L3 Value-added Aerosol Optical Depth - NRT datasets</span><br><span class="line">    were acquired from the Level-1 and Atmosphere Archive &amp; Distribution System</span><br><span class="line">    (LAADS) Distributed Active Archive Center (DAAC), located in the Goddard Space</span><br><span class="line">    Flight Center in Greenbelt, Maryland (https://ladsweb.nascom.nasa.gov/).</span><br><span class="line"></span><br><span class="line">## Model Sea Surface Temperature by JAXA/JAMSTEC</span><br><span class="line"> Latest version: v20170705</span><br><span class="line"> Area: Around Japan (117E-150E, 17N-50N)</span><br><span class="line"> Temporal resolution: 1-hour (Level 4)</span><br><span class="line"> Spatial resolution: About 3km (1/36 deg.) (Pixel number: 1190, Line number: 1190)</span><br><span class="line"> NOTE: This research is JAXA-JAMSTEC joint research and a part of the Japan Coastal </span><br><span class="line">       Ocean Predictability Experiment (JCOPE).</span><br><span class="line">       This product is constructed by data assimilation using high resolution </span><br><span class="line">       regional ocean model &quot;JCOPE-T&quot; developed by JAMSTEC and observation data </span><br><span class="line">       including the 4 types satellite SST data provided by JAXA. </span><br><span class="line">       When we do the data assimilation, we do the bias correction of satellite </span><br><span class="line">       SST data using GCOM-W/AMSR2 SST data as refer to reference value, </span><br><span class="line">       because the bias in observation data is undesirable for data assimilation. </span><br><span class="line">       Near Real-Time data (analysis and forecast) and Best Estimate data are </span><br><span class="line">       included in this product. </span><br><span class="line"></span><br><span class="line">       Update frequency and period are follow.</span><br><span class="line"></span><br><span class="line">       Near Real-Time data: Every day except Saturdays.</span><br><span class="line">        - Analysis (ANAL): 5-days (replaced every update)</span><br><span class="line">        - Forecast (FCST): 16-days (replaced every update)</span><br><span class="line">       Best Estimate data: Every week</span><br><span class="line">        (update in the beginning of the week; Sunday or Monday)</span><br><span class="line">        - This is delay mode data which is provided about two weeks late.</span><br><span class="line">        - 7-days data are added every update.</span><br><span class="line"></span><br><span class="line">## Ensemble ocean analysis product &quot;LORA&quot; by JAXA/RIKEN</span><br><span class="line"> Latest version: v1.0</span><br><span class="line"> Area: Western North Pacific (108E-180,12N-50N), Maritime Continent (95E-136E,18S-30N)</span><br><span class="line"> Temporal resolution: 1-day (Level 4)</span><br><span class="line"> Spatial resolution: About 10km (0.1 degree), 50 sigma-layers</span><br><span class="line"> Data:</span><br><span class="line">    - Daily averaged ensemble mean and spread (one 2D-variable, five 3D-variables): </span><br><span class="line">       Sea surface height, temperature, salinity, and zonal, meridional, and vertical velocities</span><br><span class="line">    - Daily averaged all sea surface ensemble (five 2D-128 ensemble variables): </span><br><span class="line">       Sea surface height, temperature, salinity, and zonal and meridional velocities</span><br><span class="line">    - Ensemble mean of each term in the daily averaged mixed layer temperature and salinity </span><br><span class="line">       budget equations and of the daily averaged related variables (forty-one 2D-variables, </span><br><span class="line">       see MLT_MLS_namelist_en.pdf for more details)</span><br><span class="line"> Note: An ensemble ocean analysis product, LORA, is created by a regional ocean data assimilation</span><br><span class="line">       system, sbPOM-LETKF, which is developed by RIKEN. sbPOM-LETKF assimilates the following</span><br><span class="line">       satellite and in-situ observations at a 1-day interval:</span><br><span class="line">        - Satellite-based sea surface temperature (Himawari-8/AHI and GCOM-W/AMSR2) </span><br><span class="line">          provided by JAXA</span><br><span class="line">        - Satellite-based sea surface salinity (SMAP and SMOS, respectively) </span><br><span class="line">          provided by NASA and ESA</span><br><span class="line">        - Satellite-based sea surface height provided by CMEMS</span><br><span class="line">        - in-situ temperature and salinity (GTSPP and AQC Argo, respectively) </span><br><span class="line">           provided by NOAA and JAMSTEC</span><br><span class="line"></span><br><span class="line">        This product has been created under a JAXA-RIKEN collaborative research project.</span><br><span class="line"></span><br><span class="line">********************************************************************************</span><br><span class="line"></span><br><span class="line"># TOP FTP Directory</span><br><span class="line"></span><br><span class="line"> /pub/</span><br><span class="line"></span><br><span class="line">********************************************************************************</span><br><span class="line"></span><br><span class="line"># Structure of FTP Directories</span><br><span class="line"></span><br><span class="line">### Level 4 (model parameters) </span><br><span class="line">### Model Aerosol Property (MRI/JMA)</span><br><span class="line"> /pub/model</span><br><span class="line">        +---/ARP</span><br><span class="line">             +---/MS</span><br><span class="line">                   +---/[VER]</span><br><span class="line">                          +---/[YYYYMM]</span><br><span class="line">                                 +---/[DD]</span><br><span class="line"></span><br><span class="line"> where VER: algorithm version;</span><br><span class="line">       YYYY: 4-digit year observation start time (timeline);</span><br><span class="line">       MM: 2-digit month of timeline;</span><br><span class="line">       DD: 2-digit day of timeline; and</span><br><span class="line">       hh: 2-digit hour of timeline.</span><br><span class="line"></span><br><span class="line">### Mpdel Sea Surface Temperature (JAXA/JAMSTEC)</span><br><span class="line"> /pub/model</span><br><span class="line">       +---/SST</span><br><span class="line">              +---/JCPT_DA</span><br><span class="line">                   +---/[VER]</span><br><span class="line">                          +---/FCST</span><br><span class="line">                          +---/ANAL</span><br><span class="line">                          +---/BEST</span><br><span class="line">                              +---/[YYYYMM]</span><br><span class="line">                                     +---/[DD]</span><br><span class="line"> where VER: algorithm version;</span><br><span class="line">       YYYY: 4-digit year observation start time (timeline);</span><br><span class="line">       MM: 2-digit month of timeline;</span><br><span class="line">       DD: 2-digit day of timeline; and</span><br><span class="line">       hh: 2-digit hour of timeline.</span><br><span class="line"></span><br><span class="line"> FCST: Near Real-Time data (Forecast)</span><br><span class="line"> ANAL: Near Real-Time data (Analysis)</span><br><span class="line"> BEST: Best Estimate data </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Ensemble ocean analysis product &quot;LORA&quot; (JAXA/RIKEN)</span><br><span class="line"> /pub/model</span><br><span class="line">       +---/OCN</span><br><span class="line">              +---/LORA</span><br><span class="line">                   +---/[VER]</span><br><span class="line">                         +---/[AREA]</span><br><span class="line">                               +---/[CAT]</span><br><span class="line">                                    +---/[YYYYMMDD]</span><br><span class="line"></span><br><span class="line"> where VER: algorithm version;</span><br><span class="line">       AREA: Analysis area;</span><br><span class="line">　　　        MC: Maritime Continent</span><br><span class="line">　　　        WNP: North West Pacific</span><br><span class="line">       CAT: category</span><br><span class="line">　     　　   ens: Daily averaged all sea surface ensemble</span><br><span class="line">　　　        mean: Ensemble mean and daily average of mixed layer related variabless</span><br><span class="line">　　　        sprd: Daily averaged ensemble mean and spread</span><br><span class="line">       YYYY: 4-digit year observation start time (timeline);</span><br><span class="line">       MM: 2-digit month of timeline; and</span><br><span class="line">       DD: 2-digit day of timeline.</span><br><span class="line"></span><br><span class="line">********************************************************************************</span><br><span class="line"></span><br><span class="line"># File Naming Convention</span><br><span class="line"></span><br><span class="line">## Level 4 (model parameters) </span><br><span class="line">### Model Aerosol Property (MRI/JMA)</span><br><span class="line"></span><br><span class="line"> Hnn_YYYYMMDD_hhmm_MSARPVER_ANL.xxxxx_yyyyy.nc</span><br><span class="line"></span><br><span class="line">where  nn: 2-digit number of Himawari satellite;</span><br><span class="line">         08: Himawari-8</span><br><span class="line">         09: Himawari-9</span><br><span class="line">       YYYY: 4-digit year of observation start time (timeline);</span><br><span class="line">       MM: 2-digit month of timeline;</span><br><span class="line">       DD: 2-digit day of timeline;</span><br><span class="line">       hh: 2-digit hour of timeline;</span><br><span class="line">       mm: 2-gidit minutes of timeline;</span><br><span class="line">       VER: algorithm version;</span><br><span class="line">       xxxxx: pixel number; and</span><br><span class="line">       yyyyy: line number.</span><br><span class="line"></span><br><span class="line">Example:  H08_20180727_0000_MSARPbet_ANL.00960_00480.nc</span><br><span class="line"></span><br><span class="line">### Model Sea Surface Temperature (JAXA/JAMSTEC)</span><br><span class="line"> JCPT_DA_JPN03_SST_YYYYMMDD_hhmm.nc</span><br><span class="line"></span><br><span class="line">where YYYY: 4-digit year of observation start time (timeline);</span><br><span class="line">       MM: 2-digit month of timeline;</span><br><span class="line">       DD: 2-digit day of timeline;</span><br><span class="line">       hh: 2-digit hour of timeline;</span><br><span class="line">       mm: 2-gidit minutes of timeline;</span><br><span class="line"></span><br><span class="line">Example: JCPT_DA_JPN03_SST_20181024_1200.nc</span><br><span class="line"></span><br><span class="line">## Ensemble ocean analysis product &quot;LORA&quot; (JAXA/RIKEN)</span><br><span class="line"> prmYYYYMMDD.nc</span><br><span class="line"></span><br><span class="line">where prm: parameters;</span><br><span class="line">            el: sea surface height</span><br><span class="line">　　　      s: salimity</span><br><span class="line">　      　　t: temprature</span><br><span class="line">　　　      u: zonal velocity</span><br><span class="line">      　　　v: meridional velocity</span><br><span class="line">    w: vertical velocity</span><br><span class="line">　　　      ** See MLT_MLS_namelist_en.pd for mixed layer related parameters</span><br><span class="line">      YYYY: 4-digit year of observation start time (timeline);</span><br><span class="line">      MM: 2-digit month of timeline; and</span><br><span class="line">      DD: 2-digit day of timeline.</span><br><span class="line"></span><br><span class="line">Example: el20230330.nc</span><br><span class="line"></span><br><span class="line">********************************************************************************</span><br><span class="line"></span><br><span class="line"># Format</span><br><span class="line"></span><br><span class="line">  All data is in NetCDF4 format. </span><br><span class="line"></span><br><span class="line">********************************************************************************</span><br></pre></td></tr></table></figure><h2 id="⛄Himawari8-x2F-9数据预处理"><a href="#⛄Himawari8-x2F-9数据预处理" class="headerlink" title="⛄Himawari8&#x2F;9数据预处理"></a>⛄Himawari8&#x2F;9数据预处理</h2><p>这里以<code>NC</code>格式的数据处理为例：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> netCDF4 <span class="keyword">as</span> nc</span><br><span class="line"><span class="keyword">from</span> osgeo <span class="keyword">import</span> gdal, osr</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> os</span><br></pre></td></tr></table></figure><p>（1）读取nc文件</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tep_data = nc.Dataset(input_path)</span><br></pre></td></tr></table></figure><p>（2）查看并获取nc文件中对应变量的信息，读取数据</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看nc文件中的变量信息</span></span><br><span class="line"><span class="built_in">print</span>(tep_data.variables.keys())</span><br></pre></td></tr></table></figure><p>（3）根据数据的经纬度，计算分辨率，确定六参数</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 获取nc文件中对应变量的信息</span></span><br><span class="line">lon_data = tep_data.variables[<span class="string">&quot;longitude&quot;</span>][:]</span><br><span class="line">lat_data = tep_data.variables[<span class="string">&quot;latitude&quot;</span>][:]</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 影像的左上角&amp;右下角坐标</span></span><br><span class="line">lonmin,latmax,lonmax,latmin=[lon_data.<span class="built_in">min</span>(),lat_data.<span class="built_in">max</span>(),lon_data.<span class="built_in">max</span>(),lat_data.<span class="built_in">min</span>()]</span><br><span class="line"><span class="comment"># print(lonmin, latmax, lonmax, latmin)</span></span><br><span class="line">    </span><br><span class="line"><span class="comment"># 分辨率计算</span></span><br><span class="line">num_lon = <span class="built_in">len</span>(lon_data)</span><br><span class="line">num_lat = <span class="built_in">len</span>(lat_data)</span><br><span class="line">lon_res = (lonmax - lonmin) / (<span class="built_in">float</span>(num_lon) - <span class="number">1</span>)</span><br><span class="line">lat_res = (latmax - latmin) / (<span class="built_in">float</span>(num_lat) - <span class="number">1</span>)</span><br><span class="line"><span class="comment"># 定义六参数，设置影像的显示范围和分辨率</span></span><br><span class="line"><span class="comment"># 影像左上角横坐标：geoTransform[0]</span></span><br><span class="line"><span class="comment"># 影像左上角纵坐标：geoTransform[3]</span></span><br><span class="line"><span class="comment"># 遥感图像的水平空间分辨率为geoTransform[1]</span></span><br><span class="line"><span class="comment"># 遥感图像的垂直空间分辨率为geoTransform[5]</span></span><br><span class="line"><span class="comment"># 通常geoTransform[5]与geoTransform[1]相等</span></span><br><span class="line"><span class="comment"># 如果遥感影像方向没有发生旋转，即上北、下南，则geoTransform[2] 与 row *geoTransform[4] 为零。</span></span><br><span class="line">geotransform = (lonmin, lon_res, <span class="number">0.0</span>, latmax, <span class="number">0.0</span>, -lat_res)</span><br></pre></td></tr></table></figure><p>（4）定义投影</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义投影</span></span><br><span class="line">proj = osr.SpatialReference()</span><br><span class="line">proj.ImportFromEPSG(<span class="number">4326</span>)  <span class="comment"># WGS84</span></span><br><span class="line">proj = proj.ExportToWkt()  <span class="comment"># 重点，转成wkt格式</span></span><br><span class="line"><span class="comment"># print(prj)               字符串</span></span><br></pre></td></tr></table></figure><p>（5）波段合成，保存数据为tif格式</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 获取葵花数据16个波段变量名称</span></span><br><span class="line">H_Keys = [<span class="string">&#x27;albedo_01&#x27;</span>, <span class="string">&#x27;albedo_02&#x27;</span>, <span class="string">&#x27;albedo_03&#x27;</span>, <span class="string">&#x27;albedo_04&#x27;</span>, <span class="string">&#x27;albedo_05&#x27;</span>, <span class="string">&#x27;albedo_06&#x27;</span>, <span class="string">&#x27;tbb_07&#x27;</span>, <span class="string">&#x27;tbb_08&#x27;</span>, <span class="string">&#x27;tbb_09&#x27;</span>, <span class="string">&#x27;tbb_10&#x27;</span>, <span class="string">&#x27;tbb_11&#x27;</span>, <span class="string">&#x27;tbb_12&#x27;</span>, <span class="string">&#x27;tbb_13&#x27;</span>, <span class="string">&#x27;tbb_14&#x27;</span>, <span class="string">&#x27;tbb_15&#x27;</span>, <span class="string">&#x27;tbb_16&#x27;</span>]</span><br><span class="line"></span><br><span class="line">im_height = tep_data.dimensions[<span class="string">&quot;latitude&quot;</span>].size</span><br><span class="line">im_width = tep_data.dimensions[<span class="string">&quot;longitude&quot;</span>].size</span><br><span class="line">bands = tep_data.dimensions[<span class="string">&quot;band&quot;</span>].size</span><br><span class="line">H_bands = np.zeros((im_height, im_width, bands), dtype = np.float64)  </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(H_Keys)):</span><br><span class="line">   band_key = H_Keys[i]</span><br><span class="line">   H_bands[:,:,i] = tep_data.variables[band_key][:]</span><br><span class="line"></span><br><span class="line">filename = os.path.basename(input_path).split(<span class="string">&quot;.&quot;</span>)[<span class="number">0</span>] + <span class="string">&quot;.tif&quot;</span></span><br><span class="line"><span class="comment"># 注意区分os.sep.join()和os.path.join()的区别</span></span><br><span class="line">output_filepath = os.path.join(output_path,filename)</span><br><span class="line">write_img(output_filepath, proj, geotransform, H_bands)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 遥感数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据处理 </tag>
            
            <tag> Himawari8-9 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python之Pandas读写文件及索引操作</title>
      <link href="/2023/03/27/Python-Pandas-RWF/"/>
      <url>/2023/03/27/Python-Pandas-RWF/</url>
      
        <content type="html"><![CDATA[<p>当使用<code>Pandas</code>做数据分析时，需要读取事先准备好的数据集，这是做数据分析的第一步。<code>Pandas</code>提供了多种读取数据的方法：</p><ul><li><code>read_csv()</code>用于读取文本文件</li><li><code>read_json()</code>用于读取<code>json</code>文件</li><li><code>read_sql_query()</code>读取<code>sql</code>语句的</li></ul><h2 id="⛄CSV读写文件"><a href="#⛄CSV读写文件" class="headerlink" title="⛄CSV读写文件"></a>⛄CSV读写文件</h2><p> <code>CSV</code>又称逗号分隔值文件，是一种简单的文件格式，以特定的结构来排列表格数据。 <code>CSV</code>文件能够以纯文本形式存储表格数据，比如电子表格、数据库文件，并具有数据交换的通用格式。<code>CSV</code>文件会在<code>Excel</code>文件中被打开，其行和列都定义了标准的数据格式。</p><p>将<code>CSV</code>中的数据转换为<code>DataFrame</code>对象是非常便捷的。和一般文件读写不一样，它不需要你做打开文件、读取文件、关闭文件等操作。相反，您只需要一行代码就可以完成上述所有步骤，并将数据存储在<code>DataFrame</code>中。  </p><p>在<code>Pandas</code>中用于读取文本的函数有两个，分别是：<code>read_csv()</code>和<code>read_table()</code>，它们能够自动地将表格数据转换为<code>DataFrame</code>对象。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pandas.read_csv(filepath_or_buffer, sep=<span class="string">&#x27;,&#x27;</span>, delimiter=<span class="literal">None</span>, header=<span class="string">&#x27;infer&#x27;</span>,names=<span class="literal">None</span>, index_col=<span class="literal">None</span>, usecols=<span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建txt文件，添加数据，另存为csv文件</span></span><br><span class="line">ID,Name,Age,City,Salary</span><br><span class="line"><span class="number">1</span>,Jack,<span class="number">28</span>,Beijing,<span class="number">22000</span></span><br><span class="line"><span class="number">2</span>,Lida,<span class="number">32</span>,Shanghai,<span class="number">19000</span></span><br><span class="line"><span class="number">3</span>,John,<span class="number">43</span>,Shenzhen,<span class="number">12000</span></span><br><span class="line"><span class="number">4</span>,Helen,<span class="number">38</span>,Hengshui,<span class="number">3500</span></span><br></pre></td></tr></table></figure><h3 id="👀read-csv"><a href="#👀read-csv" class="headerlink" title="👀read_csv()"></a>👀read_csv()</h3><p><code>read_csv()</code>表示从<code>CSV</code>文件中读取数据，并创建<code>DataFrame</code>对象。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="comment">#需要注意文件的路径</span></span><br><span class="line">df = pd.read_csv(<span class="string">r&quot;D:\Desktop\one.csv&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">   ID   Name  Age      City  Salary</span><br><span class="line"><span class="number">0</span>   <span class="number">1</span>   Jack   <span class="number">28</span>   Beijing   <span class="number">22000</span></span><br><span class="line"><span class="number">1</span>   <span class="number">2</span>   Lida   <span class="number">32</span>  Shanghai   <span class="number">19000</span></span><br><span class="line"><span class="number">2</span>   <span class="number">3</span>   John   <span class="number">43</span>  Shenzhen   <span class="number">12000</span></span><br><span class="line"><span class="number">3</span>   <span class="number">4</span>  Helen   <span class="number">38</span>  Hengshui    <span class="number">3500</span></span><br></pre></td></tr></table></figure><p>（1）自定义索引</p><p>在<code>CSV</code>文件中指定了一个列，然后使用<code>index_col</code>可以实现自定义索引。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">df = pd.read_csv(<span class="string">r&quot;D:\Desktop\one.csv&quot;</span>,index_col=[<span class="string">&#x27;ID&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">     Name  Age      City  Salary</span><br><span class="line">ID                              </span><br><span class="line"><span class="number">1</span>    Jack   <span class="number">28</span>   Beijing   <span class="number">22000</span></span><br><span class="line"><span class="number">2</span>    Lida   <span class="number">32</span>  Shanghai   <span class="number">19000</span></span><br><span class="line"><span class="number">3</span>    John   <span class="number">43</span>  Shenzhen   <span class="number">12000</span></span><br><span class="line"><span class="number">4</span>   Helen   <span class="number">38</span>  Hengshui    <span class="number">3500</span></span><br></pre></td></tr></table></figure><p>（2）查看每一列的<code>dtype</code></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">df1 = pd.read_csv(<span class="string">r&quot;D:\Desktop\one.csv&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(df1.dtypes)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 转换salary为float类型</span></span><br><span class="line">df2 = pd.read_csv(<span class="string">r&quot;D:\Desktop\one.csv&quot;</span>,dtype=&#123;<span class="string">&#x27;Salary&#x27;</span>:np.float64&#125;)</span><br><span class="line"><span class="built_in">print</span>(df2.dtypes)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">ID         int64</span><br><span class="line">Name      <span class="built_in">object</span></span><br><span class="line">Age        int64</span><br><span class="line">City      <span class="built_in">object</span></span><br><span class="line">Salary     int64</span><br><span class="line">dtype: <span class="built_in">object</span></span><br><span class="line">********************</span><br><span class="line">ID          int64</span><br><span class="line">Name       <span class="built_in">object</span></span><br><span class="line">Age         int64</span><br><span class="line">City       <span class="built_in">object</span></span><br><span class="line">Salary    float64</span><br><span class="line">dtype: <span class="built_in">object</span></span><br></pre></td></tr></table></figure><p>（3）更改文件标头名</p><p>使用<code>names</code>参数可以指定头文件的名称。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">df1 = pd.read_csv(<span class="string">r&quot;D:\Desktop\one.csv&quot;</span>,names=[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(df1)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 文件标头名是附加的自定义名称，但是您会发现，原来的标头名（列标签名）并没有被删除，此时您可以使用`header`参数来删除它。</span></span><br><span class="line">df2 = pd.read_csv(<span class="string">r&quot;D:\Desktop\one.csv&quot;</span>,names=[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>],header=<span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(df2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">    a      b    c         d       e</span><br><span class="line"><span class="number">0</span>  ID   Name  Age      City  Salary</span><br><span class="line"><span class="number">1</span>   <span class="number">1</span>   Jack   <span class="number">28</span>   Beijing   <span class="number">22000</span></span><br><span class="line"><span class="number">2</span>   <span class="number">2</span>   Lida   <span class="number">32</span>  Shanghai   <span class="number">19000</span></span><br><span class="line"><span class="number">3</span>   <span class="number">3</span>   John   <span class="number">43</span>  Shenzhen   <span class="number">12000</span></span><br><span class="line"><span class="number">4</span>   <span class="number">4</span>  Helen   <span class="number">38</span>  Hengshui    <span class="number">3500</span></span><br><span class="line">********************</span><br><span class="line">   a      b   c         d      e</span><br><span class="line"><span class="number">0</span>  <span class="number">1</span>   Jack  <span class="number">28</span>   Beijing  <span class="number">22000</span></span><br><span class="line"><span class="number">1</span>  <span class="number">2</span>   Lida  <span class="number">32</span>  Shanghai  <span class="number">19000</span></span><br><span class="line"><span class="number">2</span>  <span class="number">3</span>   John  <span class="number">43</span>  Shenzhen  <span class="number">12000</span></span><br><span class="line"><span class="number">3</span>  <span class="number">4</span>  Helen  <span class="number">38</span>  Hengshui   <span class="number">3500</span></span><br></pre></td></tr></table></figure><p>（4）跳过指定的行数</p><p><code>skiprows</code>参数表示跳过指定的行数。注意：包含标头所在行。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">df = pd.read_csv(<span class="string">r&quot;D:\Desktop\one.csv&quot;</span>,skiprows=<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">   <span class="number">2</span>   Lida  <span class="number">32</span>  Shanghai  <span class="number">19000</span></span><br><span class="line"><span class="number">0</span>  <span class="number">3</span>   John  <span class="number">43</span>  Shenzhen  <span class="number">12000</span></span><br><span class="line"><span class="number">1</span>  <span class="number">4</span>  Helen  <span class="number">38</span>  Hengshui   <span class="number">3500</span></span><br></pre></td></tr></table></figure><h3 id="👀to-csv"><a href="#👀to-csv" class="headerlink" title="👀to_csv()"></a>👀to_csv()</h3><p><code>Pandas</code>提供的<code>to_csv()</code>函数用于将<code>DataFrame</code>转换为<code>CSV</code>数据。如果想要把<code>CSV</code>数据写入文件，只需向函数传递一个文件对象即可。否则，<code>CSV</code>数据将以字符串格式返回。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd </span><br><span class="line">data = &#123;<span class="string">&#x27;Name&#x27;</span>:[<span class="string">&#x27;Smith&#x27;</span>,<span class="string">&#x27;Parker&#x27;</span>], <span class="string">&#x27;ID&#x27;</span>:[<span class="number">101</span>, <span class="number">102</span>], <span class="string">&#x27;Language&#x27;</span>:[<span class="string">&#x27;Py&#x27;</span>, <span class="string">&#x27;JS&#x27;</span>]&#125; </span><br><span class="line">info = pd.DataFrame(data) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;DataFrame Values:\n&#x27;</span>, info) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 转换为csv数据</span></span><br><span class="line">csv_data = info.to_csv() </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;CSV数据:\n&#x27;</span>, csv_data) </span><br><span class="line"><span class="comment"># 指定CSV文件输出时的分隔符，并将其保存在pandas.csv文件中</span></span><br><span class="line">csv_data = info.to_csv(<span class="string">r&quot;D:\Desktop\two.csv&quot;</span>,sep=<span class="string">&#x27;|&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">DataFrame Values:</span><br><span class="line">      Name   ID Language</span><br><span class="line"><span class="number">0</span>   Smith  <span class="number">101</span>       Py</span><br><span class="line"><span class="number">1</span>  Parker  <span class="number">102</span>       JS</span><br><span class="line">********************</span><br><span class="line">CSV数据:</span><br><span class="line"> ,Name,ID,Language</span><br><span class="line"><span class="number">0</span>,Smith,<span class="number">101</span>,Py</span><br><span class="line"><span class="number">1</span>,Parker,<span class="number">102</span>,JS</span><br></pre></td></tr></table></figure><h2 id="⛄Excel读写操作"><a href="#⛄Excel读写操作" class="headerlink" title="⛄Excel读写操作"></a>⛄Excel读写操作</h2><p>在数据量较少的情况下，<code>Excel</code>对于数据的处理、分析、可视化有其独特的优势，因此可以显著提升您的工作效率。但是，当数据量非常大时，<code>Excel</code>的劣势就暴露出来了，比如，操作重复、数据分析难等问题。<code>Pandas</code>提供了操作<code>Excel</code>文件的函数，可以很方便地处理<code>Excel</code>表格。</p><h3 id="👀read-excel"><a href="#👀read-excel" class="headerlink" title="👀read_excel()"></a>👀read_excel()</h3><p>如果您想读取<code>Excel</code>表格中的数据，可以使用<code>read_excel()</code>方法，其语法格式如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pd.read_excel(io, sheet_name=<span class="number">0</span>, header=<span class="number">0</span>, names=<span class="literal">None</span>, index_col=<span class="literal">None</span>, usecols=<span class="literal">None</span>, squeeze=<span class="literal">False</span>, dtype=<span class="literal">None</span>, engine=<span class="literal">None</span>, converters=<span class="literal">None</span>, true_values=<span class="literal">None</span>, false_values=<span class="literal">None</span>, skiprows=<span class="literal">None</span>, nrows=<span class="literal">None</span>, na_values=<span class="literal">None</span>, parse_dates=<span class="literal">False</span>, date_parser=<span class="literal">None</span>, thousands=<span class="literal">None</span>, comment=<span class="literal">None</span>, skipfooter=<span class="number">0</span>, convert_float=<span class="literal">True</span>, **kwds)</span><br><span class="line"></span><br><span class="line">参数说明</span><br><span class="line">io表示Excel文件的存储路径。</span><br><span class="line">sheet_name要读取的工作表名称。</span><br><span class="line">header指定作为列名的行，默认<span class="number">0</span>，即取第一行的值为列名；若数据不包含列名，则设定header=<span class="literal">None</span>。若将其设置为header=<span class="number">2</span>，则表示将前两行作为多重索引。</span><br><span class="line">names一般适用于Excel缺少列名，或者需要重新定义列名的情况；names的长度必须等于Excel表格列的长度，否则会报错。</span><br><span class="line">index_col用做行索引的列，可以是工作表的列名称，如index_col=<span class="string">&#x27;列名&#x27;</span>，也可以是整数或者列表。</span><br><span class="line">usecols<span class="built_in">int</span>或<span class="built_in">list</span>类型，默认为<span class="literal">None</span>，表示需要读取所有列。</span><br><span class="line">squeezeboolean，默认为<span class="literal">False</span>，如果解析的数据只包含一列，则返回一个Series。</span><br><span class="line">converters规定每一列的数据类型。</span><br><span class="line">skiprows接受一个列表，表示跳过指定行数的数据，从头部第一行开始。</span><br><span class="line">nrows需要读取的行数。</span><br><span class="line">skipfooter接受一个列表，省略指定行数的数据，从尾部最后一行开始。</span><br></pre></td></tr></table></figure><p>读取操作<code>xlsx</code>文件：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="comment"># 读取excel数据</span></span><br><span class="line">df1 = pd.read_excel(<span class="string">r&quot;D:\Desktop\学习网站.xlsx&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(df1)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">20</span>)</span><br><span class="line">df2 = pd.read_excel(<span class="string">r&quot;D:\Desktop\学习网站.xlsx&quot;</span>,index_col=<span class="string">&#x27;name&#x27;</span>,skiprows=[<span class="number">2</span>])</span><br><span class="line"><span class="built_in">print</span>(df2)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 处理未命名列</span></span><br><span class="line">df2.columns = df2.columns.<span class="built_in">str</span>.replace(<span class="string">&#x27;Unnamed.*&#x27;</span>, <span class="string">&#x27;col_label&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(df2)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># index_col选择前两列作为索引列，选择前三列数据</span></span><br><span class="line">df3 = pd.read_excel(<span class="string">r&quot;D:\Desktop\学习网站.xlsx&quot;</span>,index_col=[<span class="number">0</span>,<span class="number">1</span>],usecols=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"><span class="built_in">print</span>(df3)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">   Unnamed: <span class="number">0</span>      name  rank language                 url</span><br><span class="line"><span class="number">0</span>           <span class="number">0</span>       编程帮     <span class="number">1</span>      PHP   www.bianchneg.com</span><br><span class="line"><span class="number">1</span>           <span class="number">1</span>    c语言中文网     <span class="number">2</span>        C     c.bianchneg.net</span><br><span class="line"><span class="number">2</span>           <span class="number">2</span>       微学苑     <span class="number">3</span>      PHP  www.weixueyuan.com</span><br><span class="line"><span class="number">3</span>           <span class="number">3</span>  92python     <span class="number">4</span>   Python    www<span class="number">.92</span>python.com</span><br><span class="line">********************</span><br><span class="line">          Unnamed: <span class="number">0</span>  rank language                 url</span><br><span class="line">name                                                   </span><br><span class="line">编程帮                <span class="number">0</span>     <span class="number">1</span>      PHP   www.bianchneg.com</span><br><span class="line">微学苑                <span class="number">2</span>     <span class="number">3</span>      PHP  www.weixueyuan.com</span><br><span class="line">92python           <span class="number">3</span>     <span class="number">4</span>   Python    www<span class="number">.92</span>python.com</span><br><span class="line">********************</span><br><span class="line">          col_label  rank language                 url</span><br><span class="line">name                                                  </span><br><span class="line">编程帮               <span class="number">0</span>     <span class="number">1</span>      PHP   www.bianchneg.com</span><br><span class="line">微学苑               <span class="number">2</span>     <span class="number">3</span>      PHP  www.weixueyuan.com</span><br><span class="line">92python          <span class="number">3</span>     <span class="number">4</span>   Python    www<span class="number">.92</span>python.com</span><br><span class="line">********************</span><br><span class="line">              language</span><br><span class="line">name     rank         </span><br><span class="line">编程帮      <span class="number">1</span>         PHP</span><br><span class="line">c语言中文网   <span class="number">2</span>           C</span><br><span class="line">微学苑      <span class="number">3</span>         PHP</span><br><span class="line">92python <span class="number">4</span>      Python</span><br></pre></td></tr></table></figure><h3 id="👀to-excel"><a href="#👀to-excel" class="headerlink" title="👀to_excel()"></a>👀to_excel()</h3><p>通过<code>to_excel()</code>函数可以将<code>Dataframe</code>中的数据写入到<code>Excel</code>文件。如果想要把单个对象写入<code>Excel</code>文件，那么必须指定目标文件名；如果想要写入到多张工作表中，则需要创建一个带有目标文件名的<code>ExcelWriter</code>对象，并通过<code>sheet_name</code>参数依次指定工作表的名称。 </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">DataFrame.to_excel(excel_writer, sheet_name=<span class="string">&#x27;Sheet1&#x27;</span>, na_rep=<span class="string">&#x27;&#x27;</span>, float_format=<span class="literal">None</span>, columns=<span class="literal">None</span>, header=<span class="literal">True</span>, index=<span class="literal">True</span>, index_label=<span class="literal">None</span>, startrow=<span class="number">0</span>, startcol=<span class="number">0</span>, engine=<span class="literal">None</span>, merge_cells=<span class="literal">True</span>, encoding=<span class="literal">None</span>, inf_rep=<span class="string">&#x27;inf&#x27;</span>, verbose=<span class="literal">True</span>, freeze_panes=<span class="literal">None</span>)  </span><br><span class="line"></span><br><span class="line">参数说明</span><br><span class="line">excel_wirter文件路径或者ExcelWrite对象。</span><br><span class="line">sheet_name指定要写入数据的工作表名称。</span><br><span class="line">na_rep缺失值的表示形式。</span><br><span class="line">float_format它是一个可选参数，用于格式化浮点数字符串。</span><br><span class="line">columns指要写入的列。</span><br><span class="line">header写出每一列的名称，如果给出的是字符串列表，则表示列的别名。</span><br><span class="line">index表示要写入的索引。</span><br><span class="line">index_label 引用索引列的列标签。如果未指定，且hearder和index均为<span class="literal">True</span>，则使用索引名称。如果DataFrame使用MultiIndex，则需要给出一个序列。</span><br><span class="line">startrow初始写入的行位置，默认值<span class="number">0</span>。表示引用左上角的行单元格来储存DataFrame。</span><br><span class="line">startcol初始写入的列位置，默认值<span class="number">0</span>。表示引用左上角的列单元格来储存DataFrame。</span><br><span class="line">engine它是一个可选参数，用于指定要使用的引擎，可以是openpyxl或xlsxwriter。</span><br></pre></td></tr></table></figure><p>创建DataFrame数据，保存xlsx文件。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="comment">#创建DataFrame数据</span></span><br><span class="line">info_website = pd.DataFrame(&#123;</span><br><span class="line"><span class="string">&#x27;name&#x27;</span>: [<span class="string">&#x27;编程帮&#x27;</span>, <span class="string">&#x27;c语言中文网&#x27;</span>, <span class="string">&#x27;微学苑&#x27;</span>, <span class="string">&#x27;92python&#x27;</span>],</span><br><span class="line"><span class="string">&#x27;rank&#x27;</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line"><span class="string">&#x27;language&#x27;</span>: [<span class="string">&#x27;PHP&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;PHP&#x27;</span>,<span class="string">&#x27;Python&#x27;</span> ],</span><br><span class="line"><span class="string">&#x27;url&#x27;</span>: [<span class="string">&#x27;www.bianchneg.com&#x27;</span>,<span class="string">&#x27;c.bianchneg.net&#x27;</span>,<span class="string">&#x27;www.weixueyuan.com&#x27;</span>,<span class="string">&#x27;www.92python.com&#x27;</span>]&#125;)</span><br><span class="line"><span class="comment"># 创建ExcelWrite对象</span></span><br><span class="line">writer = pd.ExcelWriter(<span class="string">r&quot;D:\Desktop\学习网站.xlsx&quot;</span>)</span><br><span class="line">info_website.to_excel(writer)</span><br><span class="line">writer.save()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;输出成功&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="⛄index操作索引"><a href="#⛄index操作索引" class="headerlink" title="⛄index操作索引"></a>⛄index操作索引</h2><p>索引（<code>index</code>）是<code>Pandas</code>的重要工具，通过索引可以从<code>DataFame</code>中选择特定的行数和列数，这种选择数据的方式称为“子集选择”。在<code>Pandas</code>中，索引值也被称为标签（<code>label</code>），它在<code>Jupyter</code>笔记本中以粗体字进行显示。索引可以加快数据访问的速度，它就好比数据的书签，通过它可以实现数据的快速查找。  </p><p>（1）创建索引</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd    </span><br><span class="line">data1 = pd.read_csv(<span class="string">r&quot;D:\Desktop\one.csv&quot;</span>) </span><br><span class="line"><span class="built_in">print</span>(data1)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment">#设置&quot;Name&quot;为行索引    </span></span><br><span class="line">data2 = pd.read_csv(<span class="string">r&quot;D:\Desktop\one.csv&quot;</span>, index_col =<span class="string">&quot;Name&quot;</span>)   </span><br><span class="line"><span class="comment"># 通过列标签选取多列数据  </span></span><br><span class="line">a1 = data2[[<span class="string">&quot;City&quot;</span>,<span class="string">&quot;Salary&quot;</span>]]</span><br><span class="line"><span class="built_in">print</span>(a1)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 获取单列数据，或者以列表的形式传入[&quot;Salary&quot;] </span></span><br><span class="line">a2 = data2[<span class="string">&quot;Salary&quot;</span>]</span><br><span class="line"><span class="built_in">print</span>(a2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">   ID   Name  Age      City  Salary</span><br><span class="line"><span class="number">0</span>   <span class="number">1</span>   Jack   <span class="number">28</span>   Beijing   <span class="number">22000</span></span><br><span class="line"><span class="number">1</span>   <span class="number">2</span>   Lida   <span class="number">32</span>  Shanghai   <span class="number">19000</span></span><br><span class="line"><span class="number">2</span>   <span class="number">3</span>   John   <span class="number">43</span>  Shenzhen   <span class="number">12000</span></span><br><span class="line"><span class="number">3</span>   <span class="number">4</span>  Helen   <span class="number">38</span>  Hengshui    <span class="number">3500</span></span><br><span class="line">********************</span><br><span class="line">           City  Salary</span><br><span class="line">Name                   </span><br><span class="line">Jack    Beijing   <span class="number">22000</span></span><br><span class="line">Lida   Shanghai   <span class="number">19000</span></span><br><span class="line">John   Shenzhen   <span class="number">12000</span></span><br><span class="line">Helen  Hengshui    <span class="number">3500</span></span><br><span class="line">********************</span><br><span class="line">Name</span><br><span class="line">Jack     <span class="number">22000</span></span><br><span class="line">Lida     <span class="number">19000</span></span><br><span class="line">John     <span class="number">12000</span></span><br><span class="line">Helen     <span class="number">3500</span></span><br><span class="line">Name: Salary, dtype: int64</span><br></pre></td></tr></table></figure><p>（2）设置索引</p><p><code>set_index()</code>将已存在的列标签设置为<code>DataFrame</code>行索引。除了可以添加索引外，也可以替换已经存在的索引。比如您也可以把<code>Series</code>或者一个<code>DataFrme</code>设置成另一个<code>DataFrame</code>的索引。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd  </span><br><span class="line">info = pd.DataFrame(&#123;<span class="string">&#x27;Name&#x27;</span>:[<span class="string">&#x27;Parker&#x27;</span>,<span class="string">&#x27;Terry&#x27;</span>,<span class="string">&#x27;Smith&#x27;</span>,<span class="string">&#x27;William&#x27;</span>], </span><br><span class="line">                     <span class="string">&#x27;Year&#x27;</span>:[<span class="number">2011</span>,<span class="number">2009</span>,<span class="number">2014</span>,<span class="number">2010</span>],</span><br><span class="line">                     <span class="string">&#x27;Leaves&#x27;</span>: [<span class="number">10</span>,<span class="number">15</span>,<span class="number">9</span>,<span class="number">4</span>]&#125;)</span><br><span class="line"><span class="built_in">print</span>(info)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 设置Name为行索引</span></span><br><span class="line"><span class="built_in">print</span>(info.set_index(<span class="string">&#x27;Name&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">      Name  Year  Leaves</span><br><span class="line"><span class="number">0</span>   Parker  <span class="number">2011</span>      <span class="number">10</span></span><br><span class="line"><span class="number">1</span>    Terry  <span class="number">2009</span>      <span class="number">15</span></span><br><span class="line"><span class="number">2</span>    Smith  <span class="number">2014</span>       <span class="number">9</span></span><br><span class="line"><span class="number">3</span>  William  <span class="number">2010</span>       <span class="number">4</span></span><br><span class="line">********************</span><br><span class="line">         Year  Leaves</span><br><span class="line">Name                 </span><br><span class="line">Parker   <span class="number">2011</span>      <span class="number">10</span></span><br><span class="line">Terry    <span class="number">2009</span>      <span class="number">15</span></span><br><span class="line">Smith    <span class="number">2014</span>       <span class="number">9</span></span><br><span class="line">William  <span class="number">2010</span>       <span class="number">4</span></span><br></pre></td></tr></table></figure><p>（3）重置索引</p><p>使用<code>reset_index()</code>来恢复初始行索引</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">info = pd.DataFrame([(<span class="string">&#x27;William&#x27;</span>, <span class="string">&#x27;C&#x27;</span>), (<span class="string">&#x27;Smith&#x27;</span>, <span class="string">&#x27;Java&#x27;</span>), (<span class="string">&#x27;Parker&#x27;</span>, <span class="string">&#x27;Python&#x27;</span>), (<span class="string">&#x27;Phill&#x27;</span>, np.nan)], index=[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], columns=(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;Language&#x27;</span>)) </span><br><span class="line"><span class="built_in">print</span>(info)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="built_in">print</span>(info.reset_index())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">      name Language</span><br><span class="line"><span class="number">1</span>  William        C</span><br><span class="line"><span class="number">2</span>    Smith     Java</span><br><span class="line"><span class="number">3</span>   Parker   Python</span><br><span class="line"><span class="number">4</span>    Phill      NaN</span><br><span class="line">********************</span><br><span class="line">   index     name Language</span><br><span class="line"><span class="number">0</span>      <span class="number">1</span>  William        C</span><br><span class="line"><span class="number">1</span>      <span class="number">2</span>    Smith     Java</span><br><span class="line"><span class="number">2</span>      <span class="number">3</span>   Parker   Python</span><br><span class="line"><span class="number">3</span>      <span class="number">4</span>    Phill      NaN</span><br></pre></td></tr></table></figure><h2 id="⛄Pandas分层索引"><a href="#⛄Pandas分层索引" class="headerlink" title="⛄Pandas分层索引"></a>⛄Pandas分层索引</h2><p>分层索引（<code>Multiple Index</code>）是<code>Pandas</code>中非常重要的索引类型，它指的是在一个轴上拥有多个（即两个以上）索引层数，这使得我们可以用低维度的结构来处理更高维的数据。比如，当想要处理三维及以上的高维数据时，就需要用到分层索引。</p><p>分层索引的目的是用低维度的结构（<code>Series</code>或者<code>DataFrame</code>）更好地处理高维数据。通过分层索引，我们可以像处理二维数据一样，处理三维及以上的数据。分层索引的存在使得分析高维数据变得简单，让抽象的高维数据变得容易理解，同时它比废弃的<code>Panel</code>结构更容易使用。</p><p><code>Pandas</code>可以通过<code>MultiIndex()</code>方法来创建分层索引对象，该对象本质上是一个元组序列，序列中每一个元组都是唯一的。 </p><h2 id="⛄Pandas执行SQL操作"><a href="#⛄Pandas执行SQL操作" class="headerlink" title="⛄Pandas执行SQL操作"></a>⛄Pandas执行SQL操作</h2><p>如果想要从<code>SQL</code>数据库读取数据，首先您应该使用<code>Python</code>和数据库建立连接，然后将查询语句传递给<code>read_sql_query()</code>方法。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> sqlite3</span><br><span class="line"><span class="comment"># 建立数据连接</span></span><br><span class="line">con = sqlite3.connect(<span class="string">&quot;database.db&quot;</span>)</span><br><span class="line"><span class="comment"># 数据库读取数据,在SQLite数据库中创建一张信息表，您可以随意添加一些信息</span></span><br><span class="line"><span class="comment"># con参数指定操作数据库的引擎，可以指定，也可默认</span></span><br><span class="line">df = pd.read_sql_query(<span class="string">&quot;SELECT * FROM information&quot;</span>,con)  </span><br></pre></td></tr></table></figure><p><code>SELECT</code>查询语句使用<code>,</code>把要查询的每个字段分开，当然您也可以使用<code>*</code>来选择所有的字段。</p><p><code>WHERE</code>子句完成条件查询。</p><p><code>GroupBy</code>分组操作。</p><p><code>LIMIT</code>语句主要起到限制作用，比如查询前n行记录。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 科学计算 </tag>
            
            <tag> 数据分析 </tag>
            
            <tag> Pandas </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python之Pandas详解</title>
      <link href="/2023/03/07/Python-Pandas/"/>
      <url>/2023/03/07/Python-Pandas/</url>
      
        <content type="html"><![CDATA[<p><strong><code>Pandas</code>是<code>Python</code>语言的一个扩展程序库，用于数据分析。</strong></p><p><code>Pandas</code>是一个开放源码、<code>BSD</code>许可的库，提供高性能、易于使用的数据结构和数据分析工具。</p><p><code>Pandas</code>名字衍生自术语 "<code>panel data</code>"（面板数据）和 "<code>Python data analysis</code>"（<code>Python</code>数据分析）。</p><p><code>Pandas</code>一个强大的分析结构化数据的工具集，基础是<code>NumPy</code>（提供高性能的矩阵运算）。</p><p><code>Pandas</code>可以从各种文件格式比如<code>CSV</code>、<code>JSON</code>、<code>SQL</code>、<code>Microsoft Excel</code> 导入数据。</p><p><code>Pandas</code>可以对各种数据进行运算操作，比如归并、再成形、选择，还有数据清洗和数据加工特征。</p><p><code>Pandas</code>广泛应用在学术、金融、统计学等各个数据分析领域。</p><p><code>Pandas</code>主要包括以下几个特点：</p><ul><li>它提供了一个简单、高效、带有默认标签（也可以自定义标签）的<code>DataFrame</code>对象。</li><li>能够快速从不同格式的文件中加载数据（比如 <code>Excel</code>、<code>CSV</code> 、<code>SQL</code>文件），然后转换为可处理的对象；</li><li>能够按数据的行、列标签进行分组，并对分组后的对象执行聚合和转换操作；</li><li>能够很方便地实现数据归一化操作和缺失值处理；</li><li>能够很方便地对<code>DataFrame</code>的数据列进行增加、修改或者删除的操作；</li><li>能够处理不同格式的数据集，比如矩阵数据、异构数据表、时间序列等；</li><li>提供了多种处理数据集的方式，比如构建子集、切片、过滤、分组以及重新排序等。</li></ul><h2 id="pandas数据结构">⛄Pandas数据结构</h2><p><code>Pandas</code>的主要数据结构是<code>Series</code>（一维数据）与<code>DataFrame</code>（二维数据），这两种数据结构足以处理金融、统计、社会科学、工程等领域里的大多数典型用例。</p><p><strong>Series</strong>是一种类似于一维数组的对象，它由一组数据（各种<code>Numpy</code>数据类型）以及一组与之相关的数据标签（即索引）组成。</p><p><strong>DataFrame</strong>是一个表格型的数据结构，它含有一组有序的列，每列可以是不同的值类型（数值、字符串、布尔型值）。<code>DataFrame</code>既有行索引也有列索引，它可以被看做由<code>Series</code>组成的字典（共同用一个索引）。</p><h2 id="pandas-series">⛄Pandas Series</h2><p><code>Pandas Series</code>类似表格中的一个列（<code>column</code>），类似于一维数组，由一组数据值（<code>value</code>）和一组标签组成，其中标签与数据值之间是一一对应的关系。<code>Series</code>可以保存任何数据类型，比如整数、字符串、浮点数、<code>Python</code>对象等，它的标签默认为整数，从0开始依次递增。</p><h3 id="创建series对象">👀创建Series对象</h3><p><code>Series</code>由索引（<code>index</code>）和列组成，函数如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pandas.Series(data, index, dtype, name, copy)</span><br><span class="line">参数说明：</span><br><span class="line">    data：一组数据(ndarray类型)。</span><br><span class="line">    index：数据索引标签，如果不指定，默认从<span class="number">0</span>开始。</span><br><span class="line">    dtype：数据类型，默认会自己判断。</span><br><span class="line">    name：设置名称。</span><br><span class="line">    copy：拷贝数据，默认为<span class="literal">False</span>。</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">myvar = pd.Series(a)</span><br><span class="line"><span class="built_in">print</span>(myvar)</span><br><span class="line"><span class="built_in">print</span>(myvar[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果：第一列为索引，第二列为数据</span></span><br><span class="line"><span class="comment"># 如果没有指定索引，索引值就从0开始，我们可以根据索引值读取数据：</span></span><br><span class="line"><span class="number">0</span>    <span class="number">1</span></span><br><span class="line"><span class="number">1</span>    <span class="number">2</span></span><br><span class="line"><span class="number">2</span>    <span class="number">3</span></span><br><span class="line">dtype: int64</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><p>我们也可以使用数组、字典、标量值或者<code>Python</code>对象来创建<code>Series</code>对象。</p><p>（1）创建一个空<code>Series</code>对象</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="comment">#输出数据为空</span></span><br><span class="line">s = pd.Series()</span><br><span class="line"><span class="built_in">print</span>(s)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">Series([], dtype: float64)</span><br></pre></td></tr></table></figure><p>（2）<code>ndarray</code>创建<code>Series</code>对象</p><p><code>ndarray</code>是<code>NumPy</code>中的数组类型，当<code>data</code>是<code>ndarry</code>时，传递的索引必须具有与数组相同的长度。如果没有指定索引（隐式索引)，索引值就从0开始（索引值将使用是<code>range(n)</code> 生成，其中n代表数组长度）；我们可以根据索引值读取数据。可以指定索引值（显式索引），如下实例。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定索引值</span></span><br><span class="line">a = np.array([<span class="string">&quot;Google&quot;</span>, <span class="string">&quot;Runoob&quot;</span>, <span class="string">&quot;Wiki&quot;</span>])</span><br><span class="line">myvar = pd.Series(a, index = [<span class="string">&quot;x&quot;</span>, <span class="string">&quot;y&quot;</span>, <span class="string">&quot;z&quot;</span>])</span><br><span class="line"><span class="built_in">print</span>(myvar)</span><br><span class="line"><span class="built_in">print</span>(myvar[<span class="string">&quot;y&quot;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">#输出结果</span></span><br><span class="line">x    Google</span><br><span class="line">y    Runoob</span><br><span class="line">z      Wiki</span><br><span class="line">dtype: <span class="built_in">object</span></span><br><span class="line">Runoob</span><br></pre></td></tr></table></figure><p>（3）<code>dict</code>创建<code>Series</code>对象</p><p>我们也可以使用<code>key/value</code>对象，类似字典来创建<code>Series</code>：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用字典创建Series</span></span><br><span class="line"><span class="comment"># 没有传递索引，字典的key变成了索引值。</span></span><br><span class="line">sites = &#123;<span class="number">1</span>: <span class="string">&quot;Google&quot;</span>, <span class="number">2</span>: <span class="string">&quot;Runoob&quot;</span>, <span class="number">3</span>: <span class="string">&quot;Wiki&quot;</span>&#125;</span><br><span class="line">myvar1 = pd.Series(sites)</span><br><span class="line"><span class="built_in">print</span>(myvar1)</span><br><span class="line"><span class="comment"># 如果我们只需要字典中的一部分数据，只需要指定需要数据的索引即可，如下实例：</span></span><br><span class="line">myvar2 = pd.Series(sites, index = [<span class="number">1</span>,<span class="number">2</span>])</span><br><span class="line"><span class="built_in">print</span>(myvar2)</span><br><span class="line"><span class="comment"># 当传递的索引值无法找到与其对应的值时，使用NaN（非数字）填充。</span></span><br><span class="line">myvar3 = pd.Series(sites, index = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>])</span><br><span class="line"><span class="built_in">print</span>(myvar3)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="number">1</span>    Google</span><br><span class="line"><span class="number">2</span>    Runoob</span><br><span class="line"><span class="number">3</span>      Wiki</span><br><span class="line">dtype: <span class="built_in">object</span></span><br><span class="line"><span class="number">1</span>    Google</span><br><span class="line"><span class="number">2</span>    Runoob</span><br><span class="line">dtype: <span class="built_in">object</span></span><br><span class="line"><span class="number">1</span>    Google</span><br><span class="line"><span class="number">3</span>      Wiki</span><br><span class="line"><span class="number">2</span>    Runoob</span><br><span class="line"><span class="number">4</span>       NaN</span><br><span class="line">dtype: <span class="built_in">object</span></span><br></pre></td></tr></table></figure><blockquote><p>当传递的索引值无法找到与其对应的值时，使用<code>NaN</code>（非数字）填充。</p></blockquote><p>（4）标量创建<code>Series</code>对象</p><p>如果<code>data</code>是标量值，则必须提供索引，示例如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">s = pd.Series(<span class="number">5</span>, index = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"><span class="built_in">print</span>(s)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="number">0</span>    <span class="number">5</span></span><br><span class="line"><span class="number">1</span>    <span class="number">5</span></span><br><span class="line"><span class="number">2</span>    <span class="number">5</span></span><br><span class="line"><span class="number">3</span>    <span class="number">5</span></span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure><blockquote><p>标量值按照<code>index</code>的数量进行重复，并与其一一对应。</p></blockquote><p>设置<code>Series</code>名称参数：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">sites = &#123;<span class="number">1</span>: <span class="string">&quot;Google&quot;</span>, <span class="number">2</span>: <span class="string">&quot;Runoob&quot;</span>, <span class="number">3</span>: <span class="string">&quot;Wiki&quot;</span>&#125;</span><br><span class="line">myvar = pd.Series(sites, index = [<span class="number">1</span>, <span class="number">2</span>], name=<span class="string">&quot;RUNOOB-Series-TEST&quot;</span> )</span><br><span class="line"><span class="built_in">print</span>(myvar)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="number">1</span>    Google</span><br><span class="line"><span class="number">2</span>    Runoob</span><br><span class="line">Name: RUNOOB-Series-TEST, dtype: <span class="built_in">object</span></span><br></pre></td></tr></table></figure><h3 id="访问series数据">👀访问Series数据</h3><p>（1）位置索引访问</p><p>这种访问方式与<code>ndarray</code>和<code>list</code>相同，使用元素自身的下标进行访问。我们知道数组的索引计数从0开始，这表示第一个元素存储在第0个索引位置上，以此类推，就可以获得<code>Series</code>序列中的每个元素。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">s = pd.Series([<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],index = [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(s[<span class="number">0</span>])  <span class="comment"># 位置下标</span></span><br><span class="line"><span class="built_in">print</span>(s[<span class="string">&#x27;a&#x27;</span>]) <span class="comment"># 标签下标</span></span><br><span class="line"><span class="comment"># 通过切片的方式访问Series序列中的数据</span></span><br><span class="line"><span class="built_in">print</span>(s[:<span class="number">3</span>])</span><br><span class="line"><span class="comment"># 获取最后三个元素</span></span><br><span class="line"><span class="built_in">print</span>(s[-<span class="number">3</span>:])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line">a    <span class="number">5</span></span><br><span class="line">b    <span class="number">2</span></span><br><span class="line">c    <span class="number">3</span></span><br><span class="line">dtype: int64</span><br><span class="line">c    <span class="number">3</span></span><br><span class="line">d    <span class="number">4</span></span><br><span class="line">e    <span class="number">5</span></span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure><p>（2）索引标签访问</p><p><code>Series</code>类似于固定大小的<code>dict</code>，把<code>index</code>中的索引标签当做<code>key</code>，而把<code>Series</code>序列中的元素值当做<code>value</code>，然后通过<code>index</code>索引标签来访问或者修改元素值。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="comment"># 使用索标签访问单个元素值</span></span><br><span class="line">s = pd.Series([<span class="number">16</span>,<span class="number">17</span>,<span class="number">18</span>,<span class="number">19</span>,<span class="number">20</span>],index = [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(s[<span class="string">&#x27;a&#x27;</span>])</span><br><span class="line"><span class="comment"># 使用索引标签访问多个元素值</span></span><br><span class="line"><span class="built_in">print</span>(s[[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>]])</span><br><span class="line"><span class="comment"># 如果使用了index中不包含的标签，则会触发异常</span></span><br><span class="line"><span class="built_in">print</span>(s[<span class="string">&#x27;f&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="number">16</span></span><br><span class="line">a    <span class="number">16</span></span><br><span class="line">c    <span class="number">18</span></span><br><span class="line">d    <span class="number">19</span></span><br><span class="line">dtype: int64</span><br><span class="line">......</span><br><span class="line">KeyError: <span class="string">&#x27;f&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="series常用属性">👀Series常用属性</h3><p><code>Series</code>的常用属性和方法：</p><table><thead><tr class="header"><th>名称</th><th>属性</th></tr></thead><tbody><tr class="odd"><td><code>axes</code></td><td>以列表的形式返回所有行索引标签</td></tr><tr class="even"><td><code>dtype</code></td><td>返回对象的数据类型</td></tr><tr class="odd"><td><code>empty</code></td><td>返回一个空的<code>Series</code>对象</td></tr><tr class="even"><td><code>ndim</code></td><td>返回输入数据的维数</td></tr><tr class="odd"><td><code>size</code></td><td>返回输入数据的元素数量</td></tr><tr class="even"><td><code>values</code></td><td>以<code>ndarray</code>的形式返回<code>Series</code>对象</td></tr><tr class="odd"><td><code>index</code></td><td>返回一个<code>RangeIndex</code>对象，用来描述索引的取值范围</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">s = pd.Series(np.random.randn(<span class="number">6</span>))</span><br><span class="line"><span class="built_in">print</span>(s)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># axes属性</span></span><br><span class="line"><span class="built_in">print</span>(s.axes)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># dtype属性</span></span><br><span class="line"><span class="built_in">print</span>(s.dtype)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># empty</span></span><br><span class="line"><span class="built_in">print</span>(s.empty)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># ndim，Series是一维数据结构，因此它始终返回1</span></span><br><span class="line"><span class="built_in">print</span>(s.ndim)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># size返回Series对象的大小(长度)</span></span><br><span class="line"><span class="built_in">print</span>(s.size)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># value以数组的形式返回Series对象中的数据</span></span><br><span class="line"><span class="built_in">print</span>(s.values)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># index该属性用来查看Series中索引的取值范围</span></span><br><span class="line"><span class="comment">#显示索引</span></span><br><span class="line">s1 = pd.Series([<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">8</span>],index = [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(s1.index)</span><br><span class="line"><span class="comment">#隐式索引</span></span><br><span class="line">s2 = pd.Series([<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">8</span>])</span><br><span class="line"><span class="built_in">print</span>(s2.index)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="number">0</span>   -<span class="number">0.674501</span></span><br><span class="line"><span class="number">1</span>    <span class="number">1.030106</span></span><br><span class="line"><span class="number">2</span>   -<span class="number">1.636359</span></span><br><span class="line"><span class="number">3</span>   -<span class="number">1.540996</span></span><br><span class="line"><span class="number">4</span>    <span class="number">1.312837</span></span><br><span class="line"><span class="number">5</span>   -<span class="number">0.735986</span></span><br><span class="line">dtype: float64</span><br><span class="line">********************</span><br><span class="line">[RangeIndex(start=<span class="number">0</span>, stop=<span class="number">6</span>, step=<span class="number">1</span>)]</span><br><span class="line">********************</span><br><span class="line">float64</span><br><span class="line">********************</span><br><span class="line"><span class="literal">False</span></span><br><span class="line">********************</span><br><span class="line"><span class="number">1</span></span><br><span class="line">********************</span><br><span class="line"><span class="number">6</span></span><br><span class="line">********************</span><br><span class="line">[-<span class="number">0.67450078</span>  <span class="number">1.03010573</span> -<span class="number">1.63635856</span> -<span class="number">1.54099596</span>  <span class="number">1.31283698</span> -<span class="number">0.73598645</span>]</span><br><span class="line">********************</span><br><span class="line">Index([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>], dtype=<span class="string">&#x27;object&#x27;</span>)</span><br><span class="line">RangeIndex(start=<span class="number">0</span>, stop=<span class="number">4</span>, step=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><h3 id="series常用方法">👀Series常用方法</h3><p>（1）<code>head()</code>&amp;<code>tail()</code>查看数据</p><p>如果想要查看<code>Series</code>的某一部分数据，可以使用<code>head()</code>或者tail()方法。其中<code>head()</code>返回前n行数据，默认显示前5行数据。<code>tail()</code>返回的是后n行数据，默认为后5行。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">s = pd.Series(np.random.randn(<span class="number">5</span>))</span><br><span class="line"><span class="built_in">print</span> (s)</span><br><span class="line"><span class="comment"># 返回前三行数据</span></span><br><span class="line"><span class="built_in">print</span>(s.head(<span class="number">3</span>))</span><br><span class="line"><span class="comment"># 返回后两行数据</span></span><br><span class="line"><span class="built_in">print</span>(s.tail(<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="number">0</span>   -<span class="number">0.264915</span></span><br><span class="line"><span class="number">1</span>   -<span class="number">1.120671</span></span><br><span class="line"><span class="number">2</span>    <span class="number">0.621638</span></span><br><span class="line"><span class="number">3</span>   -<span class="number">0.449170</span></span><br><span class="line"><span class="number">4</span>    <span class="number">0.533876</span></span><br><span class="line">dtype: float64</span><br><span class="line"><span class="number">0</span>   -<span class="number">0.264915</span></span><br><span class="line"><span class="number">1</span>   -<span class="number">1.120671</span></span><br><span class="line"><span class="number">2</span>    <span class="number">0.621638</span></span><br><span class="line">dtype: float64</span><br><span class="line"><span class="number">2</span>    <span class="number">0.621638</span></span><br><span class="line"><span class="number">3</span>   -<span class="number">0.449170</span></span><br><span class="line"><span class="number">4</span>    <span class="number">0.533876</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure><p>（2）<code>isnull()</code>&amp;<code>notnull()</code>检测缺失值</p><p><code>isnull()</code>和<code>notnull()</code>用于检测<code>Series</code>中的缺失值。所谓缺失值，顾名思义就是值不存在、丢失、缺少。</p><ul><li><code>isnull()</code>：如果为值不存在或者缺失，则返回<code>True</code>。</li><li><code>notnull()</code>：如果值不存在或者缺失，则返回<code>False</code>。</li></ul><p>其实不难理解，在实际的数据分析任物中，数据的收集往往要经历一个繁琐的过程。在这个过程中难免会因为一些不可抗力，或者人为因素导致数据丢失的现象。这时，我们可以使用相应的方法对缺失值进行处理，比如均值插值、数据补齐等方法。上述两个方法就是帮助我们检测是否存在缺失值。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="comment">#None代表缺失数据</span></span><br><span class="line">s = pd.Series([<span class="number">1</span>,<span class="number">6</span>,<span class="literal">None</span>,<span class="number">8</span>,<span class="literal">None</span>])</span><br><span class="line"><span class="built_in">print</span>(pd.isnull(s))  <span class="comment">#是空值返回True</span></span><br><span class="line"><span class="built_in">print</span>(pd.notnull(s)) <span class="comment">#空值返回False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="number">0</span>    <span class="literal">False</span></span><br><span class="line"><span class="number">1</span>    <span class="literal">False</span></span><br><span class="line"><span class="number">2</span>     <span class="literal">True</span></span><br><span class="line"><span class="number">3</span>    <span class="literal">False</span></span><br><span class="line"><span class="number">4</span>     <span class="literal">True</span></span><br><span class="line">dtype: <span class="built_in">bool</span></span><br><span class="line"><span class="number">0</span>     <span class="literal">True</span></span><br><span class="line"><span class="number">1</span>     <span class="literal">True</span></span><br><span class="line"><span class="number">2</span>    <span class="literal">False</span></span><br><span class="line"><span class="number">3</span>     <span class="literal">True</span></span><br><span class="line"><span class="number">4</span>    <span class="literal">False</span></span><br><span class="line">dtype: <span class="built_in">bool</span></span><br></pre></td></tr></table></figure><h2 id="pandas-dataframe">⛄Pandas DataFrame</h2><p><code>DataFrame</code>是表格型的数据结构，既有行标签（<code>index</code>），又有列标签（<code>columns</code>），它也被称异构数据表。</p><p>它含有一组有序的列，每列可以是不同的值类型（数值、字符串、布尔型值）。<code>DataFrame</code>既有<strong>行索引</strong>也有<strong>列索引</strong>，它可以被看做由<code>Series</code>组成的字典（共同用一个索引），每一行数据都可以看成一个<code>Series</code>结构，<code>DataFrame</code>为这些行中每个数据值增加了一个列标签。</p><p>同<code>Series</code>一样，<code>DataFrame</code>自带行标签索引，默认为“隐式索引”即从0开始依次递增，行标签与<code>DataFrame</code>中的数据项一一对应。<code>DataFrame</code>数据结构的特点：</p><ul><li><code>DataFrame</code>每一列的标签值允许使用不同的数据类型；</li><li><code>DataFrame</code>是表格型的数据结构，具有行和列；</li><li><code>DataFrame</code>中的每个数据值都可以被修改；</li><li><code>DataFrame</code>结构的行数、列数允许增加或者删除；</li><li><code>DataFrame</code>有两个方向的标签轴，分别是行标签和列标签；</li><li><code>DataFrame</code>可以对行和列执行算术运算。</li></ul><h3 id="创建df对象">👀创建DF对象</h3><p><code>DataFrame</code>构造方法如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pandas.DataFrame(data, index, columns, dtype, copy)</span><br><span class="line">参数说明：</span><br><span class="line">    data：一组数据(ndarray、series, <span class="built_in">map</span>, lists, <span class="built_in">dict</span>等类型)。</span><br><span class="line">    index：索引值，或者可以称为行标签。</span><br><span class="line">    columns：列标签，默认为RangeIndex(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, …, n) 。</span><br><span class="line">    dtype：数据类型。</span><br><span class="line">    copy：拷贝数据，默认为<span class="literal">False</span>。</span><br></pre></td></tr></table></figure><p><code>Pandas DataFrame</code>是一个二维的数组结构，类似二维数组。</p><p><code>Pandas</code>提供了多种创建<code>DataFrame</code>对象的方式，主要包含以下五种：</p><p>（1）创建空的<code>DataFrame</code>对象</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">df = pd.DataFrame()</span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">Empty DataFrame</span><br><span class="line">Columns: []</span><br><span class="line">Index: []</span><br></pre></td></tr></table></figure><p>（2）列表创建<code>DataFame</code>对象</p><p>可以使用单一列表或嵌套列表来创建一个<code>DataFrame</code>。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 单一列表创建DataFrame对象</span></span><br><span class="line">data1 = [<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>]</span><br><span class="line">df1 = pd.DataFrame(data1)</span><br><span class="line"><span class="built_in">print</span>(df1)</span><br><span class="line"><span class="comment"># 嵌套列表创建DataFrame对象，并指定数值元素的数据类型为float</span></span><br><span class="line">data2 = [[<span class="string">&#x27;Google&#x27;</span>,<span class="number">10</span>],[<span class="string">&#x27;Runoob&#x27;</span>,<span class="number">12</span>],[<span class="string">&#x27;Wiki&#x27;</span>,<span class="number">13</span>]]</span><br><span class="line">df2 = pd.DataFrame(data2,columns = [<span class="string">&#x27;Site&#x27;</span>,<span class="string">&#x27;Age&#x27;</span>],dtype = <span class="built_in">float</span>)</span><br><span class="line"><span class="built_in">print</span>(df2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">    <span class="number">0</span></span><br><span class="line"><span class="number">0</span>   <span class="number">6</span></span><br><span class="line"><span class="number">1</span>   <span class="number">7</span></span><br><span class="line"><span class="number">2</span>   <span class="number">8</span></span><br><span class="line"><span class="number">3</span>   <span class="number">9</span></span><br><span class="line"><span class="number">4</span>  <span class="number">10</span></span><br><span class="line">     Site   Age</span><br><span class="line"><span class="number">0</span>  Google  <span class="number">10.0</span></span><br><span class="line"><span class="number">1</span>  Runoob  <span class="number">12.0</span></span><br><span class="line"><span class="number">2</span>    Wiki  <span class="number">13.0</span></span><br></pre></td></tr></table></figure><p>（3）字典嵌套列表创建<code>DataFame</code>对象</p><p><code>dict</code>字典中，键对应的值的元素长度必须相同（也就是列表长度相同）。如果传递了索引，那么索引的长度应该等于数组的长度；如果没有传递索引，那么默认情况下，索引将是<code>range(n)</code>，其中n代表数组长度。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里使用了默认行标签，也就是range(n)。它生成了0,1,2,3，并分别对应了列表中的每个元素值</span></span><br><span class="line">data = &#123;<span class="string">&#x27;Site&#x27;</span>:[<span class="string">&#x27;Google&#x27;</span>, <span class="string">&#x27;Runoob&#x27;</span>, <span class="string">&#x27;Wiki&#x27;</span>], <span class="string">&#x27;Age&#x27;</span>:[<span class="number">10</span>, <span class="number">12</span>, <span class="number">13</span>]&#125;</span><br><span class="line">df = pd.DataFrame(data)</span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line"><span class="comment"># 添加自定义的行标签,index参数为每行分配了一个索引</span></span><br><span class="line">df2 = pd.DataFrame(data,index = [<span class="string">&#x27;one&#x27;</span>,<span class="string">&#x27;two&#x27;</span>,<span class="string">&#x27;three&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(df2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">     Site  Age</span><br><span class="line"><span class="number">0</span>  Google   <span class="number">10</span></span><br><span class="line"><span class="number">1</span>  Runoob   <span class="number">12</span></span><br><span class="line"><span class="number">2</span>    Wiki   <span class="number">13</span></span><br><span class="line">         Site  Age</span><br><span class="line">one    Google   <span class="number">10</span></span><br><span class="line">two    Runoob   <span class="number">12</span></span><br><span class="line">three    Wiki   <span class="number">13</span></span><br></pre></td></tr></table></figure><p>从以上输出结果可以知道， <code>DataFrame</code>数据类型一个表格，包含<code>rows</code>（行）和<code>columns</code>（列）。</p><p>（4）列表嵌套字典创建<code>DataFrame</code>对象</p><p>列表嵌套字典可以作为输入数据传递给<code>DataFrame</code>构造函数。默认情况下，字典的键被用作列名。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列表嵌套字典</span></span><br><span class="line">data1 = [&#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>&#125;, &#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">5</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">10</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">20</span>&#125;]</span><br><span class="line"><span class="comment"># 字典嵌套列表</span></span><br><span class="line">data2 = &#123;<span class="string">&#x27;a&#x27;</span>:[<span class="number">1</span>, <span class="number">5</span>], <span class="string">&#x27;b&#x27;</span>:[<span class="number">2</span>, <span class="number">10</span>], <span class="string">&#x27;c&#x27;</span>:[<span class="number">15</span>, <span class="number">20</span>]&#125;</span><br><span class="line">df1 = pd.DataFrame(data1)</span><br><span class="line"><span class="built_in">print</span>(df1)</span><br><span class="line">df2 = pd.DataFrame(data2)</span><br><span class="line"><span class="built_in">print</span>(df2)</span><br><span class="line"><span class="comment"># 添加行标签索引</span></span><br><span class="line">df3 = pd.DataFrame(data1,index = [<span class="string">&#x27;one&#x27;</span>,<span class="string">&#x27;two&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(df3)</span><br><span class="line"><span class="comment"># 行标签索引</span></span><br><span class="line"><span class="comment"># 注意：因为&#x27;abc&#x27;在字典键中不存在，所以对应值为NaN</span></span><br><span class="line">df4 = pd.DataFrame(data1,index = [<span class="string">&#x27;one&#x27;</span>,<span class="string">&#x27;two&#x27;</span>],columns = [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;abc&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(df4)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果，没有对应的部分数据为NaN。</span></span><br><span class="line">   a   b     c</span><br><span class="line"><span class="number">0</span>  <span class="number">1</span>   <span class="number">2</span>   NaN</span><br><span class="line"><span class="number">1</span>  <span class="number">5</span>  <span class="number">10</span>  <span class="number">20.0</span></span><br><span class="line">   a   b   c</span><br><span class="line"><span class="number">0</span>  <span class="number">1</span>   <span class="number">2</span>  <span class="number">15</span></span><br><span class="line"><span class="number">1</span>  <span class="number">5</span>  <span class="number">10</span>  <span class="number">20</span></span><br><span class="line">     a   b     c</span><br><span class="line">one  <span class="number">1</span>   <span class="number">2</span>   NaN</span><br><span class="line">two  <span class="number">5</span>  <span class="number">10</span>  <span class="number">20.0</span></span><br><span class="line">     a  abc</span><br><span class="line">one  <span class="number">1</span>  NaN</span><br><span class="line">two  <span class="number">5</span>  NaN</span><br></pre></td></tr></table></figure><p>（5）<code>Series</code>创建<code>DataFrame</code>对象</p><p>可以传递一个字典形式的<code>Series</code>，从而创建一个<code>DataFrame</code>对象，其输出结果的行索引是所有index的合集。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">d = &#123;<span class="string">&#x27;one&#x27;</span> : pd.Series([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], index = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]),</span><br><span class="line">   <span class="string">&#x27;two&#x27;</span> : pd.Series([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], index = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>])&#125;</span><br><span class="line">df = pd.DataFrame(d)</span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果，对于one列而言，此处虽然显示了行索引&#x27;d&#x27;，但由于没有与其对应的值，所以它的值为NaN</span></span><br><span class="line">   one  two</span><br><span class="line">a  <span class="number">1.0</span>    <span class="number">1</span></span><br><span class="line">b  <span class="number">2.0</span>    <span class="number">2</span></span><br><span class="line">c  <span class="number">3.0</span>    <span class="number">3</span></span><br><span class="line">d  NaN    <span class="number">4</span></span><br></pre></td></tr></table></figure><h3 id="列索引操作df对象">👀列索引操作DF对象</h3><p><code>DataFrame</code>可以使用列索（<code>columns index</code>）引来完成数据的选取、添加和删除操作。</p><p>（1）列索引选取数据列</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">data = &#123;</span><br><span class="line">  <span class="string">&quot;calories&quot;</span>: [<span class="number">420</span>, <span class="number">380</span>, <span class="number">390</span>],</span><br><span class="line">  <span class="string">&quot;duration&quot;</span>: [<span class="number">50</span>, <span class="number">40</span>, <span class="number">45</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 数据载入到DataFrame对象</span></span><br><span class="line">df = pd.DataFrame(data, index = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line"><span class="comment"># 返回第一列 </span></span><br><span class="line"><span class="built_in">print</span>(df[<span class="string">&#x27;calories&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">   calories  duration</span><br><span class="line">a       <span class="number">420</span>        <span class="number">50</span></span><br><span class="line">b       <span class="number">380</span>        <span class="number">40</span></span><br><span class="line">c       <span class="number">390</span>        <span class="number">45</span></span><br><span class="line">a    <span class="number">420</span></span><br><span class="line">b    <span class="number">380</span></span><br><span class="line">c    <span class="number">390</span></span><br><span class="line">Name: calories, dtype: int64</span><br></pre></td></tr></table></figure><p>（2）列索引添加数据列</p><p>使用<code>columns</code>列索引表标签可以实现添加新的数据列。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">data = &#123;</span><br><span class="line">  <span class="string">&quot;calories&quot;</span>: [<span class="number">420</span>, <span class="number">380</span>, <span class="number">390</span>],</span><br><span class="line">  <span class="string">&quot;duration&quot;</span>: [<span class="number">50</span>, <span class="number">40</span>, <span class="number">45</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 数据载入到DataFrame对象</span></span><br><span class="line">df = pd.DataFrame(data, index = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line"><span class="comment"># 返回第一列 </span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 使用df[&#x27;列&#x27;]=值，插入新的数据列</span></span><br><span class="line">df[<span class="string">&#x27;height&#x27;</span>] = pd.Series([<span class="number">160</span>,<span class="number">170</span>,<span class="number">180</span>], index = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 将已经存在的数据列做相加运算</span></span><br><span class="line">df[<span class="string">&#x27;sums&#x27;</span>] = df[<span class="string">&#x27;calories&#x27;</span>] + df[<span class="string">&#x27;duration&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">   calories  duration</span><br><span class="line">a       <span class="number">420</span>        <span class="number">50</span></span><br><span class="line">b       <span class="number">380</span>        <span class="number">40</span></span><br><span class="line">c       <span class="number">390</span>        <span class="number">45</span></span><br><span class="line">********************</span><br><span class="line">   calories  duration  height</span><br><span class="line">a       <span class="number">420</span>        <span class="number">50</span>     <span class="number">160</span></span><br><span class="line">b       <span class="number">380</span>        <span class="number">40</span>     <span class="number">170</span></span><br><span class="line">c       <span class="number">390</span>        <span class="number">45</span>     <span class="number">180</span></span><br><span class="line">********************</span><br><span class="line">   calories  duration  height  sums</span><br><span class="line">a       <span class="number">420</span>        <span class="number">50</span>     <span class="number">160</span>  <span class="number">470</span></span><br><span class="line">b       <span class="number">380</span>        <span class="number">40</span>     <span class="number">170</span>  <span class="number">420</span></span><br><span class="line">c       <span class="number">390</span>        <span class="number">45</span>     <span class="number">180</span>  <span class="number">435</span></span><br></pre></td></tr></table></figure><p>我们初次使用了<code>DataFrame</code>的算术运算，这和<code>NumPy</code>非常相似。除了使用<code>df[]=value</code>的方式外，您还可以使用<code>insert()</code>方法插入新的列.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">info = [[<span class="string">&#x27;Jack&#x27;</span>,<span class="number">18</span>],[<span class="string">&#x27;Helen&#x27;</span>,<span class="number">19</span>],[<span class="string">&#x27;John&#x27;</span>,<span class="number">17</span>]]</span><br><span class="line">df = pd.DataFrame(info,columns = [<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;age&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line"><span class="comment"># 注意是column参数</span></span><br><span class="line"><span class="comment"># 数值1代表插入到columns列表的索引位置</span></span><br><span class="line">df.insert(<span class="number">1</span>,column = <span class="string">&#x27;score&#x27;</span>,value = [<span class="number">91</span>,<span class="number">90</span>,<span class="number">75</span>])</span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">    name  age</span><br><span class="line"><span class="number">0</span>   Jack   <span class="number">18</span></span><br><span class="line"><span class="number">1</span>  Helen   <span class="number">19</span></span><br><span class="line"><span class="number">2</span>   John   <span class="number">17</span></span><br><span class="line">    name  score  age</span><br><span class="line"><span class="number">0</span>   Jack     <span class="number">91</span>   <span class="number">18</span></span><br><span class="line"><span class="number">1</span>  Helen     <span class="number">90</span>   <span class="number">19</span></span><br><span class="line"><span class="number">2</span>   John     <span class="number">75</span>   <span class="number">17</span></span><br></pre></td></tr></table></figure><p>（3）列索引删除数据列</p><p>通过<code>del</code>和<code>pop()</code>都能够删除<code>DataFrame</code>中的数据列。示例如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">d = &#123;<span class="string">&#x27;one&#x27;</span>: pd.Series([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], index = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]),</span><br><span class="line">   <span class="string">&#x27;two&#x27;</span>: pd.Series([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], index = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>]),</span><br><span class="line">   <span class="string">&#x27;three&#x27;</span>: pd.Series([<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>], index = [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>])&#125;</span><br><span class="line">df = pd.DataFrame(d)</span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 使用del删除</span></span><br><span class="line"><span class="keyword">del</span> df[<span class="string">&#x27;one&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 使用pop方法删除</span></span><br><span class="line">df.pop(<span class="string">&#x27;two&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">   one  two  three</span><br><span class="line">a  <span class="number">1.0</span>    <span class="number">1</span>   <span class="number">10.0</span></span><br><span class="line">b  <span class="number">2.0</span>    <span class="number">2</span>   <span class="number">20.0</span></span><br><span class="line">c  <span class="number">3.0</span>    <span class="number">3</span>   <span class="number">30.0</span></span><br><span class="line">d  NaN    <span class="number">4</span>    NaN</span><br><span class="line">********************</span><br><span class="line">   two  three</span><br><span class="line">a    <span class="number">1</span>   <span class="number">10.0</span></span><br><span class="line">b    <span class="number">2</span>   <span class="number">20.0</span></span><br><span class="line">c    <span class="number">3</span>   <span class="number">30.0</span></span><br><span class="line">d    <span class="number">4</span>    NaN</span><br><span class="line">********************</span><br><span class="line">   three</span><br><span class="line">a   <span class="number">10.0</span></span><br><span class="line">b   <span class="number">20.0</span></span><br><span class="line">c   <span class="number">30.0</span></span><br><span class="line">d    NaN</span><br></pre></td></tr></table></figure><h3 id="行索引操作df对象">👀行索引操作DF对象</h3><p><code>Pandas</code>可以使用<code>loc</code>函数返回指定行的数据，如果没有设置索引，第一行索引为0，第二行索引为1，以此类推。</p><p>（1）标签索引选取</p><p>通过将行标签传递给<code>loc</code>函数，来选取数据。</p><p><code>loc</code>允许接两个参数分别是行和列，参数之间需要使用“逗号”隔开，但该函数只能接收<strong>标签索引</strong>。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">data = &#123;</span><br><span class="line">  <span class="string">&quot;calories&quot;</span>: [<span class="number">420</span>, <span class="number">380</span>, <span class="number">390</span>],</span><br><span class="line">  <span class="string">&quot;duration&quot;</span>: [<span class="number">50</span>, <span class="number">40</span>, <span class="number">45</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 数据载入到 DataFrame 对象</span></span><br><span class="line">df = pd.DataFrame(data, index = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="built_in">print</span>(df.loc[<span class="string">&#x27;a&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">   calories  duration</span><br><span class="line">a       <span class="number">420</span>        <span class="number">50</span></span><br><span class="line">b       <span class="number">380</span>        <span class="number">40</span></span><br><span class="line">c       <span class="number">390</span>        <span class="number">45</span></span><br><span class="line">********************</span><br><span class="line">calories    <span class="number">420</span></span><br><span class="line">duration     <span class="number">50</span></span><br><span class="line">Name: a, dtype: int64</span><br></pre></td></tr></table></figure><p>（2）整数索引选取</p><p>通过将数据行所在的索引位置传递给<code>iloc</code>函数，也可以实现数据行选取。</p><p><code>iloc</code>允许接受两个参数分别是行和列，参数之间使用“逗号”隔开，但该函数只能接收<strong>整数索引</strong>。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">data = &#123;</span><br><span class="line">  <span class="string">&quot;calories&quot;</span>: [<span class="number">420</span>, <span class="number">380</span>, <span class="number">390</span>],</span><br><span class="line">  <span class="string">&quot;duration&quot;</span>: [<span class="number">50</span>, <span class="number">40</span>, <span class="number">45</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 数据载入到 DataFrame 对象</span></span><br><span class="line">df = pd.DataFrame(data, index = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 返回第一行，返回结果其实就是一个Pandas Series数据。</span></span><br><span class="line"><span class="built_in">print</span>(df.iloc[<span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 返回第二行，返回结果其实就是一个Pandas Series数据。</span></span><br><span class="line"><span class="built_in">print</span>(df.iloc[<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 也可以返回多行数据，使用[[ ... ]] 格式，... 为各行的索引，以逗号隔开：</span></span><br><span class="line"><span class="comment"># 返回第一行和第二行，返回结果其实就是一个Pandas DataFrame数据。</span></span><br><span class="line"><span class="built_in">print</span>(df.iloc[[<span class="number">0</span>, <span class="number">1</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">   calories  duration</span><br><span class="line">a       <span class="number">420</span>        <span class="number">50</span></span><br><span class="line">b       <span class="number">380</span>        <span class="number">40</span></span><br><span class="line">c       <span class="number">390</span>        <span class="number">45</span></span><br><span class="line">********************</span><br><span class="line">calories    <span class="number">420</span></span><br><span class="line">duration     <span class="number">50</span></span><br><span class="line">Name: a, dtype: int64</span><br><span class="line">********************</span><br><span class="line">calories    <span class="number">380</span></span><br><span class="line">duration     <span class="number">40</span></span><br><span class="line">Name: b, dtype: int64</span><br><span class="line">********************</span><br><span class="line">   calories  duration</span><br><span class="line">a       <span class="number">420</span>        <span class="number">50</span></span><br><span class="line">b       <span class="number">380</span>        <span class="number">40</span></span><br></pre></td></tr></table></figure><p>（3）切片操作多行数据</p><p>通过使用切片的方式同时选取多行。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">data = &#123;</span><br><span class="line">  <span class="string">&quot;calories&quot;</span>: [<span class="number">420</span>, <span class="number">380</span>, <span class="number">390</span>],</span><br><span class="line">  <span class="string">&quot;duration&quot;</span>: [<span class="number">50</span>, <span class="number">40</span>, <span class="number">45</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 数据载入到 DataFrame 对象</span></span><br><span class="line">df = pd.DataFrame(data, index = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 左闭右开</span></span><br><span class="line"><span class="built_in">print</span>(df[<span class="number">1</span>:<span class="number">3</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">   calories  duration</span><br><span class="line">a       <span class="number">420</span>        <span class="number">50</span></span><br><span class="line">b       <span class="number">380</span>        <span class="number">40</span></span><br><span class="line">c       <span class="number">390</span>        <span class="number">45</span></span><br><span class="line">********************</span><br><span class="line">   calories  duration</span><br><span class="line">b       <span class="number">380</span>        <span class="number">40</span></span><br><span class="line">c       <span class="number">390</span>        <span class="number">45</span></span><br></pre></td></tr></table></figure><p>（4）添加数据行</p><p>使用<code>append()</code>函数，可以将新的数据行添加到<code>DataFrame</code>中，该函数会在行末追加数据行。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">df = pd.DataFrame([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]], index = [<span class="string">&#x27;one&#x27;</span>,<span class="string">&#x27;two&#x27;</span>], columns = [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>])</span><br><span class="line">df2 = pd.DataFrame([[<span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>]], index = [<span class="string">&#x27;one&#x27;</span>,<span class="string">&#x27;two&#x27;</span>], columns = [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>])</span><br><span class="line"><span class="comment"># 在行末追加新数据行</span></span><br><span class="line">df = df.append(df2)</span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">     a  b</span><br><span class="line">one  <span class="number">1</span>  <span class="number">2</span></span><br><span class="line">two  <span class="number">3</span>  <span class="number">4</span></span><br><span class="line">one  <span class="number">5</span>  <span class="number">6</span></span><br><span class="line">two  <span class="number">7</span>  <span class="number">8</span></span><br></pre></td></tr></table></figure><p>（5）删除数据行</p><p>使用行索引标签，从<code>DataFrame</code>中删除某一行数据。如果索引标签存在重复，那么它们将被一起删除。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">df = pd.DataFrame([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]], index = [<span class="string">&#x27;one&#x27;</span>,<span class="string">&#x27;two&#x27;</span>], columns = [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>])</span><br><span class="line">df2 = pd.DataFrame([[<span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>]], index = [<span class="string">&#x27;one&#x27;</span>,<span class="string">&#x27;two&#x27;</span>], columns = [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>])</span><br><span class="line"><span class="comment"># 在行末追加新数据行</span></span><br><span class="line">df = df.append(df2)</span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 注意此处调用了drop()方法,drop(&#x27;one&#x27;)同时删除了两行数据</span></span><br><span class="line">df1 = df.drop(<span class="string">&#x27;one&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(df1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">     a  b</span><br><span class="line">one  <span class="number">1</span>  <span class="number">2</span></span><br><span class="line">two  <span class="number">3</span>  <span class="number">4</span></span><br><span class="line">one  <span class="number">5</span>  <span class="number">6</span></span><br><span class="line">two  <span class="number">7</span>  <span class="number">8</span></span><br><span class="line">********************</span><br><span class="line">     a  b</span><br><span class="line">two  <span class="number">3</span>  <span class="number">4</span></span><br><span class="line">two  <span class="number">7</span>  <span class="number">8</span></span><br></pre></td></tr></table></figure><h3 id="df对象属性和方法">👀DF对象属性和方法</h3><p><code>DataFrame</code>的属性和方法，与Series相差无几。</p><table><thead><tr class="header"><th>名称</th><th>属性方法描述</th></tr></thead><tbody><tr class="odd"><td><code>T</code></td><td>行和列转置</td></tr><tr class="even"><td><code>axes</code></td><td>返回一个仅以行轴标签和列轴标签为成员的列表</td></tr><tr class="odd"><td><code>dtypes</code></td><td>返回每列数据的数据类型</td></tr><tr class="even"><td><code>empty</code></td><td><code>DataFrame</code>中没有数据或者任意坐标轴的长度为0，则返回True</td></tr><tr class="odd"><td><code>ndim</code></td><td>轴的数量，也指数组的维数。</td></tr><tr class="even"><td><code>shape</code></td><td>返回一个元组，表示了<code>DataFrame</code>维度</td></tr><tr class="odd"><td><code>size</code></td><td><code>DataFrame</code>中的元素数量</td></tr><tr class="even"><td><code>values</code></td><td>使用<code>numpy</code>数组表示<code>DataFrame</code>中的元素值</td></tr><tr class="odd"><td><code>head()</code></td><td>返回前n行数据</td></tr><tr class="even"><td><code>tail()</code></td><td>返回后n行数据</td></tr><tr class="odd"><td><code>shift()</code></td><td>将行或列移动指定的步幅长度</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">d = &#123;<span class="string">&#x27;Name&#x27;</span>:pd.Series([<span class="string">&#x27;小汤&#x27;</span>,<span class="string">&#x27;小王&#x27;</span>,<span class="string">&quot;小明&quot;</span>,<span class="string">&#x27;小红&#x27;</span>,<span class="string">&#x27;小小&#x27;</span>,<span class="string">&#x27;小微&#x27;</span>,<span class="string">&#x27;小黄&#x27;</span>]),</span><br><span class="line">   <span class="string">&#x27;years&#x27;</span>:pd.Series([<span class="number">2005</span>,<span class="number">2006</span>,<span class="number">2015</span>,<span class="number">2008</span>,<span class="number">2003</span>,<span class="number">2009</span>,<span class="number">2003</span>]),</span><br><span class="line">   <span class="string">&#x27;height&#x27;</span>:pd.Series([<span class="number">180</span>,<span class="number">175</span>,<span class="number">178</span>,<span class="number">179</span>,<span class="number">176</span>,<span class="number">170</span>,<span class="number">173</span>])&#125;</span><br><span class="line"><span class="comment"># 构建DataFrame</span></span><br><span class="line">df = pd.DataFrame(d)</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># T（Transpose）转置,返回DataFrame的转置，也就是把行和列进行交换</span></span><br><span class="line"><span class="built_in">print</span>(df.T)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 返回一个行标签、列标签组成的列表</span></span><br><span class="line"><span class="built_in">print</span>(df.axes)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 返回每一列的数据类型</span></span><br><span class="line"><span class="built_in">print</span>(df.dtypes)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 返回一个布尔值，判断输出的数据对象是否为空，若为True表示对象为空</span></span><br><span class="line"><span class="built_in">print</span>(df.empty)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 返回数据对象的维数。DataFrame是一个二维数据结构</span></span><br><span class="line"><span class="built_in">print</span>(df.ndim)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 返回一个代表DataFrame维度的元组。返回值元组(a,b)，其中a表示行数，b表示列数</span></span><br><span class="line"><span class="built_in">print</span>(df.shape)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 返回DataFrame中的元素数量</span></span><br><span class="line"><span class="built_in">print</span>(df.size)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 以ndarray数组的形式返回DataFrame中的数据</span></span><br><span class="line"><span class="built_in">print</span>(df.values)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span>*<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">  Name  years  height</span><br><span class="line"><span class="number">0</span>   小汤   <span class="number">2005</span>     <span class="number">180</span></span><br><span class="line"><span class="number">1</span>   小王   <span class="number">2006</span>     <span class="number">175</span></span><br><span class="line"><span class="number">2</span>   小明   <span class="number">2015</span>     <span class="number">178</span></span><br><span class="line"><span class="number">3</span>   小红   <span class="number">2008</span>     <span class="number">179</span></span><br><span class="line"><span class="number">4</span>   小小   <span class="number">2003</span>     <span class="number">176</span></span><br><span class="line"><span class="number">5</span>   小微   <span class="number">2009</span>     <span class="number">170</span></span><br><span class="line"><span class="number">6</span>   小黄   <span class="number">2003</span>     <span class="number">173</span></span><br><span class="line">********************</span><br><span class="line">           <span class="number">0</span>     <span class="number">1</span>     <span class="number">2</span>     <span class="number">3</span>     <span class="number">4</span>     <span class="number">5</span>     <span class="number">6</span></span><br><span class="line">Name      小汤    小王    小明    小红    小小    小微    小黄</span><br><span class="line">years   <span class="number">2005</span>  <span class="number">2006</span>  <span class="number">2015</span>  <span class="number">2008</span>  <span class="number">2003</span>  <span class="number">2009</span>  <span class="number">2003</span></span><br><span class="line">height   <span class="number">180</span>   <span class="number">175</span>   <span class="number">178</span>   <span class="number">179</span>   <span class="number">176</span>   <span class="number">170</span>   <span class="number">173</span></span><br><span class="line">********************</span><br><span class="line">[RangeIndex(start=<span class="number">0</span>, stop=<span class="number">7</span>, step=<span class="number">1</span>), Index([<span class="string">&#x27;Name&#x27;</span>, <span class="string">&#x27;years&#x27;</span>, <span class="string">&#x27;height&#x27;</span>], dtype=<span class="string">&#x27;object&#x27;</span>)]</span><br><span class="line">********************</span><br><span class="line">Name      <span class="built_in">object</span></span><br><span class="line">years      int64</span><br><span class="line">height     int64</span><br><span class="line">dtype: <span class="built_in">object</span></span><br><span class="line">********************</span><br><span class="line"><span class="literal">False</span></span><br><span class="line">********************</span><br><span class="line"><span class="number">2</span></span><br><span class="line">********************</span><br><span class="line">(<span class="number">7</span>, <span class="number">3</span>)</span><br><span class="line">********************</span><br><span class="line"><span class="number">21</span></span><br><span class="line">********************</span><br><span class="line">[[<span class="string">&#x27;小汤&#x27;</span> <span class="number">2005</span> <span class="number">180</span>]</span><br><span class="line"> [<span class="string">&#x27;小王&#x27;</span> <span class="number">2006</span> <span class="number">175</span>]</span><br><span class="line"> [<span class="string">&#x27;小明&#x27;</span> <span class="number">2015</span> <span class="number">178</span>]</span><br><span class="line"> [<span class="string">&#x27;小红&#x27;</span> <span class="number">2008</span> <span class="number">179</span>]</span><br><span class="line"> [<span class="string">&#x27;小小&#x27;</span> <span class="number">2003</span> <span class="number">176</span>]</span><br><span class="line"> [<span class="string">&#x27;小微&#x27;</span> <span class="number">2009</span> <span class="number">170</span>]</span><br><span class="line"> [<span class="string">&#x27;小黄&#x27;</span> <span class="number">2003</span> <span class="number">173</span>]]</span><br><span class="line">********************</span><br></pre></td></tr></table></figure><p><code>head()</code>&amp;<code>tail()</code>查看数据。如果想要查看<code>DataFrame</code>的一部分数据，可以使用<code>head()</code>或者<code>tail()</code>方法。<code>head()</code>返回前n行数据，默认显示前5行数据。<code>tail()</code>返回后n行数据。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">d = &#123;<span class="string">&#x27;Name&#x27;</span>:pd.Series([<span class="string">&#x27;小汤&#x27;</span>,<span class="string">&#x27;小王&#x27;</span>,<span class="string">&quot;小明&quot;</span>,<span class="string">&#x27;小红&#x27;</span>,<span class="string">&#x27;小小&#x27;</span>,<span class="string">&#x27;小微&#x27;</span>,<span class="string">&#x27;小黄&#x27;</span>]),</span><br><span class="line">   <span class="string">&#x27;years&#x27;</span>:pd.Series([<span class="number">2005</span>,<span class="number">2006</span>,<span class="number">2015</span>,<span class="number">2008</span>,<span class="number">2003</span>,<span class="number">2009</span>,<span class="number">2003</span>]),</span><br><span class="line">   <span class="string">&#x27;height&#x27;</span>:pd.Series([<span class="number">180</span>,<span class="number">175</span>,<span class="number">178</span>,<span class="number">179</span>,<span class="number">176</span>,<span class="number">170</span>,<span class="number">173</span>])&#125;</span><br><span class="line"><span class="comment"># 构建DataFrame</span></span><br><span class="line">df = pd.DataFrame(d)</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 获取前3行数据</span></span><br><span class="line"><span class="built_in">print</span>(df.head(<span class="number">3</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 获取后2行数据</span></span><br><span class="line"><span class="built_in">print</span>(df.tail(<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">  Name  years  height</span><br><span class="line"><span class="number">0</span>   小汤   <span class="number">2005</span>     <span class="number">180</span></span><br><span class="line"><span class="number">1</span>   小王   <span class="number">2006</span>     <span class="number">175</span></span><br><span class="line"><span class="number">2</span>   小明   <span class="number">2015</span>     <span class="number">178</span></span><br><span class="line"><span class="number">3</span>   小红   <span class="number">2008</span>     <span class="number">179</span></span><br><span class="line"><span class="number">4</span>   小小   <span class="number">2003</span>     <span class="number">176</span></span><br><span class="line"><span class="number">5</span>   小微   <span class="number">2009</span>     <span class="number">170</span></span><br><span class="line"><span class="number">6</span>   小黄   <span class="number">2003</span>     <span class="number">173</span></span><br><span class="line">********************</span><br><span class="line">  Name  years  height</span><br><span class="line"><span class="number">0</span>   小汤   <span class="number">2005</span>     <span class="number">180</span></span><br><span class="line"><span class="number">1</span>   小王   <span class="number">2006</span>     <span class="number">175</span></span><br><span class="line"><span class="number">2</span>   小明   <span class="number">2015</span>     <span class="number">178</span></span><br><span class="line">********************</span><br><span class="line">  Name  years  height</span><br><span class="line"><span class="number">5</span>   小微   <span class="number">2009</span>     <span class="number">170</span></span><br><span class="line"><span class="number">6</span>   小黄   <span class="number">2003</span>     <span class="number">173</span></span><br></pre></td></tr></table></figure><p><code>shift()</code>移动行或列。如果您想要移动<code>DataFrame</code>中的某一行/列，可以使用<code>shift()</code>函数实现。它提供了一个<code>periods</code>参数，该参数表示在特定的轴上移动指定的步幅。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">DataFrame.shift(periods=<span class="number">1</span>, freq=<span class="literal">None</span>, axis=<span class="number">0</span>)  </span><br><span class="line">参数说明：</span><br><span class="line">    peroids类型为<span class="built_in">int</span>，表示移动的幅度，可以是正数，也可以是负数，默认值为<span class="number">1</span>。</span><br><span class="line">    freq日期偏移量，默认值为<span class="literal">None</span>，适用于时间序。取值为符合时间规则的字符串。</span><br><span class="line">    axis如果是<span class="number">0</span>或者<span class="string">&quot;index&quot;</span>表示上下移动，如果是<span class="number">1</span>或者<span class="string">&quot;columns&quot;</span>则会左右移动。</span><br><span class="line">    fill_value该参数用来填充缺失值。</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">d = &#123;<span class="string">&#x27;Name&#x27;</span>:pd.Series([<span class="string">&#x27;小汤&#x27;</span>,<span class="string">&#x27;小王&#x27;</span>,<span class="string">&quot;小明&quot;</span>,<span class="string">&#x27;小红&#x27;</span>,<span class="string">&#x27;小小&#x27;</span>,<span class="string">&#x27;小微&#x27;</span>,<span class="string">&#x27;小黄&#x27;</span>]),</span><br><span class="line">   <span class="string">&#x27;years&#x27;</span>:pd.Series([<span class="number">2005</span>,<span class="number">2006</span>,<span class="number">2015</span>,<span class="number">2008</span>,<span class="number">2003</span>,<span class="number">2009</span>,<span class="number">2003</span>]),</span><br><span class="line">   <span class="string">&#x27;height&#x27;</span>:pd.Series([<span class="number">180</span>,<span class="number">175</span>,<span class="number">178</span>,<span class="number">179</span>,<span class="number">176</span>,<span class="number">170</span>,<span class="number">173</span>])&#125;</span><br><span class="line"><span class="comment"># 构建DataFrame</span></span><br><span class="line">df = pd.DataFrame(d)</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 移动幅度为3</span></span><br><span class="line"><span class="built_in">print</span>(df.shift(periods=<span class="number">3</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 使用fill_value参数填充DataFrame中的缺失值</span></span><br><span class="line"><span class="built_in">print</span>(df.shift(periods=<span class="number">3</span>,fill_value=<span class="number">52</span>)) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="built_in">print</span>(df.shift(periods=<span class="number">3</span>,axis=<span class="number">1</span>,fill_value=<span class="number">52</span>)) </span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">  Name  years  height</span><br><span class="line"><span class="number">0</span>   小汤   <span class="number">2005</span>     <span class="number">180</span></span><br><span class="line"><span class="number">1</span>   小王   <span class="number">2006</span>     <span class="number">175</span></span><br><span class="line"><span class="number">2</span>   小明   <span class="number">2015</span>     <span class="number">178</span></span><br><span class="line"><span class="number">3</span>   小红   <span class="number">2008</span>     <span class="number">179</span></span><br><span class="line"><span class="number">4</span>   小小   <span class="number">2003</span>     <span class="number">176</span></span><br><span class="line"><span class="number">5</span>   小微   <span class="number">2009</span>     <span class="number">170</span></span><br><span class="line"><span class="number">6</span>   小黄   <span class="number">2003</span>     <span class="number">173</span></span><br><span class="line">********************</span><br><span class="line">  Name   years  height</span><br><span class="line"><span class="number">0</span>  NaN     NaN     NaN</span><br><span class="line"><span class="number">1</span>  NaN     NaN     NaN</span><br><span class="line"><span class="number">2</span>  NaN     NaN     NaN</span><br><span class="line"><span class="number">3</span>   小汤  <span class="number">2005.0</span>   <span class="number">180.0</span></span><br><span class="line"><span class="number">4</span>   小王  <span class="number">2006.0</span>   <span class="number">175.0</span></span><br><span class="line"><span class="number">5</span>   小明  <span class="number">2015.0</span>   <span class="number">178.0</span></span><br><span class="line"><span class="number">6</span>   小红  <span class="number">2008.0</span>   <span class="number">179.0</span></span><br><span class="line">********************</span><br><span class="line">  Name  years  height</span><br><span class="line"><span class="number">0</span>   <span class="number">52</span>     <span class="number">52</span>      <span class="number">52</span></span><br><span class="line"><span class="number">1</span>   <span class="number">52</span>     <span class="number">52</span>      <span class="number">52</span></span><br><span class="line"><span class="number">2</span>   <span class="number">52</span>     <span class="number">52</span>      <span class="number">52</span></span><br><span class="line"><span class="number">3</span>   小汤   <span class="number">2005</span>     <span class="number">180</span></span><br><span class="line"><span class="number">4</span>   小王   <span class="number">2006</span>     <span class="number">175</span></span><br><span class="line"><span class="number">5</span>   小明   <span class="number">2015</span>     <span class="number">178</span></span><br><span class="line"><span class="number">6</span>   小红   <span class="number">2008</span>     <span class="number">179</span></span><br><span class="line">********************</span><br><span class="line">  Name  years  height</span><br><span class="line"><span class="number">0</span>   <span class="number">52</span>     <span class="number">52</span>      <span class="number">52</span></span><br><span class="line"><span class="number">1</span>   <span class="number">52</span>     <span class="number">52</span>      <span class="number">52</span></span><br><span class="line"><span class="number">2</span>   <span class="number">52</span>     <span class="number">52</span>      <span class="number">52</span></span><br><span class="line"><span class="number">3</span>   <span class="number">52</span>     <span class="number">52</span>      <span class="number">52</span></span><br><span class="line"><span class="number">4</span>   <span class="number">52</span>     <span class="number">52</span>      <span class="number">52</span></span><br><span class="line"><span class="number">5</span>   <span class="number">52</span>     <span class="number">52</span>      <span class="number">52</span></span><br><span class="line"><span class="number">6</span>   <span class="number">52</span>     <span class="number">52</span>      <span class="number">52</span></span><br></pre></td></tr></table></figure><h2 id="pandas函数操作">⛄Pandas函数操作</h2><h3 id="panel结构了解">👀Panel结构（了解）</h3><p><code>Panel</code>是一个用来承载数据的三维数据结构，它有三个轴，分别是<code>items</code>（0轴），<code>major_axis</code>（1轴），而 <code>minor_axis</code>（2轴）。这三个轴为描述、操作<code>Panel</code>提供了支持，其作用介绍如下：</p><ul><li><code>items</code>：axis =0，Panel 中的每个<code>items</code>都对应一个<code>DataFrame</code>。</li><li><code>major_axis</code>：axis=1，用来描述每个<code>DataFrame</code>的行索引。</li><li><code>minor_axis</code>：axis=2，用来描述每个<code>DataFrame</code>的列索引。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pandas.Panel(data, items, major_axis, minor_axis, dtype, copy)</span><br><span class="line">参数说明：</span><br><span class="line">    data输入数据，可以是 ndarray，Series，列表，字典，或者 DataFrame。</span><br><span class="line">    itemsaxis=<span class="number">0</span></span><br><span class="line">    major_axisaxis=<span class="number">1</span></span><br><span class="line">    minor_axisaxis=<span class="number">2</span></span><br><span class="line">    dtype每一列的数据类型。</span><br><span class="line">    copy默认为 <span class="literal">False</span>，表示是否复制数据。</span><br></pre></td></tr></table></figure><blockquote><p>自<code>Pandas 0.25</code>版本后， <code>Panel</code>结构已经被废弃。</p></blockquote><h3 id="描述性统计函数">👀描述性统计函数</h3><table><thead><tr class="header"><th>函数名称</th><th>描述说明</th></tr></thead><tbody><tr class="odd"><td><code>count()</code></td><td>统计某个非空值的数量</td></tr><tr class="even"><td><code>sum()</code></td><td>求和</td></tr><tr class="odd"><td><code>mean()</code></td><td>求均值</td></tr><tr class="even"><td><code>median()</code></td><td>求中位数</td></tr><tr class="odd"><td><code>mode()</code></td><td>求众数</td></tr><tr class="even"><td><code>std()</code></td><td>求标准差</td></tr><tr class="odd"><td><code>min()</code></td><td>求最小值</td></tr><tr class="even"><td><code>max()</code></td><td>求最大值</td></tr><tr class="odd"><td><code>abs()</code></td><td>求绝对值</td></tr><tr class="even"><td><code>prod()</code></td><td>求所有数值的乘积</td></tr><tr class="odd"><td><code>cumsum()</code></td><td>计算累计和，axis=0，按照行累加；axis=1，按照列累加</td></tr><tr class="even"><td><code>cumprod()</code></td><td>计算累计积，axis=0，按照行累积；axis=1，按照列累积</td></tr><tr class="odd"><td><code>corr()</code></td><td>计算数列或变量之间的相关系数，取值-1到1，值越大表示关联性越强</td></tr><tr class="even"><td><code>describe()</code></td><td>显示与DataFrame数据列相关的统计信息摘要</td></tr></tbody></table><p>在<code>DataFrame</code>中，使用聚合类方法时需要指定轴(<code>axis</code>)参数。下面介绍两种传参方式：</p><ul><li>对行操作，默认使用<code>axis=0</code>或者使用 "<code>index</code>"；</li><li>对列操作，默认使用<code>axis=1</code>或者使用 "<code>columns</code>"。</li><li><code>axis=0</code>表示按垂直方向进行计算，而<code>axis=1</code>则表示按水平方向。</li></ul><p><code>describe()</code>函数输出了平均值、<code>std</code>和<code>IQR</code>值(四分位距)等一系列统计信息。通过<code>describe()</code>提供的<code>include</code>能够筛选字符列或者数字列的摘要信息。<code>include</code>相关参数值说明如下：</p><ul><li><code>object</code>： 表示对字符列进行统计信息描述；</li><li><code>number</code>：表示对数字列进行统计信息描述；</li><li><code>all</code>：汇总所有列的统计信息。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">d = &#123;<span class="string">&#x27;Name&#x27;</span>:pd.Series([<span class="string">&#x27;小汤&#x27;</span>,<span class="string">&#x27;小王&#x27;</span>,<span class="string">&quot;小明&quot;</span>,<span class="string">&#x27;小红&#x27;</span>,<span class="string">&#x27;小小&#x27;</span>,<span class="string">&#x27;小微&#x27;</span>,<span class="string">&#x27;小黄&#x27;</span>]),</span><br><span class="line">   <span class="string">&#x27;years&#x27;</span>:pd.Series([<span class="number">2005</span>,<span class="number">2006</span>,<span class="number">2015</span>,<span class="number">2008</span>,<span class="number">2003</span>,<span class="number">2009</span>,<span class="number">2003</span>]),</span><br><span class="line">   <span class="string">&#x27;height&#x27;</span>:pd.Series([<span class="number">180</span>,<span class="number">175</span>,<span class="number">178</span>,<span class="number">179</span>,<span class="number">176</span>,<span class="number">170</span>,<span class="number">173</span>])&#125;</span><br><span class="line"><span class="comment"># 构建DataFrame</span></span><br><span class="line">df = pd.DataFrame(d)</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 求出数据的所有描述信息</span></span><br><span class="line"><span class="built_in">print</span>(df.describe())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="built_in">print</span>(df.describe(include=[<span class="string">&quot;object&quot;</span>]))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="built_in">print</span>(df.describe(include=<span class="string">&quot;all&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">  Name  years  height</span><br><span class="line"><span class="number">0</span>   小汤   <span class="number">2005</span>     <span class="number">180</span></span><br><span class="line"><span class="number">1</span>   小王   <span class="number">2006</span>     <span class="number">175</span></span><br><span class="line"><span class="number">2</span>   小明   <span class="number">2015</span>     <span class="number">178</span></span><br><span class="line"><span class="number">3</span>   小红   <span class="number">2008</span>     <span class="number">179</span></span><br><span class="line"><span class="number">4</span>   小小   <span class="number">2003</span>     <span class="number">176</span></span><br><span class="line"><span class="number">5</span>   小微   <span class="number">2009</span>     <span class="number">170</span></span><br><span class="line"><span class="number">6</span>   小黄   <span class="number">2003</span>     <span class="number">173</span></span><br><span class="line">********************</span><br><span class="line">             years      height</span><br><span class="line">count     <span class="number">7.000000</span>    <span class="number">7.000000</span></span><br><span class="line">mean   <span class="number">2007.000000</span>  <span class="number">175.857143</span></span><br><span class="line">std       <span class="number">4.203173</span>    <span class="number">3.532165</span></span><br><span class="line"><span class="built_in">min</span>    <span class="number">2003.000000</span>  <span class="number">170.000000</span></span><br><span class="line"><span class="number">25</span>%    <span class="number">2004.000000</span>  <span class="number">174.000000</span></span><br><span class="line"><span class="number">50</span>%    <span class="number">2006.000000</span>  <span class="number">176.000000</span></span><br><span class="line"><span class="number">75</span>%    <span class="number">2008.500000</span>  <span class="number">178.500000</span></span><br><span class="line"><span class="built_in">max</span>    <span class="number">2015.000000</span>  <span class="number">180.000000</span></span><br><span class="line">********************</span><br><span class="line">       Name</span><br><span class="line">count     <span class="number">7</span></span><br><span class="line">unique    <span class="number">7</span></span><br><span class="line">top      小汤</span><br><span class="line">freq      <span class="number">1</span></span><br><span class="line">********************</span><br><span class="line">       Name        years      height</span><br><span class="line">count     <span class="number">7</span>     <span class="number">7.000000</span>    <span class="number">7.000000</span></span><br><span class="line">unique    <span class="number">7</span>          NaN         NaN</span><br><span class="line">top      小汤          NaN         NaN</span><br><span class="line">freq      <span class="number">1</span>          NaN         NaN</span><br><span class="line">mean    NaN  <span class="number">2007.000000</span>  <span class="number">175.857143</span></span><br><span class="line">std     NaN     <span class="number">4.203173</span>    <span class="number">3.532165</span></span><br><span class="line"><span class="built_in">min</span>     NaN  <span class="number">2003.000000</span>  <span class="number">170.000000</span></span><br><span class="line"><span class="number">25</span>%     NaN  <span class="number">2004.000000</span>  <span class="number">174.000000</span></span><br><span class="line"><span class="number">50</span>%     NaN  <span class="number">2006.000000</span>  <span class="number">176.000000</span></span><br><span class="line"><span class="number">75</span>%     NaN  <span class="number">2008.500000</span>  <span class="number">178.500000</span></span><br><span class="line"><span class="built_in">max</span>     NaN  <span class="number">2015.000000</span>  <span class="number">180.000000</span></span><br></pre></td></tr></table></figure><h3 id="自定义函数">👀自定义函数</h3><p>如果想要应用自定义的函数，或者把其他库中的函数应用到Pandas对象中，有以下三种方法：</p><ul><li>操作整个<code>DataFrame</code>的函数：<code>pipe()</code></li><li>操作行或者列的函数：<code>apply()</code></li><li>操作单一元素的函数：<code>applymap()</code></li></ul><p>（1）操作整个数据表</p><p>通过给<code>pipe()</code>函数传递一个自定义函数和适当数量的参数值，从而操作<code>DataFrme</code>中的所有元素。下面示例，实现了数据表中的元素值依次加 6。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment"># 自定义函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">addsum</span>(<span class="params">a1,a2</span>):</span><br><span class="line">   <span class="keyword">return</span> a1 + a2</span><br><span class="line"><span class="comment"># 操作DataFrame</span></span><br><span class="line">df = pd.DataFrame([[<span class="number">120</span>,<span class="number">130</span>,<span class="number">150</span>],[<span class="number">90</span>,<span class="number">100</span>,<span class="number">110</span>],[<span class="number">60</span>,<span class="number">70</span>,<span class="number">80</span>]],columns=[<span class="string">&#x27;c1&#x27;</span>,<span class="string">&#x27;c2&#x27;</span>,<span class="string">&#x27;c3&#x27;</span>])</span><br><span class="line"><span class="comment"># 相加前</span></span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line"><span class="comment"># 相加后</span></span><br><span class="line"><span class="built_in">print</span>(df.pipe(addsum,<span class="number">6</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">    c1   c2   c3</span><br><span class="line"><span class="number">0</span>  <span class="number">120</span>  <span class="number">130</span>  <span class="number">150</span></span><br><span class="line"><span class="number">1</span>   <span class="number">90</span>  <span class="number">100</span>  <span class="number">110</span></span><br><span class="line"><span class="number">2</span>   <span class="number">60</span>   <span class="number">70</span>   <span class="number">80</span></span><br><span class="line">    c1   c2   c3</span><br><span class="line"><span class="number">0</span>  <span class="number">126</span>  <span class="number">136</span>  <span class="number">156</span></span><br><span class="line"><span class="number">1</span>   <span class="number">96</span>  <span class="number">106</span>  <span class="number">116</span></span><br><span class="line"><span class="number">2</span>   <span class="number">66</span>   <span class="number">76</span>   <span class="number">86</span></span><br></pre></td></tr></table></figure><p>（2）操作行或列</p><p>如果要操作<code>DataFrame</code>的某一行或者某一列，可以使用<code>apply()</code>方法，该方法与描述性统计方法类似，都有可选参数<code>axis</code>，并且默认按列操作。示例如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment"># 操作DataFrame</span></span><br><span class="line">df = pd.DataFrame([[<span class="number">120</span>,<span class="number">130</span>,<span class="number">150</span>],[<span class="number">90</span>,<span class="number">100</span>,<span class="number">110</span>],[<span class="number">60</span>,<span class="number">70</span>,<span class="number">80</span>]],columns=[<span class="string">&#x27;c1&#x27;</span>,<span class="string">&#x27;c2&#x27;</span>,<span class="string">&#x27;c3&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 默认按列操作，计算每一列均值</span></span><br><span class="line"><span class="built_in">print</span>(df.apply(np.mean))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 传递轴参axis=1，表示逐行进行操作</span></span><br><span class="line"><span class="built_in">print</span>(df.apply(np.mean,axis=<span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 求每一列中，最大值与最小值之差</span></span><br><span class="line"><span class="built_in">print</span>(df.apply(<span class="keyword">lambda</span> x: x.<span class="built_in">max</span>() - x.<span class="built_in">min</span>()))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">    c1   c2   c3</span><br><span class="line"><span class="number">0</span>  <span class="number">120</span>  <span class="number">130</span>  <span class="number">150</span></span><br><span class="line"><span class="number">1</span>   <span class="number">90</span>  <span class="number">100</span>  <span class="number">110</span></span><br><span class="line"><span class="number">2</span>   <span class="number">60</span>   <span class="number">70</span>   <span class="number">80</span></span><br><span class="line">********************</span><br><span class="line">c1     <span class="number">90.000000</span></span><br><span class="line">c2    <span class="number">100.000000</span></span><br><span class="line">c3    <span class="number">113.333333</span></span><br><span class="line">dtype: float64</span><br><span class="line">********************</span><br><span class="line"><span class="number">0</span>    <span class="number">133.333333</span></span><br><span class="line"><span class="number">1</span>    <span class="number">100.000000</span></span><br><span class="line"><span class="number">2</span>     <span class="number">70.000000</span></span><br><span class="line">dtype: float64</span><br><span class="line">********************</span><br><span class="line">c1    <span class="number">60</span></span><br><span class="line">c2    <span class="number">60</span></span><br><span class="line">c3    <span class="number">70</span></span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure><p>（3）操作单一元素</p><p><code>DataFrame</code>数据表结构的<code>applymap()</code>和<code>Series</code>系列结构的<code>map()</code>类似，它们都可以接受一个<code>Python</code>函数，并返回相应的值。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="comment"># 操作DataFrame</span></span><br><span class="line">df = pd.DataFrame([[<span class="number">120</span>,<span class="number">130</span>,<span class="number">150</span>],[<span class="number">90</span>,<span class="number">100</span>,<span class="number">110</span>],[<span class="number">60</span>,<span class="number">70</span>,<span class="number">80</span>]],columns=[<span class="string">&#x27;c1&#x27;</span>,<span class="string">&#x27;c2&#x27;</span>,<span class="string">&#x27;c3&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 自定义函数lambda函数</span></span><br><span class="line"><span class="built_in">print</span>(df[<span class="string">&#x27;c1&#x27;</span>].<span class="built_in">map</span>(<span class="keyword">lambda</span> x:x*<span class="number">10</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 使用了applymap()函数</span></span><br><span class="line"><span class="built_in">print</span>(df.applymap(<span class="keyword">lambda</span> x:x*<span class="number">10</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">    c1   c2   c3</span><br><span class="line"><span class="number">0</span>  <span class="number">120</span>  <span class="number">130</span>  <span class="number">150</span></span><br><span class="line"><span class="number">1</span>   <span class="number">90</span>  <span class="number">100</span>  <span class="number">110</span></span><br><span class="line"><span class="number">2</span>   <span class="number">60</span>   <span class="number">70</span>   <span class="number">80</span></span><br><span class="line">********************</span><br><span class="line"><span class="number">0</span>    <span class="number">1200</span></span><br><span class="line"><span class="number">1</span>     <span class="number">900</span></span><br><span class="line"><span class="number">2</span>     <span class="number">600</span></span><br><span class="line">Name: c1, dtype: int64</span><br><span class="line">********************</span><br><span class="line">     c1    c2    c3</span><br><span class="line"><span class="number">0</span>  <span class="number">1200</span>  <span class="number">1300</span>  <span class="number">1500</span></span><br><span class="line"><span class="number">1</span>   <span class="number">900</span>  <span class="number">1000</span>  <span class="number">1100</span></span><br><span class="line"><span class="number">2</span>   <span class="number">600</span>   <span class="number">700</span>   <span class="number">800</span></span><br></pre></td></tr></table></figure><h3 id="reindex重置索引">👀reindex重置索引</h3><p>重置索引（<code>reindex</code>）可以更改原<code>DataFrame</code>的行标签或列标签，并使更改后的行、列标签与<code>DataFrame</code>中的数据逐一匹配。通过重置索引操作，您可以完成对现有数据的重新排序。如果重置的索引标签在原<code>DataFrame</code>中不存在，那么该标签对应的元素值将全部填充为<code>NaN</code>。</p><p>（1）重置行列标签</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="comment"># 操作DataFrame</span></span><br><span class="line">df = pd.DataFrame([[<span class="number">120</span>,<span class="number">130</span>,<span class="number">150</span>],[<span class="number">90</span>,<span class="number">100</span>,<span class="number">110</span>],[<span class="number">60</span>,<span class="number">70</span>,<span class="number">80</span>]],columns=[<span class="string">&#x27;c1&#x27;</span>,<span class="string">&#x27;c2&#x27;</span>,<span class="string">&#x27;c3&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 重置行、列索引标签</span></span><br><span class="line">df_reindexed = df.reindex(index=[<span class="number">0</span>,<span class="number">1</span>], columns=[<span class="string">&#x27;c1&#x27;</span>, <span class="string">&#x27;c3&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(df_reindexed)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">    c1   c2   c3</span><br><span class="line"><span class="number">0</span>  <span class="number">120</span>  <span class="number">130</span>  <span class="number">150</span></span><br><span class="line"><span class="number">1</span>   <span class="number">90</span>  <span class="number">100</span>  <span class="number">110</span></span><br><span class="line"><span class="number">2</span>   <span class="number">60</span>   <span class="number">70</span>   <span class="number">80</span></span><br><span class="line">********************</span><br><span class="line">    c1   c3</span><br><span class="line"><span class="number">0</span>  <span class="number">120</span>  <span class="number">150</span></span><br><span class="line"><span class="number">1</span>   <span class="number">90</span>  <span class="number">110</span></span><br></pre></td></tr></table></figure><p>现有a、b两个<code>DataFrame</code>对象，如果想让a的行索引与b相同，您可以使用<code>reindex_like()</code> 方法。示例如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = pd.DataFrame(np.random.randn(<span class="number">10</span>,<span class="number">3</span>),columns=[<span class="string">&#x27;col1&#x27;</span>,<span class="string">&#x27;col2&#x27;</span>,<span class="string">&#x27;col3&#x27;</span>])</span><br><span class="line">b = pd.DataFrame(np.random.randn(<span class="number">7</span>,<span class="number">3</span>),columns=[<span class="string">&#x27;col1&#x27;</span>,<span class="string">&#x27;col2&#x27;</span>,<span class="string">&#x27;col3&#x27;</span>])</span><br><span class="line"><span class="comment"># a会按照b的形式重建行索引。需要特别注意的是，a与b的列索引标签必须相同。</span></span><br><span class="line">a= a.reindex_like(b)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">       col1      col2      col3</span><br><span class="line"><span class="number">0</span>  <span class="number">0.669617</span>  <span class="number">0.010243</span> -<span class="number">0.091776</span></span><br><span class="line"><span class="number">1</span> -<span class="number">0.333395</span> -<span class="number">1.521432</span>  <span class="number">0.292087</span></span><br><span class="line"><span class="number">2</span> -<span class="number">0.174709</span> -<span class="number">0.623413</span>  <span class="number">1.291384</span></span><br><span class="line"><span class="number">3</span>  <span class="number">1.033132</span> -<span class="number">0.383137</span>  <span class="number">1.280788</span></span><br><span class="line"><span class="number">4</span>  <span class="number">1.052466</span> -<span class="number">1.326848</span> -<span class="number">1.390581</span></span><br><span class="line"><span class="number">5</span>  <span class="number">1.828058</span>  <span class="number">0.422678</span> -<span class="number">0.734622</span></span><br><span class="line"><span class="number">6</span>  <span class="number">0.988210</span> -<span class="number">1.047092</span> -<span class="number">1.959839</span></span><br></pre></td></tr></table></figure><p>（2）填充元素值</p><p><code>reindex_like()</code>提供了一个可选的参数<code>method</code>，使用它来填充相应的元素值，参数值介绍如下：</p><ul><li><code>pad/ffill</code>：向前填充值；</li><li><code>bfill/backfill</code>：向后填充值；</li><li><code>nearest</code>：从距离最近的索引值开始填充。</li></ul><p><code>reindex_like()</code>还提供了一个额外参数<code>limit</code>，该参数用来控制填充的最大行数。示例如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">df1 = pd.DataFrame(np.random.randn(<span class="number">6</span>,<span class="number">3</span>),columns=[<span class="string">&#x27;col1&#x27;</span>,<span class="string">&#x27;col2&#x27;</span>,<span class="string">&#x27;col3&#x27;</span>])</span><br><span class="line">df2 = pd.DataFrame(np.random.randn(<span class="number">2</span>,<span class="number">3</span>),columns=[<span class="string">&#x27;col1&#x27;</span>,<span class="string">&#x27;col2&#x27;</span>,<span class="string">&#x27;col3&#x27;</span>])</span><br><span class="line"><span class="comment"># 使df2和df1行标签相同</span></span><br><span class="line"><span class="built_in">print</span>(df2.reindex_like(df1))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 向前填充</span></span><br><span class="line"><span class="built_in">print</span>(df2.reindex_like(df1,method=<span class="string">&#x27;ffill&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 向后填充</span></span><br><span class="line"><span class="built_in">print</span>(df2.reindex_like(df1,method=<span class="string">&#x27;backfill&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># limit限制填充行数</span></span><br><span class="line"><span class="built_in">print</span>(df2.reindex_like(df1,method=<span class="string">&#x27;ffill&#x27;</span>,limit=<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">       col1      col2      col3</span><br><span class="line"><span class="number">0</span>  <span class="number">0.552991</span>  <span class="number">1.230408</span>  <span class="number">0.403586</span></span><br><span class="line"><span class="number">1</span> -<span class="number">0.135228</span>  <span class="number">1.065911</span> -<span class="number">0.624843</span></span><br><span class="line"><span class="number">2</span>       NaN       NaN       NaN</span><br><span class="line"><span class="number">3</span>       NaN       NaN       NaN</span><br><span class="line"><span class="number">4</span>       NaN       NaN       NaN</span><br><span class="line"><span class="number">5</span>       NaN       NaN       NaN</span><br><span class="line">********************</span><br><span class="line">       col1      col2      col3</span><br><span class="line"><span class="number">0</span>  <span class="number">0.552991</span>  <span class="number">1.230408</span>  <span class="number">0.403586</span></span><br><span class="line"><span class="number">1</span> -<span class="number">0.135228</span>  <span class="number">1.065911</span> -<span class="number">0.624843</span></span><br><span class="line"><span class="number">2</span> -<span class="number">0.135228</span>  <span class="number">1.065911</span> -<span class="number">0.624843</span></span><br><span class="line"><span class="number">3</span> -<span class="number">0.135228</span>  <span class="number">1.065911</span> -<span class="number">0.624843</span></span><br><span class="line"><span class="number">4</span> -<span class="number">0.135228</span>  <span class="number">1.065911</span> -<span class="number">0.624843</span></span><br><span class="line"><span class="number">5</span> -<span class="number">0.135228</span>  <span class="number">1.065911</span> -<span class="number">0.624843</span></span><br><span class="line">********************</span><br><span class="line">       col1      col2      col3</span><br><span class="line"><span class="number">0</span>  <span class="number">0.552991</span>  <span class="number">1.230408</span>  <span class="number">0.403586</span></span><br><span class="line"><span class="number">1</span> -<span class="number">0.135228</span>  <span class="number">1.065911</span> -<span class="number">0.624843</span></span><br><span class="line"><span class="number">2</span>       NaN       NaN       NaN</span><br><span class="line"><span class="number">3</span>       NaN       NaN       NaN</span><br><span class="line"><span class="number">4</span>       NaN       NaN       NaN</span><br><span class="line"><span class="number">5</span>       NaN       NaN       NaN</span><br><span class="line">********************</span><br><span class="line">       col1      col2      col3</span><br><span class="line"><span class="number">0</span>  <span class="number">0.552991</span>  <span class="number">1.230408</span>  <span class="number">0.403586</span></span><br><span class="line"><span class="number">1</span> -<span class="number">0.135228</span>  <span class="number">1.065911</span> -<span class="number">0.624843</span></span><br><span class="line"><span class="number">2</span> -<span class="number">0.135228</span>  <span class="number">1.065911</span> -<span class="number">0.624843</span></span><br><span class="line"><span class="number">3</span> -<span class="number">0.135228</span>  <span class="number">1.065911</span> -<span class="number">0.624843</span></span><br><span class="line"><span class="number">4</span>       NaN       NaN       NaN</span><br><span class="line"><span class="number">5</span>       NaN       NaN       NaN</span><br></pre></td></tr></table></figure><p>（3）重命名标签</p><p><code>rename()</code>方法允许您使用某些映射(<code>dict</code>或<code>Series</code>)或任意函数来对行、列标签重新命名，示例如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="comment"># 操作DataFrame</span></span><br><span class="line">df = pd.DataFrame([[<span class="number">120</span>,<span class="number">130</span>,<span class="number">150</span>],[<span class="number">90</span>,<span class="number">100</span>,<span class="number">110</span>],[<span class="number">60</span>,<span class="number">70</span>,<span class="number">80</span>]],columns=[<span class="string">&#x27;c1&#x27;</span>,<span class="string">&#x27;c2&#x27;</span>,<span class="string">&#x27;c3&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 对行和列重新命名</span></span><br><span class="line"><span class="built_in">print</span>(df.rename(columns=&#123;<span class="string">&#x27;c1&#x27;</span>:<span class="string">&#x27;cc1&#x27;</span>,<span class="string">&#x27;c2&#x27;</span>:<span class="string">&#x27;cc2&#x27;</span>&#125;,index = &#123;<span class="number">0</span>:<span class="string">&#x27;one&#x27;</span>,<span class="number">1</span>:<span class="string">&#x27;two&#x27;</span>,<span class="number">2</span>:<span class="string">&#x27;three&#x27;</span>&#125;))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">    c1   c2   c3</span><br><span class="line"><span class="number">0</span>  <span class="number">120</span>  <span class="number">130</span>  <span class="number">150</span></span><br><span class="line"><span class="number">1</span>   <span class="number">90</span>  <span class="number">100</span>  <span class="number">110</span></span><br><span class="line"><span class="number">2</span>   <span class="number">60</span>   <span class="number">70</span>   <span class="number">80</span></span><br><span class="line">********************</span><br><span class="line">       cc1  cc2   c3</span><br><span class="line">one    <span class="number">120</span>  <span class="number">130</span>  <span class="number">150</span></span><br><span class="line">two     <span class="number">90</span>  <span class="number">100</span>  <span class="number">110</span></span><br><span class="line">three   <span class="number">60</span>   <span class="number">70</span>   <span class="number">80</span></span><br></pre></td></tr></table></figure><blockquote><p><code>rename()</code>方法提供了一个<code>inplace</code>参数，默认值为<code>False</code>，表示拷贝一份原数据，并在复制后的数据上做重命名操作。若<code>inplace=True</code>则表示在原数据的基础上重命名。</p></blockquote><h3 id="iteration遍历操作">👀iteration遍历操作</h3><p><code>Pandas</code>是如何遍历<code>Series</code>和<code>DataFrame</code>结构呢？对于<code>Series</code>而言，您可以把它当做一维数组进行遍历操作；而像<code>DataFrame</code>这种二维数据表结构，则类似于遍历<code>Python</code>字典。</p><p>在<code>Pandas</code>中同样也是使用<code>for</code>循环进行遍历。通过<code>for</code>遍历后，<code>Series</code>可直接获取相应的<code>value</code>，而<code>DataFrame</code>则会获取列标签。示例如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="comment"># 操作DataFrame</span></span><br><span class="line">df = pd.DataFrame([[<span class="number">120</span>,<span class="number">130</span>,<span class="number">150</span>],[<span class="number">90</span>,<span class="number">100</span>,<span class="number">110</span>],[<span class="number">60</span>,<span class="number">70</span>,<span class="number">80</span>]],columns=[<span class="string">&#x27;c1&#x27;</span>,<span class="string">&#x27;c2&#x27;</span>,<span class="string">&#x27;c3&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="keyword">for</span> col <span class="keyword">in</span> df:</span><br><span class="line">   <span class="built_in">print</span> (col)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">    c1   c2   c3</span><br><span class="line"><span class="number">0</span>  <span class="number">120</span>  <span class="number">130</span>  <span class="number">150</span></span><br><span class="line"><span class="number">1</span>   <span class="number">90</span>  <span class="number">100</span>  <span class="number">110</span></span><br><span class="line"><span class="number">2</span>   <span class="number">60</span>   <span class="number">70</span>   <span class="number">80</span></span><br><span class="line">********************</span><br><span class="line">c1</span><br><span class="line">c2</span><br><span class="line">c3</span><br></pre></td></tr></table></figure><p>如果想要遍历<code>DataFrame</code>的每一行，我们下列函数：</p><ul><li><code>iteritems()</code>：以键值对 (<code>key</code>,<code>value</code>) 的形式遍历；</li><li><code>iterrows()</code>：以 (<code>row_index</code>,<code>row</code>) 的形式遍历行;</li><li><code>itertuples()</code>：使用已命名元组的方式对行遍历。</li></ul><p><code>iteritems()</code>以键值对的形式遍历<code>DataFrame</code>对象，以<strong>列标签</strong>为键，以对应列的元素为值。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="comment"># 操作DataFrame</span></span><br><span class="line">df = pd.DataFrame([[<span class="number">120</span>,<span class="number">130</span>,<span class="number">150</span>],[<span class="number">90</span>,<span class="number">100</span>,<span class="number">110</span>],[<span class="number">60</span>,<span class="number">70</span>,<span class="number">80</span>]],columns=[<span class="string">&#x27;c1&#x27;</span>,<span class="string">&#x27;c2&#x27;</span>,<span class="string">&#x27;c3&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="keyword">for</span> key,value <span class="keyword">in</span> df.iteritems():</span><br><span class="line">   <span class="built_in">print</span>(key)</span><br><span class="line">   <span class="built_in">print</span>(value)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">    c1   c2   c3</span><br><span class="line"><span class="number">0</span>  <span class="number">120</span>  <span class="number">130</span>  <span class="number">150</span></span><br><span class="line"><span class="number">1</span>   <span class="number">90</span>  <span class="number">100</span>  <span class="number">110</span></span><br><span class="line"><span class="number">2</span>   <span class="number">60</span>   <span class="number">70</span>   <span class="number">80</span></span><br><span class="line">********************</span><br><span class="line">c1</span><br><span class="line"><span class="number">0</span>    <span class="number">120</span></span><br><span class="line"><span class="number">1</span>     <span class="number">90</span></span><br><span class="line"><span class="number">2</span>     <span class="number">60</span></span><br><span class="line">Name: c1, dtype: int64</span><br><span class="line">c2</span><br><span class="line"><span class="number">0</span>    <span class="number">130</span></span><br><span class="line"><span class="number">1</span>    <span class="number">100</span></span><br><span class="line"><span class="number">2</span>     <span class="number">70</span></span><br><span class="line">Name: c2, dtype: int64</span><br><span class="line">c3</span><br><span class="line"><span class="number">0</span>    <span class="number">150</span></span><br><span class="line"><span class="number">1</span>    <span class="number">110</span></span><br><span class="line"><span class="number">2</span>     <span class="number">80</span></span><br><span class="line">Name: c3, dtype: int64</span><br></pre></td></tr></table></figure><p><code>iterrows()</code>方法按行遍历，返回一个迭代器，以<strong>行索引</strong>标签为键，以每一行数据为值。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="comment"># 操作DataFrame</span></span><br><span class="line">df = pd.DataFrame([[<span class="number">120</span>,<span class="number">130</span>,<span class="number">150</span>],[<span class="number">90</span>,<span class="number">100</span>,<span class="number">110</span>],[<span class="number">60</span>,<span class="number">70</span>,<span class="number">80</span>]],columns=[<span class="string">&#x27;c1&#x27;</span>,<span class="string">&#x27;c2&#x27;</span>,<span class="string">&#x27;c3&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># iterrows()遍历行，其中0,1,2是行索引而c1,c2,c3是列索引。</span></span><br><span class="line"><span class="keyword">for</span> row_index,value <span class="keyword">in</span> df.iterrows():</span><br><span class="line">   <span class="built_in">print</span>(row_index)</span><br><span class="line">   <span class="built_in">print</span>(value)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">    c1   c2   c3</span><br><span class="line"><span class="number">0</span>  <span class="number">120</span>  <span class="number">130</span>  <span class="number">150</span></span><br><span class="line"><span class="number">1</span>   <span class="number">90</span>  <span class="number">100</span>  <span class="number">110</span></span><br><span class="line"><span class="number">2</span>   <span class="number">60</span>   <span class="number">70</span>   <span class="number">80</span></span><br><span class="line">********************</span><br><span class="line"><span class="number">0</span></span><br><span class="line">c1    <span class="number">120</span></span><br><span class="line">c2    <span class="number">130</span></span><br><span class="line">c3    <span class="number">150</span></span><br><span class="line">Name: <span class="number">0</span>, dtype: int64</span><br><span class="line"><span class="number">1</span></span><br><span class="line">c1     <span class="number">90</span></span><br><span class="line">c2    <span class="number">100</span></span><br><span class="line">c3    <span class="number">110</span></span><br><span class="line">Name: <span class="number">1</span>, dtype: int64</span><br><span class="line"><span class="number">2</span></span><br><span class="line">c1    <span class="number">60</span></span><br><span class="line">c2    <span class="number">70</span></span><br><span class="line">c3    <span class="number">80</span></span><br><span class="line">Name: <span class="number">2</span>, dtype: int64</span><br></pre></td></tr></table></figure><p><code>itertuples()</code>同样将返回一个迭代器，该方法会把<code>DataFrame</code>的<strong>每一行</strong>生成一个元组，示例如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="comment"># 操作DataFrame</span></span><br><span class="line">df = pd.DataFrame([[<span class="number">120</span>,<span class="number">130</span>,<span class="number">150</span>],[<span class="number">90</span>,<span class="number">100</span>,<span class="number">110</span>],[<span class="number">60</span>,<span class="number">70</span>,<span class="number">80</span>]],columns=[<span class="string">&#x27;c1&#x27;</span>,<span class="string">&#x27;c2&#x27;</span>,<span class="string">&#x27;c3&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> df.itertuples():</span><br><span class="line">    <span class="built_in">print</span>(row)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">    c1   c2   c3</span><br><span class="line"><span class="number">0</span>  <span class="number">120</span>  <span class="number">130</span>  <span class="number">150</span></span><br><span class="line"><span class="number">1</span>   <span class="number">90</span>  <span class="number">100</span>  <span class="number">110</span></span><br><span class="line"><span class="number">2</span>   <span class="number">60</span>   <span class="number">70</span>   <span class="number">80</span></span><br><span class="line">********************</span><br><span class="line">Pandas(Index=<span class="number">0</span>, c1=<span class="number">120</span>, c2=<span class="number">130</span>, c3=<span class="number">150</span>)</span><br><span class="line">Pandas(Index=<span class="number">1</span>, c1=<span class="number">90</span>, c2=<span class="number">100</span>, c3=<span class="number">110</span>)</span><br><span class="line">Pandas(Index=<span class="number">2</span>, c1=<span class="number">60</span>, c2=<span class="number">70</span>, c3=<span class="number">80</span>)</span><br></pre></td></tr></table></figure><blockquote><p>迭代器返回的是原对象的副本，如果在迭代过程中修改元素值，不会影响原对象。</p></blockquote><h3 id="排序和去重">👀排序和去重</h3><h4 id="排序sorting">👁排序sorting</h4><p><code>Pandas</code>提供了两种排序方法，分别是按标签排序和按数值排序。</p><p>（1）按行标签排序</p><p>使用<code>sort_index()</code>方法对<strong>行标签排序</strong>，指定轴参数（<code>axis</code>）或者排序顺序。或者可以对<code>DataFrame</code>进行排序。默认情况下，按照行标签序排序。通过将布尔值传递给<code>ascending</code>参数，可以控制排序的顺序（行号顺序）。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment"># 行标签乱序排列，列标签乱序排列</span></span><br><span class="line">unsorted_df = pd.DataFrame(np.random.randn(<span class="number">6</span>,<span class="number">2</span>),index=[<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">0</span>],columns=[<span class="string">&#x27;col2&#x27;</span>,<span class="string">&#x27;col1&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(unsorted_df)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span>*<span class="number">20</span>)</span><br><span class="line">sorted_df1 = unsorted_df.sort_index()</span><br><span class="line"><span class="built_in">print</span>(sorted_df1)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span>*<span class="number">20</span>)</span><br><span class="line">sorted_df2 = unsorted_df.sort_index(ascending=<span class="literal">False</span>)</span><br><span class="line"><span class="built_in">print</span>(sorted_df2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">       col2      col1</span><br><span class="line"><span class="number">1</span> -<span class="number">0.458463</span>  <span class="number">0.422606</span></span><br><span class="line"><span class="number">4</span>  <span class="number">0.809682</span>  <span class="number">2.489952</span></span><br><span class="line"><span class="number">2</span>  <span class="number">1.609935</span>  <span class="number">0.096181</span></span><br><span class="line"><span class="number">3</span>  <span class="number">1.087255</span>  <span class="number">1.215676</span></span><br><span class="line"><span class="number">5</span>  <span class="number">0.436520</span>  <span class="number">0.389565</span></span><br><span class="line"><span class="number">0</span>  <span class="number">0.536720</span>  <span class="number">0.820746</span></span><br><span class="line">********************</span><br><span class="line">       col2      col1</span><br><span class="line"><span class="number">0</span>  <span class="number">0.536720</span>  <span class="number">0.820746</span></span><br><span class="line"><span class="number">1</span> -<span class="number">0.458463</span>  <span class="number">0.422606</span></span><br><span class="line"><span class="number">2</span>  <span class="number">1.609935</span>  <span class="number">0.096181</span></span><br><span class="line"><span class="number">3</span>  <span class="number">1.087255</span>  <span class="number">1.215676</span></span><br><span class="line"><span class="number">4</span>  <span class="number">0.809682</span>  <span class="number">2.489952</span></span><br><span class="line"><span class="number">5</span>  <span class="number">0.436520</span>  <span class="number">0.389565</span></span><br><span class="line">********************</span><br><span class="line">       col2      col1</span><br><span class="line"><span class="number">5</span>  <span class="number">0.436520</span>  <span class="number">0.389565</span></span><br><span class="line"><span class="number">4</span>  <span class="number">0.809682</span>  <span class="number">2.489952</span></span><br><span class="line"><span class="number">3</span>  <span class="number">1.087255</span>  <span class="number">1.215676</span></span><br><span class="line"><span class="number">2</span>  <span class="number">1.609935</span>  <span class="number">0.096181</span></span><br><span class="line"><span class="number">1</span> -<span class="number">0.458463</span>  <span class="number">0.422606</span></span><br><span class="line"><span class="number">0</span>  <span class="number">0.536720</span>  <span class="number">0.820746</span></span><br></pre></td></tr></table></figure><p>（2）按列标签排序</p><p>通过给<code>axis</code>轴参数传递0或1，可以对列标签进行排序。默认情况下，<code>axis=0</code>表示按行排序；而<code>axis=1</code>则表示按列排序。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment"># 行标签乱序排列，列标签乱序排列</span></span><br><span class="line">unsorted_df = pd.DataFrame(np.random.randn(<span class="number">6</span>,<span class="number">2</span>),index=[<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">0</span>],columns=[<span class="string">&#x27;col2&#x27;</span>,<span class="string">&#x27;col1&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(unsorted_df)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span>*<span class="number">20</span>)</span><br><span class="line">sorted_df1 = unsorted_df.sort_index(axis=<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(sorted_df1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">       col2      col1</span><br><span class="line"><span class="number">1</span>  <span class="number">0.891755</span>  <span class="number">1.006258</span></span><br><span class="line"><span class="number">4</span>  <span class="number">0.232999</span>  <span class="number">0.549146</span></span><br><span class="line"><span class="number">2</span>  <span class="number">0.158894</span>  <span class="number">0.246825</span></span><br><span class="line"><span class="number">3</span>  <span class="number">0.653124</span> -<span class="number">1.695749</span></span><br><span class="line"><span class="number">5</span> -<span class="number">0.774252</span> -<span class="number">0.525881</span></span><br><span class="line"><span class="number">0</span>  <span class="number">0.082147</span>  <span class="number">0.384929</span></span><br><span class="line">********************</span><br><span class="line">       col1      col2</span><br><span class="line"><span class="number">1</span>  <span class="number">1.006258</span>  <span class="number">0.891755</span></span><br><span class="line"><span class="number">4</span>  <span class="number">0.549146</span>  <span class="number">0.232999</span></span><br><span class="line"><span class="number">2</span>  <span class="number">0.246825</span>  <span class="number">0.158894</span></span><br><span class="line"><span class="number">3</span> -<span class="number">1.695749</span>  <span class="number">0.653124</span></span><br><span class="line"><span class="number">5</span> -<span class="number">0.525881</span> -<span class="number">0.774252</span></span><br><span class="line"><span class="number">0</span>  <span class="number">0.384929</span>  <span class="number">0.082147</span></span><br></pre></td></tr></table></figure><p>（3）按值排序</p><p>与标签排序类似，<code>sort_values()</code>表示按值排序。它接受一个<code>by</code>参数，该参数值是要排序数列的<code>DataFrame</code>列名。示例如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="comment"># 行标签乱序排列，列标签乱序排列</span></span><br><span class="line">unsorted_df = pd.DataFrame(&#123;<span class="string">&#x27;col1&#x27;</span>:[<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],<span class="string">&#x27;col2&#x27;</span>:[<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>]&#125;)</span><br><span class="line"><span class="built_in">print</span>(unsorted_df)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span>*<span class="number">20</span>)</span><br><span class="line">sorted_df1 = unsorted_df.sort_values(by=<span class="string">&#x27;col1&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(sorted_df1)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 注意：当对col1列排序时，相应的col2列的元素值和行索引也会随col1一起改变。by参数可以接受一个列表参数值</span></span><br><span class="line">sorted_df2 = unsorted_df.sort_values(by=[<span class="string">&#x27;col1&#x27;</span>,<span class="string">&#x27;col2&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(sorted_df2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">   col1  col2</span><br><span class="line"><span class="number">0</span>     <span class="number">2</span>     <span class="number">1</span></span><br><span class="line"><span class="number">1</span>     <span class="number">1</span>     <span class="number">3</span></span><br><span class="line"><span class="number">2</span>     <span class="number">1</span>     <span class="number">2</span></span><br><span class="line"><span class="number">3</span>     <span class="number">1</span>     <span class="number">4</span></span><br><span class="line">********************</span><br><span class="line">   col1  col2</span><br><span class="line"><span class="number">1</span>     <span class="number">1</span>     <span class="number">3</span></span><br><span class="line"><span class="number">2</span>     <span class="number">1</span>     <span class="number">2</span></span><br><span class="line"><span class="number">3</span>     <span class="number">1</span>     <span class="number">4</span></span><br><span class="line"><span class="number">0</span>     <span class="number">2</span>     <span class="number">1</span></span><br><span class="line">********************</span><br><span class="line">   col1  col2</span><br><span class="line"><span class="number">2</span>     <span class="number">1</span>     <span class="number">2</span></span><br><span class="line"><span class="number">1</span>     <span class="number">1</span>     <span class="number">3</span></span><br><span class="line"><span class="number">3</span>     <span class="number">1</span>     <span class="number">4</span></span><br><span class="line"><span class="number">0</span>     <span class="number">2</span>     <span class="number">1</span></span><br></pre></td></tr></table></figure><p>（4）排序算法</p><p><code>sort_values()</code>提供了参数<code>kind</code>用来指定排序算法。这里有三种排序算法：</p><ul><li><code>mergesort</code></li><li><code>heapsort</code></li><li><code>quicksort</code></li></ul><p>默认为<code>quicksort</code>(快速排序) ，其中<code>Mergesort</code>归并排序是最稳定的算法。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="comment"># 行标签乱序排列，列标签乱序排列</span></span><br><span class="line">unsorted_df = pd.DataFrame(&#123;<span class="string">&#x27;col1&#x27;</span>:[<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],<span class="string">&#x27;col2&#x27;</span>:[<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>]&#125;)</span><br><span class="line"><span class="built_in">print</span>(unsorted_df)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span>*<span class="number">20</span>)</span><br><span class="line">sorted_df1 = unsorted_df.sort_values(by=<span class="string">&#x27;col1&#x27;</span>,kind=<span class="string">&#x27;mergesort&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(sorted_df1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">   col1  col2</span><br><span class="line"><span class="number">0</span>     <span class="number">2</span>     <span class="number">1</span></span><br><span class="line"><span class="number">1</span>     <span class="number">1</span>     <span class="number">3</span></span><br><span class="line"><span class="number">2</span>     <span class="number">1</span>     <span class="number">2</span></span><br><span class="line"><span class="number">3</span>     <span class="number">1</span>     <span class="number">4</span></span><br><span class="line">********************</span><br><span class="line">   col1  col2</span><br><span class="line"><span class="number">1</span>     <span class="number">1</span>     <span class="number">3</span></span><br><span class="line"><span class="number">2</span>     <span class="number">1</span>     <span class="number">2</span></span><br><span class="line"><span class="number">3</span>     <span class="number">1</span>     <span class="number">4</span></span><br><span class="line"><span class="number">0</span>     <span class="number">2</span>     <span class="number">1</span></span><br></pre></td></tr></table></figure><h4 id="去重drop_duplicates">👁去重drop_duplicates()</h4><p>“去重”通过字面意思不难理解，就是删除重复的数据。在一个数据集中，找出重复的数据删并将其删除，最终只保存一个唯一存在的数据项，这就是数据去重的整个过程。</p><p><code>Panda DataFrame</code>对象提供了一个数据去重的函数<code>drop_duplicates()</code></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.drop_duplicates(subset=[<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;C&#x27;</span>],keep=<span class="string">&#x27;first&#x27;</span>,inplace=<span class="literal">True</span>)</span><br><span class="line">参数说明如下：</span><br><span class="line">    subset：表示要进去重的列名，默认为<span class="literal">None</span>。</span><br><span class="line">    keep：有三个可选参数，分别是first、last、<span class="literal">False</span>，默认为first，表示只保留第一次出现的重复项，删除其余重复项，last表示只保留最后一次出现的重复项，<span class="literal">False</span>则表示删除所有重复项。</span><br><span class="line">    inplace：布尔值参数，默认为<span class="literal">False</span>表示删除重复项后返回一个副本，若为Ture则表示直接在原数据上删除重复项。</span><br></pre></td></tr></table></figure><blockquote><p>删除重复项后，行标签使用的数字是原来的，并没有从0重新开始，那么我们应该怎么从0重置索引呢？<code>Pandas</code>提供的<code>reset_index()</code>函数会直接使用重置后的索引。</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">data = &#123;<span class="string">&#x27;col1&#x27;</span>:[<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>],<span class="string">&#x27;col2&#x27;</span>:[<span class="number">0</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">0</span>],<span class="string">&#x27;col3&#x27;</span>:[<span class="number">4</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">4</span>],<span class="string">&#x27;col4&#x27;</span>:[<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>]&#125;</span><br><span class="line">df = pd.DataFrame(data)</span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 默认保留第一次出现的重复项,默认为first</span></span><br><span class="line"><span class="built_in">print</span>(df.drop_duplicates())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># keep=False删除所有重复项</span></span><br><span class="line">df1 = df.drop_duplicates(keep=<span class="literal">False</span>)</span><br><span class="line"><span class="built_in">print</span>(df1)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 重置索引，从0重新开始</span></span><br><span class="line"><span class="built_in">print</span>(df1.reset_index(drop=<span class="literal">True</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 指定多列同时去重</span></span><br><span class="line"><span class="built_in">print</span>(df.drop_duplicates([<span class="string">&#x27;col3&#x27;</span>,<span class="string">&#x27;col4&#x27;</span>],keep=<span class="string">&#x27;last&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">   col1  col2  col3  col4</span><br><span class="line"><span class="number">0</span>     <span class="number">1</span>     <span class="number">0</span>     <span class="number">4</span>     <span class="number">1</span></span><br><span class="line"><span class="number">1</span>     <span class="number">0</span>     <span class="number">2</span>     <span class="number">0</span>     <span class="number">0</span></span><br><span class="line"><span class="number">2</span>     <span class="number">1</span>     <span class="number">5</span>     <span class="number">4</span>     <span class="number">1</span></span><br><span class="line"><span class="number">3</span>     <span class="number">1</span>     <span class="number">0</span>     <span class="number">4</span>     <span class="number">1</span></span><br><span class="line">********************</span><br><span class="line">   col1  col2  col3  col4</span><br><span class="line"><span class="number">0</span>     <span class="number">1</span>     <span class="number">0</span>     <span class="number">4</span>     <span class="number">1</span></span><br><span class="line"><span class="number">1</span>     <span class="number">0</span>     <span class="number">2</span>     <span class="number">0</span>     <span class="number">0</span></span><br><span class="line"><span class="number">2</span>     <span class="number">1</span>     <span class="number">5</span>     <span class="number">4</span>     <span class="number">1</span></span><br><span class="line">********************</span><br><span class="line">   col1  col2  col3  col4</span><br><span class="line"><span class="number">1</span>     <span class="number">0</span>     <span class="number">2</span>     <span class="number">0</span>     <span class="number">0</span></span><br><span class="line"><span class="number">2</span>     <span class="number">1</span>     <span class="number">5</span>     <span class="number">4</span>     <span class="number">1</span></span><br><span class="line">********************</span><br><span class="line">   col1  col2  col3  col4</span><br><span class="line"><span class="number">0</span>     <span class="number">0</span>     <span class="number">2</span>     <span class="number">0</span>     <span class="number">0</span></span><br><span class="line"><span class="number">1</span>     <span class="number">1</span>     <span class="number">5</span>     <span class="number">4</span>     <span class="number">1</span></span><br><span class="line">********************</span><br><span class="line">   col1  col2  col3  col4</span><br><span class="line"><span class="number">1</span>     <span class="number">0</span>     <span class="number">2</span>     <span class="number">0</span>     <span class="number">0</span></span><br><span class="line"><span class="number">3</span>     <span class="number">1</span>     <span class="number">0</span>     <span class="number">4</span>     <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="字符串处理">👀字符串处理</h3><p><code>Pandas</code>提供了一系列的字符串函数，因此能够很方便地对字符串进行处理。</p><table><thead><tr class="header"><th>函数名称</th><th>函数功能和描述</th></tr></thead><tbody><tr class="odd"><td><code>lower()</code></td><td>将的字符串转换为小写</td></tr><tr class="even"><td><code>upper()</code></td><td>将的字符串转换为大写</td></tr><tr class="odd"><td><code>len()</code></td><td>得出字符串的长度</td></tr><tr class="even"><td><code>strip()</code></td><td>去除字符串两边的空格（包含换行符）</td></tr><tr class="odd"><td><code>split()</code></td><td>用指定的分割符分割字符串</td></tr><tr class="even"><td><code>cat(sep="")</code></td><td>用给定的分隔符连接字符串元素</td></tr><tr class="odd"><td><code>get_dummies()</code></td><td>返回一个带有独热编码值的<code>DataFrame</code>结构</td></tr><tr class="even"><td><code>contains(pattern)</code></td><td>如果子字符串包含在元素中，则为每个元素返回一个布尔值True，否则为False</td></tr><tr class="odd"><td><code>replace(a,b)</code></td><td>将值a替换为值b</td></tr><tr class="even"><td><code>count(pattern)</code></td><td>返回每个字符串元素出现的次数</td></tr><tr class="odd"><td><code>startswith(pattern)</code></td><td>如果<code>Series</code>中的元素以指定的字符串开头，则返回True</td></tr><tr class="even"><td><code>endswith(pattern)</code></td><td>如果<code>Series</code>中的元素以指定的字符串结尾，则返回True</td></tr><tr class="odd"><td><code>findall(pattern)</code></td><td>以列表的形式返出现的字符串</td></tr><tr class="even"><td><code>swapcase()</code></td><td>交换大小写</td></tr><tr class="odd"><td><code>islower()</code></td><td>返回布尔值，检查<code>Series</code>中组成每个字符串的所有字符是否都为小写</td></tr><tr class="even"><td><code>issupper()</code></td><td>返回布尔值，检查<code>Series</code>中组成每个字符串的所有字符是否都为大写</td></tr><tr class="odd"><td><code>isnumeric()</code></td><td>返回布尔值，检查<code>Series</code>中组成每个字符串的所有字符是否都为数字</td></tr><tr class="even"><td><code>repeat(value)</code></td><td>以指定的次数重复每个元素</td></tr><tr class="odd"><td><code>find(pattern)</code></td><td>返回字符串第一次出现的索引位置</td></tr></tbody></table><blockquote><p>注意：上述所有字符串函数全部适用于<code>DataFrame</code>对象，同时也可以与<code>Python</code>内置的字符串函数一起使用，这些函数在处理<code>Series/DataFrame</code>对象的时候会自动忽略缺失值数据（<code>NaN</code>）。</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">s = pd.Series([<span class="string">&#x27;C &#x27;</span>, <span class="string">&#x27; Python&#x27;</span>, <span class="string">&#x27;java&#x27;</span>, <span class="string">&#x27;go&#x27;</span>, np.nan, <span class="string">&#x27;1125 &#x27;</span>,<span class="string">&#x27;javascript&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(s.<span class="built_in">str</span>.lower)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="built_in">print</span>(s.<span class="built_in">str</span>.<span class="built_in">len</span>())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="built_in">print</span>(s.<span class="built_in">str</span>.strip())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="built_in">print</span>(s.<span class="built_in">str</span>.split(<span class="string">&quot; &quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="built_in">print</span>(s.<span class="built_in">str</span>.cat(sep=<span class="string">&quot;_&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="built_in">print</span>(s.<span class="built_in">str</span>.get_dummies())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="built_in">print</span>(s.<span class="built_in">str</span>.contains(<span class="string">&quot; &quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="built_in">print</span>(s.<span class="built_in">str</span>.repeat(<span class="number">3</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="built_in">print</span>(s.<span class="built_in">str</span>.startswith(<span class="string">&quot;j&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 如果返回-1表示该字符串中没有出现指定的字符</span></span><br><span class="line"><span class="built_in">print</span>(s.<span class="built_in">str</span>.find(<span class="string">&quot;j&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="built_in">print</span>(s.<span class="built_in">str</span>.swapcase())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="built_in">print</span>(s.<span class="built_in">str</span>.isnumeric())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="number">0</span>            c </span><br><span class="line"><span class="number">1</span>        python</span><br><span class="line"><span class="number">2</span>          java</span><br><span class="line"><span class="number">3</span>            go</span><br><span class="line"><span class="number">4</span>           NaN</span><br><span class="line"><span class="number">5</span>         <span class="number">1125</span> </span><br><span class="line"><span class="number">6</span>    javascript</span><br><span class="line">dtype: <span class="built_in">object</span></span><br><span class="line">********************</span><br><span class="line"><span class="number">0</span>     <span class="number">2.0</span></span><br><span class="line"><span class="number">1</span>     <span class="number">7.0</span></span><br><span class="line"><span class="number">2</span>     <span class="number">4.0</span></span><br><span class="line"><span class="number">3</span>     <span class="number">2.0</span></span><br><span class="line"><span class="number">4</span>     NaN</span><br><span class="line"><span class="number">5</span>     <span class="number">5.0</span></span><br><span class="line"><span class="number">6</span>    <span class="number">10.0</span></span><br><span class="line">dtype: float64</span><br><span class="line">********************</span><br><span class="line"><span class="number">0</span>             C</span><br><span class="line"><span class="number">1</span>        Python</span><br><span class="line"><span class="number">2</span>          java</span><br><span class="line"><span class="number">3</span>            go</span><br><span class="line"><span class="number">4</span>           NaN</span><br><span class="line"><span class="number">5</span>          <span class="number">1125</span></span><br><span class="line"><span class="number">6</span>    javascript</span><br><span class="line">dtype: <span class="built_in">object</span></span><br><span class="line">********************</span><br><span class="line"><span class="number">0</span>           [C, ]</span><br><span class="line"><span class="number">1</span>      [, Python]</span><br><span class="line"><span class="number">2</span>          [java]</span><br><span class="line"><span class="number">3</span>            [go]</span><br><span class="line"><span class="number">4</span>             NaN</span><br><span class="line"><span class="number">5</span>        [<span class="number">1125</span>, ]</span><br><span class="line"><span class="number">6</span>    [javascript]</span><br><span class="line">dtype: <span class="built_in">object</span></span><br><span class="line">********************</span><br><span class="line">C _ Python_java_go_1125 _javascript</span><br><span class="line">********************</span><br><span class="line">    Python  <span class="number">1125</span>   C   go  java  javascript</span><br><span class="line"><span class="number">0</span>        <span class="number">0</span>      <span class="number">0</span>   <span class="number">1</span>   <span class="number">0</span>     <span class="number">0</span>           <span class="number">0</span></span><br><span class="line"><span class="number">1</span>        <span class="number">1</span>      <span class="number">0</span>   <span class="number">0</span>   <span class="number">0</span>     <span class="number">0</span>           <span class="number">0</span></span><br><span class="line"><span class="number">2</span>        <span class="number">0</span>      <span class="number">0</span>   <span class="number">0</span>   <span class="number">0</span>     <span class="number">1</span>           <span class="number">0</span></span><br><span class="line"><span class="number">3</span>        <span class="number">0</span>      <span class="number">0</span>   <span class="number">0</span>   <span class="number">1</span>     <span class="number">0</span>           <span class="number">0</span></span><br><span class="line"><span class="number">4</span>        <span class="number">0</span>      <span class="number">0</span>   <span class="number">0</span>   <span class="number">0</span>     <span class="number">0</span>           <span class="number">0</span></span><br><span class="line"><span class="number">5</span>        <span class="number">0</span>      <span class="number">1</span>   <span class="number">0</span>   <span class="number">0</span>     <span class="number">0</span>           <span class="number">0</span></span><br><span class="line"><span class="number">6</span>        <span class="number">0</span>      <span class="number">0</span>   <span class="number">0</span>   <span class="number">0</span>     <span class="number">0</span>           <span class="number">1</span></span><br><span class="line">********************</span><br><span class="line"><span class="number">0</span>     <span class="literal">True</span></span><br><span class="line"><span class="number">1</span>     <span class="literal">True</span></span><br><span class="line"><span class="number">2</span>    <span class="literal">False</span></span><br><span class="line"><span class="number">3</span>    <span class="literal">False</span></span><br><span class="line"><span class="number">4</span>      NaN</span><br><span class="line"><span class="number">5</span>     <span class="literal">True</span></span><br><span class="line"><span class="number">6</span>    <span class="literal">False</span></span><br><span class="line">dtype: <span class="built_in">object</span></span><br><span class="line">********************</span><br><span class="line"><span class="number">0</span>                            C C C </span><br><span class="line"><span class="number">1</span>              Python Python Python</span><br><span class="line"><span class="number">2</span>                      javajavajava</span><br><span class="line"><span class="number">3</span>                            gogogo</span><br><span class="line"><span class="number">4</span>                               NaN</span><br><span class="line"><span class="number">5</span>                   <span class="number">1125</span> <span class="number">1125</span> <span class="number">1125</span> </span><br><span class="line"><span class="number">6</span>    javascriptjavascriptjavascript</span><br><span class="line">dtype: <span class="built_in">object</span></span><br><span class="line">********************</span><br><span class="line"><span class="number">0</span>    <span class="literal">False</span></span><br><span class="line"><span class="number">1</span>    <span class="literal">False</span></span><br><span class="line"><span class="number">2</span>     <span class="literal">True</span></span><br><span class="line"><span class="number">3</span>    <span class="literal">False</span></span><br><span class="line"><span class="number">4</span>      NaN</span><br><span class="line"><span class="number">5</span>    <span class="literal">False</span></span><br><span class="line"><span class="number">6</span>     <span class="literal">True</span></span><br><span class="line">dtype: <span class="built_in">object</span></span><br><span class="line">********************</span><br><span class="line"><span class="number">0</span>   -<span class="number">1.0</span></span><br><span class="line"><span class="number">1</span>   -<span class="number">1.0</span></span><br><span class="line"><span class="number">2</span>    <span class="number">0.0</span></span><br><span class="line"><span class="number">3</span>   -<span class="number">1.0</span></span><br><span class="line"><span class="number">4</span>    NaN</span><br><span class="line"><span class="number">5</span>   -<span class="number">1.0</span></span><br><span class="line"><span class="number">6</span>    <span class="number">0.0</span></span><br><span class="line">dtype: float64</span><br><span class="line">********************</span><br><span class="line"><span class="number">0</span>            c </span><br><span class="line"><span class="number">1</span>        pYTHON</span><br><span class="line"><span class="number">2</span>          JAVA</span><br><span class="line"><span class="number">3</span>            GO</span><br><span class="line"><span class="number">4</span>           NaN</span><br><span class="line"><span class="number">5</span>         <span class="number">1125</span> </span><br><span class="line"><span class="number">6</span>    JAVASCRIPT</span><br><span class="line">dtype: <span class="built_in">object</span></span><br><span class="line">********************</span><br><span class="line"><span class="number">0</span>    <span class="literal">False</span></span><br><span class="line"><span class="number">1</span>    <span class="literal">False</span></span><br><span class="line"><span class="number">2</span>    <span class="literal">False</span></span><br><span class="line"><span class="number">3</span>    <span class="literal">False</span></span><br><span class="line"><span class="number">4</span>      NaN</span><br><span class="line"><span class="number">5</span>    <span class="literal">False</span></span><br><span class="line"><span class="number">6</span>    <span class="literal">False</span></span><br><span class="line">dtype: <span class="built_in">object</span></span><br></pre></td></tr></table></figure><h3 id="设置数据显示格式">👀设置数据显示格式</h3><p>在用<code>Pandas</code>做数据分析的过程中，总需要打印数据分析的结果，如果数据体量较大就会存在输出内容不全（部分内容省略）或者换行错误等问题。<code>Pandas</code>为了解决上述问题，允许你对数据显示格式进行设置。下面列出了五个用来设置显示格式的函数，分别是：</p><table><thead><tr class="header"><th>函数名称</th><th>说明</th></tr></thead><tbody><tr class="odd"><td><code>get_option()</code></td><td>获取解释器的默认参数值</td></tr><tr class="even"><td><code>set_option()</code></td><td>更改解释器的默认参数值</td></tr><tr class="odd"><td><code>reset_option()</code></td><td>解释器的参数重置为默认值</td></tr><tr class="even"><td><code>describe_option()</code></td><td>输出参数的描述信息</td></tr><tr class="odd"><td><code>option_context()</code></td><td>临时设置解释器参数，当退出使用的语句块时，恢复为默认值</td></tr></tbody></table><p>上述函数常用的参数项：</p><table><colgroup><col style="width: 31%" /><col style="width: 68%" /></colgroup><thead><tr class="header"><th>参数</th><th>说明</th></tr></thead><tbody><tr class="odd"><td><code>display.max_rows</code></td><td>最大显示行数，超过该值用省略号代替，为None时显示所有行</td></tr><tr class="even"><td><code>display.max_columns</code></td><td>最大显示列数，超过该值用省略号代替，为None时显示所有列</td></tr><tr class="odd"><td><code>display.expand_frame_repr</code></td><td>输出数据宽度超过设置宽度时，表示是否对其要折叠，False不折叠，True要折叠</td></tr><tr class="even"><td><code>display.max_colwidth</code></td><td>单列数据宽度，以字符个数计算，超过时用省略号表示</td></tr><tr class="odd"><td><code>display.precision</code></td><td>设置输出数据的小数点位数</td></tr><tr class="even"><td><code>display.width</code></td><td>数据显示区域的宽度，以总字符数计算</td></tr><tr class="odd"><td><code>display.show_dimensions</code></td><td>当数据量大需要以truncate（带引号的省略方式）显示时，该参数表示是否在最后显示数据的维数，默认True显示，False不显示。</td></tr></tbody></table><h3 id="loc和iloc用法详解">👀loc和iloc用法详解</h3><p>在数据分析过程中，很多时候需要从数据表中提取出相应的数据，而这么做的前提是需要先“索引”出这一部分数据。虽然通过<code>Python</code>提供的索引操作符<code>"[]"</code>和属性操作符<code>"."</code>可以访问<code>Series</code>或者<code>DataFrame</code>中的数据，但这种方式只适应与少量的数据，为了解决这一问题，<code>Pandas</code>提供了两种类型的索引方式来实现数据的访问。</p><table><thead><tr class="header"><th>方法名称</th><th>说明</th></tr></thead><tbody><tr class="odd"><td><code>.loc[]</code></td><td>基于标签索引选取数据</td></tr><tr class="even"><td><code>.iloc[]</code></td><td>基于整数索引选取数据</td></tr></tbody></table><p><code>df.loc[]</code>只能使用标签索引，不能使用整数索引。当通过标签索引的切片方式来筛选数据时，它的取值前闭后闭，也就是只包括边界值标签（开始和结束）。</p><p><code>.loc[]</code>具有多种访问方法，如下所示：</p><ul><li>一个标量标签</li><li>标签列表</li><li>切片对象</li><li>布尔数组</li></ul><p><code>loc[]</code>接受两个参数，并以<code>','</code>分隔。第一个位置表示行，第二个位置表示列。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">data = &#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: [<span class="string">&#x27;Tom&#x27;</span>, <span class="string">&#x27;Rose&#x27;</span>, <span class="string">&#x27;Mike&#x27;</span>, <span class="string">&#x27;Twg&#x27;</span>],</span><br><span class="line">  <span class="string">&quot;calories&quot;</span>: [<span class="number">420</span>, <span class="number">380</span>, <span class="number">390</span>, <span class="number">500</span>],</span><br><span class="line">  <span class="string">&quot;duration&quot;</span>: [<span class="number">50</span>, <span class="number">40</span>, <span class="number">45</span>, <span class="number">60</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 数据载入到 DataFrame 对象</span></span><br><span class="line">df = pd.DataFrame(data, index = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 对行操作，等同于df.loc[&#x27;a&#x27;:&#x27;b&#x27;]</span></span><br><span class="line"><span class="built_in">print</span>(df.loc[<span class="string">&#x27;a&#x27;</span>:<span class="string">&#x27;b&#x27;</span>,:])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 对列操作</span></span><br><span class="line"><span class="built_in">print</span>(df.loc[:,<span class="string">&#x27;name&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 对行、列操作</span></span><br><span class="line"><span class="built_in">print</span>(df.loc[[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;d&#x27;</span>],[<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;duration&#x27;</span>]])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 布尔值操作</span></span><br><span class="line"><span class="built_in">print</span>(df.loc[:,<span class="string">&#x27;duration&#x27;</span>] &gt; <span class="number">45</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">   name  calories  duration</span><br><span class="line">a   Tom       <span class="number">420</span>        <span class="number">50</span></span><br><span class="line">b  Rose       <span class="number">380</span>        <span class="number">40</span></span><br><span class="line">c  Mike       <span class="number">390</span>        <span class="number">45</span></span><br><span class="line">d   Twg       <span class="number">500</span>        <span class="number">60</span></span><br><span class="line">********************</span><br><span class="line">   name  calories  duration</span><br><span class="line">a   Tom       <span class="number">420</span>        <span class="number">50</span></span><br><span class="line">b  Rose       <span class="number">380</span>        <span class="number">40</span></span><br><span class="line">********************</span><br><span class="line">a     Tom</span><br><span class="line">b    Rose</span><br><span class="line">c    Mike</span><br><span class="line">d     Twg</span><br><span class="line">Name: name, dtype: <span class="built_in">object</span></span><br><span class="line">********************</span><br><span class="line">  name  duration</span><br><span class="line">a  Tom        <span class="number">50</span></span><br><span class="line">d  Twg        <span class="number">60</span></span><br><span class="line">********************</span><br><span class="line">a     <span class="literal">True</span></span><br><span class="line">b    <span class="literal">False</span></span><br><span class="line">c    <span class="literal">False</span></span><br><span class="line">d     <span class="literal">True</span></span><br><span class="line">Name: duration, dtype: <span class="built_in">bool</span></span><br></pre></td></tr></table></figure><p><code>df.iloc[]</code>只能使用整数索引，不能使用标签索引，通过整数索引切片选择数据时，前闭后开(不包含边界结束值)。同<code>Python</code>和<code>NumPy</code>一样，它们的索引都是从0开始。</p><p><code>.iloc[]</code>提供了以下方式来选择数据：</p><ul><li>整数索引</li><li>整数列表</li><li>数值范围</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">data = &#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: [<span class="string">&#x27;Tom&#x27;</span>, <span class="string">&#x27;Rose&#x27;</span>, <span class="string">&#x27;Mike&#x27;</span>, <span class="string">&#x27;Twg&#x27;</span>],</span><br><span class="line">  <span class="string">&quot;calories&quot;</span>: [<span class="number">420</span>, <span class="number">380</span>, <span class="number">390</span>, <span class="number">500</span>],</span><br><span class="line">  <span class="string">&quot;duration&quot;</span>: [<span class="number">50</span>, <span class="number">40</span>, <span class="number">45</span>, <span class="number">60</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 数据载入到 DataFrame 对象</span></span><br><span class="line">df = pd.DataFrame(data, index = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="built_in">print</span>(df.iloc[<span class="number">2</span>:,:])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="built_in">print</span>(df.iloc[[<span class="number">0</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">2</span>]])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="built_in">print</span>(df.iloc[:,:<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">   name  calories  duration</span><br><span class="line">a   Tom       <span class="number">420</span>        <span class="number">50</span></span><br><span class="line">b  Rose       <span class="number">380</span>        <span class="number">40</span></span><br><span class="line">c  Mike       <span class="number">390</span>        <span class="number">45</span></span><br><span class="line">d   Twg       <span class="number">500</span>        <span class="number">60</span></span><br><span class="line">********************</span><br><span class="line">   name  calories  duration</span><br><span class="line">c  Mike       <span class="number">390</span>        <span class="number">45</span></span><br><span class="line">d   Twg       <span class="number">500</span>        <span class="number">60</span></span><br><span class="line">********************</span><br><span class="line">   calories  duration</span><br><span class="line">a       <span class="number">420</span>        <span class="number">50</span></span><br><span class="line">c       <span class="number">390</span>        <span class="number">45</span></span><br><span class="line">********************</span><br><span class="line">   name  calories</span><br><span class="line">a   Tom       <span class="number">420</span></span><br><span class="line">b  Rose       <span class="number">380</span></span><br><span class="line">c  Mike       <span class="number">390</span></span><br><span class="line">d   Twg       <span class="number">500</span></span><br></pre></td></tr></table></figure><h3 id="日期时间操作">👀日期时间操作</h3><h4 id="pandas时间序列">👁Pandas时间序列</h4><p>顾名思义，时间序列（<code>time series</code>），就是由时间构成的序列，它指的是在一定时间内按照时间顺序测量的某个变量的取值序列，比如一天内的温度会随时间而发生变化，或者股票的价格会随着时间不断的波动，这里用到的一系列时间，就可以看做时间序列。时间序列包含三种应用场景，分别是：</p><ul><li>特定的时刻（<code>timestamp</code>），也就是时间戳；</li><li>固定的日期（<code>period</code>），比如某年某月某日；</li><li>时间间隔（<code>interval</code>），每隔一段时间具有规律性；</li></ul><p>在处理时间序列的过程中，我们一般会遇到两个问题，第一，如何创建时间序列；第二，如何更改已生成时间序列的频率。 <code>Pandas</code>为解决上述问题提供了一套简单、易用的方法。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Python内置的datetime模块来获取当前时间，通过该模块提供的now()方法即可实现。</span></span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="comment"># 数据类型为datetime</span></span><br><span class="line"><span class="built_in">print</span>(datetime.now())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="number">2023</span>-03-<span class="number">19</span> <span class="number">17</span>:<span class="number">42</span>:<span class="number">39.528176</span></span><br></pre></td></tr></table></figure><p>创建时间戳：<code>TimeStamp</code>（时间戳） 是时间序列中的最基本的数据类型，它将数值与时间点完美结合在一起。</p><p>创建时间间隔：通过<code>date_range()</code>方法可以创建某段连续的时间或者固定间隔的时间时间段。该函数提供了三个参数，分别是：<code>start</code>开始时间；<code>end</code>结束时间；<code>freq</code>时间频率，默认为 "D"（天）。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="comment"># 创建时间戳</span></span><br><span class="line"><span class="built_in">print</span>(pd.Timestamp(<span class="string">&#x27;2023-03-16&#x27;</span>))</span><br><span class="line"><span class="comment"># 可以将整型或浮点型表示的时间转换为时间戳。默认的单位是纳秒(时间戳单位)</span></span><br><span class="line"><span class="built_in">print</span>(pd.Timestamp(<span class="number">1687687255</span>,unit=<span class="string">&#x27;s&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 创建时间范围，freq表示时间频率，每30min变化一次</span></span><br><span class="line"><span class="built_in">print</span>(pd.date_range(<span class="string">&quot;9:00&quot;</span>, <span class="string">&quot;18:10&quot;</span>, freq=<span class="string">&quot;30min&quot;</span>).time)</span><br><span class="line"><span class="comment"># 修改为按小时</span></span><br><span class="line"><span class="built_in">print</span>(pd.date_range(<span class="string">&quot;9:00&quot;</span>, <span class="string">&quot;18:10&quot;</span>, freq=<span class="string">&quot;H&quot;</span>).time)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 使用to_datetime()函数将series或list转换为日期对象，其中list会转换为DatetimeIndex</span></span><br><span class="line"><span class="comment"># 输出中，注意：NaT表示的不是时间 ，它等效于NaN</span></span><br><span class="line"><span class="comment"># 传入series，生成Datetimeindex</span></span><br><span class="line"><span class="built_in">print</span>(pd.to_datetime(pd.Series([<span class="string">&#x27;Jun 3, 2020&#x27;</span>,<span class="string">&#x27;2020-12-10&#x27;</span>, <span class="literal">None</span>])))</span><br><span class="line"><span class="comment"># 传入list，生成Datetimeindex</span></span><br><span class="line"><span class="built_in">print</span>(pd.to_datetime([<span class="string">&#x27;Jun 30, 2020&#x27;</span>,<span class="string">&#x27;2020-12-10&#x27;</span>, <span class="literal">None</span>]))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="number">2023</span>-03-<span class="number">16</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span></span><br><span class="line"><span class="number">2023</span>-06-<span class="number">25</span> <span class="number">10</span>:<span class="number">00</span>:<span class="number">55</span></span><br><span class="line">********************</span><br><span class="line">[datetime.time(<span class="number">9</span>, <span class="number">0</span>) datetime.time(<span class="number">9</span>, <span class="number">30</span>) datetime.time(<span class="number">10</span>, <span class="number">0</span>)</span><br><span class="line"> datetime.time(<span class="number">10</span>, <span class="number">30</span>) datetime.time(<span class="number">11</span>, <span class="number">0</span>) datetime.time(<span class="number">11</span>, <span class="number">30</span>)</span><br><span class="line"> datetime.time(<span class="number">12</span>, <span class="number">0</span>) datetime.time(<span class="number">12</span>, <span class="number">30</span>) datetime.time(<span class="number">13</span>, <span class="number">0</span>)</span><br><span class="line"> datetime.time(<span class="number">13</span>, <span class="number">30</span>) datetime.time(<span class="number">14</span>, <span class="number">0</span>) datetime.time(<span class="number">14</span>, <span class="number">30</span>)</span><br><span class="line"> datetime.time(<span class="number">15</span>, <span class="number">0</span>) datetime.time(<span class="number">15</span>, <span class="number">30</span>) datetime.time(<span class="number">16</span>, <span class="number">0</span>)</span><br><span class="line"> datetime.time(<span class="number">16</span>, <span class="number">30</span>) datetime.time(<span class="number">17</span>, <span class="number">0</span>) datetime.time(<span class="number">17</span>, <span class="number">30</span>)</span><br><span class="line"> datetime.time(<span class="number">18</span>, <span class="number">0</span>)]</span><br><span class="line">[datetime.time(<span class="number">9</span>, <span class="number">0</span>) datetime.time(<span class="number">10</span>, <span class="number">0</span>) datetime.time(<span class="number">11</span>, <span class="number">0</span>)</span><br><span class="line"> datetime.time(<span class="number">12</span>, <span class="number">0</span>) datetime.time(<span class="number">13</span>, <span class="number">0</span>) datetime.time(<span class="number">14</span>, <span class="number">0</span>)</span><br><span class="line"> datetime.time(<span class="number">15</span>, <span class="number">0</span>) datetime.time(<span class="number">16</span>, <span class="number">0</span>) datetime.time(<span class="number">17</span>, <span class="number">0</span>)</span><br><span class="line"> datetime.time(<span class="number">18</span>, <span class="number">0</span>)]</span><br><span class="line">********************</span><br><span class="line"><span class="number">0</span>   <span class="number">2020</span>-06-03</span><br><span class="line"><span class="number">1</span>   <span class="number">2020</span>-<span class="number">12</span>-<span class="number">10</span></span><br><span class="line"><span class="number">2</span>          NaT</span><br><span class="line">dtype: datetime64[ns]</span><br><span class="line">DatetimeIndex([<span class="string">&#x27;2020-06-30&#x27;</span>, <span class="string">&#x27;2020-12-10&#x27;</span>, <span class="string">&#x27;NaT&#x27;</span>], dtype=<span class="string">&#x27;datetime64[ns]&#x27;</span>, freq=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure><p>频率和周期转换：<code>Time Periods</code>表示时间跨度，一段时间周期，它被定义在<code>Pandas Periods</code>类中，通过该类提供的方法可以实现将频率转换为周期。比如<code>Periods()</code>方法，可以将频率 "<code>M</code>"（月）转换为 <code>Period</code>（时间段）。使用<code>asfreq()</code>和<code>start</code>参数，打印 "<code>01</code>" ，若使用<code>end</code>参数，则打印 "<code>31</code>"。对于常用的时间序列频率，<code>Pandas</code>为其规定了一些字符串别名，我们将这些别名称为“<code>offset</code>（偏移量）”。</p><table><thead><tr class="header"><th>别名</th><th>描述</th><th>别名</th><th>描述</th></tr></thead><tbody><tr class="odd"><td><code>B</code></td><td>工作日频率</td><td><code>BQS</code></td><td>工作季度开始频率</td></tr><tr class="even"><td><code>D</code></td><td>日历日频率</td><td><code>A</code></td><td>年终频率</td></tr><tr class="odd"><td><code>W</code></td><td>每周频率</td><td><code>BA</code></td><td>工作年度结束频率</td></tr><tr class="even"><td><code>M</code></td><td>月末频率</td><td><code>BAS</code></td><td>工作年度开始频率</td></tr><tr class="odd"><td><code>SM</code></td><td>半月结束频率</td><td><code>BH</code></td><td>营业时间频率</td></tr><tr class="even"><td><code>BM</code></td><td>工作月结束频率</td><td><code>H</code></td><td>小时频率</td></tr><tr class="odd"><td><code>MS</code></td><td>月开始频率</td><td><code>T,min</code></td><td>每分钟频率</td></tr><tr class="even"><td><code>SMS</code></td><td>半月开始频率</td><td><code>S</code></td><td>每秒钟频率</td></tr><tr class="odd"><td><code>BMS</code></td><td>工作月开始频率</td><td><code>L,ms</code></td><td>毫秒</td></tr><tr class="even"><td><code>Q</code></td><td>季末频率</td><td><code>U,us</code></td><td>微秒</td></tr><tr class="odd"><td><code>BQ</code></td><td>工作季度结束频率</td><td><code>N</code></td><td>纳秒</td></tr><tr class="even"><td><code>QS</code></td><td>季度开始频率</td><td></td><td></td></tr></tbody></table><p>周期计算：指的是对时间周期进行算术运算，所有的操作将在“频率”的基础上执行。</p><p>创建时间周期：可以使用<code>period_range()</code>方法来创建时间周期范围。</p><p>时间序列转换：如果想要把字符串日期转换为<code>Period</code>，首先需要将字符串转换为日期格式，然后再将日期转换为<code>Period</code>。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd </span><br><span class="line"><span class="comment"># S表示秒</span></span><br><span class="line">x = pd.Period(<span class="string">&#x27;2014&#x27;</span>, freq=<span class="string">&#x27;S&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line"><span class="comment"># 加1s的时间</span></span><br><span class="line"><span class="built_in">print</span>(x+<span class="number">1</span>)</span><br><span class="line"><span class="comment"># 使用period_range()方法来创建时间周期范围</span></span><br><span class="line">p = pd.period_range(<span class="string">&#x27;2016&#x27;</span>,<span class="string">&#x27;2018&#x27;</span>, freq=<span class="string">&#x27;Y&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(p)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="number">2014</span>-01-01 <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span></span><br><span class="line"><span class="number">2014</span>-01-01 <span class="number">00</span>:<span class="number">00</span>:01</span><br><span class="line">PeriodIndex([<span class="string">&#x27;2016&#x27;</span>, <span class="string">&#x27;2017&#x27;</span>, <span class="string">&#x27;2018&#x27;</span>], dtype=<span class="string">&#x27;period[A-DEC]&#x27;</span>, freq=<span class="string">&#x27;A-DEC&#x27;</span>)</span><br></pre></td></tr></table></figure><h4 id="日期时间格式化">👁日期时间格式化</h4><p>当进行数据分析时，我们会遇到很多带有日期、时间格式的数据集，在处理这些数据集时，可能会遇到日期格式不统一的问题，此时就需要对日期时间做统一的格式化处理。比如"<code>Wednesday, June 6, 2020</code>"可以写成"<code>6/6/20</code>"，或者写成"<code>06-06-2020</code>"。</p><p>（1）日期格式化符号</p><p>在对时间进行格式化处理时，它们都有固定的表示格式，比如小时的格式化符号为<code>%H</code> ,分钟简写为<code>%M</code> ，秒简写为<code>%S</code>。</p><table><thead><tr class="header"><th>符号</th><th>说明</th><th>符号</th><th>说明</th></tr></thead><tbody><tr class="odd"><td><code>%y</code></td><td>两位数的年份表示（00-99）</td><td><code>%Y</code></td><td>四位数的年份表示（000-9999）</td></tr><tr class="even"><td><code>%m</code></td><td>月份（01-12）</td><td><code>%d</code></td><td>月内中的一天（0-31）</td></tr><tr class="odd"><td><code>%H</code></td><td>24小时制小时数（0-23）</td><td><code>%I</code></td><td>12小时制小时数（01-12）</td></tr><tr class="even"><td><code>%M</code></td><td>分钟数（00=59）</td><td><code>%S</code></td><td>秒（00-59）</td></tr><tr class="odd"><td><code>%a</code></td><td>本地英文缩写星期名称</td><td><code>%A</code></td><td>本地英文完整星期名称</td></tr><tr class="even"><td><code>%b</code></td><td>本地缩写英文的月份名称</td><td><code>%B</code></td><td>本地完整英文的月份名称</td></tr><tr class="odd"><td><code>%w</code></td><td>星期（0-6），星期天为星期的开始</td><td><code>%W</code></td><td>一年中的星期数（00-53）星期一为星期的开始</td></tr><tr class="even"><td><code>%x</code></td><td>本地相应的日期表示</td><td><code>%X</code></td><td>本地相应的时间表示</td></tr><tr class="odd"><td><code>%Z</code></td><td>当前时区的名称</td><td><code>%U</code></td><td>一年中的星期数（00-53）星期天为星期的开始</td></tr><tr class="even"><td><code>%j</code></td><td>年内的一天（001-366）</td><td><code>%c</code></td><td>本地相应的日期表示和时间表示</td></tr></tbody></table><p>（2）日期格式化处理函数</p><p><code>Python</code>内置的<code>strptime()</code>方法能够将字符串日期转换为<code>datetime</code>类型。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="comment"># 将日期定义为字符串    </span></span><br><span class="line">date_str1 = <span class="string">&#x27;Wednesday,July 18,2020&#x27;</span> </span><br><span class="line">date_str2 = <span class="string">&#x27;18/7/20&#x27;</span> </span><br><span class="line">date_str3 = <span class="string">&#x27;18-07-2020&#x27;</span>  </span><br><span class="line"><span class="comment"># 将日期转化为datetime对象 </span></span><br><span class="line">dmy_dt1 = datetime.strptime(date_str1, <span class="string">&#x27;%A,%B %d,%Y&#x27;</span>) </span><br><span class="line">dmy_dt2 = datetime.strptime(date_str2, <span class="string">&#x27;%d/%m/%y&#x27;</span>) </span><br><span class="line">dmy_dt3 = datetime.strptime(date_str3, <span class="string">&#x27;%d-%m-%Y&#x27;</span>)  </span><br><span class="line"><span class="comment"># 处理为相同格式，并打印输出</span></span><br><span class="line"><span class="built_in">print</span>(dmy_dt1) </span><br><span class="line"><span class="built_in">print</span>(dmy_dt2) </span><br><span class="line"><span class="built_in">print</span>(dmy_dt3) </span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="number">2020</span>-07-<span class="number">18</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span></span><br><span class="line"><span class="number">2020</span>-07-<span class="number">18</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span></span><br><span class="line"><span class="number">2020</span>-07-<span class="number">18</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span></span><br></pre></td></tr></table></figure><p>除了使用<code>Python</code>内置的<code>strptime()</code>方法外，你还可以使用<code>Pandas</code>模块的<code>pd.to_datetime()</code>和<code>pd.DatetimeIndex()</code>进行转换。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment"># 通过to_datetime()直接转换为 datetime 类型</span></span><br><span class="line">date1 = [<span class="string">&#x27;2012-05-06 11:00:00&#x27;</span>,<span class="string">&#x27;2012-05-16 11:00:00&#x27;</span>]</span><br><span class="line">pd_date1 = pd.to_datetime(date1)</span><br><span class="line">df1 = pd.Series(np.random.randn(<span class="number">2</span>),index=pd_date1)</span><br><span class="line"><span class="built_in">print</span>(pd_date1)</span><br><span class="line"><span class="built_in">print</span>(df1)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 使用Datetimeindex()函数设置时间序</span></span><br><span class="line">date2 = pd.DatetimeIndex([<span class="string">&#x27;1/1/2008&#x27;</span>, <span class="string">&#x27;1/2/2008&#x27;</span>, <span class="string">&#x27;1/3/2008&#x27;</span>, <span class="string">&#x27;1/4/2008&#x27;</span>, <span class="string">&#x27;1/5/2008&#x27;</span>])</span><br><span class="line">dt2 = pd.DataFrame(np.random.randn(<span class="number">5</span>),index=date2, columns=[<span class="string">&#x27;value&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(date2)</span><br><span class="line"><span class="built_in">print</span>(dt2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">DatetimeIndex([<span class="string">&#x27;2012-05-06 11:00:00&#x27;</span>, <span class="string">&#x27;2012-05-16 11:00:00&#x27;</span>], dtype=<span class="string">&#x27;datetime64[ns]&#x27;</span>, freq=<span class="literal">None</span>)</span><br><span class="line"><span class="number">2012</span>-05-06 <span class="number">11</span>:<span class="number">00</span>:<span class="number">00</span>    <span class="number">2.115566</span></span><br><span class="line"><span class="number">2012</span>-05-<span class="number">16</span> <span class="number">11</span>:<span class="number">00</span>:<span class="number">00</span>   -<span class="number">0.145139</span></span><br><span class="line">dtype: float64</span><br><span class="line">********************</span><br><span class="line">DatetimeIndex([<span class="string">&#x27;2008-01-01&#x27;</span>, <span class="string">&#x27;2008-01-02&#x27;</span>, <span class="string">&#x27;2008-01-03&#x27;</span>, <span class="string">&#x27;2008-01-04&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2008-01-05&#x27;</span>],</span><br><span class="line">              dtype=<span class="string">&#x27;datetime64[ns]&#x27;</span>, freq=<span class="literal">None</span>)</span><br><span class="line">               value</span><br><span class="line"><span class="number">2008</span>-01-01  <span class="number">0.828022</span></span><br><span class="line"><span class="number">2008</span>-01-02 -<span class="number">1.873516</span></span><br><span class="line"><span class="number">2008</span>-01-03  <span class="number">1.940921</span></span><br><span class="line"><span class="number">2008</span>-01-04  <span class="number">1.563612</span></span><br><span class="line"><span class="number">2008</span>-01-05  <span class="number">0.964914</span></span><br></pre></td></tr></table></figure><h4 id="timedelta时间差">👁Timedelta时间差</h4><p><code>Timedelta</code>表示时间差（或者时间增量），我们可以使用不同的时间单位来表示它，比如，天、小时、分、秒。时间差的最终的结果可以是正时间差，也可以是负时间差。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment"># 通过传递字符串可以创建Timedelta对象</span></span><br><span class="line"><span class="built_in">print</span>(pd.Timedelta(<span class="string">&#x27;5 days 8 hours 6 minutes 59 seconds&#x27;</span>))</span><br><span class="line"><span class="comment"># 通过传递整数值和unit参数也可以创建一个Timedelta对象。</span></span><br><span class="line"><span class="built_in">print</span>(pd.Timedelta(<span class="number">19</span>,unit=<span class="string">&#x27;h&#x27;</span>))</span><br><span class="line"><span class="comment"># 数据偏移量， 比如，周(weeks)、天(days)、小时(hours)、分钟(minutes)、秒(milliseconds)、毫秒、微秒、纳秒都可以使用。</span></span><br><span class="line"><span class="built_in">print</span>(pd.Timedelta(days=<span class="number">2</span>,hours=<span class="number">6</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 您可以使用pd.to_timedelta()方法，将具有timedelta格式的值 (标量、数组、列表或Series）转换为Timedelta类型。如果输入是Series，则返回Series；如果输入是标量，则返回值也为标量，其他情况输出TimedeltaIndex。</span></span><br><span class="line"><span class="built_in">print</span>(pd.to_timedelta([<span class="string">&#x27;1 days 06:05:01.00003&#x27;</span>, <span class="string">&#x27;15.5us&#x27;</span>, <span class="string">&#x27;nan&#x27;</span>]))</span><br><span class="line"><span class="built_in">print</span>(pd.to_timedelta(np.arange(<span class="number">5</span>), unit=<span class="string">&#x27;s&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="number">5</span> days 08:06:<span class="number">59</span></span><br><span class="line"><span class="number">0</span> days <span class="number">19</span>:<span class="number">00</span>:<span class="number">00</span></span><br><span class="line"><span class="number">2</span> days 06:<span class="number">00</span>:<span class="number">00</span></span><br><span class="line">********************</span><br><span class="line">TimedeltaIndex([<span class="string">&#x27;1 days 06:05:01.000030&#x27;</span>, <span class="string">&#x27;0 days 00:00:00.000015&#x27;</span>, NaT], dtype=<span class="string">&#x27;timedelta64[ns]&#x27;</span>, freq=<span class="literal">None</span>)</span><br><span class="line">TimedeltaIndex([<span class="string">&#x27;00:00:00&#x27;</span>, <span class="string">&#x27;00:00:01&#x27;</span>, <span class="string">&#x27;00:00:02&#x27;</span>, <span class="string">&#x27;00:00:03&#x27;</span>, <span class="string">&#x27;00:00:04&#x27;</span>], dtype=<span class="string">&#x27;timedelta64[ns]&#x27;</span>, freq=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure><p>通过对<code>datetime64[ns]</code>类型的时间序列或时间戳做算术运算，其运算结果依然是<code>datetime64[ns]</code>数据类型。接下来，我们创建一个带有<code>Timedelta</code>与<code>datetime</code>的<code>DataFrame</code>对象，并对其做一些算术运算。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">s = pd.Series(pd.date_range(<span class="string">&#x27;2020-1-1&#x27;</span>, periods=<span class="number">5</span>, freq=<span class="string">&#x27;D&#x27;</span>))</span><br><span class="line"><span class="comment"># 推导式用法</span></span><br><span class="line">td = pd.Series([ pd.Timedelta(days=i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>)])</span><br><span class="line">df = pd.DataFrame(<span class="built_in">dict</span>(A = s, B = td))</span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 加法运算</span></span><br><span class="line">df[<span class="string">&#x27;C&#x27;</span>]=df[<span class="string">&#x27;A&#x27;</span>]+df[<span class="string">&#x27;B&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 减法运算</span></span><br><span class="line">df[<span class="string">&#x27;D&#x27;</span>]=df[<span class="string">&#x27;C&#x27;</span>]-df[<span class="string">&#x27;B&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">           A      B</span><br><span class="line"><span class="number">0</span> <span class="number">2020</span>-01-01 <span class="number">0</span> days</span><br><span class="line"><span class="number">1</span> <span class="number">2020</span>-01-02 <span class="number">1</span> days</span><br><span class="line"><span class="number">2</span> <span class="number">2020</span>-01-03 <span class="number">2</span> days</span><br><span class="line"><span class="number">3</span> <span class="number">2020</span>-01-04 <span class="number">3</span> days</span><br><span class="line"><span class="number">4</span> <span class="number">2020</span>-01-05 <span class="number">4</span> days</span><br><span class="line">********************</span><br><span class="line">           A      B          C</span><br><span class="line"><span class="number">0</span> <span class="number">2020</span>-01-01 <span class="number">0</span> days <span class="number">2020</span>-01-01</span><br><span class="line"><span class="number">1</span> <span class="number">2020</span>-01-02 <span class="number">1</span> days <span class="number">2020</span>-01-03</span><br><span class="line"><span class="number">2</span> <span class="number">2020</span>-01-03 <span class="number">2</span> days <span class="number">2020</span>-01-05</span><br><span class="line"><span class="number">3</span> <span class="number">2020</span>-01-04 <span class="number">3</span> days <span class="number">2020</span>-01-07</span><br><span class="line"><span class="number">4</span> <span class="number">2020</span>-01-05 <span class="number">4</span> days <span class="number">2020</span>-01-09</span><br><span class="line">********************</span><br><span class="line">           A      B          C          D</span><br><span class="line"><span class="number">0</span> <span class="number">2020</span>-01-01 <span class="number">0</span> days <span class="number">2020</span>-01-01 <span class="number">2020</span>-01-01</span><br><span class="line"><span class="number">1</span> <span class="number">2020</span>-01-02 <span class="number">1</span> days <span class="number">2020</span>-01-03 <span class="number">2020</span>-01-02</span><br><span class="line"><span class="number">2</span> <span class="number">2020</span>-01-03 <span class="number">2</span> days <span class="number">2020</span>-01-05 <span class="number">2020</span>-01-03</span><br><span class="line"><span class="number">3</span> <span class="number">2020</span>-01-04 <span class="number">3</span> days <span class="number">2020</span>-01-07 <span class="number">2020</span>-01-04</span><br><span class="line"><span class="number">4</span> <span class="number">2020</span>-01-05 <span class="number">4</span> days <span class="number">2020</span>-01-09 <span class="number">2020</span>-01-05</span><br></pre></td></tr></table></figure><h3 id="数据样本处理">👀数据样本处理</h3><h4 id="pandas缺失值处理">👁Pandas缺失值处理</h4><p>稀疏数据，指的是在数据库或者数据集中存在大量缺失数据或者空值，我们把这样的数据集称为稀疏数据集。稀疏数据不是无效数据，只不过是信息不全而已，只要通过适当的方法就可以“变废为宝”。</p><p><strong>检查缺失值</strong>：<code>Pandas</code>提供了<code>isnull()</code>和<code>notnull()</code>两个函数，它们同时适用于<code>Series</code>和<code>DataFrame</code>对象。</p><p><strong>缺失数据计算</strong>：计算缺失数据时，需要注意两点：首先数据求和时，将NA值视为0，其次，如果要计算的数据为NA，那么结果就是NA。</p><p><strong>清理并填充缺失值</strong>：<code>Pandas</code>提供了多种方法来清除缺失值。<code>fillna()</code>函数可以实现用非空数据“填充”<code>NaN</code>值；<code>ffill()</code>向前填充和<code>bfill()</code>向后填充，使用这两个函数也可以处理NA值。<code>replace()</code>将<code>DataFrame</code>中的通用值替换成特定值。</p><p><strong>删除缺失值</strong>：使用<code>dropna()</code>函数与参数<code>axis</code>可以实现删除缺失值。在默认情况下，按照<code>axis=0</code>来按行处理，这意味着如果某一行中存在<code>NaN</code>值将会删除整行数据。</p><h4 id="pandas随机样本选择">👁Pandas随机样本选择</h4><p>随机抽样，是统计学中常用的一种方法，它可以帮助我们从大量的数据中快速地构建出一组数据分析模型。在<code>Pandas</code>中，如果想要对数据集进行随机抽样，需要使用<code>sample()</code>函数。该函数返回与数据集类型相同的新对象，相当于<code>numpy.random.choice()</code>。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">DataFrame.sample(n=<span class="literal">None</span>,frac=<span class="literal">None</span>,replace=<span class="literal">False</span>,weights=<span class="literal">None</span>,random_state=<span class="literal">None</span>,axis=<span class="literal">None</span>)</span><br><span class="line">参数说明</span><br><span class="line">n表示要抽取的行数。</span><br><span class="line">frac表示抽取的比例，比如frac=<span class="number">0.5</span>，代表抽取总体数据的<span class="number">50</span>%。</span><br><span class="line">replace布尔值参数，表示是否以有放回抽样的方式进行选择，默认为<span class="literal">False</span>，取出数据后不再放回。</span><br><span class="line">weights可选参数，代表每个样本的权重值，参数值是字符串或者数组。</span><br><span class="line">random_state 可选参数，控制随机状态，默认为<span class="literal">None</span>，表示随机数据不会重复；若为<span class="number">1</span>表示会取得重复数据。</span><br><span class="line">axis表示在哪个方向上抽取数据(axis=<span class="number">1</span>表示列/axis=<span class="number">0</span>表示行)。</span><br></pre></td></tr></table></figure><h4 id="pandas数据重采样">👁Pandas数据重采样</h4><p>数据重采样是将时间序列从一个频率转换至另一个频率的过程，它主要有两种实现方式，分别是降采样和升采样，降采样指将高频率的数据转换为低频率，升采样则与其恰好相反，说明如下：</p><table><thead><tr class="header"><th>方法</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>降采样</td><td>将高频率(间隔短)数据转换为低频率(间隔长)。</td></tr><tr class="even"><td>升采样</td><td>将低频率数据转换为高频率。</td></tr></tbody></table><p><code>Pandas</code>提供了<code>resample()</code>函数来实现数据的重采样。</p><p><code>asfreq()</code>方法不仅能够实现频率转换，还可以保留原频率对应的数值，同时它也可以单独使用。</p><p>插值处理，升采样的结果会产生缺失值，那么就需要对缺失值进行处理，一般有以下几种处理方式：</p><table><thead><tr class="header"><th>方法</th><th>说明</th></tr></thead><tbody><tr class="odd"><td><code>pad/ffill</code></td><td>用前一个非缺失值去填充缺失值。</td></tr><tr class="even"><td><code>backfill/bfill</code></td><td>用后一个非缺失值去填充缺失值。</td></tr><tr class="odd"><td><code>interpolater('linear')</code></td><td>线性插值方法。</td></tr><tr class="even"><td><code>fillna(value)</code></td><td>指定一个值去替换缺失值。</td></tr></tbody></table><h4 id="pandas分类对象">👁Pandas分类对象</h4><p>通常情况下，数据集中会存在许多同一类别的信息，比如相同国家、相同行政编码、相同性别等，当这些相同类别的数据多次出现时，就会给数据处理增添许多麻烦，导致数据集变得臃肿，不能直观、清晰地展示数据。</p><p><code>Pandas</code>提供了分类对象（<code>Categorical Object</code>），该对象能够实现有序排列、自动去重的功能，但是它不能执行运算。通过<code>Category</code>的构造函数，您可以创建一个类别对象。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pandas.Categorical(values, categories, ordered)</span><br><span class="line">参数说明</span><br><span class="line">    values：以列表的形式传参，表示要分类的值。</span><br><span class="line">    ordered：布尔值，默认为<span class="literal">False</span>，若为Ture，表示对分类的数据进行排序。</span><br><span class="line">    dtype：返回一个category类型，表示分类对象。</span><br></pre></td></tr></table></figure><p><code>describe()</code>：对已经分类的数据使用<code>describe()</code>方法，得到和数据统计相关的摘要信息。</p><p><code>categories</code>：使用<code>obj.categories</code>命令可以获取对象的类别信息。</p><p><code>Series.cat.categories</code>：对类别实现重命名。</p><p><code>Series.cat.add_categories()</code>：追加新类别。</p><p><code>Series.cat.remove_categories()</code>：删除不需要的类别。</p><h3 id="其它函数">👀其它函数</h3><h4 id="pandas统计函数">👁Pandas统计函数</h4><p><code>Pandas</code>的本质是统计学原理在计算机领域的一种应用实现，通过编程的方式达到分析、描述数据的目的。而统计函数则是统计学中用于计算和分析数据的一种工具。在数据分析的过程中，使用统计函数有助于我们理解和分析数据。常见的统计函数，比如百分比函数、协方差函数、相关系数等。</p><ul><li><code>pct_change()</code> ：<code>Series</code>和<code>DatFrames</code>都可以使用<code>pct_change()</code>函数。该函数将每个元素与其前一个元素进行比较，并计算前后数值的百分比变化。默认情况下，<code>pct_change()</code>对列进行操作，如果想要操作行，则需要传递参数<code>axis=1</code>参数。</li><li><code>cov()</code>：<code>Series</code>对象提供了一个<code>cov</code>方法用来计算Series对象之间的协方差。同时，该方法也会将缺失值(<code>NAN</code>)自动排除。当应用于<code>DataFrame</code>时，协方差（<code>cov</code>）将计算所有列之间的协方差。</li><li><code>corr()</code>：相关系数显示任意两个<code>Series</code>之间的线性关系。<code>Pandas</code>提供了计算相关性的三种方法，分别是<code>pearson(default)</code>、<code>spearman()</code>和<code>kendall()</code>。注意：如果<code>DataFrame</code>存在非数值（<code>NAN</code>），该方法会自动将其删除。</li><li><code>rank()</code> ：按照某种规则（升序或者降序）对序列中的元素值排名，该函数的返回值的也是一个序列，包含了原序列中每个元素值的名次。如果序列中包含两个相同的的元素值，那么会为其分配两者的平均排名。</li></ul><h4 id="pandas窗口函数">👁Pandas窗口函数</h4><p>为了能更好地处理数值型数据，<code>Pandas</code>提供了几种窗口函数：</p><ul><li>移动函数（<code>rolling</code>）</li><li>扩展函数（<code>expanding</code>）</li><li>指数加权函数（<code>ewm</code>）</li></ul><blockquote><p>窗口是一种形象化的叫法，这些函数在执行操作时，就如同窗口一样在数据区间上移动。</p></blockquote><p>如何在<code>DataFrame</code>和<code>Series</code>对象上应用窗口函数：</p><ul><li><p><code>rolling()</code> ：移动窗口函数，它可以与<code>mean</code>、<code>count</code>、<code>sum</code>、<code>median</code>、<code>std</code>等聚合函数一起使用。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">rolling(window=n, min_periods=<span class="literal">None</span>, center=<span class="literal">False</span>)</span><br><span class="line">参数说明</span><br><span class="line">    window默认值为<span class="number">1</span>，表示窗口的大小，也就是观测值的数量，</span><br><span class="line">    min_periods表示窗口的最小观察值，默认与window的参数值相等。</span><br><span class="line">    center是否把中间值做为窗口标准，默认值为<span class="literal">False</span>。</span><br></pre></td></tr></table></figure></li><li><p><code>expanding()</code> ：扩展窗口函数，扩展是指由序列的第一个元素开始，逐个向后计算元素的聚合值。</p></li><li><p><code>ewm()</code>：（全称 Exponentially Weighted Moving）表示指数加权移动。<code>ewn()</code>函数先会对序列元素做指数加权运算，其次计算加权后的均值。该函数通过指定<code>com</code>、<code>span</code>或者<code>halflife</code>参数来实现指数加权移动。</p></li></ul><p>在数据分析的过程中，使用窗口函数能够提升数据的准确性，并且使数据曲线的变化趋势更加平滑，从而让数据分析变得更加准确、可靠。</p><h4 id="pandas聚合函数">👁Pandas聚合函数</h4><p>窗口函数可以与聚合函数一起使用，聚合函数指的是对一组数据求总和、最大值、最小值以及平均值的操作，本节重点讲解聚合函数的应用。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">data = &#123;<span class="string">&#x27;col1&#x27;</span>:[<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>],<span class="string">&#x27;col2&#x27;</span>:[<span class="number">0</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">0</span>],<span class="string">&#x27;col3&#x27;</span>:[<span class="number">4</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">4</span>],<span class="string">&#x27;col4&#x27;</span>:[<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>]&#125;</span><br><span class="line">df = pd.DataFrame(data)</span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 窗口大小为3，min_periods最小观测值为1</span></span><br><span class="line">r1 = df.rolling(window=<span class="number">3</span>,min_periods=<span class="number">1</span>)</span><br><span class="line"><span class="comment"># min_periods默认与window的参数值相等</span></span><br><span class="line">r2 = df.rolling(window=<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(r1.<span class="built_in">sum</span>())</span><br><span class="line"><span class="built_in">print</span>(r2.<span class="built_in">sum</span>())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 把一个聚合函数传递给DataFrame</span></span><br><span class="line"><span class="comment"># 对整体聚合,使用aggregate()聚合操作</span></span><br><span class="line"><span class="built_in">print</span>(r1.aggregate(np.<span class="built_in">sum</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 对任意某一列聚合</span></span><br><span class="line"><span class="built_in">print</span>(r1[<span class="string">&#x27;col1&#x27;</span>].aggregate(np.<span class="built_in">sum</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 对多列数据聚合</span></span><br><span class="line"><span class="built_in">print</span>(r1[<span class="string">&#x27;col1&#x27;</span>,<span class="string">&#x27;col2&#x27;</span>].aggregate(np.<span class="built_in">sum</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 对单列应用多个函数</span></span><br><span class="line"><span class="built_in">print</span>(r1[<span class="string">&#x27;col1&#x27;</span>].aggregate([np.<span class="built_in">sum</span>,np.mean]))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 对不同列应用多个函数</span></span><br><span class="line"><span class="built_in">print</span>(r1[<span class="string">&#x27;col1&#x27;</span>,<span class="string">&#x27;col2&#x27;</span>].aggregate([np.<span class="built_in">sum</span>,np.mean]))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 对不同列应用不同函数</span></span><br><span class="line"><span class="built_in">print</span>(r1.aggregate(&#123;<span class="string">&#x27;col1&#x27;</span>:np.<span class="built_in">sum</span>,<span class="string">&#x27;col2&#x27;</span>:np.mean&#125;))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"> col1  col2  col3  col4</span><br><span class="line"><span class="number">0</span>     <span class="number">1</span>     <span class="number">0</span>     <span class="number">4</span>     <span class="number">1</span></span><br><span class="line"><span class="number">1</span>     <span class="number">0</span>     <span class="number">2</span>     <span class="number">0</span>     <span class="number">0</span></span><br><span class="line"><span class="number">2</span>     <span class="number">1</span>     <span class="number">5</span>     <span class="number">4</span>     <span class="number">1</span></span><br><span class="line"><span class="number">3</span>     <span class="number">1</span>     <span class="number">0</span>     <span class="number">4</span>     <span class="number">1</span></span><br><span class="line">********************</span><br><span class="line">   col1  col2  col3  col4</span><br><span class="line"><span class="number">0</span>   <span class="number">1.0</span>   <span class="number">0.0</span>   <span class="number">4.0</span>   <span class="number">1.0</span></span><br><span class="line"><span class="number">1</span>   <span class="number">1.0</span>   <span class="number">2.0</span>   <span class="number">4.0</span>   <span class="number">1.0</span></span><br><span class="line"><span class="number">2</span>   <span class="number">2.0</span>   <span class="number">7.0</span>   <span class="number">8.0</span>   <span class="number">2.0</span></span><br><span class="line"><span class="number">3</span>   <span class="number">2.0</span>   <span class="number">7.0</span>   <span class="number">8.0</span>   <span class="number">2.0</span></span><br><span class="line">   col1  col2  col3  col4</span><br><span class="line"><span class="number">0</span>   NaN   NaN   NaN   NaN</span><br><span class="line"><span class="number">1</span>   NaN   NaN   NaN   NaN</span><br><span class="line"><span class="number">2</span>   <span class="number">2.0</span>   <span class="number">7.0</span>   <span class="number">8.0</span>   <span class="number">2.0</span></span><br><span class="line"><span class="number">3</span>   <span class="number">2.0</span>   <span class="number">7.0</span>   <span class="number">8.0</span>   <span class="number">2.0</span></span><br><span class="line">********************</span><br><span class="line">   col1  col2  col3  col4</span><br><span class="line"><span class="number">0</span>   <span class="number">1.0</span>   <span class="number">0.0</span>   <span class="number">4.0</span>   <span class="number">1.0</span></span><br><span class="line"><span class="number">1</span>   <span class="number">1.0</span>   <span class="number">2.0</span>   <span class="number">4.0</span>   <span class="number">1.0</span></span><br><span class="line"><span class="number">2</span>   <span class="number">2.0</span>   <span class="number">7.0</span>   <span class="number">8.0</span>   <span class="number">2.0</span></span><br><span class="line"><span class="number">3</span>   <span class="number">2.0</span>   <span class="number">7.0</span>   <span class="number">8.0</span>   <span class="number">2.0</span></span><br><span class="line">********************</span><br><span class="line"><span class="number">0</span>    <span class="number">1.0</span></span><br><span class="line"><span class="number">1</span>    <span class="number">1.0</span></span><br><span class="line"><span class="number">2</span>    <span class="number">2.0</span></span><br><span class="line"><span class="number">3</span>    <span class="number">2.0</span></span><br><span class="line">Name: col1, dtype: float64</span><br><span class="line">********************</span><br><span class="line">   col1  col2</span><br><span class="line"><span class="number">0</span>   <span class="number">1.0</span>   <span class="number">0.0</span></span><br><span class="line"><span class="number">1</span>   <span class="number">1.0</span>   <span class="number">2.0</span></span><br><span class="line"><span class="number">2</span>   <span class="number">2.0</span>   <span class="number">7.0</span></span><br><span class="line"><span class="number">3</span>   <span class="number">2.0</span>   <span class="number">7.0</span></span><br><span class="line">********************</span><br><span class="line">   <span class="built_in">sum</span>      mean</span><br><span class="line"><span class="number">0</span>  <span class="number">1.0</span>  <span class="number">1.000000</span></span><br><span class="line"><span class="number">1</span>  <span class="number">1.0</span>  <span class="number">0.500000</span></span><br><span class="line"><span class="number">2</span>  <span class="number">2.0</span>  <span class="number">0.666667</span></span><br><span class="line"><span class="number">3</span>  <span class="number">2.0</span>  <span class="number">0.666667</span></span><br><span class="line">********************</span><br><span class="line">  col1           col2          </span><br><span class="line">   <span class="built_in">sum</span>      mean  <span class="built_in">sum</span>      mean</span><br><span class="line"><span class="number">0</span>  <span class="number">1.0</span>  <span class="number">1.000000</span>  <span class="number">0.0</span>  <span class="number">0.000000</span></span><br><span class="line"><span class="number">1</span>  <span class="number">1.0</span>  <span class="number">0.500000</span>  <span class="number">2.0</span>  <span class="number">1.000000</span></span><br><span class="line"><span class="number">2</span>  <span class="number">2.0</span>  <span class="number">0.666667</span>  <span class="number">7.0</span>  <span class="number">2.333333</span></span><br><span class="line"><span class="number">3</span>  <span class="number">2.0</span>  <span class="number">0.666667</span>  <span class="number">7.0</span>  <span class="number">2.333333</span></span><br><span class="line">********************</span><br><span class="line">   col1      col2</span><br><span class="line"><span class="number">0</span>   <span class="number">1.0</span>  <span class="number">0.000000</span></span><br><span class="line"><span class="number">1</span>   <span class="number">1.0</span>  <span class="number">1.000000</span></span><br><span class="line"><span class="number">2</span>   <span class="number">2.0</span>  <span class="number">2.333333</span></span><br><span class="line"><span class="number">3</span>   <span class="number">2.0</span>  <span class="number">2.333333</span></span><br></pre></td></tr></table></figure><h4 id="groupby分组操作">👁groupby分组操作</h4><p>在数据分析中，经常会遇到这样的情况：根据某一列（或多列）标签把数据划分为不同的组别，然后再对其进行数据分析。比如，某网站对注册用户的性别或者年龄等进行分组，从而研究出网站用户的画像（特点）。在<code>Pandas</code> 中，要完成数据的分组操作，需要使用<code>groupby()</code>函数，它和<code>SQL</code>的<code>GROUP BY</code>操作非常相似。 在划分出来的组（<code>group</code>）上应用一些统计函数，从而达到数据分析的目的，比如对分组数据进行聚合、转换，或者过滤。这个过程主要包含以下三步：</p><ul><li>拆分（<code>Spliting</code>）：表示对数据进行分组；</li><li>应用（<code>Applying</code>）：对分组数据应用聚合函数，进行相应计算；</li><li>合并（<code>Combining</code>）：最后汇总计算结果。</li></ul><p>使用<code>groupby()</code>可以沿着任意轴分组。您可以把分组时指定的键（<code>key</code>）作为每组的组名，方法如下所示：</p><ul><li><code>df.groupby("key")</code></li><li><code>df.groupby("key",axis=1)</code></li><li><code>df.groupby(["key1","key2"])</code></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">data = &#123;<span class="string">&#x27;name&#x27;</span>: [<span class="string">&#x27;John&#x27;</span>, <span class="string">&#x27;Helen&#x27;</span>, <span class="string">&#x27;John&#x27;</span>, <span class="string">&#x27;Ella&#x27;</span>],</span><br><span class="line">   <span class="string">&#x27;score&#x27;</span>: [<span class="number">82</span>, <span class="number">98</span>, <span class="number">91</span>, <span class="number">87</span>],</span><br><span class="line">   <span class="string">&#x27;option_course&#x27;</span>: [<span class="string">&#x27;C#&#x27;</span>,<span class="string">&#x27;Python&#x27;</span>,<span class="string">&#x27;Java&#x27;</span>,<span class="string">&#x27;C&#x27;</span>]&#125;</span><br><span class="line">df = pd.DataFrame(data)</span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 生成分组groupby对象</span></span><br><span class="line"><span class="built_in">print</span>(df.groupby(<span class="string">&#x27;score&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 查看分组,通过调用groups属性查看分组结果</span></span><br><span class="line"><span class="built_in">print</span>(df.groupby(<span class="string">&#x27;score&#x27;</span>).groups)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 多个列标签分组</span></span><br><span class="line"><span class="built_in">print</span>(df.groupby([<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;score&#x27;</span>]).groups)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 通过 get_group()方法可以选择组内的具体数据项</span></span><br><span class="line"><span class="built_in">print</span>(df.groupby(<span class="string">&#x27;score&#x27;</span>).get_group(<span class="number">91</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 遍历分组数据</span></span><br><span class="line">grouped=df.groupby(<span class="string">&#x27;score&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> label, option_course <span class="keyword">in</span> grouped:</span><br><span class="line"><span class="comment"># 其中key代表分组后字典的键，也就是score</span></span><br><span class="line">    <span class="built_in">print</span>(label)</span><br><span class="line"><span class="comment"># 字典对应的值选修的科目</span></span><br><span class="line">    <span class="built_in">print</span>(option_course)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 通过agg()函数可以对分组对象应用多个聚合函数</span></span><br><span class="line">grouped_name = df.groupby(<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line"><span class="comment"># 应用一个聚合函数求均值</span></span><br><span class="line"><span class="built_in">print</span>(grouped_name[<span class="string">&#x27;score&#x27;</span>].agg(np.mean))</span><br><span class="line"><span class="comment"># 应用多个聚合函数求均值</span></span><br><span class="line"><span class="built_in">print</span>(grouped_name[<span class="string">&#x27;score&#x27;</span>].agg([np.size,np.mean,np.std]))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 组的数据过滤操作,筛选出名字出现超过两次的人名</span></span><br><span class="line"><span class="built_in">print</span>(grouped_name.<span class="built_in">filter</span>(<span class="keyword">lambda</span> x: <span class="built_in">len</span>(x) &gt;= <span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">  name  score option_course</span><br><span class="line"><span class="number">0</span>   John     <span class="number">82</span>            C<span class="comment">#</span></span><br><span class="line"><span class="number">1</span>  Helen     <span class="number">98</span>        Python</span><br><span class="line"><span class="number">2</span>   John     <span class="number">91</span>          Java</span><br><span class="line"><span class="number">3</span>   Ella     <span class="number">87</span>             C</span><br><span class="line">********************</span><br><span class="line">&lt;pandas.core.groupby.generic.DataFrameGroupBy <span class="built_in">object</span> at <span class="number">0x000001CB3F4CD948</span>&gt;</span><br><span class="line">********************</span><br><span class="line">&#123;<span class="number">82</span>: Int64Index([<span class="number">0</span>], dtype=<span class="string">&#x27;int64&#x27;</span>), <span class="number">87</span>: Int64Index([<span class="number">3</span>], dtype=<span class="string">&#x27;int64&#x27;</span>), <span class="number">91</span>: Int64Index([<span class="number">2</span>], dtype=<span class="string">&#x27;int64&#x27;</span>), <span class="number">98</span>: Int64Index([<span class="number">1</span>], dtype=<span class="string">&#x27;int64&#x27;</span>)&#125;</span><br><span class="line">********************</span><br><span class="line">&#123;(<span class="string">&#x27;Ella&#x27;</span>, <span class="number">87</span>): Int64Index([<span class="number">3</span>], dtype=<span class="string">&#x27;int64&#x27;</span>), (<span class="string">&#x27;Helen&#x27;</span>, <span class="number">98</span>): Int64Index([<span class="number">1</span>], dtype=<span class="string">&#x27;int64&#x27;</span>), (<span class="string">&#x27;John&#x27;</span>, <span class="number">82</span>): Int64Index([<span class="number">0</span>], dtype=<span class="string">&#x27;int64&#x27;</span>), (<span class="string">&#x27;John&#x27;</span>, <span class="number">91</span>): Int64Index([<span class="number">2</span>], dtype=<span class="string">&#x27;int64&#x27;</span>)&#125;</span><br><span class="line">********************</span><br><span class="line">   name  score option_course</span><br><span class="line"><span class="number">2</span>  John     <span class="number">91</span>          Java</span><br><span class="line">********************</span><br><span class="line"><span class="number">82</span></span><br><span class="line">   name  score option_course</span><br><span class="line"><span class="number">0</span>  John     <span class="number">82</span>            C<span class="comment">#</span></span><br><span class="line"><span class="number">87</span></span><br><span class="line">   name  score option_course</span><br><span class="line"><span class="number">3</span>  Ella     <span class="number">87</span>             C</span><br><span class="line"><span class="number">91</span></span><br><span class="line">   name  score option_course</span><br><span class="line"><span class="number">2</span>  John     <span class="number">91</span>          Java</span><br><span class="line"><span class="number">98</span></span><br><span class="line">    name  score option_course</span><br><span class="line"><span class="number">1</span>  Helen     <span class="number">98</span>        Python</span><br><span class="line">********************</span><br><span class="line">name</span><br><span class="line">Ella     <span class="number">87.0</span></span><br><span class="line">Helen    <span class="number">98.0</span></span><br><span class="line">John     <span class="number">86.5</span></span><br><span class="line">Name: score, dtype: float64</span><br><span class="line">       size  mean       std</span><br><span class="line">name                       </span><br><span class="line">Ella      <span class="number">1</span>  <span class="number">87.0</span>       NaN</span><br><span class="line">Helen     <span class="number">1</span>  <span class="number">98.0</span>       NaN</span><br><span class="line">John      <span class="number">2</span>  <span class="number">86.5</span>  <span class="number">6.363961</span></span><br><span class="line">********************</span><br><span class="line">   name  score option_course</span><br><span class="line"><span class="number">0</span>  John     <span class="number">82</span>            C<span class="comment">#</span></span><br><span class="line"><span class="number">2</span>  John     <span class="number">91</span>          Java</span><br></pre></td></tr></table></figure><p>组的转换操作：通过<code>transform()</code>函数可以实现组的转换，在组的行或列上可以执行转换操作，最终会返回一个与组大小相同的索引对象。</p><p>组的数据过滤操作：通过<code>filter()</code>函数可以实现数据的筛选，该函数根据定义的条件过滤数据并返回一个新的数据集。</p><h4 id="merge合并操作">👁merge合并操作</h4><p><code>Pandas</code>提供的<code>merge()</code>函数能够进行高效的合并操作，这与<code>SQL</code>关系型数据库的<code>MERGE</code>用法非常相似。从字面意思上不难理解，<code>merge</code>翻译为“合并”，指的是将两个<code>DataFrame</code>数据表按照指定的规则进行连接，最后拼接成一个新的<code>DataFrame</code>数据表。<code>merge()</code>函数的法格式如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pd.merge(left, right, how=<span class="string">&#x27;inner&#x27;</span>, on=<span class="literal">None</span>, left_on=<span class="literal">None</span>, right_on=<span class="literal">None</span>, left_index=<span class="literal">False</span>, right_index=<span class="literal">False</span>, sort=<span class="literal">True</span>,suffixes=(<span class="string">&#x27;_x&#x27;</span>, <span class="string">&#x27;_y&#x27;</span>), copy=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">参数说明</span><br><span class="line">left/right: 两个不同的DataFrame对象。</span><br><span class="line">on: 指定用于连接的键（即列标签的名字），该键必须同时存在于左右两个DataFrame中，如果没有指定，并且其他参数也未指定， 那么将会以两个DataFrame的列名交集做为连接键。</span><br><span class="line">left_on: 指定左侧DataFrame中作连接键的列名。该参数在左、右列标签名不相同，但表达的含义相同时非常有用。</span><br><span class="line">right_on: 指定左侧DataFrame中作连接键的列名。</span><br><span class="line">left_index: 布尔参数，默认为<span class="literal">False</span>。如果为<span class="literal">True</span> 则使用左侧DataFrame的行索引作为连接键，若DataFrame具有多层索引(MultiIndex)，则层的数量必须与连接键的数量相等。</span><br><span class="line">right_index: 布尔参数，默认为<span class="literal">False</span>。如果为<span class="literal">True</span> 则使用左侧DataFrame的行索引作为连接键。</span><br><span class="line">how: 要执行的合并类型，从&#123;<span class="string">&#x27;left&#x27;</span>,<span class="string">&#x27;right&#x27;</span>,<span class="string">&#x27;outer&#x27;</span>,<span class="string">&#x27;inner&#x27;</span>&#125; 中取值，默认为“inner”内连接。</span><br><span class="line">sort: 布尔值参数，默认为<span class="literal">True</span>，它会将合并后的数据进行排序；若设置为<span class="literal">False</span>，则按照how给定的参数值进行排序。</span><br><span class="line">suffixes: 字符串组成的元组。当左右DataFrame存在相同列名时，通过该参数可以在相同的列名后附加后缀名，默认为(<span class="string">&#x27;_x&#x27;</span>,<span class="string">&#x27;_y&#x27;</span>)。</span><br><span class="line">copy: 默认为<span class="literal">True</span>，表示对数据进行复制。</span><br></pre></td></tr></table></figure><blockquote><p>注意：<code>Pandas</code>库的<code>merge()</code>支持各种内外连接，与其相似的还有<code>join()</code>函数（默认为左连接）。</p></blockquote><h4 id="concat连接操作">👁concat连接操作</h4><p><code>Pandas</code>通过<code>concat()</code>函数能够轻松地将<code>Series</code>与<code>DataFrame</code>对象组合在一起，函数的语法格式如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pd.concat(objs, axis=<span class="number">0</span>, join=<span class="string">&#x27;outer&#x27;</span>, join_axes=<span class="literal">None</span>, ignore_index=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">参数说明</span><br><span class="line">objs: 一个序列或者是Series、DataFrame对象。</span><br><span class="line">axis: 表示在哪个轴方向上（行或者列）进行连接操作，默认axis=<span class="number">0</span>表示行方向。</span><br><span class="line">join: 指定连接方式，取值为&#123;<span class="string">&quot;inner&quot;</span>,<span class="string">&quot;outer&quot;</span>&#125;，默认为outer表示取并集，inner代表取交集。</span><br><span class="line">ignore_index: 布尔值参数，默认为<span class="literal">False</span>，如果为<span class="literal">True</span>，表示不在连接的轴上使用索引。</span><br><span class="line">join_axes: 表示索引对象的列表。</span><br></pre></td></tr></table></figure><p><code>append()</code>: 如果要连接<code>Series</code>和<code>DataFrame</code>对象，有一个最方便、快捷的方法，就是<code>append()</code>方法。该方法沿着<code>axis=0</code>（行方向）进行操作；<code>append()</code>函数也可接收多个对象。</p><h3 id="pandas绘图">👀Pandas绘图</h3><p><code>Pandas</code>对<code>Matplotlib</code>绘图软件包的基础上单独封装了一个<code>plot()</code>接口，通过调用该接口可以实现常用的绘图操作。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment"># 创建包含时间序列的数据</span></span><br><span class="line">df = pd.DataFrame(np.random.randn(<span class="number">8</span>,<span class="number">4</span>),index=pd.date_range(<span class="string">&#x27;2/1/2020&#x27;</span>,periods=<span class="number">8</span>), columns=<span class="built_in">list</span>(<span class="string">&#x27;ABCD&#x27;</span>))</span><br><span class="line">df.plot()</span><br><span class="line"><span class="comment"># 如果行索引中包含日期，Pandas会自动调用gct().autofmt_xdate()来格式化x轴。</span></span><br></pre></td></tr></table></figure><p>除了使用默认的线条绘图外，您还可以使用其他绘图方式，如下所示：</p><ul><li>柱状图：<code>bar()</code> 或 <code>barh()</code></li><li>直方图：<code>hist()</code></li><li>箱状箱：<code>box()</code></li><li>区域图：<code>area()</code></li><li>散点图：<code>scatter()</code></li></ul><p>通过关键字参数<code>kind</code>可以把上述方法传递给<code>plot()</code>。</p><p>（1）柱状图</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">df = pd.DataFrame(np.random.rand(<span class="number">10</span>,<span class="number">4</span>),columns=[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>])</span><br><span class="line"><span class="comment"># 或使用df.plot(kind=&quot;bar&quot;)</span></span><br><span class="line">df.plot.bar()</span><br><span class="line"><span class="comment"># 通过设置参数stacked=True可以生成柱状堆叠图</span></span><br><span class="line"><span class="comment"># 或者使用df.plot.bar(stacked=&quot;True&quot;)</span></span><br><span class="line">df.plot(kind=<span class="string">&quot;bar&quot;</span>,stacked=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># 如果要绘制水平柱状图</span></span><br><span class="line">df.plot.barh(stacked=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p>（2）直方图</p><p><code>plot.hist()</code>可以实现绘制直方图，并且它还可以指定<code>bins</code>（构成直方图的箱数）。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">df = pd.DataFrame(&#123;<span class="string">&#x27;A&#x27;</span>:np.random.randn(<span class="number">100</span>)+<span class="number">2</span>,<span class="string">&#x27;B&#x27;</span>:np.random.randn(<span class="number">100</span>),<span class="string">&#x27;C&#x27;</span>:np.random.randn(<span class="number">100</span>)-<span class="number">2</span>,<span class="string">&#x27;D&#x27;</span>:np.random.randn(<span class="number">100</span>)+<span class="number">3</span>&#125;,columns=[<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;D&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line"><span class="comment"># 指定箱数为15</span></span><br><span class="line">df.plot.hist(bins=<span class="number">15</span>)</span><br><span class="line"><span class="comment"># 给每一列数据都绘制一个直方图</span></span><br><span class="line">df.diff().hist(color=<span class="string">&quot;r&quot;</span>,alpha=<span class="number">0.5</span>,bins=<span class="number">15</span>)</span><br></pre></td></tr></table></figure><p>（3）箱线图</p><p>通过调用<code>Series.box.plot()</code> 、<code>DataFrame.box.plot()</code>或者<code>DataFrame.boxplot()</code>方法来绘制箱型图，它将每一列数据的分布情况，以可视化的图像展现出来。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">df = pd.DataFrame(np.random.rand(<span class="number">10</span>, <span class="number">4</span>), columns=[<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>])</span><br><span class="line">df.plot.box()</span><br></pre></td></tr></table></figure><p>（4）区域图</p><p>使用<code>Series.plot.area()</code>或<code>DataFrame.plot.area()</code>方法来绘制区域图。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">df = pd.DataFrame(np.random.rand(<span class="number">5</span>, <span class="number">4</span>), columns=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>])</span><br><span class="line">df.plot.area()</span><br></pre></td></tr></table></figure><p>（5）散点图</p><p>使用<code>DataFrame.plot.scatter()</code>方法来绘制散点图。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">df = pd.DataFrame(np.random.rand(<span class="number">30</span>, <span class="number">4</span>), columns=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>])</span><br><span class="line">df.plot.scatter(x=<span class="string">&#x27;a&#x27;</span>,y=<span class="string">&#x27;b&#x27;</span>)</span><br></pre></td></tr></table></figure><p>（6）饼状图</p><p>通过<code>DataFrame.plot.pie()</code>方法来绘制。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">df = pd.DataFrame(<span class="number">3</span> * np.random.rand(<span class="number">4</span>), index=[<span class="string">&#x27;go&#x27;</span>, <span class="string">&#x27;java&#x27;</span>, <span class="string">&#x27;c++&#x27;</span>, <span class="string">&#x27;c&#x27;</span>], columns=[<span class="string">&#x27;L&#x27;</span>])</span><br><span class="line">df.plot.pie(subplots=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><h2 id="pandas和numpy的比较">⛄Pandas和NumPy的比较</h2><p><code>Pandas</code>和<code>NumPy</code>被认为是科学计算与机器学习中必不可少的库，因为它们具有直观的语法和高性能的矩阵计算能力。</p><table><thead><tr class="header"><th>比较项</th><th>Pandas</th><th>NumPy</th></tr></thead><tbody><tr class="odd"><td>适应性</td><td><code>Pandas</code>主要用来处理类表格数据。</td><td><code>NumPy</code>主要用来处理数值数据。</td></tr><tr class="even"><td>工具</td><td><code>Pandas</code>提供了<code>Series</code>和<code>DataFrame</code>数据结构。</td><td><code>NumPy</code>构建了<code>ndarray array</code>来容纳数据。</td></tr><tr class="odd"><td>性能</td><td><code>Pandas</code>对于处理50万行以上的数据更具优势。</td><td><code>NumPy</code>则对于50万以下或者更少的数据，性能更佳。</td></tr><tr class="even"><td>内存利用率</td><td>与<code>NumPy</code>相比，<code>Pandas</code>会消耗大量的内存。</td><td><code>NumPy</code>会消耗较少的内存。</td></tr><tr class="odd"><td>对象</td><td><code>Pandas</code>提供了<code>DataFrame 2D</code>数据表对象。</td><td><code>NumPy</code>则提供了一个多维数组<code>ndarray</code>对象</td></tr></tbody></table><p>在某些情况下，需要执行一些<code>NumPy</code>数值计算的高级函数，这个时候您可以使用<code>to_numpy()</code>函数，将<code>DataFrame</code>对象转换为<code>NumPy ndarray</code>数组，并将其返回。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">DataFrame.to_numpy(dtype=<span class="literal">None</span>, copy=<span class="literal">False</span>)   </span><br><span class="line">参数说明如下：</span><br><span class="line">    dtype：可选参数，表示数据类型；</span><br><span class="line">    copy：布尔值参数，默认值为 Fales，表示返回值不是其他数组的视图。</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd </span><br><span class="line"><span class="comment">#创建DataFrame对象</span></span><br><span class="line">info = pd.DataFrame([[<span class="number">17</span>,<span class="number">62</span>,<span class="number">35</span>],[<span class="number">25</span>,<span class="number">36</span>,<span class="number">54</span>],[<span class="number">42</span>,<span class="number">20</span>,<span class="number">15</span>],[<span class="number">48</span>,<span class="number">62</span>,<span class="number">76</span>]], columns=[<span class="string">&#x27;x&#x27;</span>,<span class="string">&#x27;y&#x27;</span>,<span class="string">&#x27;z&#x27;</span>]) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;DataFrame\n----------\n&#x27;</span>, info) </span><br><span class="line"><span class="comment">#转换DataFrame为数组array</span></span><br><span class="line">arr = info.to_numpy() </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\nNumpy Array\n----------\n&#x27;</span>, arr)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">DataFrame</span><br><span class="line">----------</span><br><span class="line">     x   y   z</span><br><span class="line"><span class="number">0</span>  <span class="number">17</span>  <span class="number">62</span>  <span class="number">35</span></span><br><span class="line"><span class="number">1</span>  <span class="number">25</span>  <span class="number">36</span>  <span class="number">54</span></span><br><span class="line"><span class="number">2</span>  <span class="number">42</span>  <span class="number">20</span>  <span class="number">15</span></span><br><span class="line"><span class="number">3</span>  <span class="number">48</span>  <span class="number">62</span>  <span class="number">76</span></span><br><span class="line"></span><br><span class="line">Numpy Array</span><br><span class="line">----------</span><br><span class="line"> [[<span class="number">17</span> <span class="number">62</span> <span class="number">35</span>]</span><br><span class="line"> [<span class="number">25</span> <span class="number">36</span> <span class="number">54</span>]</span><br><span class="line"> [<span class="number">42</span> <span class="number">20</span> <span class="number">15</span>]</span><br><span class="line"> [<span class="number">48</span> <span class="number">62</span> <span class="number">76</span>]]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 科学计算 </tag>
            
            <tag> 数据分析 </tag>
            
            <tag> Pandas </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python之NumPy详解</title>
      <link href="/2023/02/13/Python-Numpy/"/>
      <url>/2023/02/13/Python-Numpy/</url>
      
        <content type="html"><![CDATA[<p><code>NumPy</code>(Numerical Python) 是<code>Python</code>语言的一个数值计算扩展程序库，支持大量的维度数组与矩阵运算，此外也针对数组运算提供大量的数学函数库。</p><p><code>NumPy</code>的前身<code>Numeric</code>最早是由Jim Hugunin与其它协作者共同开发，2005年，Travis Oliphant在<code>Numeric</code>中结合了另一个同性质的程序库<code>Numarray</code>的特色，并加入了其它扩展而开发了<code>NumPy</code>。<code>NumPy</code>为开放源代码并且由许多协作者共同维护开发。</p><p><code>NumPy</code>是一个运行速度非常快的数学库，主要用于数组计算，包含：</p><ul><li>一个强大的N维数组对象<code>ndarray</code>，对数组进行函数运算；</li><li>数值积分；</li><li>广播功能函数；</li><li>整合<code>C/C++/Fortran</code>代码的工具；</li><li>线性代数、傅里叶变换、随机数生成等功能。</li></ul><p><code>NumPy</code>通常与<code>SciPy</code>（Scientific Python）和<code>Matplotlib</code>（绘图库）一起使用， 这种组合广泛用于替代<code>MatLab</code>，是一个强大的科学计算环境，有助于我们通过<code>Python</code>学习数据科学或者机器学习。</p><p><code>SciPy</code>是一个开源的<code>Python</code>算法库和数学工具包。<code>SciPy</code>包含的模块有<strong>最优化</strong>、<strong>线性代数</strong>、<strong>积分</strong>、<strong>插值</strong>、<strong>特殊函数</strong>、<strong>快速傅里叶变换</strong>、<strong>信号处理和图像处理</strong>、<strong>常微分方程求解</strong>和其他科学与工程中常用的计算。</p><p><code>Matplotlib</code>是<code>Python</code>编程语言及其数值数学扩展包<code>NumPy</code>的可视化操作界面。它为利用通用的图形用户界面工具包，如<code>Tkinter</code>, <code>wxPython</code>, <code>Qt</code>或<code>GTK+</code>向应用程序嵌入式绘图提供了应用程序接（<code>API</code>）。</p><p>标准的<code>Python</code>中用<code>list</code>（列表）保存值，可以当做数组使用，但因为列表中的元素可以是任何对象，所以浪费了<code>CPU</code>运算时间和内存。NumPy诞生为了弥补这些缺陷，它提供了两种基本的对象。</p><ul><li><code>ndarray</code>：全称（n-dimensional array object）是储存<strong>单一数据类型</strong>的多维数组；</li><li><code>ufunc</code>：全称（universal function object）它是一种能够对数组进行处理的函数。</li></ul><p><code>NumPy</code>官网（<a href="https://numpy.org/%EF%BC%89">https://numpy.org/）</a></p><p><code>SciPy</code>官网（<a href="https://scipy.org/%EF%BC%89">https://scipy.org/）</a></p><p><code>Matplotlib</code>官网（<a href="https://matplotlib.org/%EF%BC%89">https://matplotlib.org/）</a></p><h2 id="⛄ndarray对象"><a href="#⛄ndarray对象" class="headerlink" title="⛄ndarray对象"></a>⛄ndarray对象</h2><p><code>NumPy</code>最重要的一个特点是其<code>N</code>维数组对象<code>ndarray</code>，它是一系列同类型数据的集合，以<code>0</code>下标为开始进行集合中元素的索引。<code>NumPy</code>里面所有的函数都是围绕<code>ndarray</code>展开的。</p><p><code>ndarray</code>对象是用于存放同类型元素的多维数组。</p><p><code>ndarray</code>中的每个元素在内存中都有相同存储大小的区域。</p><p><code>ndarray</code>内部由以下内容组成：</p><ul><li>一个指向数据（内存或内存映射文件中的一块数据）的指针；</li><li>数据类型或<code>dtype</code>，描述在数组中的固定大小值的格子；</li><li>一个表示数组形状（<code>shape</code>）的元组，表示各维度大小的元组；</li><li>一个跨度元组（<code>stride</code>），其中的整数指的是为了前进到当前维度下一个元素需要”跨过”的字节数。跨度可以是负数，这样会使数组在内存中后向移动，切片中 <strong>obj[::-1]</strong> 或 <strong>obj[:,::-1]</strong> 就是如此</li></ul><h3 id="👀ndarray的创建"><a href="#👀ndarray的创建" class="headerlink" title="👀ndarray的创建"></a>👀ndarray的创建</h3><h4 id="👁numpy-array-函数创建"><a href="#👁numpy-array-函数创建" class="headerlink" title="👁numpy.array()函数创建"></a>👁<code>numpy.array()</code>函数创建</h4><p>创建一个<code>ndarray</code>只需调用<code>NumPy</code>的<code>array</code>函数即可：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numpy.array(<span class="built_in">object</span>, dtype = <span class="literal">None</span>, copy = <span class="literal">True</span>, order = <span class="literal">None</span>, subok = <span class="literal">False</span>, ndmin = <span class="number">0</span>)</span><br><span class="line"><span class="comment"># 参数说明</span></span><br><span class="line"><span class="built_in">object</span>数组或嵌套的数列</span><br><span class="line">dtype数组元素的数据类型，可选</span><br><span class="line">copy对象是否需要复制，可选</span><br><span class="line">order创建数组的样式，C为行方向，F为列方向，A为任意方向（默认）</span><br><span class="line">subok默认返回一个与基类类型一致的数组</span><br><span class="line">ndmin指定生成数组的最小维度</span><br><span class="line"></span><br><span class="line"><span class="comment"># 例子</span></span><br><span class="line"><span class="comment"># dtype参数  </span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line">a = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], dtype = <span class="built_in">complex</span>)  </span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[<span class="number">1.</span>+<span class="number">0.j</span> <span class="number">2.</span>+<span class="number">0.j</span> <span class="number">3.</span>+<span class="number">0.j</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 最小维度  </span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line">a = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>], ndmin = <span class="number">2</span>)  </span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span>]]</span><br></pre></td></tr></table></figure><p><code>ndarray</code>对象由计算机内存的连续一维部分组成，并结合索引模式，将每个元素映射到内存块中的一个位置。内存块以行顺序(<code>C</code>样式)或列顺序(<code>FORTRAN</code>或<code>MatLab</code>风格，即前述的<code>F</code>样式)来保存元素。</p><h4 id="👁特殊函数创建"><a href="#👁特殊函数创建" class="headerlink" title="👁特殊函数创建"></a>👁特殊函数创建</h4><ul><li><code>numpy.empty()</code></li><li><code>numpy.zeros()</code></li><li><code>numpy.ones()</code></li><li><code>numpy.full()</code></li><li><code>numpy.random.*</code></li><li><code>numpy.eye()</code></li><li>……</li></ul><p>（1）<code>numpy.empty()</code>方法用来创建一个指定形状（<code>shape</code>）、数据类型（<code>dtype</code>）且未初始化的数组：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numpy.empty(shape, dtype = <span class="built_in">float</span>, order = <span class="string">&#x27;C&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 参数说明</span></span><br><span class="line">shape数组形状，可以是<span class="built_in">int</span>或是元组，也可以是列表，如：（<span class="number">3</span>，<span class="number">4</span>）<span class="keyword">or</span> <span class="number">3</span> <span class="keyword">or</span> [<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">dtype数据类型，可选</span><br><span class="line">order有<span class="string">&quot;C&quot;</span>和<span class="string">&quot;F&quot;</span>两个选项,分别代表，行优先和列优先，在计算机内存中的存储元素的顺序。</span><br><span class="line"></span><br><span class="line"><span class="comment"># 例子</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line">x = np.empty([<span class="number">3</span>,<span class="number">2</span>], dtype = <span class="built_in">int</span>) </span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[[ <span class="number">6917529027641081856</span>  <span class="number">5764616291768666155</span>]</span><br><span class="line"> [ <span class="number">6917529027641081859</span> -<span class="number">5764598754299804209</span>]</span><br><span class="line"> [          <span class="number">4497473538</span>      <span class="number">844429428932120</span>]]</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>：数组元素为随机值，因为它们未初始化。</p></blockquote><p>（2）<code>numpy.zeros()</code>创建指定大小的数组，数组元素以0来填充：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numpy.zeros(shape, dtype = <span class="built_in">float</span>, order = <span class="string">&#x27;C&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 参数说明</span></span><br><span class="line">shape数组形状</span><br><span class="line">dtype数据类型，可选</span><br><span class="line">order<span class="string">&#x27;C&#x27;</span>用于C的行数组，或者<span class="string">&#x27;F&#x27;</span>用于FORTRAN的列数组</span><br><span class="line"></span><br><span class="line"><span class="comment"># 例子</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment"># 默认为浮点数</span></span><br><span class="line">x = np.zeros(<span class="number">5</span>) </span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line"><span class="comment"># 设置类型为整数</span></span><br><span class="line">y = np.zeros((<span class="number">5</span>,), dtype = <span class="built_in">int</span>) </span><br><span class="line"><span class="built_in">print</span>(y)</span><br><span class="line"><span class="comment"># 自定义类型</span></span><br><span class="line">z = np.zeros((<span class="number">2</span>,<span class="number">2</span>), dtype = [(<span class="string">&#x27;x&#x27;</span>,<span class="string">&#x27;i4&#x27;</span>), (<span class="string">&#x27;y&#x27;</span>,<span class="string">&#x27;i4&#x27;</span>)])  </span><br><span class="line"><span class="built_in">print</span>(z)</span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[<span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span>]</span><br><span class="line">[<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br><span class="line">[[(<span class="number">0</span>, <span class="number">0</span>) (<span class="number">0</span>, <span class="number">0</span>)]</span><br><span class="line"> [(<span class="number">0</span>, <span class="number">0</span>) (<span class="number">0</span>, <span class="number">0</span>)]]</span><br></pre></td></tr></table></figure><p>（3）<code>numpy.ones()</code>创建指定形状的数组，数组元素以1来填充：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numpy.ones(shape, dtype = <span class="literal">None</span>, order = <span class="string">&#x27;C&#x27;</span>)</span><br><span class="line"><span class="comment"># 参数说明</span></span><br><span class="line">shape数组形状</span><br><span class="line">dtype数据类型，可选</span><br><span class="line">order<span class="string">&#x27;C&#x27;</span> 用于C的行数组，或者<span class="string">&#x27;F&#x27;</span>用于 FORTRAN 的列数组</span><br><span class="line"></span><br><span class="line"><span class="comment"># 例子</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment"># 默认为浮点数</span></span><br><span class="line">x = np.ones(<span class="number">5</span>) </span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line"><span class="comment"># 自定义类型</span></span><br><span class="line">x = np.ones([<span class="number">2</span>,<span class="number">2</span>], dtype = <span class="built_in">int</span>)</span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[<span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span>]</span><br><span class="line">[[<span class="number">1</span> <span class="number">1</span>]</span><br><span class="line"> [<span class="number">1</span> <span class="number">1</span>]]</span><br></pre></td></tr></table></figure><p>（4）<code>numpy.full()</code>创建指定形状的数组，数组元素以<code>fill_value</code>来填充：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numpy.full(shape, fill_value, dtype=<span class="literal">None</span>, order=<span class="string">&#x27;C&#x27;</span>)</span><br><span class="line"><span class="comment"># 参数说明</span></span><br><span class="line">shape数组形状</span><br><span class="line">fill_value填充值（标量或类似数组）</span><br><span class="line">dtype数据类型，可选</span><br><span class="line">order<span class="string">&#x27;C&#x27;</span> 用于C的行数组，或者<span class="string">&#x27;F&#x27;</span>用于 FORTRAN 的列数组</span><br><span class="line"></span><br><span class="line"><span class="comment"># 例子</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = np.full((<span class="number">2</span>,<span class="number">2</span>),np.pi)</span><br><span class="line">b = np.full((<span class="number">2</span>,<span class="number">2</span>),<span class="number">1</span>)</span><br><span class="line">c = np.full((<span class="number">2</span>,<span class="number">2</span>),[<span class="number">1</span>,<span class="number">2</span>])</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[[<span class="number">3.14159265</span> <span class="number">3.14159265</span>]</span><br><span class="line"> [<span class="number">3.14159265</span> <span class="number">3.14159265</span>]]</span><br><span class="line">[[<span class="number">1</span> <span class="number">1</span>]</span><br><span class="line"> [<span class="number">1</span> <span class="number">1</span>]]</span><br><span class="line">[[<span class="number">1</span> <span class="number">2</span>]</span><br><span class="line"> [<span class="number">1</span> <span class="number">2</span>]]</span><br></pre></td></tr></table></figure><p>（5）<code>numpy.random.*</code></p><p>在<code>Python</code>中，有两个模块可以产生随机数：</p><ul><li>python自带<code>random</code>包： 提供一些基本的随机数产生函数，可满足基本需要；</li><li><code>numpy.random</code>：提供一些产生随机数的高级函数，满足高级需求。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> random</span><br><span class="line"><span class="comment"># 例子1 Numpy创建标准正态分布数组</span></span><br><span class="line"><span class="comment"># 创建randn(size)服从X~N(0,1)的正态分布随机数组</span></span><br><span class="line">a = random.randn(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[[-<span class="number">0.75827863</span> -<span class="number">0.0696867</span>  -<span class="number">2.23015832</span>]</span><br><span class="line"> [-<span class="number">0.57744225</span> -<span class="number">0.20939873</span> -<span class="number">1.2368758</span> ]]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 例子2 Numpy创建随机分布整数型数组</span></span><br><span class="line"><span class="comment"># 利用randint([low,high],size)创建一个整数型指定范围在[low.high]之间的数组</span></span><br><span class="line">b=random.randint(<span class="number">100</span>,<span class="number">300</span>,(<span class="number">4</span>,<span class="number">4</span>))</span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[[<span class="number">130</span> <span class="number">136</span> <span class="number">156</span> <span class="number">208</span>]</span><br><span class="line"> [<span class="number">221</span> <span class="number">241</span> <span class="number">124</span> <span class="number">244</span>]</span><br><span class="line"> [<span class="number">203</span> <span class="number">266</span> <span class="number">160</span> <span class="number">222</span>]</span><br><span class="line"> [<span class="number">142</span> <span class="number">183</span> <span class="number">203</span> <span class="number">215</span>]]</span><br></pre></td></tr></table></figure><p>（6）<code>numpy.eye()</code></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment"># 创建对角矩阵数组</span></span><br><span class="line">a = np.eye(<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[[<span class="number">1.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span>]</span><br><span class="line"> [<span class="number">0.</span> <span class="number">1.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span>]</span><br><span class="line"> [<span class="number">0.</span> <span class="number">0.</span> <span class="number">1.</span> <span class="number">0.</span> <span class="number">0.</span>]</span><br><span class="line"> [<span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">1.</span> <span class="number">0.</span>]</span><br><span class="line"> [<span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">1.</span>]]</span><br></pre></td></tr></table></figure><h4 id="👁NumPy从已有的数组创建数组"><a href="#👁NumPy从已有的数组创建数组" class="headerlink" title="👁NumPy从已有的数组创建数组"></a>👁<code>NumPy</code>从已有的数组创建数组</h4><ul><li><code>numpy.asarray()</code></li><li><code>numpy.frombuffer()</code></li><li><code>numpy.fromiter()</code></li></ul><p>（1）<code>numpy.asarray()</code></p><p><code>numpy.asarray()</code>类似<code>numpy.array()</code>，但<code>numpy.asarray()</code>参数只有三个。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numpy.asarray(a, dtype = <span class="literal">None</span>, order = <span class="literal">None</span>)</span><br><span class="line"><span class="comment"># 参数说明</span></span><br><span class="line">a任意形式的输入参数，可以是：列表、列表的元组、元组、元组的元组、元组的列表、多维数组</span><br><span class="line">dtype数据类型，可选</span><br><span class="line">order可选，有<span class="string">&quot;C&quot;</span>和<span class="string">&quot;F&quot;</span>两个选项,分别代表，行优先和列优先，在计算机内存中的存储元素的顺序。</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment"># 将列表转换为ndarray</span></span><br><span class="line">x = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">a1 = np.asarray(x)  </span><br><span class="line">a2 = np.asarray(x, dtype = <span class="built_in">float</span>)  </span><br><span class="line"><span class="built_in">print</span>(a1)</span><br><span class="line"><span class="built_in">print</span>(a2)</span><br><span class="line"><span class="comment"># 将元组转换为ndarray</span></span><br><span class="line">y = (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>) </span><br><span class="line">b = np.asarray(y)  </span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="comment"># 将元组列表转换为ndarray</span></span><br><span class="line">z = [(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>),(<span class="number">4</span>,<span class="number">5</span>)] </span><br><span class="line">c = np.asarray(z)  </span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]</span><br><span class="line">[<span class="number">1.</span> <span class="number">2.</span> <span class="number">3.</span>]</span><br><span class="line">[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]</span><br><span class="line">[(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) (<span class="number">4</span>, <span class="number">5</span>)]</span><br></pre></td></tr></table></figure><p>（2）<code>numpy.frombuffer()</code></p><p><code>numpy.frombuffer()</code>用于实现动态数组。</p><p><code>numpy.frombuffer()</code>接受buffer输入参数，以流的形式读入转化成ndarray对象。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numpy.frombuffer(buffer, dtype = <span class="built_in">float</span>, count = -<span class="number">1</span>, offset = <span class="number">0</span>)</span><br><span class="line"><span class="comment"># 注意：buffer是字符串的时候，Python3默认str是Unicode类型，所以要转成bytestring在原str前加上b。</span></span><br><span class="line">buffer可以是任意对象，会以流的形式读入。</span><br><span class="line">dtype返回数组的数据类型，可选</span><br><span class="line">count读取的数据数量，默认为-<span class="number">1</span>，读取所有数据。</span><br><span class="line">offset读取的起始位置，默认为<span class="number">0</span>。</span><br><span class="line"></span><br><span class="line"><span class="comment"># Python3例子</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"><span class="built_in">str</span> = <span class="string">b&#x27;Hello World9527&#x27;</span> </span><br><span class="line">a = np.frombuffer(<span class="built_in">str</span>, dtype = <span class="string">&#x27;S1&#x27;</span>)  </span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[<span class="string">b&#x27;H&#x27;</span> <span class="string">b&#x27;e&#x27;</span> <span class="string">b&#x27;l&#x27;</span> <span class="string">b&#x27;l&#x27;</span> <span class="string">b&#x27;o&#x27;</span> <span class="string">b&#x27; &#x27;</span> <span class="string">b&#x27;W&#x27;</span> <span class="string">b&#x27;o&#x27;</span> <span class="string">b&#x27;r&#x27;</span> <span class="string">b&#x27;l&#x27;</span> <span class="string">b&#x27;d&#x27;</span> <span class="string">b&#x27;9&#x27;</span> <span class="string">b&#x27;5&#x27;</span> <span class="string">b&#x27;2&#x27;</span> <span class="string">b&#x27;7&#x27;</span>]</span><br></pre></td></tr></table></figure><p>（3）<code>numpy.fromiter()</code></p><p><code>numpy.fromiter()</code>方法从可迭代对象中建立ndarray对象，返回一维数组。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numpy.fromiter(iterable, dtype, count=-<span class="number">1</span>)</span><br><span class="line"><span class="comment"># 参数说明</span></span><br><span class="line">iterable可迭代对象</span><br><span class="line">dtype返回数组的数据类型</span><br><span class="line">count读取的数据数量，默认为-<span class="number">1</span>，读取所有数据</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"><span class="comment"># 使用range函数创建列表对象  </span></span><br><span class="line"><span class="built_in">list</span>=<span class="built_in">range</span>(<span class="number">5</span>)</span><br><span class="line">it=<span class="built_in">iter</span>(<span class="built_in">list</span>)</span><br><span class="line"><span class="built_in">print</span>(it)</span><br><span class="line"><span class="comment"># 使用迭代器创建 ndarray </span></span><br><span class="line">x=np.fromiter(it, dtype = <span class="built_in">float</span>)</span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">&lt;range_iterator <span class="built_in">object</span> at <span class="number">0x0000023512CA7E70</span>&gt;</span><br><span class="line">[<span class="number">0.</span> <span class="number">1.</span> <span class="number">2.</span> <span class="number">3.</span> <span class="number">4.</span>]</span><br></pre></td></tr></table></figure><h4 id="👁NumPy从数值范围创建数组"><a href="#👁NumPy从数值范围创建数组" class="headerlink" title="👁NumPy从数值范围创建数组"></a>👁<code>NumPy</code>从数值范围创建数组</h4><ul><li><code>numpy.arange()</code></li><li><code>numpy.linspace()</code></li><li><code>numpy.logspace()</code></li></ul><p>（1）<code>numpy.arange()</code></p><p><code>numpy</code>包中的使用<code>arange</code>函数创建数值范围并返回ndarray对象，函数格式如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numpy.arange(start, stop, step, dtype)</span><br><span class="line"><span class="comment"># 根据start与stop指定的范围以及step设定的步长，生成一个ndarray</span></span><br><span class="line"><span class="comment"># 参数说明</span></span><br><span class="line">start起始值，默认为<span class="number">0</span></span><br><span class="line">stop终止值（不包含）</span><br><span class="line">step步长，默认为<span class="number">1</span></span><br><span class="line">dtype返回ndarray的数据类型，如果没有提供，则会使用输入数据的类型。</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a1 = np.arange(<span class="number">10</span>)</span><br><span class="line">a2 = np.arange(<span class="number">10</span>, dtype = <span class="built_in">float</span>)</span><br><span class="line">b = np.arange(<span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line">c = np.arange(<span class="number">10</span>, <span class="number">20</span>, <span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(a1)</span><br><span class="line"><span class="built_in">print</span>(a2)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span>]</span><br><span class="line">[<span class="number">0.</span> <span class="number">1.</span> <span class="number">2.</span> <span class="number">3.</span> <span class="number">4.</span> <span class="number">5.</span> <span class="number">6.</span> <span class="number">7.</span> <span class="number">8.</span> <span class="number">9.</span>]</span><br><span class="line">[<span class="number">10</span> <span class="number">11</span> <span class="number">12</span> <span class="number">13</span> <span class="number">14</span> <span class="number">15</span> <span class="number">16</span> <span class="number">17</span> <span class="number">18</span> <span class="number">19</span>]</span><br><span class="line">[<span class="number">10</span> <span class="number">12</span> <span class="number">14</span> <span class="number">16</span> <span class="number">18</span>]</span><br></pre></td></tr></table></figure><p>（2）<code>numpy.linspace()</code></p><p><code>numpy.linspace</code>函数用于创建一个一维数组，数组是一个等差数列构成的，格式如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.linspace(start, stop, num=<span class="number">50</span>, endpoint=<span class="literal">True</span>, retstep=<span class="literal">False</span>, dtype=<span class="literal">None</span>)</span><br><span class="line"><span class="comment"># 参数说明</span></span><br><span class="line">start序列的起始值</span><br><span class="line">stop序列的终止值，如果endpoint为true，该值包含于数列中</span><br><span class="line">num要生成的等步长的样本数量，默认为<span class="number">50</span></span><br><span class="line">endpoint该值为true时，数列中包含stop值，反之不包含，默认是<span class="literal">True</span>。</span><br><span class="line">retstep如果为<span class="literal">True</span>时，生成的数组中会显示间距，反之不显示。</span><br><span class="line">dtypendarray的数据类型</span><br><span class="line"></span><br><span class="line"><span class="comment"># 例子1</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = np.linspace(<span class="number">1</span>,<span class="number">10</span>,<span class="number">10</span>)</span><br><span class="line">b = np.linspace(<span class="number">1</span>,<span class="number">1</span>,<span class="number">10</span>)</span><br><span class="line">c = np.linspace(<span class="number">10</span>, <span class="number">20</span>, <span class="number">5</span>, endpoint = <span class="literal">False</span>) </span><br><span class="line">d = np.linspace(<span class="number">10</span>, <span class="number">20</span>, <span class="number">5</span>)  </span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line"><span class="built_in">print</span>(d)</span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[<span class="number">1.</span> <span class="number">2.</span> <span class="number">3.</span> <span class="number">4.</span> <span class="number">5.</span> <span class="number">6.</span> <span class="number">7.</span> <span class="number">8.</span> <span class="number">9.</span> <span class="number">10.</span>]</span><br><span class="line">[<span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span>]</span><br><span class="line">[<span class="number">10.</span> <span class="number">12.</span> <span class="number">14.</span> <span class="number">16.</span> <span class="number">18.</span>]</span><br><span class="line">[<span class="number">10.</span> <span class="number">12.5</span> <span class="number">15.</span> <span class="number">17.5</span> <span class="number">20.</span> ]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 例子2</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">e1 = np.linspace(<span class="number">1</span>,<span class="number">10</span>,<span class="number">10</span>,retstep= <span class="literal">True</span>)</span><br><span class="line">e2 = np.linspace(<span class="number">1</span>,<span class="number">10</span>,<span class="number">5</span>,retstep= <span class="literal">True</span>) </span><br><span class="line"><span class="built_in">print</span>(e1)</span><br><span class="line"><span class="built_in">print</span>(e2)</span><br><span class="line"><span class="comment"># 拓展例子</span></span><br><span class="line">f = np.linspace(<span class="number">1</span>,<span class="number">10</span>,<span class="number">10</span>).reshape([<span class="number">10</span>,<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(f)</span><br><span class="line"><span class="comment">#输出结果</span></span><br><span class="line">(array([ <span class="number">1.</span>,  <span class="number">2.</span>,  <span class="number">3.</span>,  <span class="number">4.</span>,  <span class="number">5.</span>,  <span class="number">6.</span>,  <span class="number">7.</span>,  <span class="number">8.</span>,  <span class="number">9.</span>, <span class="number">10.</span>]), <span class="number">1.0</span>)</span><br><span class="line">(array([ <span class="number">1.</span>,  <span class="number">3.25</span>,  <span class="number">5.5</span>,  <span class="number">7.75</span>, <span class="number">10.</span>]), <span class="number">2.25</span>)</span><br><span class="line">[[ <span class="number">1.</span>]</span><br><span class="line"> [ <span class="number">2.</span>]</span><br><span class="line"> [ <span class="number">3.</span>]</span><br><span class="line"> [ <span class="number">4.</span>]</span><br><span class="line"> [ <span class="number">5.</span>]</span><br><span class="line"> [ <span class="number">6.</span>]</span><br><span class="line"> [ <span class="number">7.</span>]</span><br><span class="line"> [ <span class="number">8.</span>]</span><br><span class="line"> [ <span class="number">9.</span>]</span><br><span class="line"> [<span class="number">10.</span>]]</span><br></pre></td></tr></table></figure><p>（3）<code>numpy.logspace()</code></p><p><code>numpy.logspace</code>函数用于创建一个于等比数列。格式如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.logspace(start, stop, num=<span class="number">50</span>, endpoint=<span class="literal">True</span>, base=<span class="number">10.0</span>, dtype=<span class="literal">None</span>)</span><br><span class="line"><span class="comment"># 参数说明</span></span><br><span class="line">start序列的起始值为：base ** start</span><br><span class="line">stop序列的终止值为：base ** stop。如果endpoint为true，该值包含于数列中</span><br><span class="line">num要生成的等步长的样本数量，默认为<span class="number">50</span></span><br><span class="line">endpoint该值为 true 时，数列中中包含stop值，反之不包含，默认是<span class="literal">True</span>。</span><br><span class="line">base对数 log 的底数。</span><br><span class="line">dtypendarray 的数据类型</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment"># 默认底数是10</span></span><br><span class="line">a = np.logspace(<span class="number">1.0</span>, <span class="number">2.0</span>, num = <span class="number">10</span>)</span><br><span class="line"><span class="comment"># 将对数的底数设置为 2 </span></span><br><span class="line">b = np.logspace(<span class="number">0</span>, <span class="number">9</span>, <span class="number">10</span>,base = <span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[ <span class="number">10.</span>          <span class="number">12.91549665</span>  <span class="number">16.68100537</span>  <span class="number">21.5443469</span>   <span class="number">27.82559402</span></span><br><span class="line">  <span class="number">35.93813664</span>  <span class="number">46.41588834</span>  <span class="number">59.94842503</span>  <span class="number">77.42636827</span> <span class="number">100.</span>        ]</span><br><span class="line">[  <span class="number">1.</span>   <span class="number">2.</span>   <span class="number">4.</span>   <span class="number">8.</span>  <span class="number">16.</span>  <span class="number">32.</span>  <span class="number">64.</span> <span class="number">128.</span> <span class="number">256.</span> <span class="number">512.</span>]</span><br></pre></td></tr></table></figure><h4 id="👁结构数组"><a href="#👁结构数组" class="headerlink" title="👁结构数组"></a>👁结构数组</h4><p>C语言中可以通过struct关键字定义结构类型。NumPy中也有类似的结构数组。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment"># 例子1</span></span><br><span class="line">student = np.dtype([(<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;S20&#x27;</span>), (<span class="string">&#x27;age&#x27;</span>, <span class="string">&#x27;i1&#x27;</span>), (<span class="string">&#x27;marks&#x27;</span>, <span class="string">&#x27;f4&#x27;</span>)]) </span><br><span class="line">a = np.array([(<span class="string">&#x27;abc&#x27;</span>, <span class="number">21</span>, <span class="number">50</span>),(<span class="string">&#x27;xyz&#x27;</span>, <span class="number">18</span>, <span class="number">75</span>)], dtype = student) </span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">0</span>])</span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[(<span class="string">b&#x27;abc&#x27;</span>, <span class="number">21</span>, <span class="number">50.</span>) (<span class="string">b&#x27;xyz&#x27;</span>, <span class="number">18</span>, <span class="number">75.</span>)]</span><br><span class="line">(<span class="string">b&#x27;abc&#x27;</span>, <span class="number">21</span>, <span class="number">50.</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 例子2</span></span><br><span class="line">persontype = np.dtype(&#123;</span><br><span class="line">    <span class="string">&#x27;names&#x27;</span>:[<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;age&#x27;</span>,<span class="string">&#x27;weight&#x27;</span>],</span><br><span class="line">    <span class="string">&#x27;formats&#x27;</span>:[<span class="string">&#x27;S30&#x27;</span>,<span class="string">&#x27;i&#x27;</span>,<span class="string">&#x27;f&#x27;</span>]&#125;)</span><br><span class="line">b = np.array([(<span class="string">&#x27;Zhang&#x27;</span>,<span class="number">32</span>,<span class="number">75.5</span>),(<span class="string">&#x27;Wang&#x27;</span>,<span class="number">24</span>,<span class="number">65.2</span>)],dtype = persontype)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="built_in">print</span>(b[<span class="number">0</span>])</span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[(<span class="string">b&#x27;Zhang&#x27;</span>, <span class="number">32</span>, <span class="number">75.5</span>) (<span class="string">b&#x27;Wang&#x27;</span>, <span class="number">24</span>, <span class="number">65.2</span>)]</span><br><span class="line">(<span class="string">b&#x27;Zhang&#x27;</span>, <span class="number">32</span>, <span class="number">75.5</span>)</span><br></pre></td></tr></table></figure><blockquote><p>Python打印字符串，前面出现<code>b</code>:</p><ul><li>b: bytes </li><li>python3.x里默认的str是(py2.x里的)unicode, bytes是(py2.x)的str, b”“前缀代表的就是bytes ;</li><li>python2.x里, b前缀没什么具体意义， 只是为了兼容python3.x的这种写法.</li></ul></blockquote><h3 id="👀NumPy数据类型对象-dtype"><a href="#👀NumPy数据类型对象-dtype" class="headerlink" title="👀NumPy数据类型对象(dtype)"></a>👀NumPy数据类型对象(dtype)</h3><p><code>NumPy</code>支持的数据类型比<code>Python</code>内置的类型要多很多，基本上可以和<code>C</code>语言的数据类型对应上，其中部分类型对应为<code>Python</code>内置的类型。</p><table><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td><code>bool_</code></td><td>布尔型数据类型（True 或者 False）</td></tr><tr><td><code>int8</code></td><td>字节（-128 to 127）</td></tr><tr><td><code>int16</code></td><td>整数（-32768 to 32767）</td></tr><tr><td><code>int32</code></td><td>整数（-2147483648 to 2147483647）</td></tr><tr><td><code>int64</code></td><td>整数（-9223372036854775808 to 9223372036854775807）</td></tr><tr><td><code>uint8</code></td><td>无符号整数（0 to 255）</td></tr><tr><td><code>uint16</code></td><td>无符号整数（0 to 65535）</td></tr><tr><td><code>uint32</code></td><td>无符号整数（0 to 4294967295）</td></tr><tr><td><code>uint64</code></td><td>无符号整数（0 to 18446744073709551615）</td></tr><tr><td><code>float_</code></td><td>float64 类型的简写</td></tr><tr><td><code>float16</code></td><td>半精度浮点数，包括：1 个符号位，5 个指数位，10 个尾数位</td></tr><tr><td><code>float32</code></td><td>单精度浮点数，包括：1 个符号位，8 个指数位，23 个尾数位</td></tr><tr><td><code>float64</code></td><td>双精度浮点数，包括：1 个符号位，11 个指数位，52 个尾数位</td></tr></tbody></table><p>数据类型对象（<code>numpy.dtype</code>类的实例）用来描述与数组对应的内存区域是如何使用，它描述了数据的以下几个方面：</p><ul><li>数据的类型（整数，浮点数或者<code>Python</code>对象）</li><li>数据的大小（例如， 整数使用多少个字节存储）</li><li>数据的字节顺序（小端法或大端法）</li><li>在结构化类型的情况下，字段的名称、每个字段的数据类型和每个字段所取的内存块的部分</li><li>如果数据类型是子数组，那么它的形状和数据类型是什么。</li></ul><p>字节顺序是通过对数据类型预先设定 <code>&lt;</code>或 <code>&gt;</code> 来决定的。 <code>&lt;</code>意味着小端法(最小值存储在最小的地址，即低位组放在最前面)。<code>&gt;</code>意味着大端法(最重要的字节存储在最小的地址，即高位组放在最前面)。</p><p><code>dtype</code>对象是使用以下语法构造的：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numpy.dtype(<span class="built_in">object</span>, align, copy)</span><br><span class="line"><span class="comment"># 参数说明</span></span><br><span class="line"><span class="built_in">object</span> - 要转换为的数据类型对象</span><br><span class="line">align - 如果为true，填充字段使其类似C的结构体。</span><br><span class="line">copy - 复制dtype对象，如果为false，则是对内置数据类型对象的引用</span><br><span class="line"></span><br><span class="line"><span class="comment"># 例子1</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment"># 使用标量类型</span></span><br><span class="line">dt1 = np.dtype(np.int32)</span><br><span class="line"><span class="comment"># int8, int16, int32, int64四种数据类型可以使用字符串&#x27;i1&#x27;, &#x27;i2&#x27;,&#x27;i4&#x27;,&#x27;i8&#x27;代替</span></span><br><span class="line">dt2 = np.dtype(<span class="string">&#x27;i4&#x27;</span>)</span><br><span class="line"><span class="comment"># 字节顺序标注</span></span><br><span class="line">dt3 = np.dtype(<span class="string">&#x27;&lt;i4&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(dt1)</span><br><span class="line"><span class="built_in">print</span>(dt2)</span><br><span class="line"><span class="built_in">print</span>(dt4)</span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">int32</span><br><span class="line">int32</span><br><span class="line">int32</span><br></pre></td></tr></table></figure><p>下面实例展示结构化数据类型的使用，类型字段和对应的实际类型将被创建。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment"># 例子1</span></span><br><span class="line"><span class="comment"># 首先创建结构化数据类型</span></span><br><span class="line">dt = np.dtype([(<span class="string">&#x27;age&#x27;</span>,np.int8)]) </span><br><span class="line"><span class="built_in">print</span>(dt)</span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[(<span class="string">&#x27;age&#x27;</span>, <span class="string">&#x27;i1&#x27;</span>)]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 例子2</span></span><br><span class="line"><span class="comment"># 将数据类型应用于ndarray对象</span></span><br><span class="line">dt = np.dtype([(<span class="string">&#x27;age&#x27;</span>,np.int8)]) </span><br><span class="line">a = np.array([(<span class="number">10</span>,),(<span class="number">20</span>,),(<span class="number">30</span>,)], dtype = dt) </span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[(<span class="number">10</span>,) (<span class="number">20</span>,) (<span class="number">30</span>,)]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 例子3</span></span><br><span class="line"><span class="comment"># 类型字段名可以用于存取实际的age列</span></span><br><span class="line">dt = np.dtype([(<span class="string">&#x27;age&#x27;</span>,np.int8)]) </span><br><span class="line">a = np.array([(<span class="number">10</span>,),(<span class="number">20</span>,),(<span class="number">30</span>,)], dtype = dt) </span><br><span class="line"><span class="built_in">print</span>(a[<span class="string">&#x27;age&#x27;</span>])</span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[<span class="number">10</span> <span class="number">20</span> <span class="number">30</span>]</span><br></pre></td></tr></table></figure><p>下面的示例定义一个结构化数据类型student，包含字符串字段name，整数字段age，及浮点字段marks，并将这个dtype应用到ndarray对象。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment"># 例子1</span></span><br><span class="line">student = np.dtype([(<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;S20&#x27;</span>), (<span class="string">&#x27;age&#x27;</span>, <span class="string">&#x27;i1&#x27;</span>), (<span class="string">&#x27;marks&#x27;</span>, <span class="string">&#x27;f4&#x27;</span>)]) </span><br><span class="line"><span class="built_in">print</span>(student)</span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;S20&#x27;</span>), (<span class="string">&#x27;age&#x27;</span>, <span class="string">&#x27;i1&#x27;</span>), (<span class="string">&#x27;marks&#x27;</span>, <span class="string">&#x27;f4&#x27;</span>)]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 例子2</span></span><br><span class="line">a = np.array([(<span class="string">&#x27;abc&#x27;</span>, <span class="number">21</span>, <span class="number">50</span>),(<span class="string">&#x27;xyz&#x27;</span>, <span class="number">18</span>, <span class="number">75</span>)], dtype = student) </span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">0</span>])</span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[(<span class="string">b&#x27;abc&#x27;</span>, <span class="number">21</span>, <span class="number">50.</span>) (<span class="string">b&#x27;xyz&#x27;</span>, <span class="number">18</span>, <span class="number">75.</span>)]</span><br><span class="line">(<span class="string">b&#x27;abc&#x27;</span>, <span class="number">21</span>, <span class="number">50.</span>)</span><br></pre></td></tr></table></figure><p>每个内建类型都有一个唯一定义它的字符代码，如下：</p><table><thead><tr><th>字符</th><th>对应类型</th></tr></thead><tbody><tr><td>b</td><td>布尔型</td></tr><tr><td>i</td><td>(有符号) 整型</td></tr><tr><td>u</td><td>无符号整型 integer</td></tr><tr><td>f</td><td>浮点型</td></tr><tr><td>c</td><td>复数浮点型</td></tr><tr><td>m</td><td>timedelta（时间间隔）</td></tr><tr><td>M</td><td>datetime（日期时间）</td></tr><tr><td>O</td><td>(Python) 对象</td></tr><tr><td>S,a</td><td>(byte-)字符串</td></tr><tr><td>U</td><td>Unicode</td></tr><tr><td>V</td><td>原始数据 (void)</td></tr></tbody></table><h3 id="👀NumPy数组属性"><a href="#👀NumPy数组属性" class="headerlink" title="👀NumPy数组属性"></a>👀NumPy数组属性</h3><p><code>NumPy</code>数组的维数称为秩（rank），秩就是轴的数量，即数组的维度，一维数组的秩为 1，二维数组的秩为 2，以此类推。在<code>NumPy</code>中，每一个线性的数组称为是一个轴（<code>axis</code>），也就是维度（<code>dimensions</code>）。比如说，二维数组相当于是两个一维数组，其中第一个一维数组中每个元素又是一个一维数组。所以一维数组就是<code>NumPy</code>中的轴（<code>axis</code>），第一个轴相当于是底层数组，第二个轴是底层数组里的数组。而轴的数量——秩，就是数组的维数。</p><p>很多时候可以声明<code>axis</code>。axis&#x3D;0，表示沿着第0轴进行操作，即对每一列进行操作；axis&#x3D;1，表示沿着第1轴进行操作，即对每一行进行操作。<code>NumPy</code>的数组中比较重要<code>ndarray</code>对象属性有：</p><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td><code>ndarray.ndim</code></td><td>秩，即轴的数量或维度的数量</td></tr><tr><td><code>ndarray.shape</code></td><td>数组的维度，对于矩阵，n行m列</td></tr><tr><td><code>ndarray.size</code></td><td>数组元素的总个数，相当于 .shape中n*m的值</td></tr><tr><td><code>ndarray.dtype</code></td><td>ndarray对象的元素类型</td></tr><tr><td><code>ndarray.itemsize</code></td><td>ndarray对象中每个元素的大小，以字节为单位</td></tr><tr><td><code>ndarray.flags</code></td><td>ndarray对象的内存信息</td></tr><tr><td><code>ndarray.real</code></td><td>ndarray元素的实部</td></tr><tr><td><code>ndarray.imag</code></td><td>ndarray元素的虚部</td></tr><tr><td><code>ndarray.data</code></td><td>包含实际数组元素的缓冲区，由于一般通过数组的索引获取元素，所以通常不需要使用这个属性</td></tr></tbody></table><p><code>ndarray.ndim</code>用于返回数组的维数，等于秩。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"><span class="comment"># ndarray.ndim用于返回数组的维数，等于秩。</span></span><br><span class="line">a = np.arange(<span class="number">24</span>)  </span><br><span class="line"><span class="built_in">print</span>(a.ndim)             <span class="comment"># a 现只有一个维度</span></span><br><span class="line"><span class="comment"># 现在调整其大小</span></span><br><span class="line">b = a.reshape(<span class="number">2</span>,<span class="number">4</span>,<span class="number">3</span>)       <span class="comment"># b 现在拥有三个维度</span></span><br><span class="line"><span class="built_in">print</span>(b.ndim)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><p><code>ndarray.shape</code>表示数组的维度，返回一个元组，这个元组的长度就是维度的数目，即<code>ndim</code>属性(秩)。比如，一个二维数组，其维度表示”行数”和”列数”。</p><p><code>ndarray.shape</code>也可以用于调整数组大小。<code>NumPy</code>也提供了<code>reshape()</code>函数来调整数组大小。</p><p><code>ndarray.size</code>数组元素的总个数，相当于 <code>.shape</code>中n*m的值。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 例子1</span></span><br><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]])  </span><br><span class="line"><span class="built_in">print</span>(a.shape)</span><br><span class="line">b = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]]) </span><br><span class="line">b.shape = (<span class="number">3</span>,<span class="number">2</span>)  </span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">[[<span class="number">1</span> <span class="number">2</span>]</span><br><span class="line"> [<span class="number">3</span> <span class="number">4</span>]</span><br><span class="line"> [<span class="number">5</span> <span class="number">6</span>]]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 例子2</span></span><br><span class="line">c = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]]) </span><br><span class="line">d = c.reshape(<span class="number">3</span>,<span class="number">2</span>)  </span><br><span class="line">e = np.size(c)</span><br><span class="line"><span class="built_in">print</span>(d)</span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[[<span class="number">1</span> <span class="number">2</span>]</span><br><span class="line"> [<span class="number">3</span> <span class="number">4</span>]</span><br><span class="line"> [<span class="number">5</span> <span class="number">6</span>]]</span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure><p><code>ndarray.itemsize</code>以字节的形式返回数组中每一个元素的大小。</p><p>例如，一个元素类型为<code>float64</code>的数组<code>itemsize</code>属性值为 8(<code>float64</code>占用64个bits（位），每个字节（Byte）长度为8，所以64&#x2F;8，占用8个字节），又如，一个元素类型为<code>complex32</code>的数组item属性为4（32&#x2F;8）。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"> </span><br><span class="line"><span class="comment"># 数组的dtype为int8（一个字节）  </span></span><br><span class="line">x = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>], dtype = np.int8)  </span><br><span class="line"><span class="built_in">print</span>(x.itemsize)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 数组的dtype现在为float64（八个字节） </span></span><br><span class="line">y = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>], dtype = np.float64)  </span><br><span class="line"><span class="built_in">print</span>(y.itemsize)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">8</span></span><br></pre></td></tr></table></figure><p><code>ndarray.flags</code>返回ndarray对象的内存信息，包含以下属性：</p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td><code>C_CONTIGUOUS (C)</code></td><td>数据是在一个单一的<code>C</code>风格的连续段中</td></tr><tr><td><code>F_CONTIGUOUS (F)</code></td><td>数据是在一个单一的<code>Fortran</code>风格的连续段中</td></tr><tr><td><code>OWNDATA (O)</code></td><td>数组拥有它所使用的内存或从另一个对象中借用它</td></tr><tr><td><code>WRITEABLE (W)</code></td><td>数据区域可以被写入，将该值设置为<code>False</code>，则数据为只读</td></tr><tr><td><code>ALIGNED (A)</code></td><td>数据和所有元素都适当地对齐到硬件上</td></tr><tr><td><code>UPDATEIFCOPY (U)</code></td><td>这个数组是其它数组的一个副本，当这个数组被释放时，原数组的内容将被更新</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"> </span><br><span class="line">x = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])  </span><br><span class="line"><span class="built_in">print</span>(x.flags)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">C_CONTIGUOUS : <span class="literal">True</span></span><br><span class="line">F_CONTIGUOUS : <span class="literal">True</span></span><br><span class="line">OWNDATA : <span class="literal">True</span></span><br><span class="line">WRITEABLE : <span class="literal">True</span></span><br><span class="line">ALIGNED : <span class="literal">True</span></span><br><span class="line">WRITEBACKIFCOPY : <span class="literal">False</span></span><br><span class="line">UPDATEIFCOPY : <span class="literal">False</span></span><br></pre></td></tr></table></figure><blockquote><p><code>ndarray.reshape()</code>通常返回的是非拷贝副本，即改变返回后数组的元素，原数组对应元素的值也会改变。</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]])</span><br><span class="line">b = a.reshape((<span class="number">6</span>,))</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">20</span>)</span><br><span class="line">b[<span class="number">0</span>] = <span class="number">168</span></span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]</span><br><span class="line"> [<span class="number">4</span> <span class="number">5</span> <span class="number">6</span>]]</span><br><span class="line">[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span>]</span><br><span class="line">********************</span><br><span class="line">[<span class="number">168</span>   <span class="number">2</span>   <span class="number">3</span>   <span class="number">4</span>   <span class="number">5</span>   <span class="number">6</span>]</span><br><span class="line">[[<span class="number">168</span>   <span class="number">2</span>   <span class="number">3</span>]</span><br><span class="line"> [  <span class="number">4</span>   <span class="number">5</span>   <span class="number">6</span>]]</span><br></pre></td></tr></table></figure><h3 id="👀NumPy切片和索引"><a href="#👀NumPy切片和索引" class="headerlink" title="👀NumPy切片和索引"></a>👀NumPy切片和索引</h3><p>（1）整数和切片索引</p><p><code>ndarray</code>对象的内容可以通过索引或切片来访问和修改，与<code>Python</code>中<code>list</code>的切片操作一样。</p><p><code>ndarray</code>数组可以基于<code>0-n</code>的下标进行索引，切片对象可以通过内置的<code>slice</code>函数，并设置start, stop及step参数进行，从原数组中切割出一个新数组。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = np.arange(<span class="number">10</span>)</span><br><span class="line"><span class="comment"># 内置的slice函数</span></span><br><span class="line"><span class="comment"># 从索引2开始到索引7停止，间隔为2</span></span><br><span class="line">s = <span class="built_in">slice</span>(<span class="number">2</span>,<span class="number">7</span>,<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(a[s])</span><br><span class="line"><span class="comment"># 从索引2开始到索引7停止，间隔为2</span></span><br><span class="line">b = a[<span class="number">2</span>:<span class="number">7</span>:<span class="number">2</span>]</span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[<span class="number">2</span> <span class="number">4</span> <span class="number">6</span>]</span><br><span class="line">[<span class="number">2</span> <span class="number">4</span> <span class="number">6</span>]</span><br></pre></td></tr></table></figure><p>冒号<code>:</code>的解释：如果只放置一个参数，如<code>[2]</code>，将返回与该索引相对应的单个元素。如果为<code>[2:]</code>，表示从该索引开始以后的所有项都将被提取。如果使用了两个参数，如<code>[2:7]</code>，那么则提取两个索引(不包括停止索引)之间的项。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = np.arange(<span class="number">10</span>)  <span class="comment"># [0 1 2 3 4 5 6 7 8 9]</span></span><br><span class="line">b = a[<span class="number">5</span>]</span><br><span class="line">c = a[<span class="number">2</span>:]</span><br><span class="line">d = a[<span class="number">2</span>:<span class="number">5</span>]</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line"><span class="built_in">print</span>(d)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span>]</span><br><span class="line"><span class="number">5</span></span><br><span class="line">[<span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span>]</span><br><span class="line">[<span class="number">2</span> <span class="number">3</span> <span class="number">4</span>]</span><br></pre></td></tr></table></figure><p>多维数组同样适用上述索引提取方法。</p><p>切片还可以包括省略号<code>…</code>，来使选择元组的长度与数组的维度相同。 如果在行位置使用省略号，它将返回包含行中元素的ndarray。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]])</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="comment"># 从某个索引处开始切割</span></span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">1</span>:])</span><br><span class="line"><span class="built_in">print</span>(a[...,<span class="number">1</span>])   <span class="comment"># 第2列元素</span></span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">1</span>,...])   <span class="comment"># 第2行元素</span></span><br><span class="line"><span class="built_in">print</span>(a[...,<span class="number">1</span>:])  <span class="comment"># 第2列及剩下的所有元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]</span><br><span class="line"> [<span class="number">3</span> <span class="number">4</span> <span class="number">5</span>]</span><br><span class="line"> [<span class="number">4</span> <span class="number">5</span> <span class="number">6</span>]]</span><br><span class="line">[[<span class="number">3</span> <span class="number">4</span> <span class="number">5</span>]</span><br><span class="line"> [<span class="number">4</span> <span class="number">5</span> <span class="number">6</span>]]</span><br><span class="line">[<span class="number">2</span> <span class="number">4</span> <span class="number">5</span>]</span><br><span class="line">[<span class="number">3</span> <span class="number">4</span> <span class="number">5</span>]</span><br><span class="line">[[<span class="number">2</span> <span class="number">3</span>]</span><br><span class="line"> [<span class="number">4</span> <span class="number">5</span>]</span><br><span class="line"> [<span class="number">5</span> <span class="number">6</span>]]</span><br></pre></td></tr></table></figure><blockquote><p><code>np.s_[:]</code>的用法，可以参考Python中内置的 <code>slice</code> 函数，并设置start, stop及step参数。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Out[<span class="number">23</span>]:np.s_[:]</span><br><span class="line">Out[<span class="number">23</span>]:<span class="built_in">slice</span>(<span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>)</span><br></pre></td></tr></table></figure></blockquote><p>（2）高级索引</p><ul><li>整数数组索引</li><li>布尔索引</li><li>花式索引</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 整数数组索引</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"><span class="comment"># 获取数组中(0,0)，(1,1)和(2,0)位置处的元素。</span></span><br><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>], [<span class="number">3</span>,<span class="number">4</span>], [<span class="number">5</span>,<span class="number">6</span>]]) </span><br><span class="line">b = a[[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>],[<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>]]  </span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[<span class="number">1</span> <span class="number">4</span> <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#**********************************</span></span><br><span class="line">c = np.array([[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],[<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>],[<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>]])  </span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line">rows = np.array([[<span class="number">0</span>,<span class="number">0</span>],[<span class="number">3</span>,<span class="number">3</span>]])</span><br><span class="line">cols = np.array([[<span class="number">0</span>,<span class="number">2</span>],[<span class="number">0</span>,<span class="number">2</span>]])</span><br><span class="line">d = c[rows,cols]</span><br><span class="line"><span class="built_in">print</span>(d)</span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[[ <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>]</span><br><span class="line"> [ <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>]</span><br><span class="line"> [ <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>]</span><br><span class="line"> [ <span class="number">9</span> <span class="number">10</span> <span class="number">11</span>]]</span><br><span class="line">[[ <span class="number">0</span>  <span class="number">2</span>]</span><br><span class="line"> [ <span class="number">9</span> <span class="number">11</span>]]</span><br><span class="line"></span><br><span class="line"><span class="comment">#**********************************</span></span><br><span class="line"><span class="comment"># 借助切片:或…与索引数组组合。如下面例子：</span></span><br><span class="line">e = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]])</span><br><span class="line">f = e[<span class="number">1</span>:<span class="number">3</span>,<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line">g = e[<span class="number">1</span>:<span class="number">3</span>,[<span class="number">1</span>,<span class="number">2</span>]]</span><br><span class="line">h = e[...,<span class="number">1</span>:]</span><br><span class="line"><span class="built_in">print</span>(e)</span><br><span class="line"><span class="built_in">print</span>(f)</span><br><span class="line"><span class="built_in">print</span>(g)</span><br><span class="line"><span class="built_in">print</span>(h)</span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]</span><br><span class="line"> [<span class="number">4</span> <span class="number">5</span> <span class="number">6</span>]</span><br><span class="line"> [<span class="number">7</span> <span class="number">8</span> <span class="number">9</span>]]</span><br><span class="line">[[<span class="number">5</span> <span class="number">6</span>]</span><br><span class="line"> [<span class="number">8</span> <span class="number">9</span>]]</span><br><span class="line">[[<span class="number">5</span> <span class="number">6</span>]</span><br><span class="line"> [<span class="number">8</span> <span class="number">9</span>]]</span><br><span class="line">[[<span class="number">2</span> <span class="number">3</span>]</span><br><span class="line"> [<span class="number">5</span> <span class="number">6</span>]</span><br><span class="line"> [<span class="number">8</span> <span class="number">9</span>]]</span><br></pre></td></tr></table></figure><p><strong>布尔索引</strong>通过布尔运算（如：比较运算符）来获取符合指定条件的元素的数组。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"></span><br><span class="line">x = np.array([[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],[<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>],[<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>]])  </span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line"><span class="comment"># 现在我们会打印出大于5的元素  </span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;大于5的元素是：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(x[x&gt;<span class="number">5</span>])</span><br><span class="line"><span class="comment">#输出结果</span></span><br><span class="line">[[ <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>]</span><br><span class="line"> [ <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>]</span><br><span class="line"> [ <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>]</span><br><span class="line"> [ <span class="number">9</span> <span class="number">10</span> <span class="number">11</span>]]</span><br><span class="line">大于<span class="number">5</span>的元素是：</span><br><span class="line">[ <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span> <span class="number">10</span> <span class="number">11</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#**********************************</span></span><br><span class="line"><span class="comment"># 使用了~（取补运算符）来过滤NaN</span></span><br><span class="line">a = np.array([np.nan,<span class="number">1</span>,<span class="number">2</span>,np.nan,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])  </span><br><span class="line"><span class="built_in">print</span>(a[np.isnan(a)])</span><br><span class="line"><span class="built_in">print</span>(a[~np.isnan(a)])</span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[<span class="number">1.</span> <span class="number">2.</span> <span class="number">3.</span> <span class="number">4.</span> <span class="number">5.</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#**********************************</span></span><br><span class="line"><span class="comment"># 从数组中过滤掉非复数元素</span></span><br><span class="line">a = np.array([<span class="number">1</span>,<span class="number">2</span>+<span class="number">6j</span>,<span class="number">5</span>,<span class="number">3.5</span>+<span class="number">5j</span>])  </span><br><span class="line"><span class="built_in">print</span>(a[np.iscomplex(a)])</span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[<span class="number">2.</span>+<span class="number">6.j</span> <span class="number">3.5</span>+<span class="number">5.j</span>]</span><br></pre></td></tr></table></figure><p><strong>花式索引</strong>指的是利用整数数组进行索引。花式索引根据索引数组的值作为目标数组的某个轴的下标来取值。</p><ul><li><p>对于使用一维整型数组作为索引，如果目标是一维数组，那么索引的结果就是对应位置的元素；如果目标是二维数组，那么就是对应下标的行。</p></li><li><p>花式索引跟切片不一样，它总是将数据复制到新数组中；</p></li><li><p>传入多个索引数组（要使用<code>np.ix_</code>）。<code>np.ix_</code> 函数就是输入两个数组，产生笛卡尔积的映射关系。</p><p>笛卡尔乘积是指在数学中，两个集合 X 和 Y 的<strong>笛卡尔积</strong>（Cartesian product），又称直积，表示为 <strong>X×Y</strong>，第一个对象是X的成员而第二个对象是 Y 的所有可能有序对的其中一个成员。</p></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 一维数组只有一个轴 axis = 0，所以一维数组就在 axis = 0 这个轴上取值：</span></span><br><span class="line">a = np.arange(<span class="number">1</span>,<span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="comment"># 一维数组读取指定下标对应的元素</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;-------读取下标对应的元素-------&quot;</span>)</span><br><span class="line">b = a[[<span class="number">0</span>,<span class="number">6</span>]] <span class="comment"># 使用花式索引</span></span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="built_in">print</span>(b[<span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span>(b[<span class="number">1</span>])</span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span>]</span><br><span class="line">-------读取下标对应的元素-------</span><br><span class="line">[<span class="number">1</span> <span class="number">7</span>]</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#**********************************</span></span><br><span class="line"><span class="comment"># 二维数组</span></span><br><span class="line">c = np.arange(<span class="number">32</span>).reshape((<span class="number">8</span>,<span class="number">4</span>))</span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line"><span class="comment"># 二维数组读取指定下标对应的行,输出下表为4,2,1,7对应的行</span></span><br><span class="line"><span class="built_in">print</span>(c[[<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">7</span>]])</span><br><span class="line"><span class="comment"># 传入倒序索引数组</span></span><br><span class="line"><span class="built_in">print</span>(c[[-<span class="number">4</span>,-<span class="number">2</span>,-<span class="number">1</span>,-<span class="number">7</span>]])</span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[[ <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>]</span><br><span class="line"> [ <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>]</span><br><span class="line"> [ <span class="number">8</span>  <span class="number">9</span> <span class="number">10</span> <span class="number">11</span>]</span><br><span class="line"> [<span class="number">12</span> <span class="number">13</span> <span class="number">14</span> <span class="number">15</span>]</span><br><span class="line"> [<span class="number">16</span> <span class="number">17</span> <span class="number">18</span> <span class="number">19</span>]</span><br><span class="line"> [<span class="number">20</span> <span class="number">21</span> <span class="number">22</span> <span class="number">23</span>]</span><br><span class="line"> [<span class="number">24</span> <span class="number">25</span> <span class="number">26</span> <span class="number">27</span>]</span><br><span class="line"> [<span class="number">28</span> <span class="number">29</span> <span class="number">30</span> <span class="number">31</span>]]</span><br><span class="line">[[<span class="number">16</span> <span class="number">17</span> <span class="number">18</span> <span class="number">19</span>]</span><br><span class="line"> [ <span class="number">8</span>  <span class="number">9</span> <span class="number">10</span> <span class="number">11</span>]</span><br><span class="line"> [ <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>]</span><br><span class="line"> [<span class="number">28</span> <span class="number">29</span> <span class="number">30</span> <span class="number">31</span>]]</span><br><span class="line">[[<span class="number">16</span> <span class="number">17</span> <span class="number">18</span> <span class="number">19</span>]</span><br><span class="line"> [<span class="number">24</span> <span class="number">25</span> <span class="number">26</span> <span class="number">27</span>]</span><br><span class="line"> [<span class="number">28</span> <span class="number">29</span> <span class="number">30</span> <span class="number">31</span>]</span><br><span class="line"> [ <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>]]</span><br><span class="line"></span><br><span class="line"><span class="comment">#**********************************</span></span><br><span class="line"><span class="comment"># 传入多个索引数组（要使用np.ix_），笛卡尔积</span></span><br><span class="line"><span class="comment"># 例如 A=&#123;a,b&#125;, B=&#123;0,1,2&#125;，则：</span></span><br><span class="line"><span class="comment"># A×B=&#123;(a,0),(a,1),(a,2),(b,0),(b,1),(b,2)&#125;</span></span><br><span class="line"><span class="comment"># B×A=&#123;(0,a),(0,b),(1,a),(1,b),(2,a),(2,b)&#125;</span></span><br><span class="line">d = np.arange(<span class="number">32</span>).reshape((<span class="number">8</span>,<span class="number">4</span>))</span><br><span class="line"><span class="built_in">print</span>(d)</span><br><span class="line"><span class="built_in">print</span>(d[np.ix_([<span class="number">1</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">2</span>],[<span class="number">0</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>])])</span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[[ <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>]</span><br><span class="line"> [ <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>]</span><br><span class="line"> [ <span class="number">8</span>  <span class="number">9</span> <span class="number">10</span> <span class="number">11</span>]</span><br><span class="line"> [<span class="number">12</span> <span class="number">13</span> <span class="number">14</span> <span class="number">15</span>]</span><br><span class="line"> [<span class="number">16</span> <span class="number">17</span> <span class="number">18</span> <span class="number">19</span>]</span><br><span class="line"> [<span class="number">20</span> <span class="number">21</span> <span class="number">22</span> <span class="number">23</span>]</span><br><span class="line"> [<span class="number">24</span> <span class="number">25</span> <span class="number">26</span> <span class="number">27</span>]</span><br><span class="line"> [<span class="number">28</span> <span class="number">29</span> <span class="number">30</span> <span class="number">31</span>]]</span><br><span class="line">[[ <span class="number">4</span>  <span class="number">7</span>  <span class="number">5</span>  <span class="number">6</span>]</span><br><span class="line"> [<span class="number">20</span> <span class="number">23</span> <span class="number">21</span> <span class="number">22</span>]</span><br><span class="line"> [<span class="number">28</span> <span class="number">31</span> <span class="number">29</span> <span class="number">30</span>]</span><br><span class="line"> [ <span class="number">8</span> <span class="number">11</span>  <span class="number">9</span> <span class="number">10</span>]]</span><br></pre></td></tr></table></figure><h2 id="⛄ufunc函数"><a href="#⛄ufunc函数" class="headerlink" title="⛄ufunc函数"></a>⛄ufunc函数</h2><h3 id="👀NumPy广播（Broadcast）"><a href="#👀NumPy广播（Broadcast）" class="headerlink" title="👀NumPy广播（Broadcast）"></a>👀NumPy广播（Broadcast）</h3><p>广播(Broadcast)是numpy对不同形状(shape)的数组进行数值计算的方式， 对数组的算术运算通常在相应的元素上进行。如果两个数组a和b形状相同，即满足<strong>a.shape &#x3D;&#x3D; b.shape</strong>，那么a*b的结果就是a与b数组对应位相乘。这要求维数相同，且各维度的长度相同。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]) </span><br><span class="line">b = np.array([<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>]) </span><br><span class="line">c = a * b </span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line"><span class="comment"># 当运算中的2个数组的形状不同时，numpy将自动触发广播机制</span></span><br><span class="line">d = np.array([[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line">           [<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>],</span><br><span class="line">           [<span class="number">20</span>,<span class="number">20</span>,<span class="number">20</span>],</span><br><span class="line">           [<span class="number">30</span>,<span class="number">30</span>,<span class="number">30</span>]])</span><br><span class="line">e = np.array([<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>])</span><br><span class="line"><span class="built_in">print</span>(d + e)</span><br><span class="line"><span class="comment"># 4x3的二维数组与长为3的一维数组相加，等效于把数组b在二维上重复4次再运算：</span></span><br><span class="line">f = np.array([[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line">           [<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>],</span><br><span class="line">           [<span class="number">20</span>,<span class="number">20</span>,<span class="number">20</span>],</span><br><span class="line">           [<span class="number">30</span>,<span class="number">30</span>,<span class="number">30</span>]])</span><br><span class="line">g = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">gg = np.tile(g,(<span class="number">4</span>,<span class="number">1</span>))  <span class="comment">#重复b的各个维度</span></span><br><span class="line"><span class="built_in">print</span>(gg)</span><br><span class="line"><span class="built_in">print</span>(f+gg)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[<span class="number">10</span> <span class="number">40</span> <span class="number">90</span> <span class="number">160</span>]</span><br><span class="line">[[ <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>]</span><br><span class="line"> [<span class="number">10</span> <span class="number">11</span> <span class="number">12</span>]</span><br><span class="line"> [<span class="number">20</span> <span class="number">21</span> <span class="number">22</span>]</span><br><span class="line"> [<span class="number">30</span> <span class="number">31</span> <span class="number">32</span>]]</span><br><span class="line">[[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]</span><br><span class="line"> [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]</span><br><span class="line"> [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]</span><br><span class="line"> [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]]</span><br><span class="line">[[ <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>]</span><br><span class="line"> [<span class="number">11</span> <span class="number">12</span> <span class="number">13</span>]</span><br><span class="line"> [<span class="number">21</span> <span class="number">22</span> <span class="number">23</span>]</span><br><span class="line"> [<span class="number">31</span> <span class="number">32</span> <span class="number">33</span>]]</span><br></pre></td></tr></table></figure><p>广播的规则：</p><ul><li>让所有输入数组都向其中形状最长的数组看齐，形状中不足的部分都通过在前面加1补齐。</li><li>输出数组的形状是输入数组形状的各个维度上的最大值。</li><li>如果输入数组的某个维度和输出数组的对应维度的长度相同或者其长度为1时，这个数组能够用来计算，否则出错。</li><li>当输入数组的某个维度的长度为1时，沿着此维度运算时都用此维度上的第一组值。</li></ul><p><strong>简单理解：</strong>对两个数组，分别比较他们的每一个维度（若其中一个数组没有当前维度则忽略），满足：</p><ul><li>数组拥有相同形状。</li><li>当前维度的值相等。</li><li>当前维度的值有一个是1。</li></ul><p>若条件不满足，抛出 <strong>“ValueError: frames are not aligned”</strong> 异常。</p><h3 id="👀NumPy迭代数组"><a href="#👀NumPy迭代数组" class="headerlink" title="👀NumPy迭代数组"></a>👀NumPy迭代数组</h3><p><code>NumPy</code>迭代器对象<code>numpy.nditer</code>提供了一种灵活访问一个或者多个数组元素的方式。</p><p>迭代器最基本的任务的可以完成对数组元素的访问。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = np.arange(<span class="number">6</span>).reshape(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;原始数组是：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;迭代输出元素：&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> np.nditer(a):</span><br><span class="line">    <span class="built_in">print</span>(x, end=<span class="string">&quot;, &quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">原始数组是：</span><br><span class="line">[[<span class="number">0</span> <span class="number">1</span> <span class="number">2</span>]</span><br><span class="line"> [<span class="number">3</span> <span class="number">4</span> <span class="number">5</span>]]</span><br><span class="line"></span><br><span class="line">迭代输出元素：</span><br><span class="line"><span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, </span><br></pre></td></tr></table></figure><p>以上实例不是使用标准C或者Fortran顺序，选择的顺序是和数组内存布局一致的，这样做是为了提升访问的效率，<strong>默认是行序优先</strong>（row-major order，或者说是 C-order）。这反映了默认情况下只需访问每个元素，而无需考虑其特定顺序。<code>a</code>和<code>a.T</code>的遍历顺序是一样的，也就是他们在内存中的存储顺序也是一样的，但是<code>a.T.copy(order = &#39;C&#39;)</code>的遍历结果是不同的，那是因为它和前两种的存储方式是不一样的，默认是按行访问。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"> </span><br><span class="line">a = np.arange(<span class="number">6</span>).reshape(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> np.nditer(a.T):</span><br><span class="line">    <span class="built_in">print</span>(x, end=<span class="string">&quot;, &quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> np.nditer(a.T.copy(order=<span class="string">&#x27;C&#x27;</span>)):</span><br><span class="line">    <span class="built_in">print</span>(x, end=<span class="string">&quot;, &quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, </span><br><span class="line"></span><br><span class="line"><span class="number">0</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">5</span>,</span><br></pre></td></tr></table></figure><p>（1）控制遍历顺序</p><ul><li><code>for x in np.nditer(a, order=&#39;F&#39;):</code>Fortran order，即是列序优先；</li><li><code>for x in np.nditer(a.T, order=&#39;C&#39;):</code>C order，即是行序优先；</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"> </span><br><span class="line">a = np.arange(<span class="number">0</span>,<span class="number">60</span>,<span class="number">5</span>) </span><br><span class="line">a = a.reshape(<span class="number">3</span>,<span class="number">4</span>)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;原始数组是：&#x27;</span>) </span><br><span class="line"><span class="built_in">print</span>(a) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;原始数组的转置是：&#x27;</span>) </span><br><span class="line">b = a.T </span><br><span class="line"><span class="built_in">print</span>(b) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;以 C 风格顺序排序：&#x27;</span>) </span><br><span class="line">c = b.copy(order=<span class="string">&#x27;C&#x27;</span>)  </span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> np.nditer(c):  </span><br><span class="line">    <span class="built_in">print</span> (x, end=<span class="string">&quot;, &quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;以 F 风格顺序排序：&#x27;</span>)</span><br><span class="line">c = b.copy(order=<span class="string">&#x27;F&#x27;</span>)  </span><br><span class="line"><span class="built_in">print</span> (c)</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> np.nditer(c):  </span><br><span class="line">    <span class="built_in">print</span>(x, end=<span class="string">&quot;, &quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">原始数组是：</span><br><span class="line">[[ <span class="number">0</span>  <span class="number">5</span> <span class="number">10</span> <span class="number">15</span>]</span><br><span class="line"> [<span class="number">20</span> <span class="number">25</span> <span class="number">30</span> <span class="number">35</span>]</span><br><span class="line"> [<span class="number">40</span> <span class="number">45</span> <span class="number">50</span> <span class="number">55</span>]]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">原始数组的转置是：</span><br><span class="line">[[ <span class="number">0</span> <span class="number">20</span> <span class="number">40</span>]</span><br><span class="line"> [ <span class="number">5</span> <span class="number">25</span> <span class="number">45</span>]</span><br><span class="line"> [<span class="number">10</span> <span class="number">30</span> <span class="number">50</span>]</span><br><span class="line"> [<span class="number">15</span> <span class="number">35</span> <span class="number">55</span>]]</span><br><span class="line"></span><br><span class="line">以 C 风格顺序排序：</span><br><span class="line">[[ <span class="number">0</span> <span class="number">20</span> <span class="number">40</span>]</span><br><span class="line"> [ <span class="number">5</span> <span class="number">25</span> <span class="number">45</span>]</span><br><span class="line"> [<span class="number">10</span> <span class="number">30</span> <span class="number">50</span>]</span><br><span class="line"> [<span class="number">15</span> <span class="number">35</span> <span class="number">55</span>]]</span><br><span class="line"><span class="number">0</span>, <span class="number">20</span>, <span class="number">40</span>, <span class="number">5</span>, <span class="number">25</span>, <span class="number">45</span>, <span class="number">10</span>, <span class="number">30</span>, <span class="number">50</span>, <span class="number">15</span>, <span class="number">35</span>, <span class="number">55</span>, </span><br><span class="line"></span><br><span class="line">以 F 风格顺序排序：</span><br><span class="line">[[ <span class="number">0</span> <span class="number">20</span> <span class="number">40</span>]</span><br><span class="line"> [ <span class="number">5</span> <span class="number">25</span> <span class="number">45</span>]</span><br><span class="line"> [<span class="number">10</span> <span class="number">30</span> <span class="number">50</span>]</span><br><span class="line"> [<span class="number">15</span> <span class="number">35</span> <span class="number">55</span>]]</span><br><span class="line"><span class="number">0</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>, <span class="number">20</span>, <span class="number">25</span>, <span class="number">30</span>, <span class="number">35</span>, <span class="number">40</span>, <span class="number">45</span>, <span class="number">50</span>, <span class="number">55</span>, </span><br></pre></td></tr></table></figure><p>可以通过显式设置，来强制nditer对象使用某种顺序：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"> </span><br><span class="line">a = np.arange(<span class="number">0</span>,<span class="number">60</span>,<span class="number">5</span>) </span><br><span class="line">a = a.reshape(<span class="number">3</span>,<span class="number">4</span>)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;原始数组是：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;以 C 风格顺序排序：&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> np.nditer(a, order = <span class="string">&#x27;C&#x27;</span>):  </span><br><span class="line">    <span class="built_in">print</span>(x, end=<span class="string">&quot;, &quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;以 F 风格顺序排序：&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> np.nditer(a, order = <span class="string">&#x27;F&#x27;</span>):  </span><br><span class="line">    <span class="built_in">print</span>(x, end=<span class="string">&quot;, &quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">原始数组是：</span><br><span class="line">[[ <span class="number">0</span>  <span class="number">5</span> <span class="number">10</span> <span class="number">15</span>]</span><br><span class="line"> [<span class="number">20</span> <span class="number">25</span> <span class="number">30</span> <span class="number">35</span>]</span><br><span class="line"> [<span class="number">40</span> <span class="number">45</span> <span class="number">50</span> <span class="number">55</span>]]</span><br><span class="line"></span><br><span class="line">以 C 风格顺序排序：</span><br><span class="line"><span class="number">0</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>, <span class="number">20</span>, <span class="number">25</span>, <span class="number">30</span>, <span class="number">35</span>, <span class="number">40</span>, <span class="number">45</span>, <span class="number">50</span>, <span class="number">55</span>, </span><br><span class="line"></span><br><span class="line">以 F 风格顺序排序：</span><br><span class="line"><span class="number">0</span>, <span class="number">20</span>, <span class="number">40</span>, <span class="number">5</span>, <span class="number">25</span>, <span class="number">45</span>, <span class="number">10</span>, <span class="number">30</span>, <span class="number">50</span>, <span class="number">15</span>, <span class="number">35</span>, <span class="number">55</span>, </span><br></pre></td></tr></table></figure><p>（2）修改数组中元素的值</p><p><code>nditer</code>对象有另一个可选参数<code>op_flags</code>。 默认情况下，<code>nditer</code>将视待迭代遍历的数组为只读对象（read-only），为了在遍历数组的同时，实现对数组元素值得修改，必须指定<code>readwrite</code>或者<code>writeonly</code>的模式。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"> </span><br><span class="line">a = np.arange(<span class="number">0</span>,<span class="number">60</span>,<span class="number">5</span>) </span><br><span class="line">a = a.reshape(<span class="number">3</span>,<span class="number">4</span>)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;原始数组是：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> np.nditer(a, op_flags=[<span class="string">&#x27;readwrite&#x27;</span>]): </span><br><span class="line">    <span class="comment"># x[...]是修改原numpy元素，x只是个拷贝。</span></span><br><span class="line">    x[...]=<span class="number">2</span>*x </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;修改后的数组是：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">原始数组是：</span><br><span class="line">[[ <span class="number">0</span>  <span class="number">5</span> <span class="number">10</span> <span class="number">15</span>]</span><br><span class="line"> [<span class="number">20</span> <span class="number">25</span> <span class="number">30</span> <span class="number">35</span>]</span><br><span class="line"> [<span class="number">40</span> <span class="number">45</span> <span class="number">50</span> <span class="number">55</span>]]</span><br><span class="line"></span><br><span class="line">修改后的数组是：</span><br><span class="line">[[  <span class="number">0</span>  <span class="number">10</span>  <span class="number">20</span>  <span class="number">30</span>]</span><br><span class="line"> [ <span class="number">40</span>  <span class="number">50</span>  <span class="number">60</span>  <span class="number">70</span>]</span><br><span class="line"> [ <span class="number">80</span>  <span class="number">90</span> <span class="number">100</span> <span class="number">110</span>]]</span><br></pre></td></tr></table></figure><p>（3）使用外部循环</p><p><code>nditer</code>类的构造器拥有flags参数，它可以接受下列值：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>c_index</code></td><td>可以跟踪C顺序的索引</td></tr><tr><td><code>f_index</code></td><td>可以跟踪Fortran顺序的索引</td></tr><tr><td><code>multi_index</code></td><td>每次迭代可以跟踪一种索引类型</td></tr><tr><td><code>external_loop</code></td><td>给出的值是具有多个值的一维数组，而不是零维数组</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 迭代器遍历对应于每列，并组合为一维数组</span></span><br><span class="line"><span class="comment"># 当数组的order与在循环中指定的order顺序不同时，打印为多个一维数组，当相同时，是整个一个一维数组。</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line">a = np.arange(<span class="number">0</span>,<span class="number">60</span>,<span class="number">5</span>) </span><br><span class="line">a = a.reshape(<span class="number">3</span>,<span class="number">4</span>)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;原始数组是：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;修改后的数组(F风格)是：&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> np.nditer(a, flags = [<span class="string">&#x27;external_loop&#x27;</span>], order = <span class="string">&#x27;F&#x27;</span>):  </span><br><span class="line">   <span class="built_in">print</span>(x, end=<span class="string">&quot;, &quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;修改后的数组(C风格)是：&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> y <span class="keyword">in</span> np.nditer(a, flags = [<span class="string">&#x27;external_loop&#x27;</span>], order = <span class="string">&#x27;C&#x27;</span>):  </span><br><span class="line">   <span class="built_in">print</span>(y, end=<span class="string">&quot;, &quot;</span>)</span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">原始数组是：</span><br><span class="line">[[ <span class="number">0</span>  <span class="number">5</span> <span class="number">10</span> <span class="number">15</span>]</span><br><span class="line"> [<span class="number">20</span> <span class="number">25</span> <span class="number">30</span> <span class="number">35</span>]</span><br><span class="line"> [<span class="number">40</span> <span class="number">45</span> <span class="number">50</span> <span class="number">55</span>]]</span><br><span class="line"></span><br><span class="line">修改后的数组(F风格)是：</span><br><span class="line">[ <span class="number">0</span> <span class="number">20</span> <span class="number">40</span>], [ <span class="number">5</span> <span class="number">25</span> <span class="number">45</span>], [<span class="number">10</span> <span class="number">30</span> <span class="number">50</span>], [<span class="number">15</span> <span class="number">35</span> <span class="number">55</span>], </span><br><span class="line"></span><br><span class="line">修改后的数组(C风格)是：</span><br><span class="line">[ <span class="number">0</span>  <span class="number">5</span> <span class="number">10</span> <span class="number">15</span> <span class="number">20</span> <span class="number">25</span> <span class="number">30</span> <span class="number">35</span> <span class="number">40</span> <span class="number">45</span> <span class="number">50</span> <span class="number">55</span>], </span><br></pre></td></tr></table></figure><p>（4）广播迭代</p><p>如果两个数组是可广播的，<code>nditer</code>组合对象能够同时迭代它们。 假设数组a的维度为3X4，数组b的维度为1X4 ，则使用以下迭代器（数组b被广播到a的大小）。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"> </span><br><span class="line">a = np.arange(<span class="number">0</span>,<span class="number">60</span>,<span class="number">5</span>) </span><br><span class="line">a = a.reshape(<span class="number">3</span>,<span class="number">4</span>)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;第一个数组为：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;第二个数组为：&#x27;</span>)</span><br><span class="line">b = np.array([<span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>,  <span class="number">4</span>], dtype = <span class="built_in">int</span>)  </span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;修改后的数组为：&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> x,y <span class="keyword">in</span> np.nditer([a,b]):  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;%d:%d&quot;</span>%(x,y), end=<span class="string">&quot;, &quot;</span>)</span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">第一个数组为：</span><br><span class="line">[[ <span class="number">0</span>  <span class="number">5</span> <span class="number">10</span> <span class="number">15</span>]</span><br><span class="line"> [<span class="number">20</span> <span class="number">25</span> <span class="number">30</span> <span class="number">35</span>]</span><br><span class="line"> [<span class="number">40</span> <span class="number">45</span> <span class="number">50</span> <span class="number">55</span>]]</span><br><span class="line"></span><br><span class="line">第二个数组为：</span><br><span class="line">[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">修改后的数组为：</span><br><span class="line"><span class="number">0</span>:<span class="number">1</span>, <span class="number">5</span>:<span class="number">2</span>, <span class="number">10</span>:<span class="number">3</span>, <span class="number">15</span>:<span class="number">4</span>, <span class="number">20</span>:<span class="number">1</span>, <span class="number">25</span>:<span class="number">2</span>, <span class="number">30</span>:<span class="number">3</span>, <span class="number">35</span>:<span class="number">4</span>, <span class="number">40</span>:<span class="number">1</span>, <span class="number">45</span>:<span class="number">2</span>, <span class="number">50</span>:<span class="number">3</span>, <span class="number">55</span>:<span class="number">4</span>, </span><br></pre></td></tr></table></figure><h3 id="👀NumPy数组操作"><a href="#👀NumPy数组操作" class="headerlink" title="👀NumPy数组操作"></a>👀NumPy数组操作</h3><p><code>Numpy</code>中包含了一些函数用于处理数组，大概可分为以下几类：</p><h4 id="👁修改数组形状"><a href="#👁修改数组形状" class="headerlink" title="👁修改数组形状"></a>👁修改数组形状</h4><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td><code>reshape</code></td><td>不改变数据的条件下修改形状</td></tr><tr><td><code>flat</code></td><td>数组元素迭代器</td></tr><tr><td><code>flatten</code></td><td>返回一份数组拷贝，对拷贝所做的修改不会影响原始数组</td></tr><tr><td><code>ravel</code></td><td>返回展开数组</td></tr></tbody></table><h4 id="👁翻转数组"><a href="#👁翻转数组" class="headerlink" title="👁翻转数组"></a>👁翻转数组</h4><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td><code>transpose</code></td><td>对换数组的维度</td></tr><tr><td><code>ndarray.T</code></td><td>和 <code>self.transpose()</code> 相同</td></tr><tr><td><code>rollaxis</code></td><td>向后滚动指定的轴</td></tr><tr><td><code>swapaxes</code></td><td>对换数组的两个轴</td></tr></tbody></table><h4 id="👁修改数组维度"><a href="#👁修改数组维度" class="headerlink" title="👁修改数组维度"></a>👁修改数组维度</h4><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td><code>broadcast</code></td><td>产生模仿广播的对象</td></tr><tr><td><code>broadcast_to</code></td><td>将数组广播到新形状</td></tr><tr><td><code>expand_dims</code></td><td>扩展数组的形状</td></tr><tr><td><code>squeeze</code></td><td>从数组的形状中删除一维条目</td></tr></tbody></table><h4 id="👁连接数组"><a href="#👁连接数组" class="headerlink" title="👁连接数组"></a>👁连接数组</h4><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td><code>concatenate</code></td><td>连接沿现有轴的数组序列</td></tr><tr><td><code>stack</code></td><td>沿着新的轴加入一系列数组。</td></tr><tr><td><code>hstack</code></td><td>水平堆叠序列中的数组（列方向）</td></tr><tr><td><code>vstack</code></td><td>竖直堆叠序列中的数组（行方向）</td></tr></tbody></table><h4 id="👁分割数组"><a href="#👁分割数组" class="headerlink" title="👁分割数组"></a>👁分割数组</h4><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td><code>split</code></td><td>将一个数组分割为多个子数组</td></tr><tr><td><code>hsplit</code></td><td>将一个数组水平分割为多个子数组（按列）</td></tr><tr><td><code>vsplit</code></td><td>将一个数组垂直分割为多个子数组（按行）</td></tr></tbody></table><h4 id="👁数组元素的添加与删除"><a href="#👁数组元素的添加与删除" class="headerlink" title="👁数组元素的添加与删除"></a>👁数组元素的添加与删除</h4><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td><code>resize</code></td><td>返回指定形状的新数组</td></tr><tr><td><code>append</code></td><td>将值添加到数组末尾</td></tr><tr><td><code>insert</code></td><td>沿指定轴将值插入到指定下标之前</td></tr><tr><td><code>delete</code></td><td>删掉某个轴的子数组，并返回删除后的新数组</td></tr><tr><td><code>unique</code></td><td>查找数组内的唯一元素</td></tr></tbody></table><h3 id="👀NumPy位运算"><a href="#👀NumPy位运算" class="headerlink" title="👀NumPy位运算"></a>👀NumPy位运算</h3><p><code>NumPy</code><strong>“bitwise_”</strong> 开头的函数是位运算函数。<code>NumPy</code>位运算包括以下几个函数：</p><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td><code>bitwise_and</code></td><td>对数组元素执行位与操作</td></tr><tr><td><code>bitwise_or</code></td><td>对数组元素执行位或操作</td></tr><tr><td><code>invert</code></td><td>按位取反</td></tr><tr><td><code>left_shift</code></td><td>向左移动二进制表示的位，相当于右侧附加相等数量的0</td></tr><tr><td><code>right_shift</code></td><td>向右移动二进制表示的位，相当于左侧附加相等数量的0</td></tr></tbody></table><p><code>bitwise_and()</code>函数对数组中整数的二进制形式执行位与运算。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;13和17的二进制形式：&#x27;</span>)</span><br><span class="line">a,b = <span class="number">13</span>,<span class="number">17</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">bin</span>(a), <span class="built_in">bin</span>(b))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;13和17的位与：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.bitwise_and(<span class="number">13</span>, <span class="number">17</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="number">13</span>和<span class="number">17</span>的二进制形式：</span><br><span class="line"><span class="number">0b1101</span> <span class="number">0b10001</span></span><br><span class="line"></span><br><span class="line"><span class="number">13</span>和<span class="number">17</span>的位与：</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p><code>bitwise_or()</code>函数对数组中整数的二进制形式执行位或运算。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"> </span><br><span class="line">a,b = <span class="number">13</span>,<span class="number">17</span> </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;13和17的二进制形式：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">bin</span>(a), <span class="built_in">bin</span>(b))</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;13和17的位或：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.bitwise_or(<span class="number">13</span>, <span class="number">17</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="number">13</span>和<span class="number">17</span>的二进制形式：</span><br><span class="line"><span class="number">0b1101</span> <span class="number">0b10001</span></span><br><span class="line"><span class="number">13</span>和<span class="number">17</span>的位或：</span><br><span class="line"><span class="number">29</span></span><br></pre></td></tr></table></figure><p><code>invert()</code>函数对数组中整数进行位取反运算，即0变成1，1变成0。对于有符号整数，取该二进制数的补码，然后 +1。二进制数，最高位为0表示正数，最高位为1表示负数。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;13的位反转，其中ndarray的dtype是uint8：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.invert(np.array([<span class="number">13</span>], dtype = np.uint8)))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="comment"># 比较13和242的二进制表示，我们发现了位的反转</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;13的二进制表示：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.binary_repr(<span class="number">13</span>, width = <span class="number">8</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;242的二进制表示：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.binary_repr(<span class="number">242</span>, width = <span class="number">8</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="number">13</span>的位反转，其中ndarray的dtype是uint8：</span><br><span class="line">[<span class="number">242</span>]</span><br><span class="line"></span><br><span class="line"><span class="number">13</span>的二进制表示：</span><br><span class="line">00001101</span><br><span class="line"></span><br><span class="line"><span class="number">242</span>的二进制表示：</span><br><span class="line"><span class="number">11110010</span></span><br></pre></td></tr></table></figure><p><code>left_shift()</code>函数将数组元素的二进制形式向左移动到指定位置，右侧附加相等数量的0。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;将10左移两位：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.left_shift(<span class="number">10</span>,<span class="number">2</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;10的二进制表示：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.binary_repr(<span class="number">10</span>, width = <span class="number">8</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;40的二进制表示：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.binary_repr(<span class="number">40</span>, width = <span class="number">8</span>))</span><br><span class="line"><span class="comment"># &#x27;00001010&#x27; 中的两位移动到了左边，并在右边添加了两个0。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">将<span class="number">10</span>左移两位：</span><br><span class="line"><span class="number">40</span></span><br><span class="line"></span><br><span class="line"><span class="number">10</span>的二进制表示：</span><br><span class="line"><span class="number">0000</span>1010</span><br><span class="line"></span><br><span class="line"><span class="number">40</span>的二进制表示：</span><br><span class="line"><span class="number">00</span>101000</span><br></pre></td></tr></table></figure><p><code>right_shift()</code>函数将数组元素的二进制形式向右移动到指定位置，左侧附加相等数量的0。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;将40右移两位：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.right_shift(<span class="number">40</span>,<span class="number">2</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;40的二进制表示：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.binary_repr(<span class="number">40</span>, width = <span class="number">8</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;10的二进制表示：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.binary_repr(<span class="number">10</span>, width = <span class="number">8</span>))</span><br><span class="line"><span class="comment"># &#x27;00001010&#x27;中的两位移动到了右边，并在左边添加了两个0。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">将<span class="number">40</span>右移两位：</span><br><span class="line"><span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="number">40</span>的二进制表示：</span><br><span class="line"><span class="number">00</span>101000</span><br><span class="line"></span><br><span class="line"><span class="number">10</span>的二进制表示：</span><br><span class="line"><span class="number">0000</span>1010</span><br></pre></td></tr></table></figure><h3 id="👀NumPy字符串函数"><a href="#👀NumPy字符串函数" class="headerlink" title="👀NumPy字符串函数"></a>👀NumPy字符串函数</h3><p>以下函数用于对<code>dtype</code>为<code>numpy.string_</code>或<code>numpy.unicode_</code>的数组执行向量化字符串操作。 它们基于Python 内置库中的标准字符串函数。这些函数在字符数组类（<code>numpy.char</code>）中定义。</p><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td><code>add()</code></td><td>对两个数组的逐个字符串元素进行连接</td></tr><tr><td><code>multiply()</code></td><td>返回按元素多重连接后的字符串</td></tr><tr><td><code>center()</code></td><td>居中字符串</td></tr><tr><td><code>capitalize()</code></td><td>将字符串第一个字母转换为大写</td></tr><tr><td><code>title()</code></td><td>将字符串的每个单词的第一个字母转换为大写</td></tr><tr><td><code>lower()</code></td><td>数组元素转换为小写</td></tr><tr><td><code>upper()</code></td><td>数组元素转换为大写</td></tr><tr><td><code>split()</code></td><td>指定分隔符对字符串进行分割，并返回数组列表</td></tr><tr><td><code>splitlines()</code></td><td>返回元素中的行列表，以换行符分割</td></tr><tr><td><code>strip()</code></td><td>移除元素开头或者结尾处的特定字符</td></tr><tr><td><code>join()</code></td><td>通过指定分隔符来连接数组中的元素</td></tr><tr><td><code>replace()</code></td><td>使用新字符串替换字符串中的所有子字符串</td></tr><tr><td><code>decode()</code></td><td>数组元素依次调用<code>str.decode</code></td></tr><tr><td><code>encode()</code></td><td>数组元素依次调用<code>str.encode</code></td></tr></tbody></table><p><code>numpy.char.add()</code>函数依次对两个数组的元素进行字符串连接。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;连接两个字符串：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.char.add([<span class="string">&#x27;hello&#x27;</span>],[<span class="string">&#x27; xyz&#x27;</span>]))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;连接示例：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.char.add([<span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27;hi&#x27;</span>],[<span class="string">&#x27; abc&#x27;</span>, <span class="string">&#x27; xyz&#x27;</span>]))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">连接两个字符串：</span><br><span class="line">[<span class="string">&#x27;hello xyz&#x27;</span>]</span><br><span class="line"></span><br><span class="line">连接示例：</span><br><span class="line">[<span class="string">&#x27;hello abc&#x27;</span> <span class="string">&#x27;hi xyz&#x27;</span>]</span><br></pre></td></tr></table></figure><p><code>numpy.char.multiply()</code>函数执行多重连接。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(np.char.multiply(<span class="string">&#x27;Runoob &#x27;</span>,<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">Runoob Runoob Runoob </span><br></pre></td></tr></table></figure><p><code>numpy.char.center()</code>函数用于将字符串居中，并使用指定字符在左侧和右侧进行填充。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"> </span><br><span class="line"><span class="comment"># np.char.center(str , width,fillchar) ：</span></span><br><span class="line"><span class="comment"># str: 字符串，width: 长度，fillchar: 填充字符</span></span><br><span class="line"><span class="built_in">print</span>(np.char.center(<span class="string">&#x27;Runoob&#x27;</span>, <span class="number">20</span>,fillchar = <span class="string">&#x27;*&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">*******Runoob*******</span><br></pre></td></tr></table></figure><p><code>numpy.char.capitalize()</code>函数将字符串的第一个字母转换为大写。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(np.char.capitalize(<span class="string">&#x27;runoob&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">Runoob</span><br></pre></td></tr></table></figure><p><code>numpy.char.title()</code>函数将字符串的每个单词的第一个字母转换为大写。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(np.char.title(<span class="string">&#x27;i like runoob&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">I Like Runoob</span><br></pre></td></tr></table></figure><p><code>numpy.char.lower()</code>函数对数组的每个元素转换为小写。它对每个元素调用str.lower。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"> </span><br><span class="line"><span class="comment">#操作数组</span></span><br><span class="line"><span class="built_in">print</span>(np.char.lower([<span class="string">&#x27;RUNOOB&#x27;</span>,<span class="string">&#x27;GOOGLE&#x27;</span>]))</span><br><span class="line"><span class="comment"># 操作字符串</span></span><br><span class="line"><span class="built_in">print</span>(np.char.lower(<span class="string">&#x27;RUNOOB&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[<span class="string">&#x27;runoob&#x27;</span> <span class="string">&#x27;google&#x27;</span>]</span><br><span class="line">runoob</span><br></pre></td></tr></table></figure><p><code>numpy.char.upper()</code>函数对数组的每个元素转换为大写。它对每个元素调用 str.upper。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"> </span><br><span class="line"><span class="comment">#操作数组</span></span><br><span class="line"><span class="built_in">print</span>(np.char.upper([<span class="string">&#x27;runoob&#x27;</span>,<span class="string">&#x27;google&#x27;</span>]))</span><br><span class="line"><span class="comment"># 操作字符串</span></span><br><span class="line"><span class="built_in">print</span>(np.char.upper(<span class="string">&#x27;runoob&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[<span class="string">&#x27;RUNOOB&#x27;</span> <span class="string">&#x27;GOOGLE&#x27;</span>]</span><br><span class="line">RUNOOB</span><br></pre></td></tr></table></figure><p><code>numpy.char.split()</code>通过指定分隔符对字符串进行分割，并返回数组。默认情况下，分隔符为空格。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"> </span><br><span class="line"><span class="comment"># 分隔符默认为空格</span></span><br><span class="line"><span class="built_in">print</span>(np.char.split(<span class="string">&#x27;i like runoob?&#x27;</span>))</span><br><span class="line"><span class="comment"># 分隔符为.</span></span><br><span class="line"><span class="built_in">print</span>(np.char.split(<span class="string">&#x27;www.runoob.com&#x27;</span>, sep = <span class="string">&#x27;.&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[<span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;like&#x27;</span>, <span class="string">&#x27;runoob?&#x27;</span>]</span><br><span class="line">[<span class="string">&#x27;www&#x27;</span>, <span class="string">&#x27;runoob&#x27;</span>, <span class="string">&#x27;com&#x27;</span>]</span><br></pre></td></tr></table></figure><p><code>numpy.char.splitlines()</code>函数以换行符作为分隔符来分割字符串，并返回数组。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"><span class="comment"># \n，\r，\r\n 都可用作换行符。</span></span><br><span class="line"><span class="comment"># 换行符\n</span></span><br><span class="line"><span class="built_in">print</span>(np.char.splitlines(<span class="string">&#x27;i\nlike runoob?&#x27;</span>)) </span><br><span class="line"><span class="built_in">print</span>(np.char.splitlines(<span class="string">&#x27;i\rlike runoob?&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[<span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;like runoob?&#x27;</span>]</span><br><span class="line">[<span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;like runoob?&#x27;</span>]</span><br></pre></td></tr></table></figure><p><code>numpy.char.strip()</code>函数用于移除开头或结尾处的特定字符。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"> </span><br><span class="line"><span class="comment"># 移除字符串头尾的a字符</span></span><br><span class="line"><span class="built_in">print</span>(np.char.strip(<span class="string">&#x27;ashok arunooba&#x27;</span>,<span class="string">&#x27;a&#x27;</span>))</span><br><span class="line"><span class="comment"># 移除数组元素头尾的a字符</span></span><br><span class="line"><span class="built_in">print</span>(np.char.strip([<span class="string">&#x27;arunooba&#x27;</span>,<span class="string">&#x27;admin&#x27;</span>,<span class="string">&#x27;java&#x27;</span>],<span class="string">&#x27;a&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">shok arunoob</span><br><span class="line">[<span class="string">&#x27;runoob&#x27;</span> <span class="string">&#x27;dmin&#x27;</span> <span class="string">&#x27;jav&#x27;</span>]</span><br></pre></td></tr></table></figure><p><code>numpy.char.join()</code>函数通过指定分隔符来连接数组中的元素或字符串</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"> </span><br><span class="line"><span class="comment"># 操作字符串</span></span><br><span class="line"><span class="built_in">print</span>(np.char.join(<span class="string">&#x27;:&#x27;</span>,<span class="string">&#x27;runoob&#x27;</span>))</span><br><span class="line"><span class="comment"># 指定多个分隔符操作数组元素</span></span><br><span class="line"><span class="built_in">print</span>(np.char.join([<span class="string">&#x27;:&#x27;</span>,<span class="string">&#x27;-&#x27;</span>],[<span class="string">&#x27;runoob&#x27;</span>,<span class="string">&#x27;google&#x27;</span>]))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">r:u:n:o:o:b</span><br><span class="line">[<span class="string">&#x27;r:u:n:o:o:b&#x27;</span> <span class="string">&#x27;g-o-o-g-l-e&#x27;</span>]</span><br></pre></td></tr></table></figure><p><code>numpy.char.replace()</code>函数使用新字符串替换字符串中的所有子字符串。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(np.char.replace(<span class="string">&#x27;i like runoob&#x27;</span>, <span class="string">&#x27;oo&#x27;</span>, <span class="string">&#x27;cc&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">i like runccb</span><br></pre></td></tr></table></figure><p><code>numpy.char.encode()</code>函数对数组中的每个元素调用<code>str.encode</code>函数。 默认编码是utf-8，可以使用标准Python库中的编解码器。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"> </span><br><span class="line">a = np.char.encode(<span class="string">&#x27;runoob&#x27;</span>, <span class="string">&#x27;cp500&#x27;</span>) </span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="string">b&#x27;\x99\xa4\x95\x96\x96\x82&#x27;</span></span><br></pre></td></tr></table></figure><p><code>numpy.char.decode()</code>函数对编码的元素进行<code>str.decode()</code>解码。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"> </span><br><span class="line">a = np.char.encode(<span class="string">&#x27;runoob&#x27;</span>, <span class="string">&#x27;cp500&#x27;</span>) </span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(np.char.decode(a,<span class="string">&#x27;cp500&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="string">b&#x27;\x99\xa4\x95\x96\x96\x82&#x27;</span></span><br><span class="line">runoob</span><br></pre></td></tr></table></figure><h3 id="👀NumPy数学函数"><a href="#👀NumPy数学函数" class="headerlink" title="👀NumPy数学函数"></a>👀NumPy数学函数</h3><p><code>NumPy</code>包含大量的各种数学运算的函数，包括三角函数，算术运算的函数，复数处理函数等。</p><p>（1）三角函数</p><p>NumPy提供了标准的三角函数：sin()、cos()、tan()。arcsin，arccos，和arctan函数返回给定角度的sin，cos和tan的反三角函数。这些函数的结果可以通过<code>numpy.degrees()</code>函数将弧度转换为角度。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"> </span><br><span class="line">a = np.array([<span class="number">0</span>,<span class="number">30</span>,<span class="number">45</span>,<span class="number">60</span>,<span class="number">90</span>])  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;含有正弦值的数组：&#x27;</span>)</span><br><span class="line">sin = np.sin(a*np.pi/<span class="number">180</span>)  </span><br><span class="line"><span class="built_in">print</span>(sin)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;计算角度的反正弦，返回值以弧度为单位：&#x27;</span>)</span><br><span class="line">inv = np.arcsin(sin)  </span><br><span class="line"><span class="built_in">print</span>(inv)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;通过转化为角度制来检查结果：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.degrees(inv))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">含有正弦值的数组：</span><br><span class="line">[<span class="number">0.</span>         <span class="number">0.5</span>        <span class="number">0.70710678</span> <span class="number">0.8660254</span>  <span class="number">1.</span>        ]</span><br><span class="line"></span><br><span class="line">计算角度的反正弦，返回值以弧度为单位：</span><br><span class="line">[<span class="number">0.</span>         <span class="number">0.52359878</span> <span class="number">0.78539816</span> <span class="number">1.04719755</span> <span class="number">1.57079633</span>]</span><br><span class="line"></span><br><span class="line">通过转化为角度制来检查结果：</span><br><span class="line">[ <span class="number">0.</span> <span class="number">30.</span> <span class="number">45.</span> <span class="number">60.</span> <span class="number">90.</span>]</span><br></pre></td></tr></table></figure><p>（2）舍入函数</p><p><code>numpy.around()</code>函数返回指定数字的四舍五入值。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numpy.around(a,decimals)</span><br><span class="line">参数说明：</span><br><span class="line">    a: 数组</span><br><span class="line">    decimals: 舍入的小数位数。默认值为<span class="number">0</span>。如果为负，整数将四舍五入到小数点左侧的位置。例如decimals为-<span class="number">1</span>，代表舍入到十位，<span class="number">13</span>舍入为<span class="number">10</span>,<span class="number">16</span>舍入为<span class="number">20</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"> </span><br><span class="line">a = np.array([<span class="number">1.0</span>,<span class="number">5.55</span>,<span class="number">123</span>,<span class="number">0.567</span>,<span class="number">25.532</span>])  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;原数组：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;舍入后：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.around(a))</span><br><span class="line"><span class="built_in">print</span>(np.around(a, decimals = <span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(np.around(a, decimals = -<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">原数组：</span><br><span class="line">[<span class="number">1.</span><span class="number">5.55</span>  <span class="number">123.</span><span class="number">0.567</span>  <span class="number">25.532</span>]</span><br><span class="line"></span><br><span class="line">舍入后：</span><br><span class="line">[<span class="number">1.</span>  <span class="number">6.</span> <span class="number">123.</span>   <span class="number">1.</span>  <span class="number">26.</span>]</span><br><span class="line">[<span class="number">1.</span>  <span class="number">5.6</span> <span class="number">123.</span>    <span class="number">0.6</span>  <span class="number">25.5</span>]</span><br><span class="line">[<span class="number">0.</span>  <span class="number">10.</span> <span class="number">120.</span>   <span class="number">0.</span>  <span class="number">30.</span>]</span><br></pre></td></tr></table></figure><p><code>numpy.floor()</code>返回小于或者等于指定表达式的最大整数，即向下取整。</p><p><code>numpy.ceil()</code>返回大于或者等于指定表达式的最小整数，即向上取整。</p><h3 id="👀NumPy算术函数"><a href="#👀NumPy算术函数" class="headerlink" title="👀NumPy算术函数"></a>👀NumPy算术函数</h3><p><code>NumPy</code>算术函数包含简单的加减乘除: add()，subtract()，multiply()和divide()。需要注意的是数组必须具有相同的形状或符合数组广播规则。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"> </span><br><span class="line">a = np.arange(<span class="number">9</span>, dtype = np.float_).reshape(<span class="number">3</span>,<span class="number">3</span>)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;第一个数组：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;第二个数组：&#x27;</span>)</span><br><span class="line">b = np.array([<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>])  </span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;两个数组相加：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.add(a,b))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;两个数组相减：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.subtract(a,b))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;两个数组相乘：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.multiply(a,b))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;两个数组相除：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.divide(a,b))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">第一个数组：</span><br><span class="line">[[<span class="number">0.</span> <span class="number">1.</span> <span class="number">2.</span>]</span><br><span class="line"> [<span class="number">3.</span> <span class="number">4.</span> <span class="number">5.</span>]</span><br><span class="line"> [<span class="number">6.</span> <span class="number">7.</span> <span class="number">8.</span>]]</span><br><span class="line"></span><br><span class="line">第二个数组：</span><br><span class="line">[<span class="number">10</span> <span class="number">10</span> <span class="number">10</span>]</span><br><span class="line"></span><br><span class="line">两个数组相加：</span><br><span class="line">[[<span class="number">10.</span> <span class="number">11.</span> <span class="number">12.</span>]</span><br><span class="line"> [<span class="number">13.</span> <span class="number">14.</span> <span class="number">15.</span>]</span><br><span class="line"> [<span class="number">16.</span> <span class="number">17.</span> <span class="number">18.</span>]]</span><br><span class="line"></span><br><span class="line">两个数组相减：</span><br><span class="line">[[-<span class="number">10.</span>  -<span class="number">9.</span>  -<span class="number">8.</span>]</span><br><span class="line"> [ -<span class="number">7.</span>  -<span class="number">6.</span>  -<span class="number">5.</span>]</span><br><span class="line"> [ -<span class="number">4.</span>  -<span class="number">3.</span>  -<span class="number">2.</span>]]</span><br><span class="line"></span><br><span class="line">两个数组相乘：</span><br><span class="line">[[ <span class="number">0.</span> <span class="number">10.</span> <span class="number">20.</span>]</span><br><span class="line"> [<span class="number">30.</span> <span class="number">40.</span> <span class="number">50.</span>]</span><br><span class="line"> [<span class="number">60.</span> <span class="number">70.</span> <span class="number">80.</span>]]</span><br><span class="line"></span><br><span class="line">两个数组相除：</span><br><span class="line">[[<span class="number">0.</span>  <span class="number">0.1</span> <span class="number">0.2</span>]</span><br><span class="line"> [<span class="number">0.3</span> <span class="number">0.4</span> <span class="number">0.5</span>]</span><br><span class="line"> [<span class="number">0.6</span> <span class="number">0.7</span> <span class="number">0.8</span>]]</span><br></pre></td></tr></table></figure><p><code>numpy.reciprocal()</code>函数返回参数逐元素的倒数。如 <strong>1&#x2F;4</strong> 倒数为 <strong>4&#x2F;1</strong>。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"> </span><br><span class="line">a = np.array([<span class="number">0.25</span>,  <span class="number">1.33</span>,  <span class="number">1</span>,  <span class="number">100</span>])  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;我们的数组是：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;调用 reciprocal 函数：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.reciprocal(a))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">我们的数组是：</span><br><span class="line">[<span class="number">0.25</span>  <span class="number">1.33</span>  <span class="number">1.</span>  <span class="number">100.</span>]</span><br><span class="line"></span><br><span class="line">调用 reciprocal 函数：</span><br><span class="line">[<span class="number">4.</span><span class="number">0.7518797</span><span class="number">1.</span><span class="number">0.01</span>]</span><br></pre></td></tr></table></figure><p><code>numpy.power()</code>函数将第一个输入数组中的元素作为底数，计算它与第二个输入数组中相应元素的幂。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"> </span><br><span class="line">a = np.array([<span class="number">10</span>,<span class="number">100</span>,<span class="number">1000</span>])  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;我们的数组是；&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;调用 power 函数：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.power(a,<span class="number">2</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;第二个数组：&#x27;</span>)</span><br><span class="line">b = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])  </span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;再次调用 power 函数：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.power(a,b))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">我们的数组是；</span><br><span class="line">[<span class="number">10</span><span class="number">100</span> <span class="number">1000</span>]</span><br><span class="line"></span><br><span class="line">调用power函数：</span><br><span class="line">[<span class="number">100</span><span class="number">10000</span><span class="number">1000000</span>]</span><br><span class="line"></span><br><span class="line">第二个数组：</span><br><span class="line">[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">再次调用 power 函数：</span><br><span class="line">[<span class="number">10</span><span class="number">10000</span> <span class="number">1000000000</span>]</span><br></pre></td></tr></table></figure><p><code>numpy.mod()</code>计算输入数组中相应元素的相除后的余数。 函数<code>numpy.remainder()</code>也产生相同的结果。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"> </span><br><span class="line">a = np.array([<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>]) </span><br><span class="line">b = np.array([<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>])  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;第一个数组：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;第二个数组：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;调用 mod() 函数：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.mod(a,b))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;调用 remainder() 函数：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.remainder(a,b))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">第一个数组：</span><br><span class="line">[<span class="number">10</span> <span class="number">20</span> <span class="number">30</span>]</span><br><span class="line"></span><br><span class="line">第二个数组：</span><br><span class="line">[<span class="number">3</span> <span class="number">5</span> <span class="number">7</span>]</span><br><span class="line"></span><br><span class="line">调用mod()函数：</span><br><span class="line">[<span class="number">1</span> <span class="number">0</span> <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">调用remainder()函数：</span><br><span class="line">[<span class="number">1</span> <span class="number">0</span> <span class="number">2</span>]</span><br></pre></td></tr></table></figure><h3 id="👀NumPy统计函数"><a href="#👀NumPy统计函数" class="headerlink" title="👀NumPy统计函数"></a>👀NumPy统计函数</h3><p><code>NumPy</code>提供了很多统计函数，用于从数组中查找<strong>最小元素</strong>，<strong>最大元素</strong>，<strong>百分位标准差</strong>和<strong>方差</strong>等。 函数说明如下：</p><p><code>numpy.amin()</code>用于计算数组中的元素沿指定轴的最小值。</p><p><code>numpy.amax()</code>用于计算数组中的元素沿指定轴的最大值。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"> </span><br><span class="line">a = np.array([[<span class="number">3</span>,<span class="number">7</span>,<span class="number">5</span>],[<span class="number">8</span>,<span class="number">4</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">4</span>,<span class="number">9</span>]])  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;我们的数组是：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;调用amin()函数：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.amin(a,<span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;再次调用amin()函数：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.amin(a,<span class="number">0</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;调用amax()函数：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.amax(a))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;再次调用amax()函数：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.amax(a, axis = <span class="number">0</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">我们的数组是：</span><br><span class="line">[[<span class="number">3</span> <span class="number">7</span> <span class="number">5</span>]</span><br><span class="line"> [<span class="number">8</span> <span class="number">4</span> <span class="number">3</span>]</span><br><span class="line"> [<span class="number">2</span> <span class="number">4</span> <span class="number">9</span>]]</span><br><span class="line"></span><br><span class="line">调用amin()函数：</span><br><span class="line">[<span class="number">3</span> <span class="number">3</span> <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">再次调用amin()函数：</span><br><span class="line">[<span class="number">2</span> <span class="number">4</span> <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">调用amax()函数：</span><br><span class="line"><span class="number">9</span></span><br><span class="line"></span><br><span class="line">再次调用amax()函数：</span><br><span class="line">[<span class="number">8</span> <span class="number">7</span> <span class="number">9</span>]</span><br></pre></td></tr></table></figure><p><code>numpy.ptp()</code>函数计算数组中元素最大值与最小值的差（最大值 - 最小值）。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"> </span><br><span class="line">a = np.array([[<span class="number">3</span>,<span class="number">7</span>,<span class="number">5</span>],[<span class="number">8</span>,<span class="number">4</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">4</span>,<span class="number">9</span>]])  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;我们的数组是：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;调用ptp()函数：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.ptp(a))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;沿轴1调用ptp()函数：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.ptp(a, axis = <span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;沿轴0调用ptp()函数：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.ptp(a, axis = <span class="number">0</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">我们的数组是：</span><br><span class="line">[[<span class="number">3</span> <span class="number">7</span> <span class="number">5</span>]</span><br><span class="line"> [<span class="number">8</span> <span class="number">4</span> <span class="number">3</span>]</span><br><span class="line"> [<span class="number">2</span> <span class="number">4</span> <span class="number">9</span>]]</span><br><span class="line"></span><br><span class="line">调用ptp()函数：</span><br><span class="line"><span class="number">7</span></span><br><span class="line"></span><br><span class="line">沿轴<span class="number">1</span>调用ptp()函数：</span><br><span class="line">[<span class="number">4</span> <span class="number">5</span> <span class="number">7</span>]</span><br><span class="line"></span><br><span class="line">沿轴<span class="number">0</span>调用ptp()函数：</span><br><span class="line">[<span class="number">6</span> <span class="number">3</span> <span class="number">6</span>]</span><br></pre></td></tr></table></figure><p>百分位数是统计中使用的度量，表示小于这个值的观察值的百分比。 函数<code>numpy.percentile()</code>接受以下参数。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numpy.percentile(a, q, axis)</span><br><span class="line">参数说明：</span><br><span class="line">    a: 输入数组</span><br><span class="line">    q: 要计算的百分位数，在<span class="number">0</span>~<span class="number">100</span>之间</span><br><span class="line">    axis: 沿着它计算百分位数的轴</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"> </span><br><span class="line">a = np.array([[<span class="number">10</span>, <span class="number">7</span>, <span class="number">4</span>], [<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;我们的数组是：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;调用percentile()函数：&#x27;</span>)</span><br><span class="line"><span class="comment"># 50%的分位数，就是a里排序之后的中位数</span></span><br><span class="line"><span class="built_in">print</span>(np.percentile(a,<span class="number">50</span>)) </span><br><span class="line"><span class="comment"># axis为0，在纵列上求</span></span><br><span class="line"><span class="built_in">print</span>(np.percentile(a,<span class="number">50</span>,axis=<span class="number">0</span>)) </span><br><span class="line"><span class="comment"># axis为1，在横行上求</span></span><br><span class="line"><span class="built_in">print</span>(np.percentile(a,<span class="number">50</span>,axis=<span class="number">1</span>)) </span><br><span class="line"><span class="comment"># 保持维度不变</span></span><br><span class="line"><span class="built_in">print</span>(np.percentile(a,<span class="number">50</span>,axis=<span class="number">1</span>,keepdims=<span class="literal">True</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">我们的数组是：</span><br><span class="line">[[<span class="number">10</span>  <span class="number">7</span>  <span class="number">4</span>]</span><br><span class="line"> [ <span class="number">3</span>  <span class="number">2</span>  <span class="number">1</span>]]</span><br><span class="line">调用percentile()函数：</span><br><span class="line"><span class="number">3.5</span></span><br><span class="line">[<span class="number">6.5</span> <span class="number">4.5</span> <span class="number">2.5</span>]</span><br><span class="line">[<span class="number">7.</span> <span class="number">2.</span>]</span><br><span class="line">[[<span class="number">7.</span>]</span><br><span class="line"> [<span class="number">2.</span>]]</span><br></pre></td></tr></table></figure><p><code>numpy.median()</code>函数用于计算数组a中元素的中位数（中值）</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"> </span><br><span class="line">a = np.array([[<span class="number">30</span>,<span class="number">65</span>,<span class="number">70</span>],[<span class="number">80</span>,<span class="number">95</span>,<span class="number">10</span>],[<span class="number">50</span>,<span class="number">90</span>,<span class="number">60</span>]])  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;我们的数组是：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;调用median()函数：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.median(a))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;沿轴0调用median()函数：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.median(a, axis = <span class="number">0</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;沿轴1调用median()函数：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.median(a, axis = <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">我们的数组是：</span><br><span class="line">[[<span class="number">30</span> <span class="number">65</span> <span class="number">70</span>]</span><br><span class="line"> [<span class="number">80</span> <span class="number">95</span> <span class="number">10</span>]</span><br><span class="line"> [<span class="number">50</span> <span class="number">90</span> <span class="number">60</span>]]</span><br><span class="line"></span><br><span class="line">调用median()函数：</span><br><span class="line"><span class="number">65.0</span></span><br><span class="line"></span><br><span class="line">沿轴<span class="number">0</span>调用median()函数：</span><br><span class="line">[<span class="number">50.</span> <span class="number">90.</span> <span class="number">60.</span>]</span><br><span class="line"></span><br><span class="line">沿轴<span class="number">1</span>调用median()函数：</span><br><span class="line">[<span class="number">65.</span> <span class="number">80.</span> <span class="number">60.</span>]</span><br></pre></td></tr></table></figure><p><code>numpy.mean()</code>函数返回数组中元素的算术平均值。 如果提供了轴，则沿其计算。算术平均值是沿轴的元素的总和除以元素的数量。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"> </span><br><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]])  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;我们的数组是：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;调用mean()函数：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.mean(a))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;沿轴0调用mean()函数：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.mean(a, axis = <span class="number">0</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;沿轴1调用mean()函数：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.mean(a, axis = <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">我们的数组是：</span><br><span class="line">[[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]</span><br><span class="line"> [<span class="number">3</span> <span class="number">4</span> <span class="number">5</span>]</span><br><span class="line"> [<span class="number">4</span> <span class="number">5</span> <span class="number">6</span>]]</span><br><span class="line"></span><br><span class="line">调用mean()函数：</span><br><span class="line"><span class="number">3.6666666666666665</span></span><br><span class="line"></span><br><span class="line">沿轴<span class="number">0</span>调用mean()函数：</span><br><span class="line">[<span class="number">2.66666667</span> <span class="number">3.66666667</span> <span class="number">4.66666667</span>]</span><br><span class="line"></span><br><span class="line">沿轴<span class="number">1</span>调用mean()函数：</span><br><span class="line">[<span class="number">2.</span> <span class="number">4.</span> <span class="number">5.</span>]</span><br></pre></td></tr></table></figure><p><code>numpy.average()</code>函数根据在另一个数组中给出的各自的权重计算数组中元素的加权平均值。该函数可以接受一个轴参数。 如果没有指定轴，则数组会被展开。加权平均值即将各数值乘以相应的权数，然后加总求和得到总体值，再除以总的单位数。考虑数组[1,2,3,4]和相应的权重[4,3,2,1]，通过将相应元素的乘积相加，并将和除以权重的和，来计算加权平均值。</p><blockquote><p>加权平均值 &#x3D; (1*4+2*3+3*2+4*1)&#x2F;(4+3+2+1)</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"> </span><br><span class="line">a = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;我们的数组是：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;调用average()函数：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.average(a))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="comment"># 不指定权重时相当于mean函数</span></span><br><span class="line">wts = np.array([<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>])  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;再次调用average()函数：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.average(a,weights = wts))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="comment"># 如果returned参数设为true，则返回权重的和  </span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;权重的和：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.average([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],weights = [<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>], returned = <span class="literal">True</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">我们的数组是：</span><br><span class="line">[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">调用average()函数：</span><br><span class="line"><span class="number">2.5</span></span><br><span class="line"></span><br><span class="line">再次调用average()函数：</span><br><span class="line"><span class="number">2.0</span></span><br><span class="line"></span><br><span class="line">权重的和：</span><br><span class="line">(<span class="number">2.0</span>, <span class="number">10.0</span>)</span><br></pre></td></tr></table></figure><p>在多维数组中，可以指定用于计算的轴。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"> </span><br><span class="line">a = np.arange(<span class="number">6</span>).reshape(<span class="number">3</span>,<span class="number">2</span>)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;我们的数组是：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;修改后的数组：&#x27;</span>)</span><br><span class="line">wt = np.array([<span class="number">3</span>,<span class="number">5</span>])  </span><br><span class="line"><span class="built_in">print</span>(np.average(a, axis = <span class="number">1</span>, weights = wt))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;修改后的数组：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.average(a, axis = <span class="number">1</span>, weights = wt, returned = <span class="literal">True</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">我们的数组是：</span><br><span class="line">[[<span class="number">0</span> <span class="number">1</span>]</span><br><span class="line"> [<span class="number">2</span> <span class="number">3</span>]</span><br><span class="line"> [<span class="number">4</span> <span class="number">5</span>]]</span><br><span class="line"></span><br><span class="line">修改后的数组：</span><br><span class="line">[<span class="number">0.625</span> <span class="number">2.625</span> <span class="number">4.625</span>]</span><br><span class="line"></span><br><span class="line">修改后的数组：</span><br><span class="line">(array([<span class="number">0.625</span>, <span class="number">2.625</span>, <span class="number">4.625</span>]), array([<span class="number">8.</span>, <span class="number">8.</span>, <span class="number">8.</span>]))</span><br></pre></td></tr></table></figure><p>标准差是一组数据平均值分散程度的一种度量。标准差是方差的算术平方根。标准差公式如下：</p><blockquote><p><code>std = sqrt(mean((x-x.mean())**2))</code></p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(np.std([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="number">1.118033988749895</span></span><br></pre></td></tr></table></figure><p>统计中的方差（样本方差）是每个样本值与全体样本值的平均数之差的平方值的平均数，即<code>mean((x-x.mean())**2)</code>。换句话说，标准差是方差的平方根。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(np.var([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="number">1.25</span></span><br></pre></td></tr></table></figure><h3 id="👀NumPy排序、条件筛选函数"><a href="#👀NumPy排序、条件筛选函数" class="headerlink" title="👀NumPy排序、条件筛选函数"></a>👀NumPy排序、条件筛选函数</h3><p><code>NumPy</code>提供了多种排序的方法。 这些排序函数实现不同的排序算法，每个排序算法的特征在于执行速度，最坏情况性能，所需的工作空间和算法的稳定性。 下表显示了三种排序算法的比较。</p><table><thead><tr><th>种类</th><th>速度</th><th>最坏情况</th><th>工作空间</th><th>稳定性</th></tr></thead><tbody><tr><td><code>&#39;quicksort&#39;</code>（快速排序）</td><td>1</td><td>O(n^2)</td><td>0</td><td>否</td></tr><tr><td><code>&#39;mergesort&#39;</code>（归并排序）</td><td>2</td><td>O(n*log(n))</td><td>~n&#x2F;2</td><td>是</td></tr><tr><td><code>&#39;heapsort&#39;</code>（堆排序）</td><td>3</td><td>O(n*log(n))</td><td>0</td><td>否</td></tr></tbody></table><p><code>numpy.sort()</code>函数返回输入数组的排序副本。函数格式如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numpy.sort(a, axis, kind, order)</span><br><span class="line">参数说明：</span><br><span class="line">    a: 要排序的数组</span><br><span class="line">    axis: 沿着它排序数组的轴，如果没有数组会被展开，沿着最后的轴排序， axis=<span class="number">0</span>按列排序，axis=<span class="number">1</span>按行排序</span><br><span class="line">    kind: 默认为<span class="string">&#x27;quicksort&#x27;</span>（快速排序）</span><br><span class="line">    order: 如果数组包含字段，则是要排序的字段</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np  </span><br><span class="line"> </span><br><span class="line">a = np.array([[<span class="number">3</span>,<span class="number">7</span>],[<span class="number">9</span>,<span class="number">1</span>]])  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;我们的数组是：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;调用sort()函数：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.sort(a))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;按列排序：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.sort(a, axis =  <span class="number">0</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="comment"># 在sort函数中排序字段 </span></span><br><span class="line">dt = np.dtype([(<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;S10&#x27;</span>),(<span class="string">&#x27;age&#x27;</span>,<span class="built_in">int</span>)]) </span><br><span class="line">a = np.array([(<span class="string">&quot;raju&quot;</span>,<span class="number">21</span>),(<span class="string">&quot;anil&quot;</span>,<span class="number">25</span>),(<span class="string">&quot;ravi&quot;</span>, <span class="number">17</span>), (<span class="string">&quot;amar&quot;</span>,<span class="number">27</span>)], dtype = dt)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;我们的数组是：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;按name排序：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.sort(a, order = <span class="string">&#x27;name&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">我们的数组是：</span><br><span class="line">[[<span class="number">3</span> <span class="number">7</span>]</span><br><span class="line"> [<span class="number">9</span> <span class="number">1</span>]]</span><br><span class="line"></span><br><span class="line">调用sort()函数：</span><br><span class="line">[[<span class="number">3</span> <span class="number">7</span>]</span><br><span class="line"> [<span class="number">1</span> <span class="number">9</span>]]</span><br><span class="line"></span><br><span class="line">按列排序：</span><br><span class="line">[[<span class="number">3</span> <span class="number">1</span>]</span><br><span class="line"> [<span class="number">9</span> <span class="number">7</span>]]</span><br><span class="line"></span><br><span class="line">我们的数组是：</span><br><span class="line">[(<span class="string">b&#x27;raju&#x27;</span>, <span class="number">21</span>) (<span class="string">b&#x27;anil&#x27;</span>, <span class="number">25</span>) (<span class="string">b&#x27;ravi&#x27;</span>, <span class="number">17</span>) (<span class="string">b&#x27;amar&#x27;</span>, <span class="number">27</span>)]</span><br><span class="line"></span><br><span class="line">按 name 排序：</span><br><span class="line">[(<span class="string">b&#x27;amar&#x27;</span>, <span class="number">27</span>) (<span class="string">b&#x27;anil&#x27;</span>, <span class="number">25</span>) (<span class="string">b&#x27;raju&#x27;</span>, <span class="number">21</span>) (<span class="string">b&#x27;ravi&#x27;</span>, <span class="number">17</span>)]</span><br></pre></td></tr></table></figure><p><code>numpy.argsort()</code>函数返回的是数组值从小到大的索引值。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"> </span><br><span class="line">x = np.array([<span class="number">3</span>,  <span class="number">1</span>,  <span class="number">2</span>])  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;我们的数组是：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;对x调用argsort()函数：&#x27;</span>)</span><br><span class="line">y = np.argsort(x)  </span><br><span class="line"><span class="built_in">print</span>(y)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;以排序后的顺序重构原数组：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(x[y])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;使用循环重构原数组：&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> y:  </span><br><span class="line">    <span class="built_in">print</span> (x[i], end=<span class="string">&quot; &quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">我们的数组是：</span><br><span class="line">[<span class="number">3</span> <span class="number">1</span> <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">对x调用argsort()函数：</span><br><span class="line">[<span class="number">1</span> <span class="number">2</span> <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">以排序后的顺序重构原数组：</span><br><span class="line">[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">使用循环重构原数组：</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><p><code>numpy.lexsort()</code>用于对多个序列进行排序。把它想象成对电子表格进行排序，每一列代表一个序列，排序时优先照顾靠后的列。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"></span><br><span class="line"><span class="comment"># 传入np.lexsort的是一个tuple，排序时首先排nm，顺序为：amar、anil、raju、ravi。综上排序结果为[3 1 0 2]。</span></span><br><span class="line">nm = (<span class="string">&#x27;raju&#x27;</span>,<span class="string">&#x27;anil&#x27;</span>,<span class="string">&#x27;ravi&#x27;</span>,<span class="string">&#x27;amar&#x27;</span>) </span><br><span class="line">dv = (<span class="string">&#x27;f.y.&#x27;</span>, <span class="string">&#x27;s.y.&#x27;</span>, <span class="string">&#x27;s.y.&#x27;</span>, <span class="string">&#x27;f.y.&#x27;</span>) </span><br><span class="line">ind = np.lexsort((dv,nm))  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;调用lexsort()函数：&#x27;</span>) </span><br><span class="line"><span class="built_in">print</span>(ind) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;使用这个索引来获取排序后的数据：&#x27;</span>) </span><br><span class="line"><span class="built_in">print</span>([nm[i]+<span class="string">&quot;, &quot;</span> + dv[i] <span class="keyword">for</span> i <span class="keyword">in</span> ind])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">调用lexsort()函数：</span><br><span class="line">[<span class="number">3</span> <span class="number">1</span> <span class="number">0</span> <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">使用这个索引来获取排序后的数据：</span><br><span class="line">[<span class="string">&#x27;amar, f.y.&#x27;</span>, <span class="string">&#x27;anil, s.y.&#x27;</span>, <span class="string">&#x27;raju, f.y.&#x27;</span>, <span class="string">&#x27;ravi, s.y.&#x27;</span>]</span><br></pre></td></tr></table></figure><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td><code>msort(a)</code></td><td>数组按第一个轴排序，返回排序后的数组副本。<code>np.msort(a)</code>相等于<code>np.sort(a, axis=0)</code>。</td></tr><tr><td><code>sort_complex(a)</code></td><td>对复数按照先实部后虚部的顺序进行排序。</td></tr><tr><td><code>partition(a, kth[, axis, kind, order])</code></td><td>指定一个数，对数组进行分区</td></tr><tr><td><code>argpartition(a, kth[, axis, kind, order])</code></td><td>可以通过关键字<code>kind</code>指定算法沿着指定轴对数组进行分区</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 复数排序</span></span><br><span class="line"><span class="built_in">print</span>(np.sort_complex([<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">1</span>]))</span><br><span class="line"><span class="built_in">print</span>(np.sort_complex([<span class="number">1</span>+<span class="number">2j</span>, <span class="number">2</span>-<span class="number">1j</span>, <span class="number">3</span>-<span class="number">2j</span>, <span class="number">3</span>-<span class="number">3j</span>, <span class="number">3</span>+<span class="number">5j</span>]))</span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[<span class="number">1.</span>+<span class="number">0.j</span> <span class="number">2.</span>+<span class="number">0.j</span> <span class="number">3.</span>+<span class="number">0.j</span> <span class="number">5.</span>+<span class="number">0.j</span> <span class="number">6.</span>+<span class="number">0.j</span>]</span><br><span class="line">[<span class="number">1.</span>+<span class="number">2.j</span> <span class="number">2.</span>-<span class="number">1.j</span> <span class="number">3.</span>-<span class="number">3.j</span> <span class="number">3.</span>-<span class="number">2.j</span> <span class="number">3.</span>+<span class="number">5.j</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># partition()分区排序：</span></span><br><span class="line">a = np.array([<span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>])</span><br><span class="line"><span class="comment"># 将数组a中所有元素（包括重复元素）从小到大排列，3表示的是排序数组索引为3的数字，比该数字小的排在该数字前面，比该数字大的排在该数字的后面</span></span><br><span class="line"><span class="built_in">print</span>(np.partition(a, <span class="number">3</span>))</span><br><span class="line"><span class="comment"># 小于1的在前面，大于3的在后面，1和3之间的在中间</span></span><br><span class="line"><span class="built_in">print</span>(np.partition(a,(<span class="number">1</span>,<span class="number">3</span>)))</span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[<span class="number">2</span> <span class="number">1</span> <span class="number">3</span> <span class="number">4</span>]</span><br><span class="line">[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">arr = np.array([<span class="number">46</span>, <span class="number">57</span>, <span class="number">23</span>, <span class="number">39</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">0</span>, <span class="number">120</span>])</span><br><span class="line"><span class="comment"># 找到数组的第3小（index=2）的值和第2大（index=-2）的值</span></span><br><span class="line"><span class="built_in">print</span>(arr[np.argpartition(arr, <span class="number">2</span>)[<span class="number">2</span>]])</span><br><span class="line"><span class="built_in">print</span>(arr[np.argpartition(arr, -<span class="number">2</span>)[-<span class="number">2</span>]])</span><br><span class="line"><span class="comment"># 同时找到第3和第4小的值。注意这里，用[2,3]同时将第3和第4小的排序好，然后可以分别通过下标[2]和[3]取得。</span></span><br><span class="line"><span class="built_in">print</span>(arr[np.argpartition(arr,[<span class="number">2</span>,<span class="number">3</span>])[<span class="number">2</span>]])</span><br><span class="line"><span class="built_in">print</span>(arr[np.argpartition(arr,[<span class="number">2</span>,<span class="number">3</span>])[<span class="number">3</span>]])</span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">57</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">23</span></span><br></pre></td></tr></table></figure><p><code>numpy.argmax()</code>和<code>numpy.argmin()</code>函数分别沿给定轴返回最大和最小元素的索引。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"> </span><br><span class="line">a = np.array([[<span class="number">30</span>,<span class="number">40</span>,<span class="number">70</span>],[<span class="number">80</span>,<span class="number">20</span>,<span class="number">10</span>],[<span class="number">50</span>,<span class="number">90</span>,<span class="number">60</span>]])  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;我们的数组是：&#x27;</span>) </span><br><span class="line"><span class="built_in">print</span>(a) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;调用argmax()函数：&#x27;</span>) </span><br><span class="line"><span class="built_in">print</span>(np.argmax(a)) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;展开数组：&#x27;</span>) </span><br><span class="line"><span class="built_in">print</span>(a.flatten()) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;沿轴0的最大值索引：&#x27;</span>) </span><br><span class="line">maxindex = np.argmax(a, axis = <span class="number">0</span>)  </span><br><span class="line"><span class="built_in">print</span>(maxindex) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;沿轴1的最大值索引：&#x27;</span>) </span><br><span class="line">maxindex = np.argmax(a, axis = <span class="number">1</span>)  </span><br><span class="line"><span class="built_in">print</span>(maxindex) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;调用argmin()函数：&#x27;</span>) </span><br><span class="line">minindex = np.argmin(a)  </span><br><span class="line"><span class="built_in">print</span>(minindex) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;展开数组中的最小值：&#x27;</span>) </span><br><span class="line"><span class="built_in">print</span>(a.flatten()[minindex]) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;沿轴0的最小值索引：&#x27;</span>) </span><br><span class="line">minindex = np.argmin(a, axis = <span class="number">0</span>)  </span><br><span class="line"><span class="built_in">print</span>(minindex) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;沿轴1的最小值索引：&#x27;</span>) </span><br><span class="line">minindex = np.argmin(a, axis = <span class="number">1</span>)  </span><br><span class="line"><span class="built_in">print</span>(minindex)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">我们的数组是：</span><br><span class="line">[[<span class="number">30</span> <span class="number">40</span> <span class="number">70</span>]</span><br><span class="line"> [<span class="number">80</span> <span class="number">20</span> <span class="number">10</span>]</span><br><span class="line"> [<span class="number">50</span> <span class="number">90</span> <span class="number">60</span>]]</span><br><span class="line"></span><br><span class="line">调用argmax()函数：</span><br><span class="line"><span class="number">7</span></span><br><span class="line"></span><br><span class="line">展开数组：</span><br><span class="line">[<span class="number">30</span> <span class="number">40</span> <span class="number">70</span> <span class="number">80</span> <span class="number">20</span> <span class="number">10</span> <span class="number">50</span> <span class="number">90</span> <span class="number">60</span>]</span><br><span class="line"></span><br><span class="line">沿轴<span class="number">0</span>的最大值索引：</span><br><span class="line">[<span class="number">1</span> <span class="number">2</span> <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">沿轴<span class="number">1</span>的最大值索引：</span><br><span class="line">[<span class="number">2</span> <span class="number">0</span> <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">调用argmin()函数：</span><br><span class="line"><span class="number">5</span></span><br><span class="line"></span><br><span class="line">展开数组中的最小值：</span><br><span class="line"><span class="number">10</span></span><br><span class="line"></span><br><span class="line">沿轴<span class="number">0</span>的最小值索引：</span><br><span class="line">[<span class="number">0</span> <span class="number">1</span> <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">沿轴<span class="number">1</span>的最小值索引：</span><br><span class="line">[<span class="number">0</span> <span class="number">2</span> <span class="number">0</span>]</span><br></pre></td></tr></table></figure><p><code>numpy.nonzero()</code>函数返回输入数组中非零元素的索引。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"> </span><br><span class="line">a = np.array([[<span class="number">30</span>,<span class="number">40</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">20</span>,<span class="number">10</span>],[<span class="number">50</span>,<span class="number">0</span>,<span class="number">60</span>]])  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;我们的数组是：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;调用nonzero()函数：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.nonzero(a))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">我们的数组是：</span><br><span class="line">[[<span class="number">30</span> <span class="number">40</span>  <span class="number">0</span>]</span><br><span class="line"> [ <span class="number">0</span> <span class="number">20</span> <span class="number">10</span>]</span><br><span class="line"> [<span class="number">50</span>  <span class="number">0</span> <span class="number">60</span>]]</span><br><span class="line"></span><br><span class="line">调用nonzero()函数：</span><br><span class="line">(array([<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>], dtype=int64), array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">2</span>], dtype=int64))</span><br></pre></td></tr></table></figure><p><code>numpy.where()</code>函数返回输入数组中满足给定条件的元素的索引。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"> </span><br><span class="line">x = np.arange(<span class="number">9.</span>).reshape(<span class="number">3</span>, <span class="number">3</span>)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;我们的数组是：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;大于3的元素的索引：&#x27;</span>)</span><br><span class="line">y = np.where(x &gt; <span class="number">3</span>)  </span><br><span class="line"><span class="built_in">print</span>(y)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;使用这些索引来获取满足条件的元素：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(x[y])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">我们的数组是：</span><br><span class="line">[[<span class="number">0.</span> <span class="number">1.</span> <span class="number">2.</span>]</span><br><span class="line"> [<span class="number">3.</span> <span class="number">4.</span> <span class="number">5.</span>]</span><br><span class="line"> [<span class="number">6.</span> <span class="number">7.</span> <span class="number">8.</span>]]</span><br><span class="line">大于<span class="number">3</span>的元素的索引：</span><br><span class="line">(array([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>], dtype=int64), array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>], dtype=int64))</span><br><span class="line">使用这些索引来获取满足条件的元素：</span><br><span class="line">[<span class="number">4.</span> <span class="number">5.</span> <span class="number">6.</span> <span class="number">7.</span> <span class="number">8.</span>]</span><br></pre></td></tr></table></figure><p><code>numpy.extract()</code>函数根据某个条件从数组中抽取元素，返回满条件的元素。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"> </span><br><span class="line">x = np.arange(<span class="number">9.</span>).reshape(<span class="number">3</span>, <span class="number">3</span>)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;我们的数组是：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line"><span class="comment"># 定义条件,选择偶数元素</span></span><br><span class="line">condition = np.mod(x,<span class="number">2</span>) == <span class="number">0</span>  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;按元素的条件值：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(condition)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;使用条件提取元素：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.extract(condition, x))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">我们的数组是：</span><br><span class="line">[[<span class="number">0.</span> <span class="number">1.</span> <span class="number">2.</span>]</span><br><span class="line"> [<span class="number">3.</span> <span class="number">4.</span> <span class="number">5.</span>]</span><br><span class="line"> [<span class="number">6.</span> <span class="number">7.</span> <span class="number">8.</span>]]</span><br><span class="line">按元素的条件值：</span><br><span class="line">[[<span class="literal">True</span> <span class="literal">False</span> <span class="literal">True</span>]</span><br><span class="line"> [<span class="literal">False</span> <span class="literal">True</span> <span class="literal">False</span>]</span><br><span class="line"> [<span class="literal">True</span> <span class="literal">False</span> <span class="literal">True</span>]]</span><br><span class="line">使用条件提取元素：</span><br><span class="line">[<span class="number">0.</span> <span class="number">2.</span> <span class="number">4.</span> <span class="number">6.</span> <span class="number">8.</span>]</span><br></pre></td></tr></table></figure><h3 id="👀NumPy字节交换"><a href="#👀NumPy字节交换" class="headerlink" title="👀NumPy字节交换"></a>👀NumPy字节交换</h3><p>在几乎所有的机器上，多字节对象都被存储为连续的字节序列。字节顺序，是跨越多字节的程序对象的存储规则。</p><ul><li><strong>大端模式：</strong>指数据的高字节保存在内存的低地址中，而数据的低字节保存在内存的高地址中，这样的存储模式有点儿类似于把数据当作字符串顺序处理：地址由小向大增加，而数据从高位往低位放；这和我们的阅读习惯一致。</li><li><strong>小端模式：</strong>指数据的高字节保存在内存的高地址中，而数据的低字节保存在内存的低地址中，这种存储模式将地址的高低和数据位权有效地结合起来，高地址部分权值高，低地址部分权值低。</li></ul><p><code>numpy.ndarray.byteswap()</code>函数将<code>ndarray</code>中每个元素中的字节进行大小端转换。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"> </span><br><span class="line">a = np.array([<span class="number">1</span>, <span class="number">256</span>, <span class="number">8755</span>], dtype = np.int16)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;我们的数组是：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;以十六进制表示内存中的数据：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">map</span>(<span class="built_in">hex</span>,a))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">hex</span>, a)))</span><br><span class="line"><span class="comment"># byteswap()函数通过传入true来原地交换 </span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;调用 byteswap() 函数：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a.byteswap(<span class="literal">True</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;十六进制形式：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">map</span>(<span class="built_in">hex</span>,a))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">hex</span>, a)))</span><br><span class="line"><span class="comment"># 我们可以看到字节已经交换了</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">我们的数组是：</span><br><span class="line">[   <span class="number">1</span>  <span class="number">256</span> <span class="number">8755</span>]</span><br><span class="line">以十六进制表示内存中的数据：</span><br><span class="line">&lt;<span class="built_in">map</span> <span class="built_in">object</span> at <span class="number">0x00000229347A3D88</span>&gt;</span><br><span class="line">[<span class="string">&#x27;0x1&#x27;</span>, <span class="string">&#x27;0x100&#x27;</span>, <span class="string">&#x27;0x2233&#x27;</span>]</span><br><span class="line">调用 byteswap() 函数：</span><br><span class="line">[  <span class="number">256</span>     <span class="number">1</span> <span class="number">13090</span>]</span><br><span class="line">十六进制形式：</span><br><span class="line">&lt;<span class="built_in">map</span> <span class="built_in">object</span> at <span class="number">0x00000229347A3608</span>&gt;</span><br><span class="line">[<span class="string">&#x27;0x100&#x27;</span>, <span class="string">&#x27;0x1&#x27;</span>, <span class="string">&#x27;0x3322&#x27;</span>]</span><br></pre></td></tr></table></figure><h3 id="👀NumPy副本和视图"><a href="#👀NumPy副本和视图" class="headerlink" title="👀NumPy副本和视图"></a>👀NumPy副本和视图</h3><p>副本是一个数据的完整的拷贝，如果我们对副本进行修改，它不会影响到原始数据，物理内存不在同一位置。</p><p>视图是数据的一个别称或引用，通过该别称或引用亦便可访问、操作原有数据，但原有数据不会产生拷贝。如果我们对视图进行修改，它会影响到原始数据，物理内存在同一位置。</p><p><strong>副本一般发生在：</strong></p><ul><li>Python序列的切片操作，调用deepCopy()函数。</li><li>调用ndarray的copy()函数产生一个副本。</li></ul><p><strong>视图一般发生在：</strong></p><ul><li>numpy的切片操作返回原数据的视图。</li><li>调用ndarray的view()函数产生一个视图。</li></ul><p>（1）无复制</p><p>简单的赋值不会创建数组对象的副本。 相反，它使用<strong>原始数组的相同</strong><code>id()</code>来访问它。 <code>id()</code>返回<code>Python</code>对象的通用标识符，类似于C中的指针。此外，一个数组的任何变化都反映在另一个数组上。 例如，一个数组的形状改变也会改变另一个数组的形状。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"> </span><br><span class="line">a = np.arange(<span class="number">6</span>)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;我们的数组是：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;调用id()函数：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(a))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;a赋值给b：&#x27;</span>)</span><br><span class="line">b = a </span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;b拥有相同id()：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(b))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;修改b的形状：&#x27;</span>)</span><br><span class="line">b.shape = <span class="number">3</span>,<span class="number">2</span>  </span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;a的形状也修改了：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">我们的数组是：</span><br><span class="line">[<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span>]</span><br><span class="line">调用<span class="built_in">id</span>()函数：</span><br><span class="line"><span class="number">2375996889168</span></span><br><span class="line">a赋值给b：</span><br><span class="line">[<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span>]</span><br><span class="line">b拥有相同<span class="built_in">id</span>()：</span><br><span class="line"><span class="number">2375996889168</span></span><br><span class="line">修改 b 的形状：</span><br><span class="line">[[<span class="number">0</span> <span class="number">1</span>]</span><br><span class="line"> [<span class="number">2</span> <span class="number">3</span>]</span><br><span class="line"> [<span class="number">4</span> <span class="number">5</span>]]</span><br><span class="line">a的形状也修改了：</span><br><span class="line">[[<span class="number">0</span> <span class="number">1</span>]</span><br><span class="line"> [<span class="number">2</span> <span class="number">3</span>]</span><br><span class="line"> [<span class="number">4</span> <span class="number">5</span>]]</span><br></pre></td></tr></table></figure><p>（2）视图或浅拷贝</p><p><code>ndarray.view()</code>方会创建一个新的数组对象，该方法创建的新数组的维数变化不会改变原始数据的维数。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"> </span><br><span class="line"><span class="comment"># 最开始 a 是个 3X2 的数组</span></span><br><span class="line">a = np.arange(<span class="number">6</span>).reshape(<span class="number">3</span>,<span class="number">2</span>)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;数组a：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;创建a的视图：&#x27;</span>)</span><br><span class="line">b = a.view()  </span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;两个数组的id()不同：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;a的id()：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(a))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;b的id()：&#x27;</span> )</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(b))</span><br><span class="line"><span class="comment"># 修改b的形状，并不会修改a</span></span><br><span class="line">b.shape =  <span class="number">2</span>,<span class="number">3</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;b的形状：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;a的形状：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">数组a：</span><br><span class="line">[[<span class="number">0</span> <span class="number">1</span>]</span><br><span class="line"> [<span class="number">2</span> <span class="number">3</span>]</span><br><span class="line"> [<span class="number">4</span> <span class="number">5</span>]]</span><br><span class="line">创建a的视图：</span><br><span class="line">[[<span class="number">0</span> <span class="number">1</span>]</span><br><span class="line"> [<span class="number">2</span> <span class="number">3</span>]</span><br><span class="line"> [<span class="number">4</span> <span class="number">5</span>]]</span><br><span class="line">两个数组的<span class="built_in">id</span>()不同：</span><br><span class="line">a的<span class="built_in">id</span>()：</span><br><span class="line"><span class="number">2375996990448</span></span><br><span class="line">b的<span class="built_in">id</span>()：</span><br><span class="line"><span class="number">2375996617872</span></span><br><span class="line">b的形状：</span><br><span class="line">[[<span class="number">0</span> <span class="number">1</span> <span class="number">2</span>]</span><br><span class="line"> [<span class="number">3</span> <span class="number">4</span> <span class="number">5</span>]]</span><br><span class="line">a的形状：</span><br><span class="line">[[<span class="number">0</span> <span class="number">1</span>]</span><br><span class="line"> [<span class="number">2</span> <span class="number">3</span>]</span><br><span class="line"> [<span class="number">4</span> <span class="number">5</span>]]</span><br></pre></td></tr></table></figure><p>使用切片创建视图修改数据会影响到原始数组，变量a，b都是arr的一部分视图，对视图的修改会直接反映到原数据中。但是我们观察a，b的id，他们是不同的，也就是说，视图虽然指向原数据，但是他们和赋值引用还是有区别的。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"> </span><br><span class="line">arr = np.arange(<span class="number">12</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;我们的数组：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(arr)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;创建切片：&#x27;</span>)</span><br><span class="line">a=arr[<span class="number">3</span>:]</span><br><span class="line">b=arr[<span class="number">3</span>:]</span><br><span class="line">a[<span class="number">1</span>]=<span class="number">123</span></span><br><span class="line">b[<span class="number">2</span>]=<span class="number">234</span></span><br><span class="line"><span class="built_in">print</span>(arr)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(a),<span class="built_in">id</span>(b),<span class="built_in">id</span>(arr[<span class="number">3</span>:]))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">我们的数组：</span><br><span class="line">[ <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span> <span class="number">10</span> <span class="number">11</span>]</span><br><span class="line">创建切片：</span><br><span class="line">[  <span class="number">0</span>   <span class="number">1</span>   <span class="number">2</span>   <span class="number">3</span> <span class="number">123</span> <span class="number">234</span>   <span class="number">6</span>   <span class="number">7</span>   <span class="number">8</span>   <span class="number">9</span>  <span class="number">10</span>  <span class="number">11</span>]</span><br><span class="line"><span class="number">2375996635536</span> <span class="number">2375996634816</span> <span class="number">2375996921616</span></span><br></pre></td></tr></table></figure><p>（3）副本或深拷贝</p><p><code>ndarray.copy()</code>函数创建一个副本。 对副本数据进行修改，不会影响到原始数据，它们物理内存不在同一位置。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"> </span><br><span class="line">a = np.array([[<span class="number">10</span>,<span class="number">10</span>],  [<span class="number">2</span>,<span class="number">3</span>],  [<span class="number">4</span>,<span class="number">5</span>]])  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;数组a：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;创建a的深层副本：&#x27;</span>)</span><br><span class="line">b = a.copy()  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;数组 b：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="comment"># b与a不共享任何内容  </span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;我们能够写入b来写入a吗？&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(b <span class="keyword">is</span> a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;修改b的内容：&#x27;</span>)</span><br><span class="line">b[<span class="number">0</span>,<span class="number">0</span>] = <span class="number">100</span>  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;修改后的数组b：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;a保持不变：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">数组a：</span><br><span class="line">[[<span class="number">10</span> <span class="number">10</span>]</span><br><span class="line"> [ <span class="number">2</span>  <span class="number">3</span>]</span><br><span class="line"> [ <span class="number">4</span>  <span class="number">5</span>]]</span><br><span class="line">创建a的深层副本：</span><br><span class="line">数组 b：</span><br><span class="line">[[<span class="number">10</span> <span class="number">10</span>]</span><br><span class="line"> [ <span class="number">2</span>  <span class="number">3</span>]</span><br><span class="line"> [ <span class="number">4</span>  <span class="number">5</span>]]</span><br><span class="line">我们能够写入b来写入a吗？</span><br><span class="line"><span class="literal">False</span></span><br><span class="line">修改b的内容：</span><br><span class="line">修改后的数组b：</span><br><span class="line">[[<span class="number">100</span>  <span class="number">10</span>]</span><br><span class="line"> [  <span class="number">2</span>   <span class="number">3</span>]</span><br><span class="line"> [  <span class="number">4</span>   <span class="number">5</span>]]</span><br><span class="line">a保持不变：</span><br><span class="line">[[<span class="number">10</span> <span class="number">10</span>]</span><br><span class="line"> [ <span class="number">2</span>  <span class="number">3</span>]</span><br><span class="line"> [ <span class="number">4</span>  <span class="number">5</span>]]</span><br></pre></td></tr></table></figure><h3 id="👀NumPy矩阵库（Matrix）"><a href="#👀NumPy矩阵库（Matrix）" class="headerlink" title="👀NumPy矩阵库（Matrix）"></a>👀NumPy矩阵库（Matrix）</h3><p><code>NumPy</code>中包含了一个矩阵库<code>numpy.matlib</code>，该模块中的函数返回一个矩阵，而不是<code>ndarray</code>对象。一个<code>m×n</code>的矩阵是一个由m行（row）n列（column）元素排列成的矩形阵列。矩阵里的元素可以是数字、符号或数学式。</p><p>（1）转置矩阵</p><p><code>NumPy</code>中除了可以使用<code>numpy.transpose</code>函数来对换数组的维度，还可以使用 <strong>T</strong> 属性。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"> </span><br><span class="line">a = np.arange(<span class="number">12</span>).reshape(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;原数组：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;转置数组：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a.T)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">原数组：</span><br><span class="line">[[ <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>]</span><br><span class="line"> [ <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>]</span><br><span class="line"> [ <span class="number">8</span>  <span class="number">9</span> <span class="number">10</span> <span class="number">11</span>]]</span><br><span class="line"></span><br><span class="line">转置数组：</span><br><span class="line">[[ <span class="number">0</span>  <span class="number">4</span>  <span class="number">8</span>]</span><br><span class="line"> [ <span class="number">1</span>  <span class="number">5</span>  <span class="number">9</span>]</span><br><span class="line"> [ <span class="number">2</span>  <span class="number">6</span> <span class="number">10</span>]</span><br><span class="line"> [ <span class="number">3</span>  <span class="number">7</span> <span class="number">11</span>]]</span><br></pre></td></tr></table></figure><p>（2）matlib.empty()</p><p><code>matlib.empty()</code>函数返回一个新的矩阵，语法格式为：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numpy.matlib.empty(shape, dtype, order)</span><br><span class="line">参数说明：</span><br><span class="line">    shape: 定义新矩阵形状的整数或整数元组</span><br><span class="line">    Dtype: 可选，数据类型</span><br><span class="line">    order: C（行序优先） 或者 F（列序优先）</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(np.matlib.empty((<span class="number">2</span>,<span class="number">2</span>)))</span><br><span class="line"><span class="comment"># 填充为随机数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[[<span class="number">1.36008890e-311</span> <span class="number">1.69168361e-301</span>]</span><br><span class="line"> [<span class="number">3.42821614e-210</span> <span class="number">7.46699190e-301</span>]]</span><br></pre></td></tr></table></figure><p>（3）numpy.matlib.zeros()</p><p><code>numpy.matlib.zeros()</code>函数创建一个以0填充的矩阵。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(np.matlib.zeros((<span class="number">2</span>,<span class="number">2</span>)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[[<span class="number">0.</span> <span class="number">0.</span>]</span><br><span class="line"> [<span class="number">0.</span> <span class="number">0.</span>]]</span><br></pre></td></tr></table></figure><p>（4）numpy.matlib.ones()</p><p><code>numpy.matlib.ones()</code>函数创建一个以1填充的矩阵。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(np.matlib.ones((<span class="number">2</span>,<span class="number">2</span>)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[[<span class="number">1.</span> <span class="number">1.</span>]</span><br><span class="line"> [<span class="number">1.</span> <span class="number">1.</span>]]</span><br></pre></td></tr></table></figure><p>（5）numpy.matlib.eye()</p><p><code>numpy.matlib.eye()</code>函数返回一个矩阵，对角线元素为1，其他位置为零。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numpy.matlib.eye(n, M,k, dtype)</span><br><span class="line">参数说明：</span><br><span class="line">    n: 返回矩阵的行数</span><br><span class="line">    M: 返回矩阵的列数，默认为n</span><br><span class="line">    k: 对角线的索引</span><br><span class="line">    dtype: 数据类型</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(np.matlib.eye(n=<span class="number">3</span>, M=<span class="number">4</span>, k=<span class="number">0</span>, dtype=<span class="built_in">float</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[[<span class="number">1.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span>]</span><br><span class="line"> [<span class="number">0.</span> <span class="number">1.</span> <span class="number">0.</span> <span class="number">0.</span>]</span><br><span class="line"> [<span class="number">0.</span> <span class="number">0.</span> <span class="number">1.</span> <span class="number">0.</span>]]</span><br></pre></td></tr></table></figure><p>（6）numpy.matlib.identity()</p><p><code>numpy.matlib.identity()</code>函数返回给定大小的单位矩阵。单位矩阵是个方阵，从左上角到右下角的对角线（称为主对角线）上的元素均为1，除此以外全都为0。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"> </span><br><span class="line"><span class="comment"># 大小为 5，类型位浮点型</span></span><br><span class="line"><span class="built_in">print</span>(np.matlib.identity(<span class="number">5</span>, dtype=<span class="built_in">float</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[[<span class="number">1.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span>]</span><br><span class="line"> [<span class="number">0.</span> <span class="number">1.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span>]</span><br><span class="line"> [<span class="number">0.</span> <span class="number">0.</span> <span class="number">1.</span> <span class="number">0.</span> <span class="number">0.</span>]</span><br><span class="line"> [<span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">1.</span> <span class="number">0.</span>]</span><br><span class="line"> [<span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">1.</span>]]</span><br></pre></td></tr></table></figure><p>（7）numpy.matlib.rand()</p><p><code>numpy.matlib.rand()</code>函数创建一个给定大小的矩阵，数据是随机填充的。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(np.matlib.rand(<span class="number">3</span>,<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[[<span class="number">0.85907694</span> <span class="number">0.10033233</span> <span class="number">0.90102019</span>]</span><br><span class="line"> [<span class="number">0.60724393</span> <span class="number">0.67443377</span> <span class="number">0.19654135</span>]</span><br><span class="line"> [<span class="number">0.1626346</span>  <span class="number">0.4910893</span>  <span class="number">0.11768052</span>]]</span><br></pre></td></tr></table></figure><p>矩阵总是二维的，而ndarray是一个n维数组。 两个对象都是可互换的。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np  </span><br><span class="line"> </span><br><span class="line">i = np.matrix(<span class="string">&#x27;1,2;3,4&#x27;</span>)  </span><br><span class="line"><span class="built_in">print</span>(i)</span><br><span class="line">j = np.asarray(i)  </span><br><span class="line"><span class="built_in">print</span>(j)</span><br><span class="line">k = np.asmatrix(j)  </span><br><span class="line"><span class="built_in">print</span>(k)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[[<span class="number">1</span> <span class="number">2</span>]</span><br><span class="line"> [<span class="number">3</span> <span class="number">4</span>]]</span><br><span class="line">[[<span class="number">1</span> <span class="number">2</span>]</span><br><span class="line"> [<span class="number">3</span> <span class="number">4</span>]]</span><br><span class="line">[[<span class="number">1</span> <span class="number">2</span>]</span><br><span class="line"> [<span class="number">3</span> <span class="number">4</span>]]</span><br></pre></td></tr></table></figure><h3 id="👀NumPy线性代数"><a href="#👀NumPy线性代数" class="headerlink" title="👀NumPy线性代数"></a>👀NumPy线性代数</h3><p><code>NumPy</code>提供了线性代数函数库<strong>linalg</strong>，该库包含了线性代数所需的所有功能，可以看看下面的说明：</p><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td><code>dot</code></td><td>两个数组的点积，即元素对应相乘</td></tr><tr><td><code>vdot</code></td><td>两个向量的点积</td></tr><tr><td><code>inner</code></td><td>两个数组的内积</td></tr><tr><td><code>matmul</code></td><td>两个数组的矩阵积</td></tr><tr><td><code>determinant</code></td><td>数组的行列式</td></tr><tr><td><code>solve</code></td><td>求解线性矩阵方程</td></tr><tr><td><code>inv</code></td><td>计算矩阵的乘法逆矩阵</td></tr></tbody></table><h3 id="👀NumPy-IO"><a href="#👀NumPy-IO" class="headerlink" title="👀NumPy IO"></a>👀NumPy IO</h3><p><code>Numpy</code>可以读写磁盘上的文本数据或二进制数据。</p><p><code>NumPy</code>为<code>ndarray</code>对象引入了一个简单的文件格式：<code>npy</code>。</p><p><code>npy</code>文件用于存储重建<code>ndarray</code>所需的数据、图形、dtype和其他信息。</p><p>常用的<code>IO</code>函数有：</p><ul><li><code>load()</code>和<code>save()</code>函数是读写文件数组数据的两个主要函数，默认情况下，数组是以未压缩的原始二进制格式保存在扩展名为<code>.npy</code>的文件中。</li><li><code>savez()</code>函数用于将多个数组写入文件，默认情况，数组是以未压缩的原始二进制格式保存在扩展名为<code>.npz</code>的文件中。</li><li><code>loadtxt()</code>和<code>savetxt()</code>函数处理正常的文本文件(<code>.txt</code>等)</li></ul><p>（1）numpy.save()</p><p><code>numpy.save()</code>函数将数组保存到以<code>.npy</code>为扩展名的文件中。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numpy.save(file, arr, allow_pickle=<span class="literal">True</span>, fix_imports=<span class="literal">True</span>)</span><br><span class="line">参数说明：</span><br><span class="line">    file：要保存的文件，扩展名为.npy，如果文件路径末尾没有扩展名.npy，该扩展名会被自动加上。</span><br><span class="line">    arr: 要保存的数组</span><br><span class="line">    allow_pickle: 可选，布尔值，允许使用Python pickles保存对象数组，Python中的pickle用于在保存到磁盘文件或从磁盘文件读取之前，对对象进行序列化和反序列化。</span><br><span class="line">    fix_imports: 可选，为了方便Pyhton2中读取Python3保存的数据。</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"> </span><br><span class="line">a = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]) </span><br><span class="line"><span class="comment"># 保存到outfile.npy文件上</span></span><br><span class="line">np.save(<span class="string">&#x27;outfile.npy&#x27;</span>,a) </span><br><span class="line"><span class="comment"># 保存到outfile2.npy文件上，如果文件路径末尾没有扩展名.npy，该扩展名会被自动加上</span></span><br><span class="line">np.save(<span class="string">&#x27;outfile2&#x27;</span>,a)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以看出文件是乱码的，因为它们是Numpy专用的二进制格式后的数据。</span></span><br><span class="line"><span class="comment"># 我们可以使用load()函数来读取数据就可以正常显示了</span></span><br><span class="line">b = np.load(<span class="string">&#x27;outfile.npy&#x27;</span>)  </span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span>]</span><br></pre></td></tr></table></figure><p>（2）np.savez()</p><p><code>numpy.savez()</code>函数将多个数组保存到以<code>.npz</code>为扩展名的文件中。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numpy.savez(file, *args, **kwds)</span><br><span class="line">参数说明：</span><br><span class="line">    file：要保存的文件，扩展名为.npz，如果文件路径末尾没有扩展名.npz，该扩展名会被自动加上。</span><br><span class="line">args: 要保存的数组，可以使用关键字参数为数组起一个名字，非关键字参数传递的数组会自动起名为arr_0, arr_1, …　。</span><br><span class="line">    kwds: 要保存的数组使用关键字名称。</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"> </span><br><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]])</span><br><span class="line">b = np.arange(<span class="number">0</span>, <span class="number">1.0</span>, <span class="number">0.1</span>)</span><br><span class="line">c = np.sin(b)</span><br><span class="line"><span class="comment"># c使用了关键字参数sin_array</span></span><br><span class="line">np.savez(<span class="string">&quot;runoob.npz&quot;</span>, a, b, sin_array = c)</span><br><span class="line">r = np.load(<span class="string">&quot;runoob.npz&quot;</span>)  </span><br><span class="line"><span class="built_in">print</span>(r.files) <span class="comment"># 查看各个数组名称</span></span><br><span class="line"><span class="built_in">print</span>(r[<span class="string">&quot;arr_0&quot;</span>]) <span class="comment"># 数组 a</span></span><br><span class="line"><span class="built_in">print</span>(r[<span class="string">&quot;arr_1&quot;</span>]) <span class="comment"># 数组 b</span></span><br><span class="line"><span class="built_in">print</span>(r[<span class="string">&quot;sin_array&quot;</span>]) <span class="comment"># 数组 c</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[<span class="string">&#x27;sin_array&#x27;</span>, <span class="string">&#x27;arr_0&#x27;</span>, <span class="string">&#x27;arr_1&#x27;</span>]</span><br><span class="line">[[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]</span><br><span class="line"> [<span class="number">4</span> <span class="number">5</span> <span class="number">6</span>]]</span><br><span class="line">[<span class="number">0.</span>  <span class="number">0.1</span> <span class="number">0.2</span> <span class="number">0.3</span> <span class="number">0.4</span> <span class="number">0.5</span> <span class="number">0.6</span> <span class="number">0.7</span> <span class="number">0.8</span> <span class="number">0.9</span>]</span><br><span class="line">[<span class="number">0.</span>         <span class="number">0.09983342</span> <span class="number">0.19866933</span> <span class="number">0.29552021</span> <span class="number">0.38941834</span> <span class="number">0.47942554</span></span><br><span class="line"> <span class="number">0.56464247</span> <span class="number">0.64421769</span> <span class="number">0.71735609</span> <span class="number">0.78332691</span>]</span><br></pre></td></tr></table></figure><p>（3）np.savetxt()</p><p><code>savetxt()</code>函数是以简单的文本文件格式存储数据，对应的使用<code>loadtxt()</code>函数来获取数据。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.loadtxt(FILENAME, dtype=<span class="built_in">int</span>, delimiter=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">np.savetxt(FILENAME, a, fmt=<span class="string">&quot;%d&quot;</span>, delimiter=<span class="string">&quot;,&quot;</span>)</span><br><span class="line"><span class="comment"># 参数delimiter可以指定各种分隔符、针对特定列的转换器函数、需要跳过的行数等。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"> </span><br><span class="line">a = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]) </span><br><span class="line">np.savetxt(<span class="string">&#x27;out.txt&#x27;</span>,a) </span><br><span class="line">b = np.loadtxt(<span class="string">&#x27;out.txt&#x27;</span>)  </span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[<span class="number">1.</span> <span class="number">2.</span> <span class="number">3.</span> <span class="number">4.</span> <span class="number">5.</span>]</span><br></pre></td></tr></table></figure><p>使用delimiter参数：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"></span><br><span class="line"><span class="comment"># arr.shape    # (a,b)</span></span><br><span class="line"><span class="comment"># arr.reshape(m,-1) # 改变维度为m行、d列（-1表示列数自动计算，d=a*b/m）</span></span><br><span class="line"><span class="comment"># arr.reshape(-1,m) # 改变维度为d行、m列（-1表示行数自动计算，d=a*b/m）</span></span><br><span class="line">a = np.arange(<span class="number">0</span>,<span class="number">10</span>,<span class="number">0.5</span>).reshape(<span class="number">4</span>,-<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line">np.savetxt(<span class="string">&quot;out.txt&quot;</span>,a,fmt=<span class="string">&quot;%d&quot;</span>,delimiter=<span class="string">&quot;,&quot;</span>) <span class="comment"># 改为保存为整数，以逗号分隔</span></span><br><span class="line">b = np.loadtxt(<span class="string">&quot;out.txt&quot;</span>,delimiter=<span class="string">&quot;,&quot;</span>) <span class="comment"># load 时也要指定为逗号分隔</span></span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[[<span class="number">0.</span>  <span class="number">0.5</span> <span class="number">1.</span>  <span class="number">1.5</span> <span class="number">2.</span> ]</span><br><span class="line"> [<span class="number">2.5</span> <span class="number">3.</span>  <span class="number">3.5</span> <span class="number">4.</span>  <span class="number">4.5</span>]</span><br><span class="line"> [<span class="number">5.</span>  <span class="number">5.5</span> <span class="number">6.</span>  <span class="number">6.5</span> <span class="number">7.</span> ]</span><br><span class="line"> [<span class="number">7.5</span> <span class="number">8.</span>  <span class="number">8.5</span> <span class="number">9.</span>  <span class="number">9.5</span>]]</span><br><span class="line">[[<span class="number">0.</span> <span class="number">0.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">2.</span>]</span><br><span class="line"> [<span class="number">2.</span> <span class="number">3.</span> <span class="number">3.</span> <span class="number">4.</span> <span class="number">4.</span>]</span><br><span class="line"> [<span class="number">5.</span> <span class="number">5.</span> <span class="number">6.</span> <span class="number">6.</span> <span class="number">7.</span>]</span><br><span class="line"> [<span class="number">7.</span> <span class="number">8.</span> <span class="number">8.</span> <span class="number">9.</span> <span class="number">9.</span>]]</span><br></pre></td></tr></table></figure><h3 id="👀NumPy-Matplotlib"><a href="#👀NumPy-Matplotlib" class="headerlink" title="👀NumPy Matplotlib"></a>👀NumPy Matplotlib</h3><p><code>Matplotlib</code>是<code>Python</code>的绘图库。 它可与<code>NumPy</code>一起使用，提供了一种有效的<code>MatLab</code>开源替代方案。它也可以和图形工具包一起使用，如<code>PyQt</code>和<code>wxPython</code>。</p><p>参考资料：菜鸟教程</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 科学计算 </tag>
            
            <tag> Numpy </tag>
            
            <tag> 数据分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Matlab语法基础（01）</title>
      <link href="/2022/12/17/Matlab-Basic01/"/>
      <url>/2022/12/17/Matlab-Basic01/</url>
      
        <content type="html"><![CDATA[<p><code>MathWorks</code>公司创立于 1984 年，是领先的为工程师和科学家提供数学计算软件的供应商，旗下产品包括<code>MATLAB</code>产品家族、<code>Simulink</code>产品家族及 <code>PolySpace</code>产品家族。</p><p><code>MATLAB</code>是矩阵实验室（<code>Matrix Laboratory</code>）的简称，是一种用于算法开发、数据可视化、数据分析及数值计算的高级技术计算语言和交互式环境。<code>MATLAB</code>的应用范围非常广，包括信号和图像处理、通信、控制系统设计、测试和测量、财务建模和分析，以及计算生物学等众多应用领域。附加的工具箱（单独提供的专用 <code>MATLAB</code> 函数集）扩展了<code>MATLAB</code>的使用环境，以解决这些应用领域内特定类型的问题。</p><p><code>Simulink</code>是一个用于对动态系统进行多域建模和模型设计的平台。它提供了一个交互式图形环境，以及一个自定义模块库，并可针对特定应用加以扩展，可应用于控制系统设计、信号处理和通信及图像处理等众多领域。</p><p><code>PolySpace</code>提供代码验证，可确保消除源代码中的溢出、除零、数组访问越界及其他运行错误。此类产品可以证明源代码中不存在某些运行错误，使工程师能够选择并跟踪嵌入式软件质量的指标和阈值，帮助软件团队更好地定义质量目标，并更快地实施。该软件已经在汽车、航空、国防及工业自动化和机械行业中得到广泛应用。</p><p>目前，经常使用的<code>MATLAB</code>软件集成了<code>MATLAB</code>和<code>Simulink</code>两大模块；而<code>PolySpace</code> 是独立于<code>MATLAB</code> 软件之外的，需要单独安装。</p><table><thead><tr><th>数学软件</th><th>备注</th></tr></thead><tbody><tr><td><code>Mathematica</code></td><td><code>Mathematica</code>是一个综合的数学软件环境，具有数值计算、符号推导、数据可视化和编程等多种功能，在符号计算领域有很高的知名度。<code>Mathematica</code>软件分为两大部分：<code>Kemel</code>和<code>FrontEnd</code>。<code>Kemel</code>是软件的计算中心，而<code>FrontEnd</code>负责与用户的交流，两者有一定的独立性。<code>Mathematica</code>的表达式含义十分丰富，几乎包含了一切要处理的对象。</td></tr><tr><td><code>Maple</code></td><td><code>Maple</code>是世界上较优秀的几款数学软件之一。它以友善的使用环境、强大的符号处理、精确的数值计算、灵活的图形显示、高效的编程功能为越来越多的教师、学生和科研人员所喜爱，并成为数学处理的首选工具。由于<code>Maple</code>软件原是为符号计算而设计的，因此在数值计算与绘图方面的运算速度要比<code>MATLAB</code>慢。<code>Maple</code>的帮助系统是用英语写的，这给英文差的人们带来了不便。</td></tr></tbody></table><p><code>MATLAB</code>作为和<code>Mathematica</code>、<code>Maple</code>并列的三大数学软件之一，强项就是其强大的矩阵计算及仿真能力。每次 <code>MathWorks</code>公司发布<code>MATLAB</code>的同时，也会发布仿真工具<code>Simulink</code>。<code>MATLAB</code>以其良好的开放性和运行的可靠性，已经成为国际控制界公认的标准计算软件，<code>MATLAB</code>在数值计算方面独占鳌头。</p><ul><li>计算功能强大；</li><li>绘图方便：它包括强力的二维及三维图形函数、图像处理和动画显示等函数；</li><li>功能强大的工具箱（应用程序）：功能性工具箱和学科性工具；</li><li>帮助功能完整。</li></ul><blockquote><p><strong>clc</strong>：清除命令窗口的内容，对工作环境中的全部变量无影响；</p><p><strong>close</strong>：关闭当前的Figure窗口；</p><p><strong>close all</strong>：关闭所有的Figure窗口；</p><p><strong>clear</strong>：清除工作空间的所有变量；</p><p><strong>clear all</strong>：清除工作空间所有变量、函数、MEX文件；</p><p><strong>disp</strong>：用来展示变量的内容，可以是字符串、元胞、矩阵、结构体；</p><p><strong>调用帮助</strong>：help ~；或demos；或doc；</p><p><strong>whos函数</strong>：用来列出当前工作区中的变量名及它们的详细信息，如 size（大小）、bytes（字节）及class（数据类型）等；</p><p><strong>数组&#x2F;矩阵索引</strong>：从1开始；</p><p><strong>命令行小细节</strong>：当命令后面有分号（半角符号格式）时，按Enter键后，命令行窗口中不显示运算结果；如果无分号，则在命令行窗口中显示运算结果。当希望先输入多条语句，然后再同时执行它们时，则在输入下一条命令时，要在按住Shift键的同时按Enter键进行换行输入。</p></blockquote><h2 id="⛄数据类型"><a href="#⛄数据类型" class="headerlink" title="⛄数据类型"></a>⛄数据类型</h2><p><code>MATLAB</code>中的数据类型主要包括数值类型、逻辑类型、字符串、函数句柄、结构体和单元数组类型。这 6 种基本的数据类型都是按照数组形式存储和操作的。</p><h3 id="👀数值类型"><a href="#👀数值类型" class="headerlink" title="👀数值类型"></a>👀数值类型</h3><p>基本的数值类型主要有整数、单精度浮点数和双精度浮点数。<code>MATLAB</code>中数值类型的数据包括有符号和无符号整数、单精度浮点数和双精度浮点数。在未加说明与特殊定义时，<code>MATLAB</code>对所有数值按照<strong>双精度浮点数</strong>类型进行存储和操作，相对于双精度浮点数格式，整数型与单精度浮点型的优点在于节省变量占用的内存空间，当然首先要在满足精度要求的前提下。</p><h4 id="👁整数类型"><a href="#👁整数类型" class="headerlink" title="👁整数类型"></a>👁整数类型</h4><p><code>MATLAB</code>中提供了8种内置的整数类型，这8种类型的存储占用位数、能表示的数值范围和转换函数均不相同。不同的整数类型所占用的位数不同，因此能够表示的数值范围也不同。在实际应用中，应根据实际需要合理选择合适的整数类型。</p><table><thead><tr><th align="center">整数类型</th><th align="center">数值范围</th><th align="center">转换函数</th></tr></thead><tbody><tr><td align="center">有符号 8 位整数</td><td align="center">-2^7^~2^7^-1</td><td align="center">int8</td></tr><tr><td align="center">无符号 8 位整数</td><td align="center">0~2^8^-1</td><td align="center">uint8</td></tr><tr><td align="center">有符号 16 位整数</td><td align="center">-2^15^~2^15^-1</td><td align="center">int16</td></tr><tr><td align="center">无符号 16 位整数</td><td align="center">0~2^16^-1</td><td align="center">uint16</td></tr><tr><td align="center">有符号 32 位整数</td><td align="center">-2^31^~2^31^-1</td><td align="center">int32</td></tr><tr><td align="center">无符号 32 位整数</td><td align="center">0~2^32^-1</td><td align="center">uint32</td></tr><tr><td align="center">有符号 64 位整数</td><td align="center">-2^63^~2^63^-1</td><td align="center">int64</td></tr><tr><td align="center">无符号 64 位整数</td><td align="center">0~2^64^-1</td><td align="center">uint64</td></tr></tbody></table><p>由于 <code>MATLAB</code>中数值的默认存储类型是<strong>双精度浮点类型</strong>，因此将变量设置为整数类型时，需要使用相应的转换函数，将双精度浮点数转换为指定的整数类型。<code>MATLAB</code>中还包含了几类不同运算法则的取整函数，也可以把浮点数转换成整数。在不超出数值范围的情况下，任意两个整数类型之间也可以通过转换函数进行相互转换。同时，由于不同的整数类型能够表示的数值范围不同，因此当运算结果超出相应的整数类型能够表示的范围时，就会出现一处错误，运算结果被置为该整数类型能够表示的最大值或最小值。</p><table><thead><tr><th align="center">函数</th><th align="center">运算法则</th><th align="center">示例</th></tr></thead><tbody><tr><td align="center"><code>floor</code>(x)</td><td align="center">向下取整</td><td align="center">floor(1.2)&#x3D;1；floor(2.5)&#x3D;2；floor(－2.5)&#x3D; －3</td></tr><tr><td align="center"><code>ceil</code>(x)</td><td align="center">向上取整</td><td align="center">ceil(1.2)&#x3D;2；ceil(2.5)&#x3D;3；ceil(－2.5)&#x3D;－2</td></tr><tr><td align="center"><code>round</code>(x)</td><td align="center">四舍五入</td><td align="center">round(1.2)&#x3D;1；round(2.5)&#x3D;3；round(－2.5)&#x3D;－3</td></tr><tr><td align="center"><code>fix</code>(x)</td><td align="center">向0取整</td><td align="center">fix(1.2)&#x3D;1；fix(2.5)&#x3D;2；fix(－2.5)&#x3D;－2</td></tr></tbody></table><h4 id="👁浮点数类型"><a href="#👁浮点数类型" class="headerlink" title="👁浮点数类型"></a>👁浮点数类型</h4><p><code>MATLAB</code>中提供了单精度浮点数类型和双精度浮点数类型，其存储位宽、能够表示的数值范围、数值精度各方面均不相同，单精度浮点类型的占用位数少，因此占用内存小，但能够表示的数值范围和数值的精度都比双精度浮点类型小。</p><table><thead><tr><th align="center">浮点类型</th><th align="center">存储位宽</th><th>数值范围</th><th align="center">转换函数</th></tr></thead><tbody><tr><td align="center">单精度</td><td align="center">32</td><td>－3.40282e+038 ~－1.17549e-038 <br/>1.17549e-038 ~ 3.40282e+038</td><td align="center">single</td></tr><tr><td align="center">双精度</td><td align="center">64</td><td>－1.79769e+308 ~－2.22507e-308 <br/>2.22507e－308 ~ 1.79769e+308</td><td align="center">double</td></tr></tbody></table><p>双精度浮点数参与运算时，返回值的类型依赖于参与运算的其他数据类型。参与运算的其他数据为逻辑型、字符型时，返回结果为双精度浮点型；参与运算的其他数据为整数型时，返回结果为相应的整数类型；参与运算的其他数据为单精度浮点型时，返回结果为相应的单精度浮点型。</p><blockquote><p>在 <code>MATLAB</code>中，单精度浮点类型不能与整数类型进行算术运算。</p></blockquote><h4 id="👁复数"><a href="#👁复数" class="headerlink" title="👁复数"></a>👁复数</h4><p>复数包括实部和虚部两部分。<code>MATLAB</code>中默认使用字符<code>i</code>或<code>j</code>作为虚部标志。创建复数时，可以直接按照复数形式进行输入或者利用 <code>complex</code>函数。</p><table><thead><tr><th>函数</th><th>说明</th><th>函数</th><th>说明</th></tr></thead><tbody><tr><td><code>real</code>(z)</td><td>返回复数 z 的实部</td><td><code>imag</code>(z)</td><td>返回复数 z 的虚部</td></tr><tr><td><code>abs</code>(z)</td><td>返回复数 z 的模</td><td><code>angle</code>(z)</td><td>返回复数 z 的辐角</td></tr><tr><td><code>conj</code>(z)</td><td>返回复数 z 的共轭复数</td><td><code>complex</code>(a,b)</td><td>以 a 为实部、b 为虚部创建复数</td></tr></tbody></table><h4 id="👁无穷量（Inf）和非数值量（NaN）"><a href="#👁无穷量（Inf）和非数值量（NaN）" class="headerlink" title="👁无穷量（Inf）和非数值量（NaN）"></a>👁无穷量（<code>Inf</code>）和非数值量（<code>NaN</code>）</h4><p><code>MATLAB</code>中使用<code>Inf</code>和<code>-Inf</code>分别代表正无穷量和负无穷量，<code>NaN</code>表示非数值量。正负无穷量的产生一般是由于运算溢出，产生了超出双精度浮点数数值范围的结果，非数值量则是由于<code>0/0</code>或<code>Inf/Inf</code>类型的非正常运算而产生的，这两个<code>NaN</code>彼此是不相等的。</p><h3 id="👀逻辑类型"><a href="#👀逻辑类型" class="headerlink" title="👀逻辑类型"></a>👀逻辑类型</h3><p>逻辑类型的数据是指布尔类型的数据及数据之间的逻辑关系。作为所有关系和逻辑表达式的输入，<code>MATLAB</code>把任何非零数值当作真，把零当作假。所有关系和逻辑表达式的输出：对于真，输出为1；对于假，输出为0。逻辑类型数据进行运算时需要用到关系操作符和逻辑运算符。</p><table><thead><tr><th align="center">关系操作符</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">&lt;</td><td align="center">小于</td></tr><tr><td align="center">&lt;&#x3D;</td><td align="center">小于或等于</td></tr><tr><td align="center">&gt;</td><td align="center">大于</td></tr><tr><td align="center">&gt;&#x3D;</td><td align="center">大于或等于</td></tr><tr><td align="center">&#x3D;&#x3D;</td><td align="center">等于</td></tr><tr><td align="center">~&#x3D;</td><td align="center">不等于</td></tr></tbody></table><p><code>MATLAB</code>关系操作符能用来比较两个同样大小的数组，或用来比较一个数组和一个标量。在后一种情况中，标量和数组中的每一个元素相比较，结果与数组大小一样。</p><table><thead><tr><th align="center">逻辑运算符</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">&amp;</td><td align="center">与</td></tr><tr><td align="center">|</td><td align="center">或</td></tr><tr><td align="center">~</td><td align="center">非</td></tr></tbody></table><blockquote><p><code>xor</code>(x , y )指令的功能为异或运算，x和y同为零（假）或非零（真）时返回0，否则返回1。<br><code>any</code>(x)指令的功能为判断是否为零向量或零矩阵（即向量或矩阵中的元素全部为零），如果是零向量或零矩阵，则返回1，否则返回0。</p></blockquote><p><code>MATLAB</code> 还提供了大量的函数，在运算过程中用来测试特殊值或条件是否存在，并返回相应的表示结果的逻辑值。</p><table><thead><tr><th>函数名称</th><th>函数功能</th></tr></thead><tbody><tr><td><code>finite</code></td><td>元素有限，返回真值</td></tr><tr><td><code>Isempty</code></td><td>参量为空，返回真值</td></tr><tr><td><code>isglobal</code></td><td>参量是一个全局变量，返回真值</td></tr><tr><td><code>ishold</code></td><td>当前绘图保持状态是“ON”，返回真值</td></tr><tr><td><code>isieee</code></td><td>计算机执行 IEEE 算术运算，返回真值</td></tr><tr><td><code>isinf</code></td><td>元素无穷大，返回真值</td></tr><tr><td><code>isletter</code></td><td>元素为字母，返回真值</td></tr><tr><td><code>isnan</code></td><td>元素为不定值，返回真值</td></tr><tr><td><code>isreal</code></td><td>参量无虚部，返回真值</td></tr><tr><td><code>isspace</code></td><td>元素为空格字符，返回真值</td></tr><tr><td><code>isstr</code></td><td>参量为一个字符串，返回真值</td></tr><tr><td><code>isstudent</code></td><td>MATLAB 为学生版，返回真值</td></tr><tr><td><code>isunix</code></td><td>计算机为 UNIX 系统，返回真值</td></tr></tbody></table><h3 id="👀字符和字符串"><a href="#👀字符和字符串" class="headerlink" title="👀字符和字符串"></a>👀字符和字符串</h3><p>一个字符串是存储在一个行向量中的文本，这个行向量中的每一个元素代表一个字符。实际上，元素中存放的是字符的内部代码，即<code>ASCII</code>码。由于字符串是以向量的形式来存储的，因此可以通过它的下标对字符串中的任何一个元素进行访问。字符矩阵也可以通过下标索引进行访问，但是矩阵的每行字符数必须相同。</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">String =</span><br><span class="line">    <span class="string">&#x27;Every good boy does fun.&#x27;</span></span><br><span class="line">&gt;&gt; <span class="built_in">size</span>(String)</span><br><span class="line"></span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line">     <span class="number">1</span>    <span class="number">24</span></span><br><span class="line">&gt;&gt; whos </span><br><span class="line">  Name        Size            Bytes  Class     Attributes</span><br><span class="line"></span><br><span class="line">  String      <span class="number">1</span>x24               <span class="number">48</span>  char                </span><br><span class="line">  <span class="built_in">ans</span>         <span class="number">1</span>x2                <span class="number">16</span>  double   </span><br></pre></td></tr></table></figure><p>一个字符串是由<strong>单引号</strong>括起来的简单文本。在字符串里的每个字符是数组里的一个元素，字符串的存储要求每个字符8字节，如同<code>MATLAB</code>的其他变量。</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">&gt;&gt; String =<span class="string">&#x27;Every good boy does fun.&#x27;</span></span><br><span class="line">String =</span><br><span class="line">    <span class="string">&#x27;Every good boy does fun.&#x27;</span></span><br><span class="line">&gt;&gt; a = String(<span class="number">7</span>:<span class="number">10</span>) </span><br><span class="line">a =</span><br><span class="line">    <span class="string">&#x27;good&#x27;</span></span><br><span class="line">&gt;&gt; b = String(<span class="number">10</span>:<span class="number">-1</span>:<span class="number">7</span>) </span><br><span class="line">b =</span><br><span class="line">    <span class="string">&#x27;doog&#x27;</span></span><br></pre></td></tr></table></figure><p>字符串内的单引号是由两个连续的单引号来表示的。字符串的连接可以直接将字符串数组连接来实现。</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">&gt;&gt; String =<span class="string">&#x27;It&#x27;&#x27;s not the manual!&#x27;</span></span><br><span class="line">String =</span><br><span class="line">    <span class="string">&#x27;It&#x27;</span>s not the manual!<span class="string">&#x27;</span></span><br><span class="line"><span class="string">&gt;&gt; U =&#x27;</span>Hello,<span class="string">&#x27;; </span></span><br><span class="line"><span class="string">&gt;&gt; V =&#x27;</span> world!<span class="string">&#x27;; </span></span><br><span class="line"><span class="string">&gt;&gt; W = [U V] </span></span><br><span class="line"><span class="string">W =</span></span><br><span class="line"><span class="string">    &#x27;</span>Hello, world!<span class="string">&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="👀函数句柄"><a href="#👀函数句柄" class="headerlink" title="👀函数句柄"></a>👀函数句柄</h3><p>在<code>MATLAB</code>平台中，对函数的调用方法分为直接调用法和间接调用法。</p><ul><li>直接调用函数，被调用的函数通常被称为子函数。但是子函数只能被与其<code>M</code>文件同名的主函数或在<code>M</code>文件中的其他函数所调用，同时在一个文件中只能有一个主函数。</li><li>而使用函数句柄对函数进行调用则避免了上述问题。函数句柄实际上提供了一种间接调用函数的方法。创建函数句柄需要用到操作符<code>@</code>。对<code>MATLAB</code>库函数中提供的各种<code>M</code>文件中的函数和使用者自主编写的程序中的内部函数，都可以创建函数句柄，从而可以通过函数句柄来实现对这些函数的间接调用。</li></ul><p>创建函数句柄的一般句法格式为：</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">Function_Handle = @Function_Filename; </span><br><span class="line"><span class="comment">% Function_Filename是函数所对应的M文件的名称或MATLAB内部函数的名称。</span></span><br><span class="line"><span class="comment">% @是句柄创建操作符。</span></span><br><span class="line"><span class="comment">% Function_Handle变量保存了这一函数句柄，并在后续的运算中作为数据流进行传递。</span></span><br></pre></td></tr></table></figure><p>例如，<code>F_Handle=@cos</code>就创建了<code>MATLAB</code>内部函数<code>cos</code>的句柄，并将其保存在<code>F_Handle</code>变量中，后续的运算过程中就可以通过<code>F_Handle(x)</code>来实现<code>cos(x)</code>的功能。</p><h3 id="👀结构体类型"><a href="#👀结构体类型" class="headerlink" title="👀结构体类型"></a>👀结构体类型</h3><p><code>MATLAB</code>中的结构体与<code>C</code>语言中的结构体类似，一个结构体可以通过字段存储多个不同类型的数据。因此，结构体相当于一个数据容器，把多个相关联的不同类型的数据封装在一个结构体对象中。</p><p>一个结构体中可以具有多个字段，每个字段又可以存储不同类型的数据，通过这种方式就把多个不同类型的数据组织在一个结构体对象中。创建结构体对象的方法有两种，可以直接通过赋值语句给结构体的字段赋值，也可以使用结构体创建函数<code>struct</code>。</p><p>（1）直接赋值创建</p><p>通过字段赋值创建结构体。在对结构体的字段进行赋值时，赋值表达式的变量名使用“<code>结构体名称.字段名称</code>”的形式书写，对同一个结构体可以进行多个字段的赋值。</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">Student.Name=<span class="string">&#x27;Sam&#x27;</span>; </span><br><span class="line">Student.Grade=<span class="number">6</span>; </span><br><span class="line">Student.Subject=&#123;<span class="string">&#x27;Chinese&#x27;</span>,<span class="string">&#x27;Math&#x27;</span>,<span class="string">&#x27;English&#x27;</span>&#125;; </span><br><span class="line">Student.Result=&#123;<span class="number">99</span>,<span class="number">99</span>,<span class="number">99</span>&#125;; </span><br><span class="line"></span><br><span class="line"><span class="comment">% 输出结果</span></span><br><span class="line">&gt;&gt; Student</span><br><span class="line">Student = </span><br><span class="line">  包含以下字段的 struct:</span><br><span class="line">       Name: <span class="string">&#x27;Sam&#x27;</span></span><br><span class="line">      Grade: <span class="number">6</span></span><br><span class="line">    Subject: &#123;<span class="string">&#x27;Chinese&#x27;</span>  <span class="string">&#x27;Math&#x27;</span>  <span class="string">&#x27;English&#x27;</span>&#125;</span><br><span class="line">     Result: &#123;[<span class="number">99</span>]  [<span class="number">99</span>]  [<span class="number">99</span>]&#125;</span><br><span class="line"><span class="comment">% Student 是一个 1×1 的结构体数组</span></span><br><span class="line">&gt;&gt; whos</span><br><span class="line">  Name         SizeBytes  Class     Attributes</span><br><span class="line"></span><br><span class="line">  Student      <span class="number">1</span>x1<span class="number">1450</span>     struct  </span><br></pre></td></tr></table></figure><p>（2）函数<code>struct</code>创建</p><p><code>struct</code>函数的句法形式为：<code>StrArray = struct(&#39;field1&#39;, var1, &#39;field2&#39;, var2,…,&#39;fieldn&#39;, varn)</code> </p><blockquote><p>在进行字段赋值操作时，没有明确赋值的字段，<code>MATLAB</code>默认赋值为空数组。通过<strong>圆括号</strong>索引进行字段赋值，还可以创建<strong>任意尺寸的结构体数组</strong>。需要注意的是，同一个结构体数组中的所有结构体对象具有<strong>相同</strong>的字段组合。</p></blockquote><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">Schedule(<span class="number">2</span>)=struct(<span class="string">&#x27;Day&#x27;</span>,<span class="string">&#x27;Thursday&#x27;</span>,<span class="string">&#x27;Time&#x27;</span>,<span class="string">&#x27;15:00&#x27;</span>,<span class="string">&#x27;Number&#x27;</span>,<span class="number">18</span>) </span><br><span class="line">ScheduleArray=<span class="built_in">repmat</span>(struct(<span class="string">&#x27;Day&#x27;</span>,<span class="string">&#x27;Thursday&#x27;</span>,<span class="string">&#x27;Time&#x27;</span>,<span class="string">&#x27;15:00&#x27;</span>,<span class="string">&#x27;Number&#x27;</span>,<span class="number">18</span>),<span class="number">1</span>,<span class="number">2</span>) </span><br><span class="line">newArray=struct(<span class="string">&#x27;Day&#x27;</span>,&#123;<span class="string">&#x27;Thursday&#x27;</span>,<span class="string">&#x27;Friday&#x27;</span>&#125;,<span class="string">&#x27;Time&#x27;</span>,&#123;<span class="string">&#x27;15:00&#x27;</span>,<span class="string">&#x27;9:00&#x27;</span>&#125;, <span class="string">&#x27;Number&#x27;</span>,&#123;<span class="number">18</span>,<span class="number">6</span>&#125;) </span><br><span class="line"></span><br><span class="line"><span class="comment">% 输出结果</span></span><br><span class="line">Schedule = </span><br><span class="line">  包含以下字段的 <span class="number">1</span>×<span class="number">2</span> struct 数组:</span><br><span class="line">    Day</span><br><span class="line">    Time</span><br><span class="line">    Number</span><br><span class="line">ScheduleArray = </span><br><span class="line">  包含以下字段的 <span class="number">1</span>×<span class="number">2</span> struct 数组:</span><br><span class="line">    Day</span><br><span class="line">    Time</span><br><span class="line">    Number</span><br><span class="line">newArray = </span><br><span class="line">  包含以下字段的 <span class="number">1</span>×<span class="number">2</span> struct 数组:</span><br><span class="line">    Day</span><br><span class="line">    Time</span><br><span class="line">    Number</span><br><span class="line"><span class="comment">% 获取结构体某个元素</span></span><br><span class="line"><span class="comment">% 结构体第一个元素没有赋值，因此所有字段均为空数组</span></span><br><span class="line">&gt;&gt; Schedule(<span class="number">1</span>) </span><br><span class="line"><span class="built_in">ans</span> = </span><br><span class="line">  包含以下字段的 struct:</span><br><span class="line">       Day: []</span><br><span class="line">      Time: []</span><br><span class="line">    Number: []</span><br><span class="line"><span class="comment">% 1×2 的结构体数组ScheduleArray的两个元素完全相同</span></span><br><span class="line">&gt;&gt; ScheduleArray(<span class="number">1</span>) </span><br><span class="line"><span class="built_in">ans</span> = </span><br><span class="line">  包含以下字段的 struct:</span><br><span class="line">       Day: <span class="string">&#x27;Thursday&#x27;</span></span><br><span class="line">      Time: <span class="string">&#x27;15:00&#x27;</span></span><br><span class="line">    Number: <span class="number">18</span></span><br><span class="line">&gt;&gt; ScheduleArray(<span class="number">2</span>) </span><br><span class="line"><span class="built_in">ans</span> = </span><br><span class="line">  包含以下字段的 struct:</span><br><span class="line"></span><br><span class="line">       Day: <span class="string">&#x27;Thursday&#x27;</span></span><br><span class="line">      Time: <span class="string">&#x27;15:00&#x27;</span></span><br><span class="line">    Number: <span class="number">18</span></span><br><span class="line"><span class="comment">% newArray结构体中包含的结构体对象具有相同的字段组合</span></span><br><span class="line">&gt;&gt; newArray(<span class="number">1</span>) </span><br><span class="line"><span class="built_in">ans</span> = </span><br><span class="line">  包含以下字段的 struct:</span><br><span class="line">       Day: <span class="string">&#x27;Thursday&#x27;</span></span><br><span class="line">      Time: <span class="string">&#x27;15:00&#x27;</span></span><br><span class="line">    Number: <span class="number">18</span></span><br><span class="line">&gt;&gt; newArray(<span class="number">2</span>) </span><br><span class="line"><span class="built_in">ans</span> = </span><br><span class="line">  包含以下字段的 struct:</span><br><span class="line">       Day: <span class="string">&#x27;Friday&#x27;</span></span><br><span class="line">      Time: <span class="string">&#x27;9:00&#x27;</span></span><br><span class="line">    Number: <span class="number">6</span></span><br></pre></td></tr></table></figure><h3 id="👀数组类型"><a href="#👀数组类型" class="headerlink" title="👀数组类型"></a>👀数组类型</h3><p>在<code>MATLAB</code>中进行运算的所有数据类型，都是按照数组及矩阵的形式进行存储和运算的，而二者在<code>MATLAB</code>中的基本运算性质不同，阵列强调元素对元素的运算，而矩阵则采用线性代数的运算方式。数组的属性及数组之间的逻辑关系，是编写程序时非常重要的两个方面。在<code>MATLAB</code>平台上，数组的定义是广义的，数组的元素可以是<strong>任意</strong>的数据类型，例如可以是数值、字符串、指针等。</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">Array = [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span>]</span><br><span class="line"><span class="comment">% 在MATLAB中可以使用冒号“:”来代表一系列数值，有时也使用它来定义数组。</span></span><br><span class="line"><span class="comment">% 创建从i开始、步长为1、到k结束的数字序列</span></span><br><span class="line"><span class="comment">% 如果i&gt;k，MATLAB则返回一个空矩阵。数字i和k不必是整数，该序列的最后一个数小于或等于k。</span></span><br><span class="line">Array = <span class="built_in">i</span>:k </span><br><span class="line"><span class="comment">% 创建从i开始、步长为j、到k结束的数字序列</span></span><br><span class="line"><span class="comment">% 如果j=0，则返回一个空矩阵。数字i、j和k不必是整数，该序列的最后一个数小于或等于k。</span></span><br><span class="line">Array = <span class="built_in">i</span>:<span class="built_in">j</span>:k</span><br><span class="line"></span><br><span class="line"><span class="comment">% 预定义函数也可以用来创建线性序列和逻辑序列</span></span><br><span class="line"><span class="comment">% 在区间[a,b]上创建一个有n个元素的向量，这n个数把整个区间线性分隔。</span></span><br><span class="line"><span class="comment">% 当数组的元素个数为0时，就称数组为空。空数组是特殊的数组，它不含有任何元素。空数组主要用于逻辑运算、数组声明、数组的清空等。</span></span><br><span class="line">Array = <span class="built_in">linspace</span>(a,b,n) </span><br><span class="line"></span><br><span class="line"><span class="comment">% 创建空数组</span></span><br><span class="line">Array_Empty=[] </span><br></pre></td></tr></table></figure><h3 id="👀单元数组类型"><a href="#👀单元数组类型" class="headerlink" title="👀单元数组类型"></a>👀单元数组类型</h3><p>单元（<code>Cell</code>）数组是一种无所不包的广义矩阵。组成单元数组的每一个元素称为一个单元。每一个单元可以包括一个任意数组，如数值数组、字符串数组、结构体数组或另外一个单元数组，因而每一个单元可以具有不同的尺寸和内存占用空间。<code>MATLAB</code>中使用单元数组的目的在于，它可以把不同类型的数据归并到一个数组中。</p><blockquote><p>和一般的数值数组一样，单元数组的维数不受限制，可以是一维、二维或多维。</p></blockquote><h4 id="👁单元数组的创建"><a href="#👁单元数组的创建" class="headerlink" title="👁单元数组的创建"></a>👁单元数组的创建</h4><p>单元数组的创建有两种方法：使用<strong>赋值语句创建</strong>单元数组和利用<code>cell</code><strong>函数创建</strong>数组。</p><p>（1）赋值语句创建单元数组 </p><p>与一般数组有所不同的是，单元数组使用花括号“<code>&#123;&#125;</code>”来创建，使用逗号“<code>,</code>”或空格来分隔每一个单元，使用分号“<code>;</code>”来分行。</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">&gt;&gt; C = &#123;<span class="string">&#x27;x&#x27;</span>,[<span class="number">1</span>;<span class="number">3</span>;<span class="number">6</span>];<span class="number">10</span>,<span class="built_in">pi</span>&#125; </span><br><span class="line">C =</span><br><span class="line">  <span class="number">2</span>×<span class="number">2</span> cell 数组</span><br><span class="line">    &#123;<span class="string">&#x27;x&#x27;</span> &#125;    &#123;<span class="number">3</span>×<span class="number">1</span> double&#125;</span><br><span class="line">    &#123;[<span class="number">10</span>]&#125;    &#123;[  <span class="number">3.1416</span>]&#125;</span><br><span class="line">&gt;&gt; whos</span><br><span class="line">  Name      Size    Bytes  Class    Attributes</span><br><span class="line">  C         <span class="number">2</span>x2          <span class="number">490</span>           cell     </span><br></pre></td></tr></table></figure><p>（2）<code>cell</code>函数创建单元数组</p><p><code>cell</code>函数的调用格式如下：</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% cell函数创建一个 m×n 的空单元数组，其每一个单元均为空矩阵。</span></span><br><span class="line">cellName = cell(m，n)</span><br></pre></td></tr></table></figure><p>同一般的数值数组一样，单元数组的内存空间也是动态分配的。因此，使用<code>cell</code>函数创建空单元数组的主要目的是为该单元数组预先分配连续的存储空间，以节约内存占用，提高执行效率。</p><h4 id="👁单元数组的寻访"><a href="#👁单元数组的寻访" class="headerlink" title="👁单元数组的寻访"></a>👁单元数组的寻访</h4><p>在单元数组中，单元和单元中的内容是两个不同范畴的东西，因此，寻访单元和单元中的内容是两个不同的操作。<code>MATLAB</code>为两种操作设计了相对应的操作对象：单元外标识（<code>Cell Indexing</code>）和单元内编址（<code>Content Addressing</code>）。</p><p>对于单元数组<code>C</code>，<code>C(m,n)</code>指的是单元数组中第<code>m</code>行第<code>n</code>列的<strong>单元</strong>，而 <code>C&#123;m,n&#125;</code>指的是单元数组中第<code>m</code>行第<code>n</code>列<strong>单元中的内容</strong>。</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">&gt;&gt; C = &#123;<span class="number">3</span>,[<span class="number">4</span> <span class="number">7</span>;<span class="number">6</span> <span class="number">6</span>;<span class="number">80</span> <span class="number">9</span>],<span class="string">&#x27;string&#x27;</span>;<span class="built_in">sin</span>(<span class="built_in">pi</span>/<span class="number">8</span>),<span class="number">3</span>&gt;<span class="number">10</span>,<span class="string">&#x27;code&#x27;</span>&#125;</span><br><span class="line">C =</span><br><span class="line">  <span class="number">2</span>×<span class="number">3</span> cell 数组</span><br><span class="line">    &#123;[     <span class="number">3</span>]&#125;    &#123;<span class="number">3</span>×<span class="number">2</span> double&#125;    &#123;<span class="string">&#x27;string&#x27;</span>&#125;</span><br><span class="line">    &#123;[<span class="number">0.3827</span>]&#125;    &#123;[       <span class="number">0</span>]&#125;    &#123;<span class="string">&#x27;code&#x27;</span>  &#125;</span><br><span class="line"></span><br><span class="line">&gt;&gt; unitVal_1 = C(<span class="number">2</span>,<span class="number">2</span>) </span><br><span class="line">unitVal_1 =</span><br><span class="line">  <span class="number">1</span>×<span class="number">1</span> cell 数组</span><br><span class="line">    &#123;[<span class="number">0</span>]&#125;</span><br><span class="line">&gt;&gt; class(unitVal_1) </span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line">    <span class="string">&#x27;cell&#x27;</span></span><br><span class="line">&gt;&gt; unitVal_2 = C&#123;<span class="number">2</span>,<span class="number">2</span>&#125; </span><br><span class="line">unitVal_2 =</span><br><span class="line">  logical</span><br><span class="line">   <span class="number">0</span></span><br><span class="line">&gt;&gt; class(unitVal_2) </span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line">    <span class="string">&#x27;logical&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="👁单元数组的操作"><a href="#👁单元数组的操作" class="headerlink" title="👁单元数组的操作"></a>👁单元数组的操作</h4><p>单元数组的操作包括合并、删除单元数组中的指定单元、改变单元数组的形状等。</p><p>（1）单元数组的合并</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">a&#123;<span class="number">1</span>,<span class="number">1</span>&#125;=<span class="string">&#x27;cellclass&#x27;</span>; </span><br><span class="line">a&#123;<span class="number">1</span>,<span class="number">2</span>&#125;=[<span class="number">1</span> <span class="number">2</span> <span class="number">2</span>];</span><br><span class="line">a&#123;<span class="number">2</span>,<span class="number">1</span>&#125;=[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>]; </span><br><span class="line">a&#123;<span class="number">2</span>,<span class="number">2</span>&#125;=[<span class="number">9</span> <span class="number">5</span> <span class="number">6</span>];</span><br><span class="line">a</span><br><span class="line">b = &#123;<span class="string">&#x27;Jan&#x27;</span>&#125; </span><br><span class="line">c = &#123;a b&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">% 输出结果</span></span><br><span class="line">a = </span><br><span class="line"> <span class="string">&#x27;cellclass&#x27;</span> [<span class="number">1</span>x3 double] </span><br><span class="line"> <span class="string">&#x27;abc&#x27;</span> [<span class="number">1</span>x3 double] </span><br><span class="line">b = <span class="string">&#x27;Jan&#x27;</span> </span><br><span class="line">c = &#123;<span class="number">2</span>x2 cell&#125; &#123;<span class="number">1</span>x1 cell&#125; </span><br></pre></td></tr></table></figure><p>（2）单元数组中指定单元的删除</p><p>如果要删除单元数组中指定的某个单元，只需要将空矩阵赋给该单元，即：</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">C&#123;m,n&#125; = [] </span><br></pre></td></tr></table></figure><p>（3）单元数组的形状修改</p><p>使用<code>reshape</code>函数改变单元数组的形状。<code>reshape</code>函数的调用格式为：</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% reshape函数将单元数组C改变成一个具有M行N列的新单元数组。</span></span><br><span class="line">trimC = <span class="built_in">reshape</span>（C, M, N）</span><br></pre></td></tr></table></figure><h3 id="👀map容器类型"><a href="#👀map容器类型" class="headerlink" title="👀map容器类型"></a>👀map容器类型</h3><p><code>map</code>的本意是映射，是可以将一个量映射到另一个量。比如将一个字符串映射为一个数值，那个字符串就是 <code>map</code>的键（<code>key</code>），那个值就是<code>map</code>的数据（<code>value</code>）。因此，可以将map容器理解为一种快速查找数据结构的键。</p><blockquote><p>对一个<code>map</code>元素进行寻访的索引称为“<code>键</code>”。一个“<code>键</code>”可以是以下任何一种数据类型：</p><ul><li>1×N 字符串；</li><li>单精度或双精度实数标量；</li><li>有符号或无符号标量整数。</li></ul></blockquote><p>这些键和其对应的数据存储在<code>map</code>中。一个<code>map</code>的每一个条目都包括唯一的键和相对应的数据。<code>map</code>中存储的数据可以是任何类型，包括数值类型、字符或字符串类型、结构体类型、单元类型或其他<code>map</code>。一个<code>map</code>是<code>MATLAB</code>类的一个对象。<code>map</code>类的所有对象具有3种属性。用户不能直接对这些属性进行修改，但可以通过作用于<code>map</code>类的函数进行修改。</p><table><thead><tr><th>属性</th><th>说明</th><th>默认值</th></tr></thead><tbody><tr><td><code>Count</code></td><td>无符号 64 位整数，表示 map 对象中存储的 key&#x2F;value 对的总数</td><td>0</td></tr><tr><td><code>KeyType</code></td><td>字符串，表示 map 对象中包括的 key 的类型</td><td>char</td></tr><tr><td><code>ValueType</code></td><td>字符串，表示 map 对象中包括的数据类型</td><td>any</td></tr></tbody></table><blockquote><p><code>map</code>属性的查看方法为<code>map名＋小数点“.”＋map的属性名</code>。例如，为了查看<code>mapW</code>对象包括的数据类型，需要使用 <code>mapW.ValueType</code>。</p></blockquote><h4 id="👁创建map对象"><a href="#👁创建map对象" class="headerlink" title="👁创建map对象"></a>👁创建<code>map</code>对象</h4><p><code>map</code>是一个<code>map</code>类中的对象，由<code>MATLAB</code>中名为“容器”的一个包来定义，通过构造函数来创建，其创建方法如下：</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">mapObj = containers.Map(&#123;key1,key2,…&#125;,&#123;val1,val2,…&#125;) </span><br><span class="line"><span class="comment">% 当键和值是字符串时，需要对上述语法稍作变更，即：</span></span><br><span class="line">mapObj = containers.Map(&#123;<span class="string">&#x27;key1&#x27;</span>,<span class="string">&#x27;key2&#x27;</span>,…&#125;,&#123;val1,val2,…&#125;) </span><br></pre></td></tr></table></figure><p><code>map</code>对象的创建可以分为两个步骤：首先创建一个空<code>map</code>对象；然后使用<code>keys</code>和<code>values</code>方法对其内容进行补充。空<code>map</code>对象的创建方法如下：</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">&gt;&gt; newMap = containers.Map() </span><br><span class="line">&gt;&gt; newMap</span><br><span class="line">newMap = </span><br><span class="line"> Map (带属性): </span><br><span class="line"> Count: <span class="number">0</span> </span><br><span class="line"> KeyType: char </span><br><span class="line"> ValueType: any </span><br></pre></td></tr></table></figure><h4 id="👁查看-x2F-读取-map-对象"><a href="#👁查看-x2F-读取-map-对象" class="headerlink" title="👁查看&#x2F;读取 map 对象"></a>👁查看&#x2F;读取 <code>map</code> 对象</h4><p>（1）查看<code>map</code>对象</p><p><code>map</code>对象中的每个条目包括两个部分：一个唯一的键及其对应的值。可以通过使用<code>keys</code>函数查看<code>map</code>对象中包含的所有键；通过<code>values</code>函数查看所有的值。</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">&gt;&gt; schedulemap = containers.Map(&#123;<span class="string">&#x27;Monday&#x27;</span>,<span class="string">&#x27;Tuesday&#x27;</span>,<span class="string">&#x27;Wednesday&#x27;</span>,<span class="string">&#x27;Thursday&#x27;</span>,<span class="string">&#x27;Friday&#x27;</span>&#125;, &#123;<span class="string">&#x27;Maths&#x27;</span>,<span class="string">&#x27;Chinese&#x27;</span>,<span class="string">&#x27;History&#x27;</span>,<span class="string">&#x27;Geography&#x27;</span>,<span class="string">&#x27;Biology&#x27;</span>&#125;) </span><br><span class="line">schedulemap = </span><br><span class="line">  Map - 属性:</span><br><span class="line">        Count: <span class="number">5</span></span><br><span class="line">      KeyType: char</span><br><span class="line">    ValueType: char</span><br><span class="line">&gt;&gt; keys(schedulemap) </span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line">  <span class="number">1</span>×<span class="number">5</span> cell 数组</span><br><span class="line">    &#123;<span class="string">&#x27;Friday&#x27;</span>&#125;    &#123;<span class="string">&#x27;Monday&#x27;</span>&#125;    &#123;<span class="string">&#x27;Thursday&#x27;</span>&#125;    &#123;<span class="string">&#x27;Tuesday&#x27;</span>&#125;    &#123;<span class="string">&#x27;Wednesday&#x27;</span>&#125;</span><br><span class="line">&gt;&gt; values(schedulemap) </span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line">  <span class="number">1</span>×<span class="number">5</span> cell 数组</span><br><span class="line">    &#123;<span class="string">&#x27;Biology&#x27;</span>&#125;    &#123;<span class="string">&#x27;Maths&#x27;</span>&#125;    &#123;<span class="string">&#x27;Geography&#x27;</span>&#125;    &#123;<span class="string">&#x27;Chinese&#x27;</span>&#125;    &#123;<span class="string">&#x27;History&#x27;</span>&#125;</span><br></pre></td></tr></table></figure><p>（2）读取<code>map</code>对象</p><p>在创建好一个<code>map</code>对象后，用户可以对其进行数据的寻访。寻访指定键（<code>keyName</code>）所对应的值（<code>valueName</code>）使用的格式如下：</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">valueName = mapName（keyName）</span><br><span class="line"><span class="comment">% 当键名是一个字符串时，需使用单引号将键名括起来。</span></span><br><span class="line"></span><br><span class="line">&gt;&gt; course = schedulemap(<span class="string">&#x27;Wednesday&#x27;</span>) </span><br><span class="line">course =</span><br><span class="line">    <span class="string">&#x27;History&#x27;</span></span><br><span class="line"><span class="comment">% 如果需要对多个键进行访问，可以使用 values 函数，如：</span></span><br><span class="line">&gt;&gt; values(schedulemap,&#123;<span class="string">&#x27;Monday&#x27;</span>,<span class="string">&#x27;Thursday&#x27;</span>&#125;) </span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line">  <span class="number">1</span>×<span class="number">2</span> cell 数组</span><br><span class="line">    &#123;<span class="string">&#x27;Maths&#x27;</span>&#125;    &#123;<span class="string">&#x27;Geography&#x27;</span>&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在对多个键进行访问时，不能像在其他数据类型中那样使用冒号“<code>:</code>”，这将导致错误产生。例如输入：<br><code>schedulemap(&#39;Monday&#39;:&#39;Thursday&#39;) </code><br>结果弹出如下错误信息：<br>警告: 冒号操作数必须为实数标量。</p></blockquote><h4 id="👁编辑map对象"><a href="#👁编辑map对象" class="headerlink" title="👁编辑map对象"></a>👁编辑<code>map</code>对象</h4><p>（1）从<code>map</code>对象中删除<code>keys/values</code>对</p><p>用户可以使用<code>remove</code>函数从<code>map</code>对象中删除<code>keys/values</code>对，该函数的调用格式为：</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% mapName和keyName分别为map对象名称及需要删除的键名。</span></span><br><span class="line"><span class="comment">% 执行该命令后，MATLAB 系统删除指定的键名及其相对应的值。</span></span><br><span class="line">remove(<span class="string">&#x27;mapName&#x27;</span>, <span class="string">&#x27;keyName&#x27;</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment">% 删除schedulemap中的“星期四”及其对应的科目。</span></span><br><span class="line">&gt;&gt; remove(schedulemap,<span class="string">&#x27;Thursday&#x27;</span>) </span><br><span class="line"><span class="built_in">ans</span> = </span><br><span class="line">  Map - 属性:</span><br><span class="line">        Count: <span class="number">4</span></span><br><span class="line">      KeyType: char</span><br><span class="line">    ValueType: char</span><br><span class="line">&gt;&gt; keys(schedulemap) </span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line">  <span class="number">1</span>×<span class="number">4</span> cell 数组</span><br><span class="line">    &#123;<span class="string">&#x27;Friday&#x27;</span>&#125;    &#123;<span class="string">&#x27;Monday&#x27;</span>&#125;    &#123;<span class="string">&#x27;Tuesday&#x27;</span>&#125;    &#123;<span class="string">&#x27;Wednesday&#x27;</span>&#125;</span><br><span class="line">&gt;&gt; values(schedulemap) </span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line">  <span class="number">1</span>×<span class="number">4</span> cell 数组</span><br><span class="line">    &#123;<span class="string">&#x27;Biology&#x27;</span>&#125;    &#123;<span class="string">&#x27;Maths&#x27;</span>&#125;    &#123;<span class="string">&#x27;Chinese&#x27;</span>&#125;    &#123;<span class="string">&#x27;History&#x27;</span>&#125;</span><br></pre></td></tr></table></figure><p>（2）添加<code>keys/values</code>对象</p><p>当用户向一个<code>map</code>对象中写入新元素的值时，需要提供键名，而且该键的类型必须和<code>map</code>中的其他键一致。该操作的调用格式为：</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">existingMapObj(newKeyName)= newValue </span><br><span class="line"></span><br><span class="line"><span class="comment">% 为schedulemap添加“星期六”及其对应的科目“public elective course”</span></span><br><span class="line">&gt;&gt; schedulemap(<span class="string">&#x27;Saturday&#x27;</span>) = <span class="string">&#x27;public elective course&#x27;</span> </span><br><span class="line">schedulemap = </span><br><span class="line">  Map - 属性:</span><br><span class="line">        Count: <span class="number">5</span></span><br><span class="line">      KeyType: char</span><br><span class="line">    ValueType: char</span><br><span class="line">&gt;&gt; keys(schedulemap) </span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line">  <span class="number">1</span>×<span class="number">5</span> cell 数组</span><br><span class="line">    &#123;<span class="string">&#x27;Friday&#x27;</span>&#125;    &#123;<span class="string">&#x27;Monday&#x27;</span>&#125;    &#123;<span class="string">&#x27;Saturday&#x27;</span>&#125;    &#123;<span class="string">&#x27;Tuesday&#x27;</span>&#125;    &#123;<span class="string">&#x27;Wednesday&#x27;</span>&#125;</span><br><span class="line">&gt;&gt; values(schedulemap) </span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line">  <span class="number">1</span>×<span class="number">5</span> cell 数组</span><br><span class="line">    &#123;<span class="string">&#x27;Biology&#x27;</span>&#125;    &#123;<span class="string">&#x27;Maths&#x27;</span>&#125;    &#123;<span class="string">&#x27;public elective…&#x27;</span>&#125;    &#123;<span class="string">&#x27;Chinese&#x27;</span>&#125;    &#123;<span class="string">&#x27;History&#x27;</span>&#125;</span><br></pre></td></tr></table></figure><p>（3）修改<code>keys</code></p><p>如果需要在保持值不变的情况下对键名进行更改，首先要删除键名和对应的值，然后再添加一个有正确键名的新条目。</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% 修改“星期六”及其对应的科目“公共选修课”为“星期天”及其对应的科目“MBA”</span></span><br><span class="line">&gt;&gt; remove(schedulemap,<span class="string">&#x27;Saturday&#x27;</span>);</span><br><span class="line">&gt;&gt; schedulemap(<span class="string">&#x27;Sunday&#x27;</span>) = <span class="string">&#x27;MBA&#x27;</span>; </span><br><span class="line">&gt;&gt; keys(schedulemap) </span><br><span class="line"></span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line">  <span class="number">1</span>×<span class="number">5</span> cell 数组</span><br><span class="line">    &#123;<span class="string">&#x27;Friday&#x27;</span>&#125;    &#123;<span class="string">&#x27;Monday&#x27;</span>&#125;    &#123;<span class="string">&#x27;Sunday&#x27;</span>&#125;    &#123;<span class="string">&#x27;Tuesday&#x27;</span>&#125;    &#123;<span class="string">&#x27;Wednesday&#x27;</span>&#125;</span><br><span class="line">&gt;&gt; values(schedulemap) </span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line">  <span class="number">1</span>×<span class="number">5</span> cell 数组</span><br><span class="line">    &#123;<span class="string">&#x27;Biology&#x27;</span>&#125;    &#123;<span class="string">&#x27;Maths&#x27;</span>&#125;    &#123;<span class="string">&#x27;MBA&#x27;</span>&#125;    &#123;<span class="string">&#x27;Chinese&#x27;</span>&#125;    &#123;<span class="string">&#x27;History&#x27;</span>&#125;</span><br></pre></td></tr></table></figure><p>（4）修改<code>values</code></p><p>通过赋值操作，覆盖原有的值，即可对<code>map</code>对象中的值进行修改。</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% 修改“星期一”的科目为“英语”</span></span><br><span class="line">&gt;&gt; schedulemap(<span class="string">&#x27;Monday&#x27;</span>)</span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line">    <span class="string">&#x27;Maths&#x27;</span></span><br><span class="line">&gt;&gt; schedulemap(<span class="string">&#x27;Monday&#x27;</span>) = <span class="string">&#x27;english&#x27;</span>; </span><br><span class="line">&gt;&gt; keys(schedulemap) </span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line">  <span class="number">1</span>×<span class="number">5</span> cell 数组</span><br><span class="line">    &#123;<span class="string">&#x27;Friday&#x27;</span>&#125;    &#123;<span class="string">&#x27;Monday&#x27;</span>&#125;    &#123;<span class="string">&#x27;Sunday&#x27;</span>&#125;    &#123;<span class="string">&#x27;Tuesday&#x27;</span>&#125;    &#123;<span class="string">&#x27;Wednesday&#x27;</span>&#125;</span><br><span class="line">&gt;&gt; values(schedulemap) </span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line">  <span class="number">1</span>×<span class="number">5</span> cell 数组</span><br><span class="line">    &#123;<span class="string">&#x27;Biology&#x27;</span>&#125;    &#123;<span class="string">&#x27;english&#x27;</span>&#125;    &#123;<span class="string">&#x27;MBA&#x27;</span>&#125;    &#123;<span class="string">&#x27;Chinese&#x27;</span>&#125;    &#123;<span class="string">&#x27;History&#x27;</span>&#125;</span><br></pre></td></tr></table></figure><h2 id="⛄基本矩阵操作"><a href="#⛄基本矩阵操作" class="headerlink" title="⛄基本矩阵操作"></a>⛄基本矩阵操作</h2><p>对矩阵的基本操作，主要有矩阵的构建、矩阵维度与矩阵大小的改变、矩阵的索引、矩阵属性信息的获取、矩阵结构的改变等。对于这些操作，<code>MATLAB</code>中都有固定指令或相应的库函数与之相对应。</p><p>矩阵最早来自于方程组的系数及常数所构成的方阵，这一概念由19世纪英国数学家凯利首先提出。数组是在程序设计中，为了处理方便，把具有相同类型的若干变量按有序的形式组织起来的一种形式。这些按序排列的同类数据元素的集合称为数组。</p><p>在<code>MATLAB</code>中，一个数组可以分解为多个数组元素，这些数组元素可以是基本数据类型或构造类型。因此按数组元素的类型不同，数组又可分为数值数组、字符数组、单元数组、结构数组等各种类别。</p><p>由此可见，矩阵和数组在<code>MATLAB</code>中存在很多方面的区别，主要有以下几个方面：</p><ul><li>矩阵是数学上的概念，而数组是计算机程序设计领域的概念。</li><li>作为一种变换或者映射算符的体现，矩阵运算有着明确而严格的数学规则。而数组运算是 MATLAB 软件定义的规则，其目的是为了使数据管理方便，操作简单，命令形式自然，执行计算有效。</li></ul><p>两者间的联系主要体现在：在<code>MATLAB</code>中，矩阵是以数组的形式存在的。因此，一维数组相当于向量，二维数组相当于矩阵，所以矩阵是数组的子集。</p><h3 id="👀矩阵的构造"><a href="#👀矩阵的构造" class="headerlink" title="👀矩阵的构造"></a>👀矩阵的构造</h3><p>矩阵的构建方式有两种，一种与单元数组相似，可以对变量直接进行赋值；另一种是<code>MATLAB</code>中提供构建特殊矩阵的指令。特殊矩阵的构建函数：</p><p><strong>1矩阵</strong>：<code>ones()</code>；</p><p><strong>0矩阵</strong>：<code>zeros()</code>；</p><p><strong>单位矩阵</strong>：<code>eyes()</code>；</p><p><strong>行&#x2F;列和相等的矩阵</strong>：<code>magic()</code>；</p><p><strong>随机矩阵</strong>：<code>rand()</code>和<code>randn()</code>；</p><p><strong>其它矩阵（对角线、上三角形、下三角形）</strong>：<code>diag()</code>、<code>triu()</code>、<code>tril()</code>。</p><p>（1）建立简单矩阵</p><p>简单矩阵采用矩阵构造符号——方括号“<code>[]</code>”，将矩阵元素置于方括号内，同行元素之间用<code>空格</code>或<code>逗号</code>隔开，行与行之间用分号“<code>;</code>”隔开，格式如下：</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">matrixName = [element11,element12,element13;element21,element22,element23] </span><br><span class="line">matrixName = [element11 element12 element13;element21 element22 element23] </span><br></pre></td></tr></table></figure><p>（2）建立特殊矩阵</p><p>特殊矩阵是指非零元素或零元素的分布有一定规律的矩阵，常见的有对称矩阵、三角矩阵和对角矩阵等。</p><p>（3）向量、标量和空矩阵</p><p>通常情况下，矩阵包含m行和n列，即m×n。当m和n取一些特殊值时，得到的矩阵具有一些特殊的性质。</p><p><strong>向量</strong>：当m&#x3D;1或n&#x3D;1，即1×n或m×1时，建立的矩阵称为向量。</p><p><strong>标量</strong>：当m&#x3D;n&#x3D;1时，建立的矩阵称为标量。任意以1×1的矩阵形式表示的<strong>单个实数</strong>、<strong>复数</strong>都是标量。单个实数或者复数在<code>MATLAB</code>中都是以矩阵的形式存储的；在<code>MATLAB</code>中，单个数据或由单个数据构造的矩阵都是标量。</p><p><strong>空矩阵</strong>：当m&#x3D;n&#x3D;0，或者m&#x3D;0，或者n&#x3D;0，即0×0、0×n、m×0 时，创建的矩阵称为空矩阵。空矩阵可以通过赋值语句建立。<strong>空矩阵</strong>和<strong>0矩阵</strong>的本质区别在于：空矩阵内没有任何元素，因此不占用任何存储空间；而 0 矩阵表示该矩阵中的所有元素全部为0，需要占用一定的存储空间。</p><h3 id="👀矩阵大小及结构的改变"><a href="#👀矩阵大小及结构的改变" class="headerlink" title="👀矩阵大小及结构的改变"></a>👀矩阵大小及结构的改变</h3><p>根据运算时的不同情况和需要，矩阵大小和结构的改变，主要的方式有旋转矩阵、改变矩阵维度、删除矩阵元素等。</p><table><thead><tr><th>函数名称</th><th>函数功能</th></tr></thead><tbody><tr><td><code>fliplr(A)</code></td><td>矩阵每一行均进行逆序排列</td></tr><tr><td><code>flipud(A)</code></td><td>矩阵每一列均进行逆序排列</td></tr><tr><td><code>flipdim(A,dim)</code></td><td>生成一个在dim维矩阵A内的元素交换位置的多维矩阵</td></tr><tr><td><code>rot90(A)</code></td><td>生成一个由矩阵A逆时针旋转90°而得到的新矩阵</td></tr><tr><td><code>rot90(A,k)</code></td><td>生成一个由矩阵A逆时针旋转k×90°而得到的新矩阵</td></tr><tr><td><code>reshape(A,m,n)</code></td><td>生成一个m×n×…×p维的矩阵，其元素以线性索引的顺序从矩阵A中取得<br/>如果矩阵A中没有m×n×…×p个元素，将返回一个错误信息</td></tr><tr><td><code>repmat(A,[m n…p])</code></td><td>创建一个和矩阵A有相同元素的m×n×…×p块的多维矩阵</td></tr><tr><td><code>shiftdim(A,n)</code></td><td>矩阵的列移动n步。n为正数，矩阵向左移；n为负数，矩阵向右移</td></tr><tr><td><code>squeeze(A)</code></td><td>返回没有空维的矩阵A</td></tr><tr><td><code>cat(dim,A,B)</code></td><td>将矩阵A和B组合成一个dim维的多维矩阵</td></tr><tr><td><code>permute(A,order)</code></td><td>根据向量order来改变矩阵A中的维数顺序</td></tr><tr><td><code>ipermute(A,order)</code></td><td>进行命令permute的逆变换</td></tr><tr><td><code>sort(A)</code></td><td>对一维或二维矩阵进行升序排序，并返回排序后的矩阵；<br/>当A为二维矩阵时，对矩阵的每一列分别进行排序</td></tr><tr><td><code>sort(A,dim)</code></td><td>对矩阵按指定的方向进行升序排序，并返回排序后的矩阵。<br />当dim&#x3D;1时，对矩阵的每一列排序；dim&#x3D;2时，对矩阵的每一行排序</td></tr><tr><td><code>sort(A,dim,mode)</code></td><td>mode为’ascend’时，进行升序排序；mode为’descend’时，进行降序排序</td></tr><tr><td><code>[B,IX] = sort(A,…)</code></td><td>IX为排序后备元素在原矩阵中的行位置或列位置的索引</td></tr></tbody></table><h3 id="👀矩阵下标引用"><a href="#👀矩阵下标引用" class="headerlink" title="👀矩阵下标引用"></a>👀矩阵下标引用</h3><p>在<code>MATLAB</code>中，普通二维数组元素的数字索引分为<strong>双下标索引</strong>和<strong>单下标索引</strong>。<strong>双下标索引</strong>是通过一个二元数组对来对应元素在矩阵中的行列位置，例如A(2,3)表示矩阵A中第2行第3列的元素。<strong>单下标索引</strong>的方式是采用列元素优先的原则，对m行n列的矩阵按列排序进行重组，成为一维数组，再取新的一维数组中的元素位置对应的值作为元素在原矩阵中的单下标，例如对于4×4的矩阵，A(7)表示矩阵A中第3行第2列的元素，而 A(13)表示矩阵A中第1行第4列的元素。</p><p>（1）矩阵下标访问单个矩阵元素</p><table><thead><tr><th>索引表达式</th><th>函数功能</th></tr></thead><tbody><tr><td><code>A(1)</code></td><td>将二维矩阵<code>A</code>重组为一维数组，返回数组中第一个元素</td></tr><tr><td><code>A(:,j)</code></td><td>返回二维矩阵<code>A</code>中第<code>j</code>列列向量</td></tr><tr><td><code>A(i,:)</code></td><td>返回二维矩阵<code>A</code>中第<code>i</code>行行向量</td></tr><tr><td><code>A(:,j:k)</code></td><td>返回由二维矩阵<code>A</code>中的第<code>j</code>列到第<code>k</code>列列向量组成的子矩阵</td></tr><tr><td><code>A(i:k,:)</code></td><td>返回由二维矩阵<code>A</code>中的第<code>i</code>行到第<code>k</code>行行向量组成的子矩阵</td></tr><tr><td><code>A(i:k,j:l)</code></td><td>返回由二维矩阵<code>A</code>中的第<code>i</code>行到第<code>k</code>行行向量<br />和第<code>j</code>列到第<code>l</code>列列向量的交集组成的子矩阵</td></tr><tr><td><code>A(:)</code></td><td>将矩阵<code>A</code>中的每列合并成一个长的列向量</td></tr><tr><td><code>A(j:k)</code></td><td>返回一个行向量，其元素为<code>A(:)</code>中的第<code>j</code>个元素到第<code>k</code>个元素</td></tr><tr><td><code>A([j1 j2 …])</code></td><td>返回一个行向量，其元素为<code>A(:)</code>中的第<code>j1</code>、<code>j2</code>元素</td></tr><tr><td><code>A(:,[j1 j2…])</code></td><td>返回矩阵<code>A</code>的第<code>j1</code>列、第<code>j2</code>列等的列向量</td></tr><tr><td><code>A([i1 i2 …],:)</code></td><td>返回矩阵<code>A</code>的第<code>i1</code>行、第<code>i2</code>行等的行向量</td></tr><tr><td><code>A([i1 i2…],[j1 j2…])</code></td><td>返回矩阵第<code>i1</code>行、第<code>i2</code>行等和第<code>j1</code>列、第<code>j2</code>列等的元素</td></tr></tbody></table><p>（2）线性应用矩阵元素</p><p>矩阵中某一元素的单下标索引值和双下标索引值之间，可以通过<code>MATLAB</code>内部函数进行转换。</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% 将双下标索引值转换为单下标索引值</span></span><br><span class="line"><span class="comment">% siz是一个包含两个元素的数组，代表了转换矩阵的行列数，一般可以直接用size(A)表示;</span></span><br><span class="line"><span class="comment">% i与j分别是双下表索引中的行、列值，IND是转换后的单下标索引值。</span></span><br><span class="line">IND = <span class="built_in">sub2ind</span>(siz, <span class="built_in">i</span>, <span class="built_in">j</span>) </span><br><span class="line"><span class="comment">% 将单下标索引值转换为双下标索引值，各变量意义同上</span></span><br><span class="line">[I J] = <span class="built_in">ind2sub</span>(siz, ind) </span><br></pre></td></tr></table></figure><p>（3）访问多个矩阵元素</p><p>在下标表达式里，可以用冒号来表示矩阵的多个元素。例如，<code>A(1:k,j)</code>表示矩阵第<code>j</code>列的前<code>k</code>个元素。在 <code>MATLAB</code>中提供了一个关键字<code>end</code>，用于表示该维中的最后一个元素。</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">A=<span class="built_in">magic</span>(<span class="number">4</span>)，</span><br><span class="line"><span class="comment">% 利用冒号，第4列元素的和可以用更为简洁的式子</span></span><br><span class="line">sum(A(<span class="number">1</span>:<span class="number">4</span>,<span class="number">4</span>)) </span><br><span class="line"><span class="comment">% 冒号本身可以表示一列或者一行的所有元素，上式还可写为：</span></span><br><span class="line">sum(A(:,<span class="number">4</span>)) </span><br><span class="line"><span class="comment">% 关键字end，用于表示该维中的最后一个元素，上式还可写为：</span></span><br><span class="line">sum(A(:,<span class="keyword">end</span>)) </span><br><span class="line"></span><br><span class="line"><span class="comment">% 还可以用冒号来表示非相邻的多个元素</span></span><br><span class="line">B=<span class="number">1</span>:<span class="number">10</span> </span><br><span class="line">C=B(<span class="number">1</span>:<span class="number">3</span>:<span class="number">10</span>) </span><br></pre></td></tr></table></figure><h3 id="👀矩阵信息的获取"><a href="#👀矩阵信息的获取" class="headerlink" title="👀矩阵信息的获取"></a>👀矩阵信息的获取</h3><p>矩阵的信息主要包括矩阵结构、矩阵大小、矩阵维度、矩阵的数据类型及内存占用等。</p><p>（1）矩阵结构</p><p>矩阵的结构是指矩阵子元素的排列方式。这类函数的返回值是逻辑类型的数据。返回值为“<code>1</code>”表示该矩阵是某一特定类型的矩阵；返回值为“<code>0</code>”表示该矩阵不是该特定类型的矩阵。</p><table><thead><tr><th>函数名称</th><th>函数功能</th></tr></thead><tbody><tr><td><code>isempty(A)</code></td><td>检测矩阵是否为空</td></tr><tr><td><code>isscalar(A)</code></td><td>检测矩阵是否是单元素的标量矩阵</td></tr><tr><td><code>isvector(A)</code></td><td>检测矩阵是否是只具有一行或一列元素的一维向量</td></tr><tr><td><code>issparse(A)</code></td><td>检测数组是否是稀疏矩阵</td></tr></tbody></table><p>（2）矩阵大小</p><p>矩阵的形状信息反映了矩阵的大小，通常又包括以下几个方面的内容：</p><ul><li>矩阵的维数。</li><li>矩阵各维（例如最长维、用户指定的维）的长度。</li><li>矩阵元素的个数。</li></ul><table><thead><tr><th>函 数</th><th></th><th>描 述</th></tr></thead><tbody><tr><td><code>ndims</code></td><td>n&#x3D;ndims(X)</td><td>获取矩阵的维数</td></tr><tr><td><code>size</code></td><td>[m,n]&#x3D;size(X)</td><td>获取矩阵在各维上的长度</td></tr><tr><td><code>length</code></td><td>n&#x3D;length(X)</td><td>获取矩阵最长维的长度</td></tr><tr><td><code>numel</code></td><td>n&#x3D;numel(X)</td><td>获取矩阵元素的个数</td></tr></tbody></table><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">A = <span class="built_in">eye</span>(<span class="number">5</span>,<span class="number">3</span>) </span><br><span class="line">[m,n] = <span class="built_in">size</span>(A) </span><br><span class="line">m = <span class="number">5</span> </span><br><span class="line">n = <span class="number">3</span> </span><br><span class="line">d = <span class="built_in">size</span>(A) </span><br><span class="line">d = <span class="number">5</span> <span class="number">3</span> </span><br><span class="line">e1 = <span class="built_in">size</span>(A,<span class="number">1</span>) </span><br><span class="line">e1 = <span class="number">5</span> </span><br><span class="line">e2 = <span class="built_in">size</span>(A,<span class="number">2</span>) </span><br><span class="line">e2 = <span class="number">3</span> </span><br></pre></td></tr></table></figure><blockquote><p><code>size</code>函数的应用可知：①<code>size</code>函数的返回值可以是分开显示的单个实数变量，也可以是一个行向量；②在<code>size</code>函数的输入参数中增加维度参数可以获取指定维度的长度，其中“<code>1</code>”表示行，“<code>2</code>”表示列。</p></blockquote><p>（3）矩阵维度</p><p>对于空矩阵、标量矩阵、一维矩阵和二维矩阵，<code>MATLAB</code>都将其作为普通二维数组对待。特别需要注意的是，用[]产生的空矩阵是作为二维矩阵的，但是在高维矩阵中也有空矩阵的概念，此时空矩阵则具有多个维度。</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">A = []; B = <span class="number">5</span>; C = <span class="number">1</span>:<span class="number">3</span>; D = <span class="built_in">magic</span>(<span class="number">2</span>); E(:,:,<span class="number">2</span>) = [<span class="number">1</span> <span class="number">2</span>; <span class="number">3</span> <span class="number">4</span>]; </span><br><span class="line">Ndims = [<span class="built_in">ndims</span>(A) <span class="built_in">ndims</span>(B) <span class="built_in">ndims</span>(C) <span class="built_in">ndims</span>(D) <span class="built_in">ndims</span>(E)] </span><br><span class="line"><span class="comment">% 输出结果</span></span><br><span class="line">Ndims = <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">3</span> </span><br></pre></td></tr></table></figure><p>（4）矩阵的数据类型</p><p>矩阵作为<code>MATLAB</code>的内部数据存储和运算结构，其元素可以是各种各样的数据类型，对应不同数据类型的元素，可以是数值、字符串、元胞、结构体等。这类函数的返回值也是逻辑类型的数据。返回值为“<code>1</code>”表示是某一特定的数据类型；返回值为“<code>0</code>”表示不是该特定的数据类型。</p><table><thead><tr><th>函数名称</th><th>函数功能</th></tr></thead><tbody><tr><td><code>isnumeric</code></td><td>检测矩阵元素是否为数值型变量</td></tr><tr><td><code>isreal</code></td><td>检测矩阵元素是否为实数数值型变量</td></tr><tr><td><code>isfloat</code></td><td>检测矩阵元素是否为浮点数值型变量</td></tr><tr><td><code>isinteger</code></td><td>检测矩阵元素是否为整数型变量</td></tr><tr><td><code>islogical</code></td><td>检测矩阵元素是否为逻辑型变量</td></tr><tr><td><code>ischar</code></td><td>检测矩阵元素是否为字符型变量</td></tr><tr><td><code>isstruct</code></td><td>检测矩阵元素是否为结构体型变量</td></tr><tr><td><code>iscell</code></td><td>检测矩阵元素是否为元胞型变量</td></tr><tr><td><code>iscellstr</code></td><td>检测矩阵元素是否为结构体的元胞型变量</td></tr></tbody></table><p>（5）矩阵占用的内存</p><p>了解矩阵的内存占用情况，对于优化<code>MATLAB</code>代码性能是十分重要的。使用者可以通过<code>whos</code>命令查看当前工作区中指定变量的所有信息，包括变量名、矩阵大小、内存占用和数据类型等。</p><h3 id="👀矩阵的保存和加载"><a href="#👀矩阵的保存和加载" class="headerlink" title="👀矩阵的保存和加载"></a>👀矩阵的保存和加载</h3><p>矩阵在MATLAB中的存储方式、矩阵元素的寻址方法、矩阵元素的赋值及扩展。<code>MATLAB</code>就是将矩阵元素按<code>列优先</code>排列的原则依次放置在相应的格子内。因此，可以看成是一个长列向量。<code>MATLAB</code>采用了两种元素寻址方式：①矩阵下标寻址；②线性寻址。</p><h4 id="👁矩阵元素的寻址"><a href="#👁矩阵元素的寻址" class="headerlink" title="👁矩阵元素的寻址"></a>👁矩阵元素的寻址</h4><p>（1）矩阵下标寻址方法</p><p>在<code>MATLAB</code>中，使用<code>A(i,j)</code>来表示一个矩阵<code>A</code>从左上角数起的第i行、第j列上的元素，这就是矩阵下标寻址方法。这种方法和线性代数中矩阵元素的引用方法一致，通俗易懂。</p><p><strong>单元素的寻访</strong>：当使用双下标访问一个二维矩阵中的某个元素时，必须同时指定该元素所在的行号和列号，访问格式为：<code>A(numRow,numColumn)</code> ，其中，<code>numRow</code>和<code>numColumn</code>分别代表行号和列号。</p><p><strong>矩阵元素区域的寻访</strong>：访问矩阵的多个元素，可以是某一行、某一列或者其中的部分元素，也可以是矩阵中的某一块区域。在<code>MATLAB</code>中，元素区域的访问需要用到冒号“<code>:</code>”来表示矩阵中的多个元素，具体的访问格式如下：</p><ul><li><code>A(1:m,n)</code>：表示访问第n列的第一个元素至第m个元素。</li><li><code>A(m,:)</code>：表示访问第m行的所有元素。</li><li><code>A(i:j,m:n)</code> ：表示访问从第i 行至第j行、从第m列至第n列的矩阵区域。</li><li><code>A(i:inc1:j,m:inc2:n)</code> ：表示访问从第i行至第j行，行间隔为inc1行；从第m列至第n列，列间隔为inc2的非相邻的多个矩阵元素。</li></ul><p>（2）线性寻址</p><p>线性寻址的原理来自于<code>MATLAB</code>将矩阵元素存储在内存空间的存储方法。与矩阵下标寻址相比，只需要单一下标即可实现矩阵中任意位置元素的寻访。线性寻址的下标是通过矩阵的双下标换算得到的。</p><p>一般，设A是一个m×n的矩阵，位于第i行、第j列上的元素A(i,j)的单一下标为<code>A((j-1)·m+i)</code>。</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">A = <span class="built_in">hilb</span>(<span class="number">3</span>) </span><br><span class="line">A(<span class="number">2</span>,<span class="number">3</span>) <span class="comment">% 采用矩阵下标寻址的方法访问第 2 行第 3 列的元素</span></span><br><span class="line">A(<span class="number">8</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment">% 输出结果</span></span><br><span class="line">A = </span><br><span class="line"> <span class="number">1.0000</span> <span class="number">0.5000</span> <span class="number">0.3333</span> </span><br><span class="line"> <span class="number">0.5000</span> <span class="number">0.3333</span> <span class="number">0.2500</span> </span><br><span class="line"><span class="number">0.3333</span> <span class="number">0.2500</span> <span class="number">0.2000</span> </span><br><span class="line"><span class="built_in">ans</span> = <span class="number">0.2500</span> </span><br><span class="line"><span class="built_in">ans</span> = <span class="number">0.2500</span> </span><br></pre></td></tr></table></figure><h4 id="👁矩阵元素的赋值及扩展"><a href="#👁矩阵元素的赋值及扩展" class="headerlink" title="👁矩阵元素的赋值及扩展"></a>👁矩阵元素的赋值及扩展</h4><p>（1）矩阵元素的赋值</p><p><code>MATLAB</code>使用赋值语句对矩阵元素进行赋值，基本语法如下：</p><ul><li><code>A(i,j) = value</code>：等号左侧为矩阵中的某个元素；等号右侧为值。</li><li><code>A = []</code>：删除矩阵中的所有元素。</li></ul><p>（2）矩阵元素的扩展与删除</p><p>增加或删除矩阵元素最常用的办法是使用赋值语句。此外，<code>MATLAB</code>提供了多个函数进行矩阵合并操作，从而实现将多个矩阵合并成一个矩阵。</p><table><thead><tr><th>函数</th><th>调用格式</th><th>描述</th></tr></thead><tbody><tr><td><code>cat</code></td><td><code>cat(DIM,A,B)</code></td><td>在DIM指定的维度上合并矩阵 A 和 B。<br />DIM&#x3D;1表示按行（竖直方向）合并；DIM&#x3D;2表示按列（水平方向）合并</td></tr><tr><td><code>horzcat</code></td><td><code>horzcat(A,B)</code></td><td>在水平方向上合并矩阵A和B</td></tr><tr><td><code>vertcat</code></td><td><code>vertcat(A,B)</code></td><td>在竖直方向上合并矩阵A和B</td></tr><tr><td><code>repmat</code></td><td><code>B=repmat(A,M,N)</code></td><td>通过复制M×N个矩阵A来构造新的矩阵B</td></tr><tr><td><code>blkdiag</code></td><td><code>Y=blkdiag(A,B,...)</code></td><td>用已知的A、B等多个矩阵构造块对角化矩阵Y</td></tr></tbody></table><blockquote><p>cat及其相关的函数在将两个矩阵按某个维度进行合并操作时，原始的两个矩阵要在某一个维度上具有相同的长度，否则 MATLAB 在进行计算时就会发生错误。</p></blockquote><h2 id="⛄运算符"><a href="#⛄运算符" class="headerlink" title="⛄运算符"></a>⛄运算符</h2><p><code>MATLAB</code>中的运算符分为算术运算符、关系运算符和逻辑运算符。这三种运算符可以分别使用，也可以在同一运算式中出现。当在同一运算式中同时出现两种或两种以上运算符时，运算的优先级排列如下：算术运算符优先级最高，其次是关系运算符，最低级别是逻辑运算符。</p><h3 id="👀算术运算符"><a href="#👀算术运算符" class="headerlink" title="👀算术运算符"></a>👀算术运算符</h3><p><code>MATLAB</code>中的算术运算符有加、减、乘、除、点乘、点除等。</p><table><thead><tr><th>算术运算符</th><th>运算法则</th><th>算术运算符</th><th>运算法则</th></tr></thead><tbody><tr><td><code>A+B</code></td><td>A与B相加<br/>（A、B为数值或矩阵）</td><td><code>A-B</code></td><td>A与B相减<br/>（A、B为数值或矩阵）</td></tr><tr><td><code>A * B</code></td><td>A与B相乘<br/>（A、B为数值或矩阵）</td><td><code>A.* B</code></td><td>A与B相应元素相乘<br/>（A、B为相同维度的矩阵）</td></tr><tr><td><code>A / B</code></td><td>A与B相除<br/>（A、B为数值或矩阵）</td><td><code>A./ B</code></td><td>A与B相应元素相除<br/>（A、B为相同维度的矩阵）</td></tr><tr><td><code>A ^ B</code></td><td>A的B次幂<br/>（A、B为数值或矩阵）</td><td><code>A.^ B</code></td><td>A的每个元素的B次幂<br/>（A 为矩阵，B为数值）</td></tr></tbody></table><p><code>MATLAB</code>平台上还提供了大量的运算函数：<code>exp(x)</code>、<code>log(x)</code>、<code>log10(x)</code>、<code>sqrt(x)</code>、<code>sin(x)</code>、<code>cos(x)</code>、<code>tan(x)</code>、<code>asin(x)</code>、<code>acos(x)</code>、<code>atan(x)</code>、<code>mod(a,b)</code>、<code>min(a,b)</code>、<code>max(a,b)</code>、<code>mean(x)</code>、<code>median(x)</code>、<code>sum(x)</code>、<code>prod(x)</code>、<code>cumsum(x)</code>、<code>cumprod(x)</code>、<code>sign(x)</code>、<code>rem(x,y)</code>、<code>diff(x)</code>、<code>sort(x)</code>、<code>fft(x)</code>、<code>rank(x)</code> 。</p><h3 id="👀关系运算符"><a href="#👀关系运算符" class="headerlink" title="👀关系运算符"></a>👀关系运算符</h3><p><code>MATLAB</code>中的关系运算符有6个。关系运算符可以用来对两个数值、两个数组、两个矩阵或两个字符串等数据类型进行比较，同样也可以进行不同类型两个数据之间的比较。比较的方式根据所比较的两个数据类型的不同而不同。例如对矩阵和一个标量进行比较时，需将矩阵中的每个元素与标量进行比较。关系运算符通过比较对应的元素，产生一个仅包含1和0的数值或矩阵。</p><ul><li>返回值为 1，比较结果是真。</li><li>返回值为 0，比较结果是假。</li></ul><table><thead><tr><th align="center">关系运算符</th><th align="center">关系说明</th><th align="center">关系运算符</th><th align="center">关系说明</th></tr></thead><tbody><tr><td align="center">&lt;</td><td align="center">小于</td><td align="center">&lt;&#x3D;</td><td align="center">小于等于</td></tr><tr><td align="center">&gt;</td><td align="center">大于</td><td align="center">&gt;&#x3D;</td><td align="center">大于等于</td></tr><tr><td align="center">&#x3D;&#x3D;</td><td align="center">等于</td><td align="center">~&#x3D;</td><td align="center">不等于</td></tr></tbody></table><blockquote><p>“<code>=</code>”和“<code>==</code>”的区别：“<code>==</code>”的运算法则是比较两个变量，当它们相等时返回 1，当它们不相等时返回 0；而“<code>=</code>”则是被用来将运算的结果赋给一个变量。</p></blockquote><h3 id="👀逻辑运算符"><a href="#👀逻辑运算符" class="headerlink" title="👀逻辑运算符"></a>👀逻辑运算符</h3><p>逻辑运算符提供了一种组合或否定关系表达式。</p><table><thead><tr><th align="center">逻辑运算符</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">&amp;</td><td align="center">与</td></tr><tr><td align="center">|</td><td align="center">或</td></tr><tr><td align="center">~</td><td align="center">非</td></tr></tbody></table><p>与关系运算符一样，逻辑运算符也可以进行矩阵与数值之间的比较，比较的方式为将矩阵的每一个元素都与数值进行比较，比较结果为一个相同维数的矩阵，新生成矩阵的每一个元素都代表着原来矩阵中相同位置上的元素与该数值的逻辑运算结果。使用逻辑运算符比较两个相同维数的矩阵时，是按元素来进行比较的，其比较结果是一个包含1和0的矩阵。元素0表示逻辑为假，元素1表示逻辑为真。</p><p>除了上面的逻辑运算符，<code>MATLAB</code>还提供了各种逻辑函数：</p><table><thead><tr><th>函数</th><th>运算法则</th></tr></thead><tbody><tr><td><code>xor(x,y)</code></td><td>异或运算。x与y不同时，返回1；x与y相同时，返回0</td></tr><tr><td><code>any(x)</code></td><td>如果在一个向量x中，有任何元素是非零，返回1；否则返回0 <br/>如果矩阵x中的每一列有非零元素，返回1；否则返回0</td></tr><tr><td><code>all(x)</code></td><td>如果在一个向量x中，所有元素非零，返回1；否则返回0 <br/>矩阵x中的每一列所有元素非零，返回1；否则返回0</td></tr></tbody></table><h2 id="⛄字符串处理函数"><a href="#⛄字符串处理函数" class="headerlink" title="⛄字符串处理函数"></a>⛄字符串处理函数</h2><p><code>MATLAB</code>提供了大量的字符串函数：</p><table><thead><tr><th>字符串函数</th><th>函数功能</th></tr></thead><tbody><tr><td><code>eval(string)</code></td><td>作为一个MATLAB命令求字符串的值</td></tr><tr><td><code>blanks(n)</code></td><td>返回一个n个零或空格的字符串</td></tr><tr><td><code>deblank</code></td><td>去掉字符串中后拖的空格</td></tr><tr><td><code>feval</code></td><td>求由字符串给定的函数值</td></tr><tr><td><code>findstr</code></td><td>从一个字符串内找出字符串</td></tr><tr><td><code>isletter</code></td><td>字母存在时返回真值</td></tr><tr><td><code>isspace</code></td><td>空格字符存在时返回真值</td></tr><tr><td><code>Isstr</code></td><td>输入一个字符串，返回真值</td></tr><tr><td><code>iasterr</code></td><td>返回上一个产生 MATLAB 错误的字符串</td></tr><tr><td><code>strcmp</code></td><td>字符串相同，返回真值</td></tr><tr><td><code>strrep</code></td><td>用一个字符串替换另一个字符串</td></tr><tr><td><code>strtok</code></td><td>在一个字符串里找出第一个标记</td></tr></tbody></table><h3 id="👀字符串的构造"><a href="#👀字符串的构造" class="headerlink" title="👀字符串的构造"></a>👀字符串的构造</h3><p>字符串或字符串数组的构造可以通过直接给变量赋值来实现，具体表达式中字符串的内容需要写在<strong>单引号</strong>内。如果字符串的内容包含单引号，那么以两个重复的单引号来表示。</p><p>构造多行字符串时，若字符串内容写在<code>[]</code>内，那么多行字符串的长度必须相同；若字符串内容写在<code>&#123;&#125;</code>内，则这多行字符串的长度可以不同。</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">&gt;&gt; Str_mat = [<span class="string">&#x27;July&#x27;</span>;<span class="string">&#x27;August&#x27;</span>;<span class="string">&#x27;September&#x27;</span>;] </span><br><span class="line">要串联的数组的维度不一致。</span><br><span class="line">&gt;&gt; Str_mat2 = &#123;<span class="string">&#x27;July&#x27;</span>;<span class="string">&#x27;August&#x27;</span>;<span class="string">&#x27;September&#x27;</span>;&#125; </span><br><span class="line">Str_mat2 =</span><br><span class="line">  <span class="number">3</span>×<span class="number">1</span> cell 数组</span><br><span class="line">    &#123;<span class="string">&#x27;July&#x27;</span>     &#125;</span><br><span class="line">    &#123;<span class="string">&#x27;August&#x27;</span>   &#125;</span><br><span class="line">    &#123;<span class="string">&#x27;September&#x27;</span>&#125;</span><br></pre></td></tr></table></figure><p><code>MATLAB</code>中还提供了<code>strvcat</code>和<code>char</code>函数用于纵向连接多个字符串。<code>strvcat</code>函数连接多行字符串时，每行字符串的长度不要求相等，所有非最长字符串的右边会自动补偿空格，使得每行字符串的长度相同。<code>char</code>函数与<code>strvcat</code>函数类似，不过当多行字符串中有空字符串时，<code>strvcat</code>函数会自动进行忽略，而<code>char</code>函数会把空字符串也用空格补偿后再进行连接。</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">A=<span class="string">&#x27;top&#x27;</span>; B=<span class="string">&#x27;&#x27;</span>; C=<span class="string">&#x27;Bottom&#x27;</span>; </span><br><span class="line">sABC=strvcat(A,B,C),cABC=char(A,B,C),<span class="built_in">size</span>=[<span class="built_in">size</span>(sABC);<span class="built_in">size</span>(cABC)] </span><br><span class="line"></span><br><span class="line"><span class="comment">% 输出结果</span></span><br><span class="line">sABC = </span><br><span class="line">top </span><br><span class="line">Bottom </span><br><span class="line">cABC = </span><br><span class="line">top </span><br><span class="line"></span><br><span class="line">Bottom </span><br><span class="line"><span class="built_in">size</span> = </span><br><span class="line"> <span class="number">2</span> <span class="number">6</span> </span><br><span class="line"> <span class="number">3</span> <span class="number">6</span> </span><br></pre></td></tr></table></figure><h3 id="👀字符串比较函数"><a href="#👀字符串比较函数" class="headerlink" title="👀字符串比较函数"></a>👀字符串比较函数</h3><p>两个字符串之间的关系可以通过关系运算符来比较，也可以使用<code>strcmp</code>函数来比较两个字符串是否相同。</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">&gt;&gt; A = (<span class="string">&#x27; Hello &#x27;</span> == <span class="string">&#x27; Word &#x27;</span>) </span><br><span class="line">矩阵维度必须一致。</span><br><span class="line">&gt;&gt; A = (<span class="string">&#x27; Hello &#x27;</span> == <span class="string">&#x27; World &#x27;</span>)</span><br><span class="line">A =</span><br><span class="line">  <span class="number">1</span>×<span class="number">7</span> logical 数组</span><br><span class="line">   <span class="number">1</span>   <span class="number">0</span>   <span class="number">0</span>   <span class="number">0</span>   <span class="number">1</span>   <span class="number">0</span>   <span class="number">1</span></span><br><span class="line">&gt;&gt; C = strcmp(<span class="string">&#x27; Hello &#x27;</span>, <span class="string">&#x27; World &#x27;</span>)</span><br><span class="line">C =</span><br><span class="line">  logical</span><br><span class="line">   <span class="number">0</span></span><br></pre></td></tr></table></figure><blockquote><p>使用<strong>关系运算符</strong>进行比较时，会对字符串的每个字符进行比较，返回值是一个与字符串长度相同大小的数组，因此被比较的两个字符串的长度必须相同；而<strong>strcmp函数</strong>则根据两个字符串相同与否，返回值为数值0或 1。</p></blockquote><h3 id="👀字符串查找和替换函数"><a href="#👀字符串查找和替换函数" class="headerlink" title="👀字符串查找和替换函数"></a>👀字符串查找和替换函数</h3><p>字符串的查找与搜索可以通过<code>findstr</code>函数来实现。<code>findstr</code>函数对字母的大小写是敏感的。另外，<code>findstr</code>函数对字符串矩阵不起作用，因此对字符串矩阵的搜索只能通过循环索引矩阵内的元素进行搜索。</p><p>字符串的替换可以通过对字符串数组中相应的元素直接赋值来实现，也可以使用<code>strrep</code>函数来实现。直接赋值方法并不能使两个不同长度的字符串相互替换，而<code>strrep</code>函数可以替换两个任意长度的字符串。与<code>findstr</code>函数类似，<code>strrep</code>函数也对字符串矩阵不起作用。</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">&gt;&gt; String =<span class="string">&#x27;Peter Piper picked a peck of pickled peppers.&#x27;</span></span><br><span class="line">String =</span><br><span class="line">    <span class="string">&#x27;Peter Piper picked a peck of pickled peppers.&#x27;</span></span><br><span class="line">&gt;&gt; findstr(String,<span class="string">&#x27;pick&#x27;</span>)</span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line">    <span class="number">13</span>    <span class="number">30</span></span><br><span class="line">&gt;&gt; String = strrep(String, <span class="string">&#x27;Peter Piper&#x27;</span>, <span class="string">&#x27;Sabrina Crame&#x27;</span>) </span><br><span class="line">String =</span><br><span class="line">    <span class="string">&#x27;Sabrina Crame picked a peck of pickled peppers.&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="👀数值转换"><a href="#👀数值转换" class="headerlink" title="👀数值转换"></a>👀数值转换</h3><p><code>MATLAB</code>还提供了大量字符串与各种数据类型之间的转换函数：</p><table><thead><tr><th>函数名称</th><th>函数功能</th></tr></thead><tbody><tr><td><code>abs</code></td><td>字符转换成 ASCII</td></tr><tr><td><code>dec2hex</code></td><td>十进制数转换成十六进制字符串</td></tr><tr><td><code>fprintf</code></td><td>把格式化的文本写到文件中或显示屏上</td></tr><tr><td><code>hex2dec</code></td><td>十六进制字符串转换成十进制数</td></tr><tr><td><code>hex2num</code></td><td>十六进制字符串转换成 IEEE 浮点数</td></tr><tr><td><code>int2str</code></td><td>整数转换成字符串</td></tr><tr><td><code>lower</code></td><td>字符串转换成小写</td></tr><tr><td><code>num2str</code></td><td>数字转换成字符串</td></tr><tr><td><code>setstr</code></td><td>ASCII 转换成字符串</td></tr><tr><td><code>sprintf</code></td><td>用格式控制数字转换成字符串</td></tr><tr><td><code>sscanf</code></td><td>用格式控制字符串转换成数字</td></tr><tr><td><code>str2mat</code></td><td>字符串转换成一个文本矩阵</td></tr><tr><td><code>str2num</code></td><td>字符串转换成数字</td></tr><tr><td><code>upper</code></td><td>字符串转换成大写</td></tr></tbody></table><h2 id="⛄数组与矩阵"><a href="#⛄数组与矩阵" class="headerlink" title="⛄数组与矩阵"></a>⛄数组与矩阵</h2><h3 id="👀数组运算"><a href="#👀数组运算" class="headerlink" title="👀数组运算"></a>👀数组运算</h3><p>数组运算是<code>MATLAB</code>计算的基础。由于<code>MATLAB</code>面向对象的特性，这种数值数组成为<code>MATLAB</code>最重要的一种内建数据类型，而数组运算就是定义这种数据结构的方法。</p><h4 id="👁数组的创建和操作"><a href="#👁数组的创建和操作" class="headerlink" title="👁数组的创建和操作"></a>👁数组的创建和操作</h4><p>在<code>MATLAB</code>中一般使用方括号“<code>[ ]</code>”、逗号“<code>,</code>”、空格号和分号“<code>;</code>”来创建数组，数组中同一行的元素使用<strong>逗号或空格</strong>进行分隔，不同行之间用<strong>分号</strong>进行分隔。</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% 空数组</span></span><br><span class="line">A=[]</span><br><span class="line"><span class="comment">% 行向量</span></span><br><span class="line">B=[<span class="number">6</span> <span class="number">5</span> <span class="number">4</span> <span class="number">3</span> <span class="number">2</span> <span class="number">1</span>]</span><br><span class="line">C=[<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line"><span class="comment">% 列向量</span></span><br><span class="line">D=[<span class="number">6</span>;<span class="number">5</span>;<span class="number">4</span>;<span class="number">3</span>;<span class="number">2</span>;<span class="number">1</span>]</span><br><span class="line"><span class="comment">% 转置</span></span><br><span class="line">E=B&#x27;</span><br><span class="line"></span><br><span class="line">F=[<span class="number">6</span> <span class="number">5</span> <span class="number">4</span> <span class="number">3</span> <span class="number">2</span> <span class="number">1</span>]</span><br><span class="line"><span class="comment">% 访问数组第 3 个到最后一个元素</span></span><br><span class="line">a3=F(<span class="number">3</span>:<span class="keyword">end</span>)</span><br><span class="line"><span class="comment">% 数组元素反序输出</span></span><br><span class="line">a4=F(<span class="keyword">end</span>:<span class="number">-1</span>:<span class="number">1</span>) </span><br><span class="line"><span class="comment">% 访问数组第1个及第6个元素</span></span><br><span class="line">a5=F([<span class="number">1</span> <span class="number">6</span>])</span><br></pre></td></tr></table></figure><p>（1）通过冒号创建一维数组</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% A是创建一维数组的第一个变量，step是每次递增或递减的数值，直到最后一个元素和B的差的绝对值小于等于step的绝对值为止。</span></span><br><span class="line">X=A:step:B</span><br><span class="line"></span><br><span class="line">A=<span class="number">2</span>:<span class="number">6</span> </span><br><span class="line">B=<span class="number">2.1</span>:<span class="number">1.5</span>:<span class="number">6</span> </span><br><span class="line">C=<span class="number">2.1</span>:<span class="number">-1.5</span>:<span class="number">-6</span> </span><br><span class="line">D=<span class="number">2.1</span>:<span class="number">-1.5</span>:<span class="number">6</span> </span><br><span class="line"><span class="comment">% 输出结果</span></span><br><span class="line">A = <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> </span><br><span class="line">B = <span class="number">2.1000</span> <span class="number">3.6000</span> <span class="number">5.1000</span> </span><br><span class="line">C = <span class="number">2.1000</span> <span class="number">0.6000</span> <span class="number">-0.9000</span> <span class="number">-2.4000</span> <span class="number">-3.9000</span> <span class="number">-5.4000</span> </span><br><span class="line">D = Empty matrix: <span class="number">1</span>-by<span class="number">-0</span> </span><br></pre></td></tr></table></figure><p>（2）通过函数创建一维数组</p><p><code>logspace()</code>函数创建一维数组；<code>linspace()</code>函数创建一维数组</p><h4 id="👁数组的常见运算"><a href="#👁数组的常见运算" class="headerlink" title="👁数组的常见运算"></a>👁数组的常见运算</h4><p>（1）数组的算术运算</p><p>数组的运算是从数组的单个元素出发，针对每个元素进行的运算。在<code>MATLAB</code>中，一维数组的基本运算包括加、减、乘、左除、右除和乘方。</p><p>数组的加减运算：通过格式A+B或A-B可实现数组的加减运算。但是运算规则要求数组A和B的<strong>维数相同</strong>。</p><p>数组的乘除运算：通过格式“<code>.*</code>”或“<code>./</code>”可实现数组的乘除运算。但是运算规则要求数组A和B的<strong>维数相同</strong>。</p><blockquote><p>乘法：数组A和B的维数相同，运算为数组对应元素相乘，计算结果与A和B是相同维数的数组。<br>除法：数组A和B的维数相同，运算为数组对应元素相除，计算结果与A和B是相同维数的数组。<br>右除和左除的关系：A.&#x2F;B&#x3D;B.\A，其中A是被除数，B是除数。</p></blockquote><p>乘方格式“<code>.^</code>”实现数组的乘方运算。数组的乘方运算包括：数组间的乘方运算、数组与某个具体数值的乘方运算，以及常数与数组的乘方运算。</p><p>函数<code>dot()</code>可实现数组的点积运算，但是运算规则要求数组A和B的维数相同，其调用格式如下</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">C = <span class="built_in">dot</span>(A,B)</span><br><span class="line">C = <span class="built_in">dot</span>(A,B,dim)</span><br><span class="line"></span><br><span class="line">clear all</span><br><span class="line">A=[<span class="number">1</span> <span class="number">5</span> <span class="number">6</span> <span class="number">8</span> <span class="number">9</span> <span class="number">6</span>]</span><br><span class="line">B=[<span class="number">9</span> <span class="number">5</span> <span class="number">6</span> <span class="number">2</span> <span class="number">4</span> <span class="number">0</span>]</span><br><span class="line"><span class="comment">% 数组的点积</span></span><br><span class="line">C=<span class="built_in">dot</span>(A,B)</span><br><span class="line"><span class="comment">% 数组元素的乘积之和</span></span><br><span class="line">D=sum(A.*B)</span><br><span class="line"></span><br><span class="line"><span class="comment">% 输出结果</span></span><br><span class="line">A = <span class="number">1</span> <span class="number">5</span> <span class="number">6</span> <span class="number">8</span> <span class="number">9</span> <span class="number">6</span> </span><br><span class="line">B = <span class="number">9</span> <span class="number">5</span> <span class="number">6</span> <span class="number">2</span> <span class="number">4</span> <span class="number">0</span> </span><br><span class="line">C = <span class="number">122</span> </span><br><span class="line">D = <span class="number">122</span> </span><br></pre></td></tr></table></figure><p>（2）数组的关系运算</p><p>在<code>MATLAB</code>中提供了6种数组关系运算符，即<code>&lt;</code>（小于）、<code>&lt;=</code>（小于等于）、<code>&gt;</code>（大于）、<code>&gt;=</code>（大于等于）、<code>==</code>（恒等于）、<code>~=</code>（不等于）。关系运算的运算法则如下：</p><ul><li>当两个比较量是标量时，直接比较两个数的大小。若关系成立，则返回的结果为1，否则为0。</li><li>当两个比较量是维数相等的数组时，逐一比较两个数组相同位置的元素，并给出比较结果。最终的关系运算结果是一个与参与比较的数组维数相同的数组，其组成元素为0或1。</li></ul><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clear all</span><br><span class="line">A=[<span class="number">1</span> <span class="number">5</span> <span class="number">6</span> <span class="number">8</span> <span class="number">9</span> <span class="number">6</span>]</span><br><span class="line">B=[<span class="number">9</span> <span class="number">5</span> <span class="number">6</span> <span class="number">2</span> <span class="number">4</span> <span class="number">0</span>]</span><br><span class="line"><span class="comment">% 数组与常数比较，小于</span></span><br><span class="line">C=A&lt;<span class="number">6</span></span><br><span class="line"><span class="comment">% 数组与常数比较，大于等于</span></span><br><span class="line">D=A&gt;=<span class="number">6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 输出结果</span></span><br><span class="line">A = <span class="number">1</span> <span class="number">5</span> <span class="number">6</span> <span class="number">8</span> <span class="number">9</span> <span class="number">6</span> </span><br><span class="line">B = <span class="number">9</span> <span class="number">5</span> <span class="number">6</span> <span class="number">2</span> <span class="number">4</span> <span class="number">0</span> </span><br><span class="line">C = <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> </span><br><span class="line">D = <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> </span><br></pre></td></tr></table></figure><p>（3）数组的逻辑运算</p><p>在<code>MATLAB</code>中数组提供了3种数组逻辑运算符，即<code>&amp;</code>（与）、<code>|</code>（或）和<code>~</code>（非）。逻辑运算的运算法则如下：</p><ul><li>如果是非零元素则为真，用1表示；如果是零元素则为假，用0表示。</li><li>当两个比较量是维数相等的数组时，逐一比较两个数组相同位置的元素，并给出比较结果。最终的关系运算结果是一个与参与比较的数组维数相同的数组，其组成元素为0或1。</li><li>与运算（a&amp;b）时，a、b全为非零，则为真，运算结果为1；或运算（a|b）时，只要a、b有一个为非零，则运算结果为1；非运算（~a）时，若a为0，运算结果为1，a为非零，运算结果为0。</li></ul><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clear all</span><br><span class="line">A=[<span class="number">1</span> <span class="number">5</span> <span class="number">6</span> <span class="number">8</span> <span class="number">9</span> <span class="number">6</span>]</span><br><span class="line">B=[<span class="number">9</span> <span class="number">5</span> <span class="number">6</span> <span class="number">2</span> <span class="number">4</span> <span class="number">0</span>]</span><br><span class="line"><span class="comment">% 与、或、非</span></span><br><span class="line">C=A&amp;B</span><br><span class="line">D=A|B</span><br><span class="line">E=~B</span><br><span class="line"></span><br><span class="line"><span class="comment">% 输出结果</span></span><br><span class="line">A = <span class="number">1</span> <span class="number">5</span> <span class="number">6</span> <span class="number">8</span> <span class="number">9</span> <span class="number">6</span> </span><br><span class="line">B = <span class="number">9</span> <span class="number">5</span> <span class="number">6</span> <span class="number">2</span> <span class="number">4</span> <span class="number">0</span> </span><br><span class="line">C = <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> </span><br><span class="line">D = <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> </span><br><span class="line">E = <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> </span><br></pre></td></tr></table></figure><h3 id="👀矩阵操作"><a href="#👀矩阵操作" class="headerlink" title="👀矩阵操作"></a>👀矩阵操作</h3><h4 id="👁创建矩阵"><a href="#👁创建矩阵" class="headerlink" title="👁创建矩阵"></a>👁创建矩阵</h4><p>零矩阵、单位矩阵和全1矩阵等特殊矩阵，<code>MATLAB</code>中提供了函数生成试验矩阵。还有一些其他特殊矩阵的指令集。</p><p>希尔伯特（Hilbert）矩阵，它是一个条件数差的矩阵，所以将它用来作为试验矩阵。</p><blockquote><p><code>hilb(n)</code>、<code>invhilb(n)</code></p></blockquote><p>托普利兹（Toeplitz）矩阵，它由两个向量定义，一个行向量和一个列向量。对称的托普利兹矩阵由单一向量来定义。</p><blockquote><p><code>toeplitz(k,r)</code>、<code>toeplitz(c)</code></p></blockquote><p>0～1间均匀分布的随机矩阵，产生 0～1 间均匀分布的随机矩阵。</p><blockquote><p><code>rand(n)</code>、<code>rand(m,n)</code>、<code>rand(m,n,p,...)</code>、<code>rand(size(A))</code></p></blockquote><p>标准正态分布随机矩阵，产生均值为 0、方差为 1 的随机矩阵。</p><blockquote><p><code>randn(n)</code>、<code>randn(m,n)</code>、<code>randn(m,n,p,...)</code>、<code>randn([m,n,p,...])</code>、<code>randn(size(A))</code></p></blockquote><p>魔方矩阵，每行、列和两条对角线上的元素和相等。</p><blockquote><p><code>magic(n)</code></p></blockquote><p>帕斯卡矩阵。</p><blockquote><p><code>pascal(n)</code>、<code>pascal(n,1)</code>、<code>pascal(n,2)</code></p></blockquote><p>范德蒙（Vandermonde）矩阵。</p><blockquote><p><code>vander(v)</code>，生成范德蒙矩阵，矩阵的列是向量v的幂，输入向量可以使行向量或列向量。</p></blockquote><h4 id="👁改变矩阵大小"><a href="#👁改变矩阵大小" class="headerlink" title="👁改变矩阵大小"></a>👁改变矩阵大小</h4><p>（1）矩阵的合并</p><p>矩阵的合并就是把两个或者两个以上的矩阵数据连接起来得到一个新的矩阵。</p><blockquote><p>矩阵构造符<code>[]</code>不仅可用于构造矩阵，同时还可以作为一个矩阵合并操作符。表达式<code>C=[A B]</code>在水平方向合并矩阵A和B，而表达式<code>C=[A;B]</code>在竖直方向合并矩阵A和B。</p><p>除了使用矩阵合并符“<code>[]</code>”来合并矩阵，还可以使用<strong>矩阵合并函数</strong>来合并矩阵。</p></blockquote><p>可以用矩阵合并符来构造任意大小的矩阵。不过需要注意的是，在矩阵合并的过程中一定要保持矩阵的形状是方形，否则矩阵合并将无法进行。</p><p>（2）矩阵行列的删除</p><p>要删除矩阵的某一行或者某一列，只要把该行或者该列赋予一个空矩阵“<code>[]</code>”即可。</p><h4 id="👁重构矩阵"><a href="#👁重构矩阵" class="headerlink" title="👁重构矩阵"></a>👁重构矩阵</h4><p>矩阵重构的两个比较重要的运算是转置和共轭转置，在<code>MATLAB</code>中，用在函数后面加撇号“<code>&#39;</code>”来表示。在线性代数的专业书籍中，这种运算经常用<code>*</code>和<code>H</code>表示。</p><p>如果A是一个实数矩阵，那么它被转置时，第1行变成第1列，第2行变成第2列……以此类推，一个m×n矩阵变为一个n×m矩阵。如果矩阵是方阵，那么这个矩阵在主对角线上反映出来。如果矩阵A的元素a<del>ij</del>是复数，那么所有元素也是共轭的。如果仅希望转置，在撇号“<code>&#39;</code>”之前输入一点，即成为“<code>.&#39;</code>”，A.’表示转置，其结果与conj(A’)相同。如果A是实数矩阵，那么A’与A.’相同。</p><h3 id="👀矩阵元素的运算"><a href="#👀矩阵元素的运算" class="headerlink" title="👀矩阵元素的运算"></a>👀矩阵元素的运算</h3><p>矩阵的加、减、乘、除、比较运算和逻辑运算等代数运算是<code>MATLAB</code>数值计算最基础的部分。</p><p><strong>矩阵的加减运算</strong>。进行矩阵加法、减法运算的前提是参与运算的两个矩阵或多个矩阵必须具有相同的行数和列数，即A、B、C等多个矩阵均为m×n矩阵；或者其中有一个或多个矩阵为标量。</p><p><strong>矩阵的乘法运算</strong>。<code>MATLAB</code>中矩阵的乘法运算包括两种：数与矩阵的乘法；矩阵与矩阵的乘法。</p><ul><li>数与矩阵的乘法：由于单个数在<code>MATLAB</code>中是以标量来存储的，因此数与矩阵的乘法也可以称为标量与矩<br>阵的乘法。</li><li>矩阵与矩阵的乘法：两个矩阵的乘法必须满足被乘矩阵的列数与乘矩阵的行数相等。</li></ul><p><strong>矩阵的除法运算</strong>。矩阵的除法是乘法的逆运算，分为左除和右除两种，分别用运算符号“<code>\</code>”和“<code>/</code>”表示。</p><ul><li>A\B表示矩阵A的逆乘以B，A&#x2F;B表示矩阵A乘以矩阵B的逆。除非矩阵A和矩阵B相同，否则A&#x2F;B和A\B是不等价的。</li><li>对于一般的二维矩阵A和B，当进行A\B运算时，要求A的行数与B的行数相等；当进行A&#x2F;B运算时，要求A的列数与B的列数相等。</li></ul><p><strong>矩阵的幂运算</strong>。当矩阵A为<code>方阵</code>时，可进行矩阵的幂运算，使用运算符号“<code>^</code>”表示幂运算。</p><p><strong>矩阵元素的查找</strong>。函数<code>find()</code>的作用是进行矩阵元素的查找，它通常与关系函数和逻辑运算相结合。其调用格式如下：</p><ul><li><code>ind = find(X)</code>：该函数查找矩阵X中的非零元素，函数返回这些元素的单下标。</li><li><code>[row,col] = find(X, ...)</code>：该函数查找矩阵X中的非零元素，函数返回这些元素的双下标i和j。</li></ul><p><strong>矩阵元素的排序</strong>。函数<code>sort()</code>的作用是按照升序排序，排序后的矩阵和原矩阵的维数相同。其调用格式如下：</p><ul><li><code>B = sort(A)</code>：该函数对矩阵A进行升序排列。A可为矩阵或向量。</li><li><code>B = sort(A,dim)</code>：该函数对矩阵 A 进行升序排列，并将结果返回在给定的维数dim上按照升序排列。当dim&#x3D;1时，按照列进行排序；当dim&#x3D;2时，按照行进行排序。</li><li><code>B = sort(...,mode)</code>：该函数对矩阵 A 进行排序，mode可指定排序的方式。ascend指定按升序排列，为默认值；descend指定按降序排列。</li></ul><p><strong>矩阵元素的求和</strong>。函数<code>sum()</code>和<code>cumsum()</code>的作用是对矩阵的元素求和。函数<code>cumsum()</code>的调用格式与<code>sum()</code>类似，不同的是其返回值为矩阵。其调用格式如下：</p><ul><li><code>B = sum(A)</code>：该函数对矩阵A的元素求和，返回由矩阵A各列元素的和组成的向量。通过<code>sum(sum())</code>可求出矩阵所有元素的和。</li><li><code>B = sum(A,dim)</code>：该函数返回在给定的维数dim上元素的和。当dim&#x3D;1时，计算矩阵A各列元素的和；当dim&#x3D;2时，计算矩阵A各行元素的和。</li><li><code>B = cumsum(A)</code>。</li><li><code>B = cumsum(A,dim)</code>。</li></ul><p><strong>矩阵元素的求积</strong>。函数<code>prod()</code>和<code>cumprod()</code>的作用是对矩阵的元素求积。函数<code>cumprod()</code>的调用格式与<code>prod()</code>类似，不同的是其返回值为矩阵。其调用格式如下：</p><ul><li><code>B = prod(A)</code>：该函数对矩阵A的元素求积，返回由矩阵A各列元素的积组成的向量。</li><li><code>B = prod(A,dim)</code>：该函数返回在给定的维数dim上元素的积。当dim&#x3D;1时，计算矩阵A各列元素的积；当dim&#x3D;2时，计算矩阵A各行元素的积。</li><li><code>B = cumprod(A)</code>。</li><li><code>B = cumprod(A,dim)</code>。</li></ul><p><strong>矩阵元素的差分</strong>。函数<code>diff()</code>的作用是计算矩阵的差分。其调用格式如下：</p><ul><li><code>Y = diff(X)</code>：计算矩阵各列元素的差分。</li><li><code>Y = diff(X,n)</code>：计算矩阵各列元素的n阶差分。</li><li><code>Y = diff(X,n,dim)</code>：计算矩阵在给定的维数dim上元素的n阶差分。当dim&#x3D;1时，计算矩阵各列元素的差分；当dim&#x3D;2时，计算矩阵各行元素的差分。当参数n≥size(x,dim)时，函数的返回值是空矩阵。</li></ul><h3 id="👀矩阵运算"><a href="#👀矩阵运算" class="headerlink" title="👀矩阵运算"></a>👀矩阵运算</h3><p>矩阵运算是线性代数中极其重要的部分，包括矩阵分析、特征值求解和奇异值等。</p><p>（1）矩阵分析</p><table><thead><tr><th>函数名</th><th>功能描述</th></tr></thead><tbody><tr><td><code>norm</code></td><td>求矩阵或者向量的范数</td></tr><tr><td><code>normest</code></td><td>估计矩阵的 2 阶范数</td></tr><tr><td><code>rank</code></td><td>矩阵的秩，即求对角元素的和</td></tr><tr><td><code>det</code></td><td>矩阵的行列式</td></tr><tr><td><code>trace</code></td><td>矩阵的迹</td></tr><tr><td><code>null</code></td><td>0 空间</td></tr><tr><td><code>orth</code></td><td>正交化空间</td></tr><tr><td><code>rref</code></td><td>约化行阶梯形式</td></tr><tr><td><code>subspace</code></td><td>求两个矩阵空间的角度</td></tr></tbody></table><p>（2）矩阵分解</p><p>矩阵分解是把一个矩阵分解成几个“较简单”的矩阵连乘的形式。</p><table><thead><tr><th>函数</th><th>功能描述</th></tr></thead><tbody><tr><td><code>chol</code></td><td>Cholesky分解</td></tr><tr><td><code>cholinc</code></td><td>稀疏矩阵的不完全Cholesky分解</td></tr><tr><td><code>lu</code></td><td>矩阵LU分解（高斯消去法分解）</td></tr><tr><td><code>luinc</code></td><td>稀疏矩阵的不完全LU分解</td></tr><tr><td><code>qr</code></td><td>正交三角分解</td></tr><tr><td><code>svd</code></td><td>奇异值分解</td></tr><tr><td><code>gsvd</code></td><td>一般奇异值分解</td></tr><tr><td><code>schur</code></td><td>舒尔分解</td></tr></tbody></table><p>（3）特征值和特征向量</p><p><code>MATLAB</code>中的命令计算特征值和特征向量十分方便，可以得到不同的子结果和分解，这在线性代数学习中十分有意义。</p><h3 id="👀稀疏矩阵"><a href="#👀稀疏矩阵" class="headerlink" title="👀稀疏矩阵"></a>👀稀疏矩阵</h3><p>在许多问题中提到了含有大量0元素的矩阵，这样的矩阵称为稀疏矩阵。为了节省存储空间和计算时间，<code>MATLAB</code>考虑到矩阵的稀疏性，在对它进行运算时有特殊的命令。稀疏矩阵大部分的元素是0，因此只需存储非零元素的下标和元素值，这种特殊的存储方式可以节省大量的存储空间和不必要的运算。</p><h4 id="👁稀疏矩阵的存储方式"><a href="#👁稀疏矩阵的存储方式" class="headerlink" title="👁稀疏矩阵的存储方式"></a>👁稀疏矩阵的存储方式</h4><p>对于稀疏矩阵，<code>MATLAB</code>仅存储矩阵所有的非零元素的值及其位置（行号和列号）。显然，这对于具有大量0元素的稀疏矩阵来说是十分有效的。</p><h4 id="👁稀疏矩阵的生成"><a href="#👁稀疏矩阵的生成" class="headerlink" title="👁稀疏矩阵的生成"></a>👁稀疏矩阵的生成</h4><p><code>MATLAB</code>提供了多种创建稀疏矩阵的方法。</p><ul><li>利用<code>sparse</code>函数从满矩阵转换得到稀疏矩阵。</li><li>利用一些特定函数创建包括单位稀疏矩阵在内的特殊稀疏矩阵。</li></ul><p>（1）利用<code>sparse</code>函数建立一般的稀疏矩阵</p><table><thead><tr><th>函数名称</th><th>表示意义</th></tr></thead><tbody><tr><td><code>sparse(A)</code></td><td>由非零元素和下标建立稀疏矩阵A。如果A已是一个稀疏矩阵，则返回A本身</td></tr><tr><td><code>sparse(m,n)</code></td><td>生成一个m×n的所有元素都是0的稀疏矩阵</td></tr><tr><td><code>sparse(u,v,a)</code></td><td>生成大小为max(u)×max(v)的稀疏矩阵。其中u和v是整数向量，a为实数或复数向量</td></tr><tr><td><code>sparse(u,v,a,m,n)</code></td><td>生成一个m×n的稀疏矩阵，(ui,vi)对应值 ai。向量u，v和a长度必须相同</td></tr><tr><td><code>spconvert(D)</code></td><td>生成一个稀疏矩阵。D共有3列，第1列为行下标，第2列为列下标，最后一列为元素值</td></tr><tr><td><code>full(S)</code></td><td>将稀疏矩阵S转换成一个满矩阵</td></tr></tbody></table><p><code>MATLAB</code>提供了<code>full()</code>函数把稀疏矩阵转换为满矩阵。<code>full()</code>函数的调用格式如下：</p><ul><li><code>A = full(S)</code>：S为稀疏矩阵。</li></ul><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">A = [<span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>;<span class="number">0</span> <span class="number">5</span> <span class="number">0</span> <span class="number">0</span>;<span class="number">2</span> <span class="number">0</span> <span class="number">0</span> <span class="number">7</span>] </span><br><span class="line">S = sparse(A)</span><br><span class="line">B = full(S) </span><br><span class="line"><span class="comment">% 输出结果</span></span><br><span class="line">S = </span><br><span class="line">     (<span class="number">1</span>,<span class="number">1</span>) <span class="number">1</span> </span><br><span class="line">     (<span class="number">3</span>,<span class="number">1</span>) <span class="number">2</span> </span><br><span class="line">     (<span class="number">2</span>,<span class="number">2</span>) <span class="number">5</span> </span><br><span class="line">     (<span class="number">3</span>,<span class="number">4</span>) <span class="number">7</span> </span><br><span class="line">B = </span><br><span class="line">     <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> </span><br><span class="line">     <span class="number">0</span> <span class="number">5</span> <span class="number">0</span> <span class="number">0</span> </span><br><span class="line">     <span class="number">2</span> <span class="number">0</span> <span class="number">0</span> <span class="number">7</span> </span><br></pre></td></tr></table></figure><p>查看稀疏矩阵中非零的信息示例：</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clear all </span><br><span class="line">a=[<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span>;<span class="number">0</span> <span class="number">0</span> <span class="number">8</span> <span class="number">0</span>;<span class="number">4</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>;<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]; </span><br><span class="line">S=sparse(a); <span class="comment">% 创建稀疏矩阵</span></span><br><span class="line">whos; </span><br><span class="line">n1=nnz(S) <span class="comment">% 查看非零元素的个数</span></span><br><span class="line">n2=nonzeros(S) <span class="comment">% 非零元素的值</span></span><br><span class="line">n3=nzmax(S) <span class="comment">% 查看稀疏矩阵的存储空间</span></span><br><span class="line"><span class="comment">% spy()函数对稀疏矩阵中非零元素的分布进行图形化显示，</span></span><br><span class="line">spy(S) </span><br><span class="line"><span class="comment">% 采用nnz(S)/prod(size(S))计算稀疏矩阵的非零元素密度</span></span><br><span class="line">n4=nnz(S)/prod(<span class="built_in">size</span>(S)) </span><br><span class="line"><span class="comment">% 输出结果</span></span><br><span class="line">Name      Size            Bytes  Class     Attributes</span><br><span class="line"> S         <span class="number">4</span>x4                <span class="number">88</span>  double    sparse    </span><br><span class="line"> a         <span class="number">4</span>x4               <span class="number">128</span>  double </span><br><span class="line">n1 = <span class="number">3</span> </span><br><span class="line">n2 = </span><br><span class="line">     <span class="number">4</span> </span><br><span class="line">     <span class="number">8</span> </span><br><span class="line">     <span class="number">1</span> </span><br><span class="line">n3 = <span class="number">3</span> </span><br><span class="line">n4 = <span class="number">0.1875</span> </span><br></pre></td></tr></table></figure><p>（2）利用特定函数建立稀疏矩阵</p><table><thead><tr><th>函数</th><th>调用格式</th><th>描述</th></tr></thead><tbody><tr><td><code>speye</code></td><td><code>S = speye(m,n)</code></td><td>创建单位稀疏矩阵</td></tr><tr><td><code>spones</code></td><td><code>S = spones(X)</code></td><td>创建非零元素为1的稀疏矩阵</td></tr><tr><td><code>sprand</code></td><td><code>S = sprand(X)</code></td><td>创建非零元素为均匀分布的随机数的稀疏矩阵</td></tr><tr><td><code>sprandn</code></td><td><code>S = sprandn(X)</code></td><td>创建非零元素为高斯分布的随机数的稀疏矩阵</td></tr><tr><td><code>sprandsym</code></td><td><code>S = sprandsym(X)</code></td><td>创建非零元素为高斯分布的随机数的对称稀疏矩阵</td></tr><tr><td><code>spdiags</code></td><td><code>S = spdiags(X)</code></td><td>创建对角稀疏矩阵</td></tr><tr><td><code>spalloc</code></td><td><code>S = spalloc(X)</code></td><td>为稀疏矩阵分配空间</td></tr></tbody></table><h4 id="👁稀疏矩阵的运算"><a href="#👁稀疏矩阵的运算" class="headerlink" title="👁稀疏矩阵的运算"></a>👁稀疏矩阵的运算</h4><ul><li>满矩阵的四则运算对稀疏矩阵同样有效，但是返回结果有可能是稀疏矩阵或者满矩阵。</li><li>对于单个稀疏矩阵的输入，大部分函数输出的结果都是稀疏矩阵，有部分函数输出的结果是满矩阵。对于多个矩阵的输入，如果其中至少有一个矩阵是满矩阵，那么大部分函数的输出结果是满矩阵。</li><li>对于矩阵的加、减、乘、除运算，只要其中有一个是满矩阵，则输出的结果都是满矩阵。</li><li>稀疏矩阵的数乘为稀疏矩阵；稀疏矩阵的幂为稀疏矩阵。</li></ul><p>笔者不才，请多交流！！！</p>]]></content>
      
      
      <categories>
          
          <category> Matlab </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Matlab </tag>
            
            <tag> 科学计算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IDL语法基础（01）</title>
      <link href="/2022/10/30/IDL-Basic01/"/>
      <url>/2022/10/30/IDL-Basic01/</url>
      
        <content type="html"><![CDATA[<h2 id="⛄IDL简介"><a href="#⛄IDL简介" class="headerlink" title="⛄IDL简介"></a>⛄<code>IDL</code>简介</h2><p>交互式数据语言——<code>IDL</code>（<code>Interactive Data Language</code>）是进行应用程序开发、科学数据分析与可视化表达的理想工具。<code>IDL</code>是基于矩阵运算的计算机语言，它语法简单，自带大量的功能函数，用很少的几行代码就能实现其它语言很难实现的功能。利用IDL可以快速地进行科学数据读写、三维数据可视化、数值运算和三维图形建模等。<code>IDL</code>可以应用在地球科学（包括气象、水文、海洋、土壤和地质等），医学影像、图像处理、<code>GIS</code>系统、软件开发、测试、天文、航空航天、信息处理、数学统计与分析以及环境工程等领域。<code>IDL</code>的优势：</p><ul><li>数据访问 —— 灵活的数据输入、输出方式。在科学研究中，将会使用大量不同格式的数据。IDL 基本上支持各种数据格式，并提供了大量的数据读写工具，免除数据读写的烦恼，可以将更多的精力投入到数据分析。</li><li>数据分析 —— 强大的图像处理、信号处理和数据统计分析能力。<code>IDL</code> 集成了完善的数据分析、数据统计、图像处理和信号处理软件包。项目应用 <code>IDL</code> 可以节省大量时间。使用传统的 <code>C</code> 或者 <code>FORTRAN</code> 语言需要数天或数周的项目，使用 <code>IDL</code> 可以在数小时内完成。</li><li>数据可视化 —— 先进的图形技术和强大的可视化能力。从简单的二维绘图、三维绘图、体数据可视化、图像显示、动画显示等，到利用 <code>OpenGL</code>硬件加速功能进行交互式的三维图形浏览，以及支持多处理器快速进行体数据渲染，使用 <code>IDL</code>可以轻松获得丰富的可视化效果。从直接图形法到对象图形法，再到快速可视化函数，<code>IDL</code> 提供了丰富的可视化过程和函数供用户调用，使用少量代码即可实现复杂的可视化结果。</li><li>软件开发 —— 跨平台支持、全新且统一的开发环境、有效的数据管理手段。</li><li>集成 —— 灵活的外部语言接口。<code>IDL</code> 是一个灵活的、可扩展的用于可视化、分析和开发的工具，能够轻松的与其他的软件工具集成。<code>IDL</code> 能够将其他编程语言的代码和函数导入，也可以将 <code>IDL</code> 实现的功能集成到其他语言编写的应用程序中去。</li><li>程序共享 —— 灵活多样的程序发布方式和轻松的成果共享。</li></ul><p><code>IDL</code>的帮助提供了详细的使用说明和函数功能描述，学会使用帮助是快速入门和解决问题的最佳途径。帮助的启动方式有以下三种：</p><ul><li>点击主菜单[帮助]下的[选中项目帮助]和[帮助内容]功能菜单；</li><li>工作台编辑代码时按 <code>F1</code> 或选择一个函数后按 <code>F1</code>，则启动帮助；</li><li>命令行中输入<code>?</code>回车后启动帮助。</li></ul><blockquote><p>注意事项：</p><p>（1）<code>IDL</code>不区分大小写；</p><p>（2）分号”;”表示注释内容的开始；</p><p>（3）符号”<code>$</code>“，续行符；符号”<code>&amp;</code>“，续命令符；</p><p>（4）创建<code>IDL</code>变量不需要事先声明，直接赋值，并且变量随时可以进行数据类型和维数的动态改变；</p><p>（5）科学计数法：<code>a = 6.63e-34，b = 2.998e8</code></p><p>（6）<code>help</code>命令可以帮助用户跟踪变量类型和大小。对于标量，显示变量的名称、类型和值；对于数组型变量，显示变量名称、类型和大小。</p></blockquote><h2 id="⛄IDL语法基础"><a href="#⛄IDL语法基础" class="headerlink" title="⛄IDL语法基础"></a>⛄<code>IDL</code>语法基础</h2><h3 id="👀数据类型"><a href="#👀数据类型" class="headerlink" title="👀数据类型"></a>👀数据类型</h3><p><code>IDL</code>中有17种基本数据类型。基本数据类型的名称、类型代码、字节大小、创建方式和范围，以及类型转换等。</p><table><thead><tr><th>数据类型</th><th align="center">代码</th><th align="center">字节数</th><th align="center">范围</th><th>创建变量</th><th>类型转换</th></tr></thead><tbody><tr><td>字节型</td><td align="center">1</td><td align="center">1</td><td align="center"><code>0~255</code></td><td><code>Var=0B</code></td><td><code>byte()</code></td></tr><tr><td>16位有符号整型</td><td align="center">2</td><td align="center">2</td><td align="center"><code>-32768~32767</code></td><td><code>Var=0</code></td><td><code>fix()</code></td></tr><tr><td>32位有符号长整型</td><td align="center">3</td><td align="center">4</td><td align="center"><code>-2^31~2^31-1</code></td><td><code>Var=0L</code></td><td><code>long()</code></td></tr><tr><td>64位有符号整型</td><td align="center">14</td><td align="center">8</td><td align="center"><code>-2^63~2^63-1</code></td><td><code>Var=0LL</code></td><td><code>long64()</code></td></tr><tr><td>16位无符号整型</td><td align="center">12</td><td align="center">2</td><td align="center"><code>0~65535</code></td><td><code>Var=0U</code></td><td><code>uint()</code></td></tr><tr><td>32位无符号长整型</td><td align="center">13</td><td align="center">4</td><td align="center"><code>0~2^32-1</code></td><td><code>Var=0UL</code></td><td><code>ulong()</code></td></tr><tr><td>64位无符号整型</td><td align="center">15</td><td align="center">8</td><td align="center"><code>0~2^64-1</code></td><td><code>Var==0ULL</code></td><td><code>ulong64()</code></td></tr><tr><td>浮点型</td><td align="center">4</td><td align="center">4</td><td align="center"><code>-10^38~2^38</code></td><td><code>Var=0.0</code></td><td><code>float()</code></td></tr><tr><td>双精度浮点型</td><td align="center">5</td><td align="center">8</td><td align="center"><code>-10^308~2^308</code></td><td><code>Var=0.0D</code></td><td><code>double()</code></td></tr><tr><td>复数</td><td align="center">6</td><td align="center">8</td><td align="center"><code>-10^38~2^38</code></td><td><code>Var=Complex(0.0,0.0)</code></td><td><code>complex()</code></td></tr><tr><td>双精度复数</td><td align="center">9</td><td align="center">16</td><td align="center"><code>-10^308~2^308</code></td><td><code>Var=Dcomplex(0.0D,0.0D)</code></td><td><code>dcomplex()</code></td></tr><tr><td>字符串</td><td align="center">7</td><td align="center">0~32767</td><td align="center"><code>None</code></td><td><code>Var=&#39; &#39;或Var=&quot; &quot;</code></td><td><code>string()</code></td></tr><tr><td>结构体</td><td align="center">8</td><td align="center">复合类型</td><td align="center"><code>None</code></td><td><code>St1=&#123;&#125;</code></td><td></td></tr><tr><td>指针</td><td align="center">10</td><td align="center">4</td><td align="center"><code>None</code></td><td><code>Var=Ptr_New()</code></td><td></td></tr><tr><td>对象</td><td align="center">11</td><td align="center">4</td><td align="center"><code>None</code></td><td><code>Var=Obj_New()</code></td><td></td></tr><tr><td>链表</td><td align="center">11</td><td align="center">复合类型</td><td align="center"><code>None</code></td><td><code>Ls=List()</code></td><td></td></tr><tr><td>哈希表</td><td align="center">11</td><td align="center">复合类型</td><td align="center"><code>None</code></td><td><code>Hs=Hash()</code></td><td></td></tr></tbody></table><p>变量的类型代码通过<code>Size(var, /type)</code>来获得，如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IDL&gt; a=10</span><br><span class="line">IDL&gt; print,size(a,/type)</span><br><span class="line">           2</span><br><span class="line">IDL&gt; b=10.0</span><br><span class="line">IDL&gt; print,size(b,/type)</span><br><span class="line">           4</span><br><span class="line">IDL&gt; c=10L</span><br><span class="line">IDL&gt; print,size(c,/type)</span><br><span class="line">           3</span><br></pre></td></tr></table></figure><h3 id="👀常量和变量"><a href="#👀常量和变量" class="headerlink" title="👀常量和变量"></a>👀常量和变量</h3><p>常量。常量是不能修改的固定值，分为整型常量、浮点型常量、复数型常量和字符型常量等类型。</p><p>变量。<code>IDL</code> 中的变量分为局部变量和系统变量。在 <code>IDL</code> 程序中，二者的区别在于生命周期不一样，局部变量仅仅在所在的函数或过程中有效，而系统变量则在始终有效或某个程序的周期中有效。</p><p>（1）命名规则</p><p>变量名称的最大长度不超过 255 个字符，变量的首位只能是字母和下划线，中后部只能是字母、数字、下划线<code>_</code>和连接符<code>$</code>。如下正确：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">abc_3$dok_24_bit IDL_type variable _day_month_year</span><br><span class="line">如下错误：</span><br><span class="line">abc.cha one%file 4_lists $file</span><br></pre></td></tr></table></figure><p>变量相关函数 <code>IDL_VALIDNAME</code>。该函数用来检测字符串是否可以作为 <code>IDL</code> 下的变量，并能够将无效字符转换为“<code>_</code>”并返回变量。调用格式为 <code>IDL_VALIDNAME ( String [, /CONVERT_ALL] [, /CONVERT_SPACES])</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IDL&gt; print,IDL_VALIDNAME(&#x27;idl&#x27;)</span><br><span class="line">idl</span><br><span class="line">IDL&gt; print,IDL_VALIDNAME(&#x27;i d l&#x27;, /CONVERT_SPACES)</span><br><span class="line">i_d_l</span><br><span class="line">IDL&gt; print,IDL_VALIDNAME(&#x27;16ENVIIDL&#x27;, /CONVERT_ALL)</span><br><span class="line">_16ENVIIDL</span><br></pre></td></tr></table></figure><p>判断变量是否已经被定义，可以使用<code>N_Elements</code>函数，示例代码如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IDL&gt; a=1</span><br><span class="line">IDL&gt; ;变量已经定义        </span><br><span class="line">IDL&gt; print,N_Elements(a)</span><br><span class="line">           1</span><br><span class="line">IDL&gt; ;变量没有定义</span><br><span class="line">IDL&gt; print,N_Elements(aa)</span><br><span class="line">           0</span><br></pre></td></tr></table></figure><p>（2）变量类型转换</p><p>变量可以通过类型转换函数进行强制类型转换。</p><table><thead><tr><th>类型转换</th><th>函数名称</th><th>操作</th><th>结果</th></tr></thead><tbody><tr><td>字节型</td><td><code>BYTE</code></td><td>BYTE(1.2)</td><td>1B</td></tr><tr><td>整型</td><td><code>FIX</code></td><td>FIX(2.5)</td><td>2</td></tr><tr><td>无符号整型</td><td><code>UINT</code></td><td>UINT([5.5,-3])</td><td>5 65533</td></tr><tr><td>长整型</td><td><code>LONG</code></td><td>LONG(65538.5)</td><td>65538</td></tr><tr><td>无符号长整型</td><td><code>ULONG</code></td><td>ULONG([5.5,-3])</td><td>5 4294967293</td></tr><tr><td>64 位长整型</td><td><code>LONG64</code></td><td>LONG64([5.5,-3])</td><td>5 -3</td></tr><tr><td>无符号 64 位长整型</td><td><code>ULONG64</code></td><td>ULONG64([5.5,-3])</td><td>5 18446744073709551613</td></tr><tr><td>浮点型</td><td><code>FLOAT</code></td><td>FLOAT([5.5,-3])</td><td>5.50000 -3.00000</td></tr><tr><td>双精度类型</td><td><code>DOUBLE</code></td><td>DOUBLE([5.5,-3])</td><td>5.5000000 -3.0000000</td></tr><tr><td>复数类型</td><td><code>COMPLEX</code></td><td>COMPLEX(1, 2)</td><td>(1.00000, 2.00000)</td></tr><tr><td>双精度复数类型</td><td><code>DCOMPLEX</code></td><td>DCOMPLEX(1, 2)</td><td>(1.0000000, 2.0000000)</td></tr></tbody></table><p>在进行数据的转换中需要注意转换后的数据的界限问题。如下面操作：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IDL&gt; ;整型转换为浮点</span><br><span class="line">IDL&gt; print,float(1)</span><br><span class="line">      1.00000</span><br><span class="line"></span><br><span class="line">IDL&gt; ;浮点数取整</span><br><span class="line">IDL&gt; print,fix(1.3+1.8)</span><br><span class="line">       3</span><br><span class="line"> </span><br><span class="line">IDL&gt; ;fix还可以指定输出类型</span><br><span class="line">IDL&gt; help,fix(1.3,type=5)</span><br><span class="line">&lt;Expression&gt;    DOUBLE    =        1.3000000</span><br><span class="line"></span><br><span class="line">IDL&gt; ;出现这个错误是因为整型变量是16Bit的，最大值为32767，此种情况下用长整型强制转换函数long(a)。</span><br><span class="line">IDL&gt; a=33000</span><br><span class="line">IDL&gt; print,fix(a)</span><br><span class="line">  -32536</span><br><span class="line"></span><br><span class="line">IDL&gt; ;注意整型变量的运算，如除法运算</span><br><span class="line">IDL&gt; ;结果是1，原因在于参与运算的两个数字为整数，运算结果依然是整数。</span><br><span class="line">IDL&gt; result = 8/5</span><br><span class="line">IDL&gt; print,result</span><br><span class="line">IDL&gt; ;在运算时需要增加强制类型转换，将整形类型转换为浮点类型。</span><br><span class="line">IDL&gt; result = 8/float(5)</span><br><span class="line">IDL&gt; print,result</span><br><span class="line">      1.60000</span><br><span class="line">IDL&gt; result = 8*1.0/5</span><br><span class="line">IDL&gt; print,result</span><br><span class="line">      1.60000</span><br></pre></td></tr></table></figure><p>浮点类型和双精度类型的取整操作函数如下：</p><table><thead><tr><th>函数名称</th><th>功能</th><th>操作</th><th>结果</th></tr></thead><tbody><tr><td><code>floor</code></td><td>向下取整</td><td>floor(2.4)<br />floor(2.5)</td><td>2<br />2</td></tr><tr><td><code>ceil</code></td><td>向上取整</td><td>floor(2.4)<br />floor(2.5)</td><td>3<br />3</td></tr><tr><td><code>round</code></td><td>四舍五入</td><td>floor(2.4)<br />floor(2.5)</td><td>2<br />3</td></tr></tbody></table><p>（3）变量类型的动态性</p><p>在使用的过程中，可以随时修改变量类型，即变量类型具备动态性。该特性使得<code>IDL</code>在数学运算中将低精度类型提升为高精度类型，确保计算结果具备足够的精度。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IDL&gt; num=6</span><br><span class="line">IDL&gt; help,num</span><br><span class="line">NUM             INT       =        6</span><br><span class="line">IDL&gt; num=num*1.1</span><br><span class="line">IDL&gt; help,num</span><br><span class="line">NUM             FLOAT     =       6.60000</span><br></pre></td></tr></table></figure><p>（4）系统变量</p><p>系统变量分为预定义系统变量和自定义系统变量。预定义系统变量是<code>IDL</code>中预先定义的系统变量，一般情况下不允许修改，包括常数变量、图形变量、系统配置和错误处理；自定义系统变量是用户创建的系统变量。</p><h3 id="👀数组"><a href="#👀数组" class="headerlink" title="👀数组"></a>👀数组</h3><p>程序设计中，为了处理方便， 把具有相同类型的若干变量按有序的形式组织起来。这些按序排列的同类数据元素的集合称为数组。<code>IDL</code> 是面向矩阵的第四代语言，对数组的维数为0～8 维，在数组的处理时非常的灵活、高效。</p><blockquote><p>注意，IDL 中数组下标的顺序先是列标，后是行标。</p></blockquote><h4 id="👁创建数组"><a href="#👁创建数组" class="headerlink" title="👁创建数组"></a>👁创建数组</h4><p>（1）赋值创建</p><p>通过方括号<code>[]</code>赋值创建数组。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IDL&gt; arr = [1,2,3]</span><br><span class="line">IDL&gt; help,arr</span><br><span class="line">ARR             INT       = Array[3]</span><br><span class="line">IDL&gt; arr = [[1,2,3],[4,5,6]]</span><br><span class="line">IDL&gt; help,arr</span><br><span class="line">ARR             INT       = Array[3, 2]</span><br><span class="line">IDL&gt; arr</span><br><span class="line">       1       2       3</span><br><span class="line">       4       5       6</span><br></pre></td></tr></table></figure><p>（2）函数创建</p><p>利用数组创建函数可创建不同类型或维数的数组。</p><p><strong>通用函数</strong>，可以用 <code>IDL</code> 的通用函数进行全零数组或索引数组的创建。</p><table><thead><tr><th>数据类型</th><th>创建全0数组</th><th>创建索引数组</th></tr></thead><tbody><tr><td>字节型</td><td><code>bytArr()</code></td><td><code>bindgen()</code></td></tr><tr><td>16位有符号整型</td><td><code>intarr()</code></td><td><code>indgen()</code></td></tr><tr><td>32位有符号长整型</td><td><code>lonarr()</code></td><td><code>lindgen()</code></td></tr><tr><td>64位有符号整型</td><td><code>lon64arr()</code></td><td><code>l64indgen()</code></td></tr><tr><td>16位无符号整型</td><td><code>uintarr()</code></td><td><code>uindgen()</code></td></tr><tr><td>32位无符号长整型</td><td><code>ulongarr()</code></td><td><code>ulindgen()</code></td></tr><tr><td>64位无符号整型</td><td><code>ulon64arr()</code></td><td><code>ul64indgen()</code></td></tr><tr><td>浮点型</td><td><code>fltarr()</code></td><td><code>findgen()</code></td></tr><tr><td>双精度浮点型</td><td><code>dblarr()</code></td><td><code>dindgen()</code></td></tr><tr><td>复数</td><td><code>complexarr()</code></td><td><code>cindgen()</code></td></tr><tr><td>双精度复数</td><td><code>dcomplexarr()</code></td><td><code>dcindgen()</code></td></tr><tr><td>字符串</td><td><code>strarr()</code></td><td><code>sindgen()</code></td></tr><tr><td>指针</td><td><code>ptrarr()</code></td><td></td></tr><tr><td>对象</td><td><code>objarr()</code></td><td></td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IDL&gt; num = findgen(20)</span><br><span class="line">IDL&gt; num</span><br><span class="line">      0.00000000       1.0000000       2.0000000       3.0000000       4.0000000         5.0000000   6.0000000       7.0000000       8.0000000       9.0000000         10.000000       11.000000   12.000000       13.000000       14.000000               15.000000       16.000000       17.00000018.000000       19.000000</span><br></pre></td></tr></table></figure><p><strong>常规函数</strong>，<code>MAKE_ARRAY()</code>函数：是在程序运行过程中创建特定的数组。</p><p>调用格式为： <code>Result = MAKE_ARRAY ( [D1 [, ..., D8]] [, /INDEX] [, DIMENSION = vector] [, /NOZERO] [, SIZE=vector] [, TYPE=type_code] [, VALUE=value] )</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IDL&gt; a = Make_array(4,5,/Integer,Value=6)</span><br><span class="line">IDL&gt; a</span><br><span class="line">       6       6       6       6</span><br><span class="line">       6       6       6       6</span><br><span class="line">       6       6       6       6</span><br><span class="line">       6       6       6       6</span><br><span class="line">       6       6       6       6</span><br></pre></td></tr></table></figure><blockquote><p>创建特殊数组：<code>RANDOMU()</code>函数返回一个或多个均匀分布的浮点型数组，值在[0,1]之间。<code>RANDOMN()</code>函数返回一个或多个正态分布的浮点型数组，这些数的平均为零，标准偏差为 1 。</p></blockquote><h4 id="👁数组存储"><a href="#👁数组存储" class="headerlink" title="👁数组存储"></a>👁数组存储</h4><p><code>IDL</code>中的矢量和数组均是以先行后列顺序存储的(<code>IDL</code>最初是设计用来处理行扫描的卫星数据)，下标值的起始值是 0。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IDL&gt; array = indgen(4,3)</span><br><span class="line">IDL&gt; array</span><br><span class="line">       0       1       2       3</span><br><span class="line">       4       5       6       7</span><br><span class="line">       8       9      10      11</span><br></pre></td></tr></table></figure><h4 id="👁数组访问"><a href="#👁数组访问" class="headerlink" title="👁数组访问"></a>👁数组访问</h4><p>（1）下标方式</p><p>可以使用下标来存取该数组中的每一个元素。按照“<code>数组名[下标]</code>”或“<code>数组名（下标）</code>”对数组中元素进行存取，数组下标起始值为0。因为函数的调用方式为“<code>函数名（参数）</code>”，为避免混淆，数组下标使用时一般使用<code>[]</code>。其中-1为最后一个元素的下标，可根据下标值依次获取元素。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IDL&gt; arr = indgen(9)</span><br><span class="line">IDL&gt; arr</span><br><span class="line">       0       1       2       3       4       5       6       7       8</span><br><span class="line">IDL&gt; arr(3)</span><br><span class="line">       3</span><br><span class="line">IDL&gt; arr[3]</span><br><span class="line">       3</span><br><span class="line">IDL&gt; arr[-1]</span><br><span class="line">       8</span><br><span class="line">IDL&gt; arr[-5:-1]</span><br><span class="line">       4       5       6       7       8</span><br></pre></td></tr></table></figure><p>（2）向量方式</p><p>下标可以通过向量方式表示。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IDL&gt; arr = indgen(9)+5</span><br><span class="line">IDL&gt; arr</span><br><span class="line">       5       6       7       8       9      10      11      12      13</span><br><span class="line">IDL&gt; index = [0,2,4,6,8]</span><br><span class="line">IDL&gt; arr[index]</span><br><span class="line">       5       7       9      11      13</span><br><span class="line">;对30行20列的索引数组取出第6~10列中第12~15行的数据，可以通过“:”方式</span><br><span class="line">IDL&gt; arr1 = indgen(20,30)</span><br><span class="line">IDL&gt; select_arr1 = arr1[5:9,11:14]</span><br><span class="line">IDL&gt; select_arr1</span><br><span class="line">     225     226     227     228     229</span><br><span class="line">     245     246     247     248     249</span><br><span class="line">     265     266     267     268     269</span><br><span class="line">     285     286     287     288     289 </span><br><span class="line">;对30行20列的索引数组取出第10行的数据，可以通过“*”方式</span><br><span class="line">IDL&gt; vec_10 = arr1[*,9]</span><br><span class="line">IDL&gt; vec_10</span><br><span class="line">     180     181     182     183     184     185     186     187     188     189     190 191 192     193     194     195     196     197     198     199</span><br></pre></td></tr></table></figure><h4 id="👁数组运算"><a href="#👁数组运算" class="headerlink" title="👁数组运算"></a>👁数组运算</h4><p>（1）求大、求小和求余</p><p>数组的求大(<code>&lt;</code>)、求小(<code>&gt;</code>)和求余(<code>mod</code>)操作返回的是同维数组的计算结果。数组求大（&lt;<code>value</code>）是将数组中小于<code>value</code>的元素赋为<code>value</code>；求小（&gt;<code>value</code>）是将数组中大于<code>value</code>的值赋为<code>value</code>；数组求余（<code>mod</code>)是计算数组中各元素的余数。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IDL&gt; a = indgen(8)+3</span><br><span class="line">IDL&gt; a</span><br><span class="line">       3       4       5       6       7       8       9      10</span><br><span class="line">IDL&gt; a&gt;6</span><br><span class="line">       6       6       6       6       7       8       9      10</span><br><span class="line">IDL&gt; a</span><br><span class="line">       3       4       5       6       7       8       9      10</span><br><span class="line">IDL&gt; a&lt;6</span><br><span class="line">       3       4       5       6       6       6       6       6</span><br></pre></td></tr></table></figure><p>（2）数组与数运算<br>数组与数的运算遵循的基本规律是，数组中的每个元素与数进行运算。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IDL&gt; a = indgen(8)</span><br><span class="line">IDL&gt; a</span><br><span class="line">       0       1       2       3       4       5       6       7</span><br><span class="line">IDL&gt; a = indgen(8)+5</span><br><span class="line">IDL&gt; a</span><br><span class="line">       5       6       7       8       9      10      11      12</span><br></pre></td></tr></table></figure><p>（3）数组与数组运算<br>数组与数组的运算，结果的元素个数与运算的最小数组个数一致，多维数组需要转换为一维数组来运算。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IDL&gt; arr = [2,4,6,8]</span><br><span class="line">IDL&gt; arr1  = [4.5]</span><br><span class="line">IDL&gt; arr + arr1</span><br><span class="line">       6.5000000</span><br><span class="line">IDL&gt; arr1  = [5,6]</span><br><span class="line">IDL&gt; arr + arr1</span><br><span class="line">       7      10</span><br><span class="line">IDL&gt; arr2 = [[1,3,5],[2,4,6]]</span><br><span class="line">IDL&gt; arr3 = [[1,2],[3,4]]</span><br><span class="line">IDL&gt; arr2 + arr3</span><br><span class="line">       2       5</span><br><span class="line">       8       6</span><br></pre></td></tr></table></figure><p>（4）数组合并</p><p>数组与数组的合并需要两个数组的行数或列数相同。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IDL&gt; a = indgen(2,5)</span><br><span class="line">IDL&gt; b = indgen(4,5)</span><br><span class="line">IDL&gt; ;行数相同，可直接使用[]</span><br><span class="line">IDL&gt; c = [a,b]</span><br><span class="line">IDL&gt; c</span><br><span class="line">       0       1       0       1       2       3</span><br><span class="line">       2       3       4       5       6       7</span><br><span class="line">       4       5       8       9      10      11</span><br><span class="line">       6       7      12      13      14      15</span><br><span class="line">       8       9      16      17      18      19</span><br><span class="line">IDL&gt; ;列数相同，需要使用[[],[]]</span><br><span class="line">IDL&gt; d = indgen(2,3)</span><br><span class="line">IDL&gt; e = [[a],[d]]</span><br><span class="line">IDL&gt; e</span><br><span class="line">       0       1</span><br><span class="line">       2       3</span><br><span class="line">       4       5</span><br><span class="line">       6       7</span><br><span class="line">       8       9</span><br><span class="line">       0       1</span><br><span class="line">       2       3</span><br><span class="line">       4       5</span><br></pre></td></tr></table></figure><h4 id="👁相关函数"><a href="#👁相关函数" class="headerlink" title="👁相关函数"></a>👁相关函数</h4><p>（1）数组信息 <code>Size()</code></p><p><code>Size()</code>函数能够返回数组的结构信息，调用格式为 <code>Result = SIZE(变量, [/KeyWords])</code>。输入变量可以是常量、数组、字符串、结构体、指针和对象等任何数据类型。不设置关键字时，函数返回变量的基本信息：变量维数、每一维的数值元素个数（维数），变量类型代码、元素总个数。设置关键字<code>N_Dimensions</code>、<code>N_Elements</code>、<code>Dimensions</code>、<code>Tname</code>和<code>Type</code>，则依次返回数组的维数、元素个数、每一维的维数、类型名称和类型代码信息。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IDL&gt; data = indgen(4,5)</span><br><span class="line">IDL&gt; size(data)</span><br><span class="line">           2           4           5           2          20</span><br><span class="line">IDL&gt; size(data,/N_dimensions)</span><br><span class="line">           2</span><br><span class="line">IDL&gt; size(data,/N_elements)</span><br><span class="line">          20</span><br><span class="line">IDL&gt; size(data,/Dimensions)</span><br><span class="line">           4           5</span><br><span class="line">IDL&gt; size(data,/Tname)</span><br><span class="line">INT</span><br></pre></td></tr></table></figure><p>（2）条件查找</p><p><code>WHERE()</code>函数返回满足指定条件（即数组表达式）数组元素的下标所组成的一维数组。调用格式为：</p><p> <code>Result =WHERE(数组表达式 [, count] [, COMPLEMENT=变量 1] [, /L64] [, NCOMPLEMENT=变量 2])</code>。</p><p>关键字：count 返回的是符合指定条件的个数；变量 1 是不满足条件的数组的下标信息；变量 2 是不满足条件的数组的个数；</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IDL&gt; a = indgen(10)+3</span><br><span class="line">IDL&gt; a</span><br><span class="line">       3       4       5       6       7       8       9      10      11      12</span><br><span class="line">IDL&gt; B = WHERE(a GT 6, count, COMPLEMENT=B_C, NCOMPLEMENT=count_c)</span><br><span class="line">IDL&gt; count</span><br><span class="line">           6</span><br><span class="line">IDL&gt; B</span><br><span class="line">           4           5           6           7           8           9</span><br><span class="line">IDL&gt; count_c</span><br><span class="line">           4</span><br><span class="line">IDL&gt; B_C</span><br><span class="line">           0           1           2           3</span><br></pre></td></tr></table></figure><p>（3）大小调整</p><p><code>Reform()</code>函数可以使数组在元素个数不修改的前提下，改变数组的维数，方便了数组的动态使用。调用格式：</p><blockquote><p><code>Result = REFORM(Array, D1 [, ..., D8] [, 关键字] )</code></p></blockquote><p><code>Rebin()</code>函数可以修改数组的维数大小，将维数调整为 <code>D1 [, ..., D8]</code>指定的维数，且大小必须原数据的大小的整数倍，默认抽样算法是双线性内插。调用格式：</p><blockquote><p><code>Result = REBIN(数组, D1 [, ..., D8] [, /SAMPLE] )</code><br><code>SAMPLE</code>：设置该关键字则使用最近临值抽样法。</p></blockquote><p><code>Congrid()</code>函数可以调整数组为同维任意大小的数组，默认在处理一维或二维数组时默认是最近邻重采样方式，处理三维数组时默认是双线性内插值。在数据缩小操作时，<code>Rebin</code> 做了插值处理，而 <code>Congrid</code> 仅仅是重新采样。调用格式为：</p><blockquote><p><code>Result = Congrid(数组, X,Y,Z [,关键字] )</code><br><code>INTERP</code>：抽样采用线性内插法；<br><code>CUBIC</code>：采用卷积内插法。</p></blockquote><p><code>EXPAND</code> 用来对二维数组进行大小修改，采用双线性内插算法。调用格式：</p><blockquote><p><code>EXPAND, A, Nx, Ny, Result[, FILLVAL=value] [, MAXVAL=value]</code> </p><p>其中 <code>A</code> 为源数组，<code>Nx</code>、<code>Ny</code> 为修改后的维数，<code>Result</code> 为修改后的数组，<code>FILLVAL</code> 是填充数据，默认为-1；<code>MAXVAL</code> 是数据的最大值，大于该值的赋为 <code>FILLVAL</code>。</p></blockquote><p><code>INTERPOLATE()</code>函数可以调整数组为同维任意大小的数组，并能够任意定位插值点。调用格式：</p><blockquote><p><code>INTERPOLATE(数组, X[, Y [, Z]] [, 关键字] )</code></p><p>其中，<code>X [, Y [, Z]]</code>为待调整数组下标索引，可以是单个变量或数组，若<code>X</code>为0.5，则表示计算下标[0]和下标[1]中间位置的数值；<br><code>GRID</code> 关键字：采用网格插值方式生成插值点，否则按线性方式生成；<br><code>Missing</code> 关键字：插值点坐标超出数组自身坐标范围时赋予该值。</p></blockquote><p>（4）数组反转</p><p><code>Reverse()</code>函数可以对数组进行反转。调用格式：</p><blockquote><p><code>result = Reverse(数组, index[, 关键字] )</code><br><code>index</code> 是反转的数组的维数索引，它不能大于数组的维数。</p></blockquote><p>（5）数组转置 Transpose()<br><code>Transpose ()</code>函数可以对数组进行反转。调用格式：</p><blockquote><p><code>result = Transpose(数组, [P])</code><br>关键字：<code>P</code> 是调整后的维数数组列表，如不设置则完全反转。</p></blockquote><p>（6）数组旋转</p><p>①<code>Rotate()</code>函数</p><p><code>Rotate()</code>函数可以以 <code>90°</code>整倍数的角度对数组进行旋转操作。调用格式：</p><blockquote><p><code>result = Rotate (数组, direction )</code><br><code>Direction</code>：该关键字为整数，范围 <code>0-7</code>，分别代表的图像旋转方式。</p></blockquote><p>②<code>Rot()</code>函数</p><p><code>Rot()</code>函数可以以任意的角度对数组进行旋转操作并能进行放大、缩小操作。调用格式：</p><blockquote><p><code>result = Rot(数组, Angle, [Mag, X0, Y0],[关键字])</code><br><code>Angle</code>：该关键字数组旋转地角度，单位为度(°)。<br><code>Mag</code>：为放大的倍数；<br><code>X0</code>：为旋转中心的 <code>X</code> 坐标，默认为列中心；<br><code>Y0</code>：为旋转中心的 <code>Y</code> 坐标，默认为行中心；<br><code>PIVOT</code>：该关键字控制旋转后<code>(X0,Y0)</code>点是否仍然在原图像中的位置，不设置则<code>(X0,Y0)</code>点在图像的中心位置。</p></blockquote><p>（7）数组平移</p><p><code>Shift()</code>函数是按指定的平移量 <code>S1、…、Sn</code>，分别对数组的第 <code>1、…、n</code> 维进行平移后生成新数组。其中 <code>Si</code> 为正表示向前平移；<code>Si</code> 为负表示向后平移。调用格式：</p><blockquote><p><code>result = Shift(数组，S1、…、Sn)</code></p></blockquote><p>（8）数组排序<br><code>Sort()</code>函数返回排序后的<strong>数组索引</strong>。调用格式：</p><blockquote><p><code>result = Sort(数组[, /L64])</code></p></blockquote><p>（9）数组唯一调整 （求不同值）<br><code>Uniq()</code>函数返回数组中<strong>相邻元素不同值</strong>的<strong>索引</strong>。该函数<strong>只能发现相邻值</strong>，若不相邻，则会认为是两个值。如果先对数组进行排序，则可求出数组中包含的不同值。调用格式为：</p><blockquote><p><code>result = UNIQ(数组 [, Index] )</code></p></blockquote><p>（10）判断数组</p><p><code>Array_Equal()</code>函数进行数组相同的判断。调用格式：</p><blockquote><p><code>result = Array_Equal(数组, /关键字)</code><br><code>result</code>：返回 0 或 1。<br><code>NO_TYPECONV</code>：添加该关键字，用于将两数组转换为同一类型，判断数据类型是否相同；为1时，数组可直接比较，不转换数据类型。</p></blockquote><p>（11）元素个数</p><p><code>N_Elements()</code>函数返回数组元素的个数。调用格式：</p><blockquote><p><code>result = N_Elements(数组)</code></p></blockquote><p>（12）求最值</p><p><code>Max()</code>函数返回满足数组元素的最大值。调用格式：</p><blockquote><p><code>result = Max(数组 [,关键字], min =变量 1)。</code><br><code>result</code>：返回的是数组的最大值；<br><code>变量 1</code>：返回的是数组的最小值；</p></blockquote><p><code>Min()</code>函数返回满足数组元素的最小值。调用格式：</p><blockquote><p><code>result = Min(数组 [,关键字], max =变量 1)。</code><br><code>result</code>：返回的是数组的最小值；<br><code>变量 1</code>：返回的是数组的最大值；</p></blockquote><p>（13）求和</p><p>Total()函数返回满足数组元素和，并可以通过关键字进行求和选项的控制。调用格式：</p><blockquote><p><code>result = Total(数组, Dimension, [,关键字])。</code><br><code>result</code>：返回的是数组元素求和结果；<br><code>Dimension</code>：数组求和元素的行列控制；<br><code>CUMULATIVE</code>：设置该关键字后，返回结果与原数组一致，第 <code>i</code> 个元素的值为 <code>0-i</code> 值的和；<br><code>Double</code>：返回双精度类型结果；<br><code>Integer</code>：返回整型数据结果；<br><code>PRESERVE_TYPE</code>：返回结果类型与原数组类型一致，设置该关键字的时，&#x2F;double 等关键字无效。</p></blockquote><p>（14）乘积计算<br><code>Product()</code>函数计算数组中所有或部分元素的乘积。调用格式：</p><blockquote><p><code>result = Product(数组, Dimension, [,关键字])。</code><br>关键字控制与 total 函数的关键字基本一致。</p></blockquote><p>（15）其它运算</p><p><code>Factorial()</code>函数计算满足数组元素阶乘。调用格式：</p><blockquote><p><code>result = Factorial(数组, [,关键字])。</code><br>关键字-<code>Stirling</code>：返回结果为Stirling近似值。</p></blockquote><p><code>Mean()</code>函数计算数组元素的平均值。调用格式为：</p><blockquote><p><code>result = Mean(数组, [,关键字])。</code></p></blockquote><p><code>Variance()</code>函数计算数组元素的方差。调用格式：</p><blockquote><p><code>result = Variance(数组, [,关键字])。</code></p></blockquote><p><code>Stddev()</code>函数计算数组元素的方差。调用格式：</p><blockquote><p><code>result = Variance(数组, [,关键字])。</code></p></blockquote><p><code>Moment()</code>函数计算数组元素的平均值、方差、倾斜度及频率曲线峰态。调用格式：</p><blockquote><p><code>result = Moment(数组, [,关键字])。</code></p></blockquote><h4 id="👁矩阵运算"><a href="#👁矩阵运算" class="headerlink" title="👁矩阵运算"></a>👁矩阵运算</h4><p>矩阵间的运算，遵循以下两个法则（注意与线性代数矩阵运算的区别和联系）：</p><p><code>A#B</code> 表示 A 的列乘以 B 的行，要求A的行数必须跟B的列数一致。</p><p><code>A##B</code> 表示 A 的行乘以 B 的列，要求A的列数必须跟B的行数一致。</p><h3 id="👀字符串"><a href="#👀字符串" class="headerlink" title="👀字符串"></a>👀字符串</h3><p>字符串和字符串数组的创建可以通过直接赋值或函数来实现。在IDL中字符串用双引号<code>&quot; &quot;</code>或单引号<code>&#39;&#39;</code>括起来表示。但以<code>&quot;</code>为首的字符串的首字符不能为数字，因为以<code>&quot;</code>开头的数字串代表一个8进制。</p><p>字符串连接直接用加号<code>&quot;+&quot;</code>。字符串操作在文件读取、命令行输入以及窗口参数输入时经常被用到。字符串操作都是通过字符串处理函数来实现的。</p><table><thead><tr><th>函数名</th><th>函数描述</th></tr></thead><tbody><tr><td><code>STRCMP(str1, str2, N, /FOLD_CASE)</code></td><td>对两个字符串进行比较，如果 N 存在，只对前 N 个进行比较，<code>/FOLD_CASE</code> 表示模糊比较</td></tr><tr><td><code>STRCOMPRESS(str1)</code></td><td>删除字符串 <code>str1</code> 中的空格</td></tr><tr><td><code>STREGEX()</code></td><td>正则表达式</td></tr><tr><td><code>STRJOIN()</code></td><td>字符串相连接</td></tr><tr><td><code>STRLEN(）</code></td><td>返回字符串的长度</td></tr><tr><td><code>STRLOWCASE(）</code></td><td>将所有的大写字母改写成小写字母</td></tr><tr><td><code>STRMATCH(Str1,str2)</code></td><td>字符串 <code>Str1</code> 中是否存在 <code>Str2</code>，可以使用通配符</td></tr><tr><td><code>STRMID(Str1,po1,Len,REVERSE_OFFSET)</code></td><td>从字符串 <code>po1</code> 开始取出 <code>Len</code> 个字符。字符串的第一个字符的位置为 0</td></tr><tr><td><code>STRPOS(Exp_Str1,Sea_Str2,Pos,&lt;br /&gt;REVERSE_OFFSET,/REVERSE_SEARCH] )</code></td><td>从一个字符串中查找与另外一个字符串完全匹配的起始点所在的位置。<code>Pos</code>是查找点的起始位置，默认值 为0、1（如果指定<code>/REVERSE_SEARCH]</code>）；指定时，则表示从开始的Pos起，或者从末尾开始的<code>Pos</code> 起（如果指定 <code>REVERSE_OFFSET</code> ）</td></tr><tr><td><code>STRPUT,Des_Var_str,Sou_str,Pos</code></td><td>将字符串<code>Sou_str</code>插入到字符串<code>Des_Var_str</code>之中，<code>POS</code>插入点的位置，默认值为 0，依次将字符串Sou_str覆盖插入到<code>Des_Var_str</code>中。<code>Sou_str</code> 不为字符串，则按默认格式自动转化从 <code>POS</code> 处开始插入<code>Des_Var_str</code>，如果插入值的位置超过了 <code>Des_Var</code> 的最大长度，则自然截断</td></tr><tr><td><code>STRSPLIT(Str1)</code></td><td>根据特定要求拆分字符串<code>str1</code>；</td></tr><tr><td><code>STRTRIM(str,Flag)</code></td><td>移去字符串中的空格。<code>Flag</code>：0(移去右边空格），1(移去左边空格），2（移去两边的空格）</td></tr><tr><td><code>STRUPCASE(）</code></td><td>将所有的小写字母改写成大写字母</td></tr></tbody></table><h3 id="👀其它数据类型"><a href="#👀其它数据类型" class="headerlink" title="👀其它数据类型"></a>👀其它数据类型</h3><p><strong>结构体</strong>：创建结构体时用大括号<code>&#123;&#125;</code>，同时需要赋予结构体名称。</p><blockquote><p>注意：通过<code>&quot;help, struct1, /structure&quot;</code>语句可以查看结构体<code>struct1</code>的基本信息。通过结构体<code>&quot;变量名.成员名&quot;</code>或<code>&quot;变量名.(index)&quot;</code>的方式访问。</p></blockquote><p><strong>指针</strong>：指针用指针函数<code>Ptr_New()</code>来创建，通过<code>&quot;*&quot;</code>+指针变量名来访问。</p><blockquote><p>指针赋值与变量赋值不一样，指针赋值是使两个指针指向同一个堆向量，修改任意一个会影响另一个。</p></blockquote><p><strong>对象</strong>：对象是数据（属性）和程序（方法）封装在一起的实体。<code>IDL</code>中用<code>Obj_New</code>函数或<code>ObjArr</code>函数来创建对象。<code>ObjArr()</code>函数用来创建对象数组；<code>Obj_New()</code>函数用来创建某一特定类的对象。</p><blockquote><p>调用对象、销毁对象、处理函数</p></blockquote><p><strong>链表</strong>：链表（<code>list</code>)是一个复合数据类型，它可以包含变量、数组、结构体、指针、对象、链表和哈希表等数据类型。链表中的元素是有次序的，可以通过索引来进行编辑操作。</p><blockquote><p>链表是由<code>list()</code>函数来创建。链表访问与数组访问一样，通过下标索引来实现。创建链表、访问链表、增加链表、删除链表、链表反转、转为数组、链表连接、链表比较、销毁链表</p></blockquote><p><strong>哈希表</strong>：哈希表（<code>Hash</code>)是一个高效的复合数据类型，可以包含变量、数组、结构体、指针、对象、链表和哈希表等数据类型。哈希表的特点是关键字（<code>keys</code>）与值对应，通过链表函数或关键字快速访问处理。</p><blockquote><p>哈希表创建通过创建函数<code>Hash()</code>创建；元素访问是根据关键字；哈希表元素添加与数组元素的添加类似；其他操作：关键字输出、关键字查询、删除哈希表、转换为结构体、哈希表组合、哈希表比较、销毁哈希表。</p></blockquote><h3 id="👀运算符"><a href="#👀运算符" class="headerlink" title="👀运算符"></a>👀运算符</h3><ul><li>数学运算符</li></ul><blockquote><p>加（<code>+</code>）、减（<code>-</code>）、增运算（<code>++</code>）、减运算（<code>--</code>）、乘（<code>*</code>）、除（<code>/</code>）、幂（<code>^</code>）、取余（<code>mod</code>）、取小（<code>&lt;</code>）、取大（<code>&gt;</code>）</p></blockquote><ul><li>逻辑运算符</li></ul><blockquote><p>逻辑与（<code>&amp;&amp;</code>）、逻辑或（<code>||</code>）、逻辑非（<code>~</code>）</p></blockquote><ul><li>位运算符</li></ul><blockquote><p>位加符（<code>AND</code>）、位取反符（<code>NOT</code>）、位或符（<code>OR</code>）、位异或符（<code>XOR</code>）</p></blockquote><ul><li>关系运算符</li></ul><blockquote><p>等于（<code>EQ</code>）、不等于（<code>NE</code>）、大于等于（<code>GE</code>）、大于（<code>GT</code>）、小于等于（<code>LE</code>）、小于（<code>LT</code>）。返回值是真（<code>1</code>）假（<code>0</code>）</p></blockquote><ul><li>数组（矩阵）运算符</li></ul><blockquote><p>数组乘（<code>#</code>）是第一个数组的列元素乘以第二个数组的行元素并求和。</p><p>矩阵乘（<code>##</code>）与数组乘类似，区别是行乘以列。</p></blockquote><ul><li>其它运算符</li></ul><blockquote><p>圆括号<code>()</code>用来对表达式进行组合或一系列表达式控制优先级。</p><p>方括号<code>[]</code>用来数组连接或对数组进行元素调用。</p><p>条件运算符是<code>？:</code>，<code>value = expr1 ? expr2 : expr3</code> 如果 <code>expr1</code> 是 <code>true</code>，那么 <code>value</code> 等于 <code>expr2</code> ，否则 <code>value</code> &#x3D;等于<code>expr3</code>。</p><p>对象方法调用符<code>.</code>或<code>-&gt;</code>两种，对象可以通过这两种符号来调用相关的方法。</p><p>指针调用符为<code>*</code>，引用格式为<code>*指针变量名</code>。</p></blockquote><ul><li>运算符优先级</li></ul><table><thead><tr><th align="center">优先级</th><th align="left">操作符</th></tr></thead><tbody><tr><td align="center">一级（最高）</td><td align="left"><code>()</code> (公式表达式)<br /><code>[]</code> (数组连接)</td></tr><tr><td align="center">二级</td><td align="left"><code>.</code> (结构体域表达式)<br /><code>[]</code> (数组元素调用)<br /><code>()</code> (函数引用)</td></tr><tr><td align="center">三级</td><td align="left"><code>*</code> (指针调用)<br /><code>^</code> (幂函数)<br /><code>++</code> (增函数)<br /><code>--</code> (减函数)</td></tr><tr><td align="center">四级</td><td align="left"><code>*</code> (乘)<br /><code>#</code> 和 <code>##</code> (矩阵乘)<br /><code>/</code>(除)<br /><code>MOD</code> (取余数)</td></tr><tr><td align="center">五级</td><td align="left"><code>+</code> (加)<br /><code>-</code> (减和取反)<br /><code>&lt;</code> (求小)<br /><code>&gt;</code> (求大)<br /><code>NOT</code> (位取反)<br /><code>~</code> (逻辑取反)</td></tr><tr><td align="center">六级</td><td align="left"><code>EQ</code> (等于) <br/><code>NE</code> (不等于)<br /><code>LE</code> (小于等于) <br/><code>LT</code> (小于) <br/><code>GE</code> (大于等于) <br/><code>GT</code> (大于)</td></tr><tr><td align="center">七级</td><td align="left"><code>AND</code> (位与) <br/><code>OR</code> (位或) <br/><code>XOR</code> (位异或)</td></tr><tr><td align="center">八级</td><td align="left"><code>&amp;&amp;</code> (逻辑与)</td></tr><tr><td align="center">九级</td><td align="left"><code>?:</code> (条件表达式)</td></tr></tbody></table><h3 id="👀其他符号"><a href="#👀其他符号" class="headerlink" title="👀其他符号"></a>👀其他符号</h3><p><code>$</code>续行符：续行符主要应用在一条语句过长或参数过多时进行格式化显示；</p><p><code>&amp;</code>同行符：使用了同行符相当于两行代码写在一行之中；</p><p><code>;</code>注释符：此符号之后的该行所有代码都将看做是注释，不参与编译运行。</p><p>笔者不才，请多交流！！！</p>]]></content>
      
      
      <categories>
          
          <category> IDL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ENVI </tag>
            
            <tag> IDL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python异常处理-模块Model/Package-文件处理</title>
      <link href="/2022/09/25/Ex-Model-File/"/>
      <url>/2022/09/25/Ex-Model-File/</url>
      
        <content type="html"><![CDATA[<h2 id="⛄异常处理"><a href="#⛄异常处理" class="headerlink" title="⛄异常处理"></a>⛄异常处理</h2><p>编写计算机程序时，通常能够区分<strong>正常</strong>和<strong>异常</strong>（不正常）情况。异常事件可能是错误（如试图除以零），也可能是通常不会发生的事情。为处理这些异常事件，可在每个可能发生这些事件的地方都使用条件语句。例如，对于每个除法运算，都检查除数是否为零。然而，这样做不仅效率低下、缺乏灵活性，还可能导致程序难以卒读。你可能很想忽略这些异常事件，希望它们不会发生，但<code>Python</code>提供功能强大的替代解决方案——异常处理机制。</p><p><code>Python</code>使用异常对象来表示异常状态，并在遇到错误时引发异常。异常对象未被处理（或捕获）时，程序将终止并显示一条错误消息（<code>traceback</code>）。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">1</span>]:<span class="number">1</span>/<span class="number">0</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;ipython-input-2-9e1622b385b6&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    <span class="number">1</span>/<span class="number">0</span></span><br><span class="line">ZeroDivisionError: division by zero</span><br></pre></td></tr></table></figure><p>如果异常只能用来显示错误消息，就没多大意思了。但事实上，每个异常都是某个类的实例。你能以各种方式引发和捕获这些实例，从而逮住错误并采取措施，而不是放任整个程序失败。</p><h3 id="👀异常的概念"><a href="#👀异常的概念" class="headerlink" title="👀异常的概念"></a>👀异常的概念</h3><ul><li>程序在运行时，如果<code>Python解释器</code>遇到到一个错误，会停止程序的执行，并且提示一些错误信息，这就是<strong>异常</strong>。</li><li>程序停止执行并且提示错误信息这个动作，我们通常称之为：<strong>抛出(<code>raise</code>)异常</strong>。</li></ul><blockquote><p>程序开发时，很难将所有的特殊情况，都处理的面面俱到，通过<strong>异常捕获</strong>可以针对突发事件做集中的处理，从而保证程序的<strong>稳定性和健壮性</strong>。</p></blockquote><h3 id="👀捕获异常"><a href="#👀捕获异常" class="headerlink" title="👀捕获异常"></a>👀捕获异常</h3><p>（1）简单的捕获异常语法</p><p>在程序开发中，如果对某些代码的执行不能确定是否正确，可以增加<code>try(尝试)</code>来<strong>捕获异常</strong>。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 捕获异常最简单的语法格式</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line"><span class="comment"># 尝试执行的代码</span></span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line"><span class="comment"># 出现错误的处理</span></span><br></pre></td></tr></table></figure><ul><li><code>try</code>尝试，下方编写要尝试代码，不确定是否能够正常执行的代码。</li><li><code>except</code>如果不是，下方编写尝试失败的代码。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># 提示用户输入一个数字</span></span><br><span class="line">    num = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入数字：&quot;</span>))</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;请输入正确的数字&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果样例</span></span><br><span class="line">请输入数字：<span class="number">1</span></span><br><span class="line"></span><br><span class="line">请输入数字：a</span><br><span class="line">请输入正确的数字</span><br></pre></td></tr></table></figure><p>（2）错误类型捕获及完整语法</p><p>在程序执行时，可能会遇到<strong>不同类型的异常</strong>，并且需要<strong>针对不同类型的异常</strong>，<strong>做出不同的响应</strong>，这个时候，就需要捕获错误类型了。</p><p><strong>捕获未知错误</strong></p><ul><li>在开发时，<strong>要预判到所有可能出现的错误</strong>，还是有一定难度的。</li><li>如果希望程序<strong>无论出现任何错误</strong>，都不会因为<code>Python解释器</code><strong>抛出异常而被终止</strong>，可以再增加一个<code>except</code>。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 语法</span></span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> result:</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;未知错误%s&quot;</span>%result)</span><br></pre></td></tr></table></figure><p>异常捕获完整语法：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 语法</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># 尝试执行的代码</span></span><br><span class="line">    <span class="keyword">pass</span> </span><br><span class="line"><span class="keyword">except</span> 错误类型<span class="number">1</span>:</span><br><span class="line">    <span class="comment"># 针对错误类型1,对应的代码处理</span></span><br><span class="line">    <span class="keyword">pass</span> </span><br><span class="line"><span class="keyword">except</span>(错误类型<span class="number">2</span>, 错误类型<span class="number">3</span>):</span><br><span class="line">    <span class="comment"># 针对错误类型2和3,对应的代码处理</span></span><br><span class="line">    <span class="keyword">pass</span> </span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> result:</span><br><span class="line">    <span class="comment"># 捕获未知错误</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;未知错误%s&quot;</span>%result)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="comment"># 只有没有异常时才会执行的代码</span></span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="comment"># 无论是否有异常，都会执行的代码</span></span><br></pre></td></tr></table></figure><p>完整捕获异常的例子：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># 提示用户输入一个数字</span></span><br><span class="line">    num = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入数字：&quot;</span>))</span><br><span class="line">    result = <span class="number">8</span> / num</span><br><span class="line">    <span class="built_in">print</span>(result)</span><br><span class="line"><span class="keyword">except</span> ValueError:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;请输入正确的数字&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> ZeroDivisionError:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;除0错误&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> result:</span><br><span class="line">    <span class="comment"># 捕获未知错误</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;未知错误%s&quot;</span>%result)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;正常执行&quot;</span>)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;执行完成，但是不保证正确&quot;</span>)   </span><br></pre></td></tr></table></figure><h3 id="👀异常的传递"><a href="#👀异常的传递" class="headerlink" title="👀异常的传递"></a>👀异常的传递</h3><ul><li><strong>异常的传递</strong>——当<strong>函数&#x2F;方法</strong>执行<strong>出现异常</strong>，会将异常传递给函数&#x2F;方法的调用一方；</li><li>如果<strong>传递到主程序</strong>，仍然<strong>没有异常处理</strong>，程序才会被终止。</li></ul><blockquote><ul><li>在开发中，可以在<strong>主函数</strong>中增加<strong>异常捕获</strong>；</li><li>而在主函数中调用的其他函数，只要出现异常，都会传递到主函数的<strong>异常捕获</strong>中；</li><li>这样就不需要在代码中，增加大量的<strong>异常捕获</strong>，能够保证代码的整洁和健壮性。</li></ul></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">demo1</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入一个整数：&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">demo2</span>():</span><br><span class="line">    <span class="keyword">return</span> demo1()</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">print</span>(demo2())</span><br><span class="line"><span class="keyword">except</span> ValueError:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;请输入正确的数字&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> result:</span><br><span class="line">    <span class="comment"># 捕获未知错误</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;未知错误%s&quot;</span>%result)</span><br></pre></td></tr></table></figure><h3 id="👀抛出raise异常"><a href="#👀抛出raise异常" class="headerlink" title="👀抛出raise异常"></a>👀抛出<code>raise</code>异常</h3><p><strong>应用场景</strong></p><ul><li>在开发中，除了<strong>代码执行出错</strong><code>Python解释器</code>会抛出异常之外；</li><li>还可以根据应用程序特有的业务需求<strong>主动抛出异常</strong>。</li></ul><p><strong>示例</strong></p><ul><li>提示用户输入密码，如果长度少于8，抛出异常。</li></ul><p><strong>注意</strong></p><ul><li>当前函数只负责提示用户输入密码，如果密码长度不正确，需要其他的函数进行额外处理；</li><li>因此可以<strong>抛出异常</strong>，由其他需要处理的函数<strong>捕获异常</strong>。</li></ul><p><strong>抛出异常</strong></p><ul><li><p><code>Python</code>中提供了一个<code>Exception</code> 异常类。</p></li><li><p>在开发时，如果满足<strong>特定业务需求</strong>时，希望抛出异常，可以：</p><ul><li><p>创建一个<code>Exception</code>的对象</p></li><li><p>使用<code>raise</code>关键字抛出异常对象</p></li></ul></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">input_passward</span>():</span><br><span class="line">    <span class="comment"># 提示输入密码</span></span><br><span class="line">    pwd = <span class="built_in">input</span>(<span class="string">&quot;请输入密码：&quot;</span>)</span><br><span class="line">    <span class="comment"># 判断，如果密码长度≥8，返回用户输入的密码</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(pwd) &gt;= <span class="number">8</span>:</span><br><span class="line">        <span class="keyword">return</span> pwd</span><br><span class="line">    <span class="comment"># 如果密码长度&lt;8，主动抛出异常</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;主动抛出异常&quot;</span>)</span><br><span class="line">    <span class="comment"># 1.创建异常对象，可以使用错误信息字符串作为参数</span></span><br><span class="line">    ex = Exception(<span class="string">&quot;密码长度不够&quot;</span>)</span><br><span class="line">    <span class="comment"># 2.抛出异常</span></span><br><span class="line">    <span class="keyword">raise</span> ex</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">print</span>(input_passward())</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> result:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;异常为:%s&quot;</span> % result)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果样例</span></span><br><span class="line">请输入密码：<span class="number">123</span></span><br><span class="line">主动抛出异常</span><br><span class="line">异常为:密码长度不够</span><br></pre></td></tr></table></figure><h2 id="⛄模块和包-Package"><a href="#⛄模块和包-Package" class="headerlink" title="⛄模块和包(Package)"></a>⛄模块和包(Package)</h2><h3 id="👀模块"><a href="#👀模块" class="headerlink" title="👀模块"></a>👀模块</h3><p>（1）模块的概念</p><p>模块是<code>Python</code>程序架构的一个核心概念</p><ul><li>每一个以扩展名<code>py</code>结尾的<code>Python</code>源代码文件都是一个<strong>模块</strong>，文件名就是<strong>模块名</strong>；</li><li><strong>模块名</strong>同样也是一个标识符，需要符合标识符的命名规则(字母、数字、下划线，不能以数字开头)；</li><li>在模块中定义的<strong>全局变量</strong>、<strong>函数</strong>、<strong>类</strong>都是提供给外界直接使用的工具；</li><li><strong>模块</strong>就好比是<strong>工具包</strong>，要想使用这个工具包中的工具，就需要先<strong>导入</strong>这个模块。</li></ul><p>（2）模块导入方式</p><p>① <code>import</code>导入</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> 模块名<span class="number">1</span>, 模块名<span class="number">2</span></span><br></pre></td></tr></table></figure><blockquote><p>提示：在导入模块时，<code>PEP8</code>建议每个导入应该独占一行</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> 模块名<span class="number">1</span></span><br><span class="line"><span class="keyword">import</span> 模块名<span class="number">2</span></span><br></pre></td></tr></table></figure><p>导入之后，通过<code>模块名.</code>使用模块提供的工具–全局变量、函数、类。如果模块的名字太长，可以使用<code>as</code>指定模块的名称，以方便在代码中的使用。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> 模块名 <span class="keyword">as</span> 模块别名</span><br></pre></td></tr></table></figure><blockquote><p>注意：<strong>模块别名</strong>应该符合<strong>大驼峰命名法</strong></p></blockquote><p>② <code>from..import</code>导入</p><ul><li>如果希望从某一个模块中，导入部分工具，就可以使用<code>from..import</code>的方式；</li><li><code>import 模块名</code>是<strong>一次性</strong>把模块中<strong>所有工具全部导入</strong>，并且通过<strong>模块名&#x2F;别名</strong>访问。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 从模块导入某一个工具</span></span><br><span class="line"><span class="keyword">from</span> 模块名<span class="number">1</span> <span class="keyword">import</span> 工具名</span><br></pre></td></tr></table></figure><p>导入之后</p><ul><li>不需要通过<code>模块名.</code>；</li><li>可以直接使用<code>模块提供的工具</code>——全局变量、函数、类。</li></ul><p>注意</p><p>如果两个模块，存在<strong>同名的函数</strong>，那么<strong>后导入模块的函数</strong>，会<strong>覆盖掉先导入的函数</strong>。</p><ul><li>开发时<code>import</code>代码应该统一写在<strong>代码的顶部</strong>，更容易及时发现冲突；</li><li>一旦发现冲突，可以使用<code>as</code>关键字<strong>给其中一个工具起一个别名</strong>。</li></ul><p>③ <code>from...import *</code> (知道)</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 从模块导入所有工具</span></span><br><span class="line"><span class="keyword">from</span> 模块名<span class="number">1</span> <span class="keyword">import</span> *</span><br></pre></td></tr></table></figure><blockquote><p>注意：这种方式不推荐使用，不需要通过<code>模块名.</code>调用，因为函数重名并没有任何提示，出现问题不好排查。</p></blockquote><p>（3）模块的搜索顺序</p><p><code>Python</code>的解释器在导入模块时，会：</p><ul><li>搜索<strong>当前目录</strong>指定模块名的文件，如果有就直接导入；</li><li>如果没有，再搜索<strong>系统目录</strong>。</li></ul><blockquote><p>在开发时，给文件起名，不要和系统的模块文件重名</p></blockquote><p><code>Python</code>中每一个模块都有一个内置属性<code>__file__</code>可以查看模块的<strong>完整路径</strong>。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="comment"># 生成一个0~18的数字</span></span><br><span class="line">rand = random.randint(e,<span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(rand)</span><br></pre></td></tr></table></figure><blockquote><p>注意：如果当前目录下，存在一个<code>random.py</code>的文件，程序就无法正常执行了！这个时候，<code>Python</code>的解释器会加载当前目录下的<code>random.py</code>而不会加载系统的<code>random</code>模块。</p></blockquote><p>（4）每一个文件都应该是可以被导入的</p><ul><li>一个独立的<code>Python</code>文件就是一个<strong>模块</strong>；</li><li>在导入文件时，文件中<strong>所有没有任何缩进的代码</strong>都会被执行一遍！</li></ul><p>实际开发场景</p><ul><li>在实际开发中，每一个模块都是独立开发的，大多都有专人负责；</li><li>开发人员通常会在模块下方增加一些<strong>测试代码</strong>，仅在模块内使用，而被导入到其他文件中不需要执行。</li></ul><p><code>__name__</code>属性</p><ul><li><code>__name__</code>属性可以做到，测试模块的代码<strong>只在测试情况下被运行</strong>，而在被<strong>导入时不会被执行</strong>！</li><li><code>__name__</code>是<code>Python</code>的一个内置属性，记录着一个字符串；</li><li>如果是被其他文件导入的，<code>__name__</code>就是模块名；</li><li>如果是当前执行的程序，<code>__name__</code>是<code>__main__</code>。</li></ul><p>​    在很多<code>Python</code>文件中都会看到以下格式的代码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 导入模块</span></span><br><span class="line"><span class="comment"># 定义全局变量</span></span><br><span class="line"><span class="comment"># 定义类</span></span><br><span class="line"><span class="comment"># 定义函数</span></span><br><span class="line">        </span><br><span class="line"><span class="comment"># 在代码的最下方</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line"><span class="comment">#...</span></span><br><span class="line"><span class="keyword">pass</span></span><br><span class="line"><span class="comment"># 根据_name判断是否执行下方代码</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">main()</span><br></pre></td></tr></table></figure><h3 id="👀包-Package"><a href="#👀包-Package" class="headerlink" title="👀包(Package)"></a>👀包(<code>Package</code>)</h3><ul><li><strong>包</strong>是一个<strong>包含多个模块</strong>的<strong>特殊目录</strong>；</li><li>目录下有一个<strong>特殊的文件</strong><code>__init__.py</code>；</li><li>包名的<strong>命名方式</strong>和变量名一致，小写字母、下划线等。</li></ul><blockquote><p>好处：使用<code>import 包名</code>可以一次性导入包中所有的模块。</p></blockquote><p> <code>__init__.py</code>，要在外界使用包中的模块，需要在<code>__init__.py</code>中指定对外界提供的模块列表。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 从当前目录导入模块列表</span></span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> 模块名<span class="number">1</span></span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> 模块名<span class="number">2</span></span><br></pre></td></tr></table></figure><h2 id="⛄文件处理"><a href="#⛄文件处理" class="headerlink" title="⛄文件处理"></a>⛄文件处理</h2><h3 id="👀文件的概念"><a href="#👀文件的概念" class="headerlink" title="👀文件的概念"></a>👀文件的概念</h3><ul><li>计算机的文件，就是存储在某种长期储存设备上的一段数据。</li><li>文件的存储方式：是以二进制的方式保存在磁盘上。</li></ul><h3 id="👀文件的基本操作"><a href="#👀文件的基本操作" class="headerlink" title="👀文件的基本操作"></a>👀文件的基本操作</h3><p>文本文件和二进制文件，在计算机中操作文件的套路非常固定，一共包含三个步骤：</p><ul><li><p>打开文件</p></li><li><p>读、写文件</p><ul><li><p>读，将文件内容读入内存</p></li><li><p>写，将内存内容写入文件</p></li></ul></li><li><p>关闭文件</p></li></ul><p>在<code>Python</code>中要操作文件需要记住1个函数和3个方法</p><table><thead><tr><th>序号</th><th>函数&#x2F;方法</th><th>说明</th></tr></thead><tbody><tr><td>01</td><td><code>open</code></td><td>打开文件，并且返回文件操作对象</td></tr><tr><td>02</td><td><code>read</code></td><td>将文件内容读取到内存</td></tr><tr><td>03</td><td><code>write</code></td><td>将指定内容写入文件</td></tr><tr><td>04</td><td><code>close</code></td><td>关闭文件</td></tr></tbody></table><blockquote><p><code>open</code>函数负责打开文件，并且返回文件对象；</p><p><code>read</code>&#x2F;<code>write</code>&#x2F;<code>close</code>三个方法都需要通过<strong>文件对象</strong>调用。</p></blockquote><h3 id="👀read-方法"><a href="#👀read-方法" class="headerlink" title="👀read()方法"></a>👀<code>read()</code>方法</h3><ul><li><p><code>open</code>函数的第一个参数是要打开的文件名(文件名区分大小写)。</p><ul><li><p>如果文件<strong>存在</strong>，返回文件操作对象；</p></li><li><p>如果文件<strong>不存在</strong>，会抛出异常。</p></li></ul></li><li><p><code>read</code>方法可以一次性<strong>读入</strong>并<strong>返回</strong>文件的<strong>所有内容</strong>。</p></li><li><p><code>close</code>方法负责<strong>关闭文件</strong>。</p><ul><li>如果忘记关闭文件，会造成系统资源消耗，而且会影响到后续对文件的访问。</li></ul></li><li><p>注意：<code>read</code>方法执行后，会把<strong>文件指针</strong>移动到<strong>文件的末尾</strong>。</p></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1.打开-文件名需要注意大小写</span></span><br><span class="line">file = <span class="built_in">open</span>(<span class="string">&quot;README&quot;</span>)</span><br><span class="line"><span class="comment"># 2.读取</span></span><br><span class="line">text = file.read()</span><br><span class="line"><span class="built_in">print</span>(text)</span><br><span class="line"><span class="comment"># 3.关闭</span></span><br><span class="line">file.close()</span><br></pre></td></tr></table></figure><blockquote><p>提示：在开发中，通常会先编写打开和关闭的代码，再编写中间针对文件的读&#x2F;写操作！使用 <code>with</code> 关键字系统会自动调用 <code>f.close()</code> 方法， <code>with</code> 的作用等效于 <code>try/finally</code> 语句是一样的。</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 打开文件</span></span><br><span class="line">filename=<span class="built_in">open</span>(<span class="string">&quot;file.txt&quot;</span>)</span><br><span class="line"><span class="comment"># 读取文件内容</span></span><br><span class="line">text = filename.read()</span><br><span class="line"><span class="built_in">print</span>(text)</span><br><span class="line"><span class="comment"># 如果执行了一次read方法,读取了所有内容,那么再次调用read方法,还能够获得到内容吗？读取不到</span></span><br><span class="line"><span class="comment"># 当执行了read方法后,文件指针会移动到读取内容的末尾</span></span><br><span class="line">text1 = filename.read()</span><br><span class="line"><span class="built_in">print</span>(text1)</span><br><span class="line"><span class="comment"># 关闭文件</span></span><br><span class="line">filename.close()</span><br></pre></td></tr></table></figure><p>文件指针（知道）</p><ul><li><strong>文件指针</strong>标记<strong>从哪个位置开始读取数据</strong>；</li><li><strong>第一次打开</strong>文件时，通常<strong>文件指针会指向文件的开始位置</strong>；</li><li>当执行了<code>read</code>方法后，<strong>文件指针</strong>会移动到<strong>读取内容的末尾</strong>；<ul><li>默认情况下会移动到<strong>文件末尾</strong>。</li></ul></li></ul><blockquote><p>思考：</p><p>如果执行了一次<code>read</code>方法，读取了所有内容，那么再次调用<code>read</code>方法，还能够获得到内容吗？</p><p>不能，第一次读取之后，文件指针移动到了文件末尾，再次调用不会读取到任何的内容。</p></blockquote><h3 id="👀打开文件的方式"><a href="#👀打开文件的方式" class="headerlink" title="👀打开文件的方式"></a>👀打开文件的方式</h3><p><code>open</code>函数默认以只读方式打开文件，并且返回文件对象语法如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;文件名&quot;</span>,<span class="string">&quot;访问方式&quot;</span>)</span><br></pre></td></tr></table></figure><p>访问方式说明</p><table><thead><tr><th align="center">访问方式</th><th align="left">说明</th></tr></thead><tbody><tr><td align="center"><code>r</code></td><td align="left">以只读方式打开文件。<br />文件的指针将会放在文件的开头，这是默认模式。如果文件不存在，抛出异常。</td></tr><tr><td align="center"><code>w</code></td><td align="left">以只写方式打开文件。<br />如果文件存在会被覆盖。如果文件不存在，创建新文件。</td></tr><tr><td align="center"><code>a</code></td><td align="left">以追加方式打开文件。<br />如果该文件已存在，文件指针将会放在文件的结尾。如果文件不存在，创建新文件进行写入。</td></tr><tr><td align="center"><code>r+</code></td><td align="left">以读写方式打开文件。<br />文件的指针将会放在文件的开头。如果文件不存在，抛出异常。</td></tr><tr><td align="center"><code>w+</code></td><td align="left">以读写方式打开文件。<br />如果文件存在会被覆盖。如果文件不存在，创建新文件。</td></tr><tr><td align="center"><code>a+</code></td><td align="left">以读写方式打开文件。<br />如果该文件已存在，文件指针将会放在文件的结尾。如果文件不存在，创建新文件进行写入。</td></tr></tbody></table><blockquote><p>提示：频繁的移动文件指针，会影响文件的读写效率，开发中更多会以只读、只写的方式来操作文件。</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 写入文件</span></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;README&quot;</span>, <span class="string">&quot;w&quot;</span>)</span><br><span class="line"></span><br><span class="line">f.write(<span class="string">&quot;hello python \n&quot;</span>)</span><br><span class="line">f.write(<span class="string">&quot;我是谁&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭文件</span></span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure><h3 id="👀按行读取文件内容"><a href="#👀按行读取文件内容" class="headerlink" title="👀按行读取文件内容"></a>👀按行读取文件内容</h3><ul><li><code>read</code>方法默认会把文件的<strong>所有内容一次性读取到内存</strong>；</li><li>如果文件太大，对内存的占用会非常严重。</li></ul><p><code>readline</code>方法</p><ul><li><code>readline</code>方法可以一次读取一行内容；</li><li>方法执行后，会把文件指针移动到下一行，准备再次读取。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 读取大文件的正确方法</span></span><br><span class="line"><span class="comment"># 打开文件</span></span><br><span class="line">file=<span class="built_in">open</span>(<span class="string">&quot;README&quot;</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="comment"># 读取一行内容</span></span><br><span class="line">    text=file.readline()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 判断是否读到内容</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> text:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment"># 每读取一行的末尾已经有了一个&#x27;\n&#x27;</span></span><br><span class="line">    <span class="built_in">print</span>(text,end=<span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="comment"># 关闭文件</span></span><br><span class="line">file.close()</span><br></pre></td></tr></table></figure><h3 id="👀文件-x2F-目录常用管理操作os"><a href="#👀文件-x2F-目录常用管理操作os" class="headerlink" title="👀文件&#x2F;目录常用管理操作os"></a>👀文件&#x2F;目录常用管理操作<code>os</code></h3><ul><li>在<strong>终端&#x2F;文件浏览器</strong>中可以执行常规的<strong>文件&#x2F;目录</strong>管理操作，例如：<ul><li>创建、重命名、删除、改变路径、查看目录内容、……</li></ul></li><li>在<code>Python</code>中，如果希望通过程序实现上述功能，需要导入<code>os</code>模块。</li></ul><p>文件操作</p><table><thead><tr><th align="center">序号</th><th>方法名</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td align="center">01</td><td><code>rename</code></td><td>重命名文件</td><td><code>os.rename(源文件名，目标文件名)</code></td></tr><tr><td align="center">02</td><td><code>remove</code></td><td>删除文件</td><td><code>os.remove(文件名)</code></td></tr></tbody></table><p>目录操作</p><table><thead><tr><th align="center">序号</th><th>方法名</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td align="center">01</td><td><code>listdir</code></td><td>目录列表</td><td><code>os.listdir(目录名)</code></td></tr><tr><td align="center">02</td><td><code>mkdir</code></td><td>创建目录</td><td><code>os.mkdir(目录名)</code></td></tr><tr><td align="center">03</td><td><code>rmdir</code></td><td>删除目录</td><td><code>os.rmdir(目录名)</code></td></tr><tr><td align="center">04</td><td><code>getcwd</code></td><td>获取当前目录</td><td><code>os.getcwd()</code></td></tr><tr><td align="center">05</td><td><code>chdir</code></td><td>修改工作目录</td><td><code>os.chdir(目标目录)</code></td></tr><tr><td align="center">06</td><td><code>path.isdir</code></td><td>判断是否是文件</td><td><code>os.path.isdir(文件路径)</code></td></tr></tbody></table><blockquote><p>提示：文件或者目录操作都支持<strong>相对路径</strong>和<strong>绝对路径</strong>。其他操作，可以具体了解<code>os</code>模块详细内容。</p></blockquote><p>文本文件的编码格式（科普）。文本文件存储的内容是基于字符编码的文件,常见的编码有<code>ASCII</code>编码，<code>UNICODE</code>编码等。</p><ul><li><code>Python 2.x</code>默认使用<code>ASCII</code>编码</li><li><code>Python 3.x</code>默认使用<code>UTF-8</code>编码</li></ul><p><code>unicode</code>字符串</p><ul><li>在<code>Python2.x</code>中，即使指定了文件使用<code>UTF-8</code>的编码格式，但是在遍历字符时，仍然会以字节为单位遍历字符串；</li><li>要能够正确的遍历字符串，在定义字符串时，需要在字符串的引号前，增加一个小写字母<code>u</code>，告诉解释器这是一个<code>unicode</code>字符串(使用<code>UTF-8</code>编码格式的字符串)。</li></ul><h2 id="⛄eval-函数"><a href="#⛄eval-函数" class="headerlink" title="⛄eval()函数"></a>⛄<code>eval()</code>函数</h2><p><code>eval()</code>函数十分强大，将<strong>字符串</strong>当成<strong>有效的表达式</strong>来求值并<strong>返回计算结果</strong>，但是不能滥用。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 基本的数学计算</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">eval</span>(<span class="string">&quot;1+1&quot;</span>))</span><br><span class="line"><span class="comment"># 字符串重复</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">eval</span>(<span class="string">&quot;&#x27;*&#x27;*10&quot;</span>))</span><br><span class="line"><span class="comment"># 将字符串转换成列表</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="built_in">eval</span>(<span class="string">&quot;[1,2,3,4,5]&quot;</span>)))</span><br><span class="line"><span class="comment"># 将字符串转换成字典</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="built_in">eval</span>(<span class="string">&quot;&#123;&#x27;name&#x27;:&#x27;xiaoming&#x27;,&#x27;age&#x27;:18&#125;&quot;</span>)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line">**********</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;list&#x27;</span>&gt;</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;dict&#x27;</span>&gt;</span><br></pre></td></tr></table></figure><p>笔者不才，请多交流！！！</p><p>参考文献：黑马程序员《<code>Python</code>入门教程完整版》</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Python基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python面向对象详解</title>
      <link href="/2022/09/18/Python-OOP/"/>
      <url>/2022/09/18/Python-OOP/</url>
      
        <content type="html"><![CDATA[<h2 id="⛄面向对象基本概念"><a href="#⛄面向对象基本概念" class="headerlink" title="⛄面向对象基本概念"></a>⛄面向对象基本概念</h2><p>面向过程和面向对象，是两种不同的编程方式。</p><h3 id="👀面向过程"><a href="#👀面向过程" class="headerlink" title="👀面向过程"></a>👀面向过程</h3><ol><li>把完成某一个需求的所有步骤，<strong>从头到尾</strong>逐步实现；</li><li>根据开发需求，将某些功能独立的代码封装成一个又一个函数；</li><li>最后完成的代码，就是<strong>顺序</strong>地调用不同的函数。</li></ol><p>特点：</p><ul><li>注重<strong>步骤与过程</strong>，不注重职责分工；</li><li>如果需求复杂，代码会变得很复杂；</li><li>开发复杂项目，没有固定的套路，开发难度很大！</li></ul><h3 id="👀面向对象"><a href="#👀面向对象" class="headerlink" title="👀面向对象"></a>👀面向对象</h3><p>相比较函数，面向对象是更大的封装，根据职责在一个对象中封装多个方法。</p><ol><li>在完成某一个需求前，首先确定<strong>职责</strong>——<strong>要做的事情（方法）</strong>；</li><li>根据<strong>职责</strong>确定不同的<strong>对象</strong>，在<strong>对象</strong>内部封装不同的<strong>方法</strong>（多个）；</li><li>最后完成的代码，就是顺序地让<strong>不同的对象</strong>调用<strong>不同的方法</strong>。</li></ol><p>特点</p><ul><li>注重<strong>对象和职责</strong>，不同的对象承担不同的职责；</li><li>更加适合应对复杂的需求变化，是专门应对复杂项目开发，提供的固定套路；</li><li>需要在面向过程基础上，再学习一些面向对象的语法。</li></ul><h2 id="⛄类和对象"><a href="#⛄类和对象" class="headerlink" title="⛄类和对象"></a>⛄类和对象</h2><h3 id="👀类和对象的概念"><a href="#👀类和对象的概念" class="headerlink" title="👀类和对象的概念"></a>👀类和对象的概念</h3><p>类和对象是面向对象编程的两个核心概念。</p><p>（1）类</p><ol><li><p><strong>类</strong>是对一群具有<strong>相同特征</strong>或者<strong>行为</strong>的事物的一个统称，是抽象的，不能直接使用。</p><ul><li><p><strong>特征</strong>被称为<strong>属性</strong>；</p></li><li><p><strong>行为</strong>被称为<strong>方法</strong>；</p></li></ul></li><li><p><strong>类</strong>就相当于制造飞机时的图纸，是一个模板，是<strong>负责创建对象</strong>的</p></li></ol><p>（2）对象</p><ol><li><p><strong>对象</strong>是<strong>由类创建出来的一个具体存在</strong>，可以直接使用。</p></li><li><p>由<strong>哪一个类</strong>创建出来的<strong>对象</strong>，就拥有在<strong>哪一个类</strong>中定义的：</p><ul><li><p>属性</p></li><li><p>方法</p></li></ul></li><li><p><strong>对象</strong>就相当于用图纸制造的飞机。在程序开发中，应该<strong>先有类</strong>，<strong>再有对象</strong>。</p></li></ol><p>（3）类和对象的关系</p><ol><li><strong>类是模板</strong>，对象是根据类这个模板创建出来的，应该<strong>先有类</strong>，<strong>再有对象</strong>。</li><li>类只有一个，而对象可以有很多个<ul><li><strong>不同的对象</strong>之间<strong>属性</strong>可能会各不相同</li></ul></li><li><strong>类</strong>中定义了什么属性和方法，对象中就有什么属性和方法，不可能多，也不可能少。</li></ol><h3 id="👀类的设计"><a href="#👀类的设计" class="headerlink" title="👀类的设计"></a>👀类的设计</h3><p>在程序开发中，要设计一个类，通常需要满足一下三个要素：</p><ol><li><strong>类名</strong>这类事物的名字，满足<strong>大驼峰命名法</strong>；</li><li><strong>属性</strong>这类事物具有什么样的特征；</li><li><strong>方法</strong>这类事物具有什么样的行为。</li></ol><blockquote><p>大驼峰命名法：HelloWorld，每一个单词的首字母大写；单词与单词之间没有下划线。</p></blockquote><p>（1）类名的确定</p><p>名词提炼法分析整个业务流程，出现的名词，通常就是找到的类。</p><p>（2）属性和方法的确定</p><ul><li><strong>对象的特征描述</strong>，通常可以定义成<strong>属性</strong>；</li><li><strong>对象具有的行为</strong>（<strong>动词</strong>），通常可以定义成<strong>方法</strong>。</li></ul><blockquote><p>提示：需求中没有涉及的属性或者方法在设计类时，不需要考虑。</p></blockquote><h2 id="⛄面向对象基础语法"><a href="#⛄面向对象基础语法" class="headerlink" title="⛄面向对象基础语法"></a>⛄面向对象基础语法</h2><h3 id="👀dir-内置函数"><a href="#👀dir-内置函数" class="headerlink" title="👀dir()内置函数"></a>👀dir()内置函数</h3><p>在<code>Python</code>中对象几乎是无所不在的，我们之前学习的<strong>变量</strong>、<strong>数据</strong>、<strong>函数</strong>都是对象。</p><p>在<code>Python</code>中可以使用以下两个方法验证：</p><ol><li>在<strong>标识符&#x2F;数据</strong>后输入一个<code>.</code>，然后按下<code>TAB</code>键，<code>ipython</code>会提示该对象能够调用的<strong>方法列表</strong>。</li><li>使用内置函数<code>dir()</code>传入<strong>标识符&#x2F;数据</strong>，可以查看对象内的<strong>所有属性及方法</strong>。</li></ol><blockquote><p>提示：<code>__方法名__</code>格式的方法是<code>Python</code> 提供的<strong>内置方法&#x2F;属性</strong>。</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">__new__|方法|创建对象时，会被自动调用</span><br><span class="line">__init__|方法|对象被初始化时，会被自动调用</span><br><span class="line">__del__|方法|对象被从内存中销毁前，会被自动调用</span><br><span class="line">__str__|方法|返回对象的描述信息，<span class="built_in">print</span>函数输出使用</span><br></pre></td></tr></table></figure><h3 id="👀定义简单的类"><a href="#👀定义简单的类" class="headerlink" title="👀定义简单的类"></a>👀定义简单的类</h3><p>面向对象是更大的封装，在一个类中封装多个方法，这样通过这个类创建出来的对象，就可以直接调用这些方法了！！</p><p>（1）定义只包含方法的类</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 类名的命名格式符合大驼峰命名法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">类名</span>：</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">方法1</span>(<span class="params">self, 参数列表</span>)：</span><br><span class="line">      <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">方法2</span>(<span class="params">self, 参数列表</span>)：</span><br><span class="line">      <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>方法的定义格式和之前学习过的函数几乎一样；区别在于第一个参数必须是<code>self</code>。</p><p>（2）创建对象</p><p>当一个类定义完成之后，要使用这个类来创建对象：</p><p><code>对象变量 = 类名（）</code></p><h3 id="👀self的使用"><a href="#👀self的使用" class="headerlink" title="👀self的使用"></a>👀<code>self</code>的使用</h3><p>在<code>Python</code>中，给对象设置属性，只需要在类的外部的代码中直接通过<code>.</code>设置一个属性即可（这种方式虽然简单，但是不推荐使用）。</p><ul><li>在类封装的方法内部，<code>self</code>就表示当前调用方法的对象自己；</li><li>由哪一个对象调用的方法，方法内的<code>self</code>就是哪一个对象的引用；</li><li>调用方法时，程序员不需要传递<code>self</code>参数；</li><li>在方法内部，可以通过<code>self.</code>访问对象的属性，可以通过<code>self.</code>调用其它对象方法；</li></ul><blockquote><p>在类的外部，通过<code>变量名.</code>访问对象的属性和方法；</p><p>在类封装的方法中，通过<code>self.</code>访问对象的属性和方法。</p></blockquote><h3 id="👀-init-方法"><a href="#👀-init-方法" class="headerlink" title="👀__init__方法"></a>👀<code>__init__</code>方法</h3><p>在日常开发中，不推荐在<strong>类的外部</strong>给对象增加属性；如果在运行时，没有找到属性，程序会报错；对象应该包含有哪些属性，应该<strong>封装在类的内部</strong>。</p><ol><li><p>当使用<code>类名()</code>创建对象时，会自动执行以下操作：</p><ul><li><p>为对象在内存中分配空间——创建对象</p></li><li><p>为对象的属性设置初始值——初始化方法（<code>__init__</code>）</p></li></ul></li><li><p>这个初始化方法就是<code>__init__</code>方法，<code>__init__</code>是对象的内置方法</p></li></ol><p><code>__init__</code>方法是专门用来定义一个类具有哪些属性的方法！在<code>__init__</code>方法内部使用<code>self.属性名 = 属性的初始值</code>就可以<strong>定义属性</strong>。</p><p>在开发中，如果希望在创建对象的同时，就设置对象的属性，可以对<code>__init__</code>方法进行改造：</p><ul><li>把希望设置的属性值，定义成<code>__init__</code>方法的参数</li><li>在方法内部使用<code>se1f.属性 = 形参</code>接收外部传递的参数</li><li>在创建对象时，使用<code>类名（属性1，属性2..…）</code>调用</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">People</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;初始化方法%s&quot;</span> % self.name)</span><br><span class="line">xt = People(<span class="string">&quot;xiaotang&quot;</span>)</span><br><span class="line">xm = People(<span class="string">&quot;xiaoming&quot;</span>)</span><br><span class="line"><span class="comment"># 使用id()函数查看数据在内存中的地址</span></span><br><span class="line"><span class="built_in">print</span>(xt, <span class="built_in">id</span>(xt))</span><br><span class="line"><span class="built_in">print</span>(xm, <span class="built_in">id</span>(xm))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">初始化方法xiaotang</span><br><span class="line">初始化方法xiaoming</span><br><span class="line">&lt;__main__.People <span class="built_in">object</span> at <span class="number">0x0000027E373FC408</span>&gt; <span class="number">2741116060680</span></span><br><span class="line">&lt;__main__.People <span class="built_in">object</span> at <span class="number">0x0000027E37E98348</span>&gt; <span class="number">2741127185224</span></span><br></pre></td></tr></table></figure><h3 id="👀-del-和-str-方法"><a href="#👀-del-和-str-方法" class="headerlink" title="👀__del__和__str__方法"></a>👀<code>__del__</code>和<code>__str__</code>方法</h3><p>（1）<code>__del__</code>方法</p><ol><li><p>在<code>Python</code>中</p><ul><li><p>当使用<code>类名()</code>创建对象时，为对象分配完空间后，<strong>自动</strong>调用<code>__init__</code>方法；</p></li><li><p>当一个对象被从内存中销毁前，<strong>自动</strong>调用<code>__del__</code>方法。</p></li></ul></li><li><p>应用场景</p><ul><li><p><code>__init__</code>改造初始化方法，可以让创建对象更加灵活；</p></li><li><p><code>__del__</code>如果希望在对象被销毁前，再做一些事情，可以考虑一下<code>__del__</code>方法。</p></li></ul></li><li><p>生命周期</p><ul><li><p>一个对象从调用<code>类名()</code>创建，生命周期开始；</p></li><li><p>一个对象的<code>__del__</code>方法一旦被调用，生命周期结束；</p></li><li><p>在对象的生命周期内，可以访问对象属性，或者让对象调用方法。</p></li></ul></li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">People</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;初始化方法%s&quot;</span> % self.name)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__del__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;对象销毁，%s&quot;</span> % self.name)</span><br><span class="line">xt = People(<span class="string">&quot;xiaotang&quot;</span>)</span><br><span class="line">xm = People(<span class="string">&quot;xiaoming&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(xt, <span class="built_in">id</span>(xt))</span><br><span class="line"><span class="built_in">print</span>(xm, <span class="built_in">id</span>(xm))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">初始化方法xiaotang</span><br><span class="line">初始化方法xiaoming</span><br><span class="line">&lt;__main__.People <span class="built_in">object</span> at <span class="number">0x0000027E37EC63C8</span>&gt; <span class="number">2741127373768</span></span><br><span class="line">&lt;__main__.People <span class="built_in">object</span> at <span class="number">0x0000027E37EC6448</span>&gt; <span class="number">2741127373896</span></span><br><span class="line">对象销毁，xiaotang</span><br><span class="line">对象销毁，xiaoming</span><br></pre></td></tr></table></figure><p>（2）<code>__str__</code>方法</p><ul><li>在<code>Python</code>中，使用<code>print</code> 输出对象变量，默认情况下，会输出这个变量<strong>引用的对象</strong>是由<strong>哪一个类创建的对象</strong>，以及在<strong>内存中的地址</strong>（<strong>十六进制表示</strong>）；</li><li>如果在开发中，希望使用<code>print</code>输出<code>对象变量</code>时，能够打印<strong>自定义的内容</strong>，就可以利用<code>__str__</code>这个内置方法了。</li></ul><p>注意：<code>__str__</code>方法必须返回一个字符串</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">People</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;初始化方法%s&quot;</span> % self.name)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__del__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;对象销毁，%s&quot;</span> % self.name)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;我的名字：%s&quot;</span> % self.name</span><br><span class="line">xt = People(<span class="string">&quot;xiaotang&quot;</span>)</span><br><span class="line">xm = People(<span class="string">&quot;xiaoming&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(xt, <span class="built_in">id</span>(xt))</span><br><span class="line"><span class="built_in">print</span>(xm, <span class="built_in">id</span>(xm))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果（对比上一条代码的输出结果）</span></span><br><span class="line">初始化方法xiaotang</span><br><span class="line">初始化方法xiaoming</span><br><span class="line">我的名字：xiaotang <span class="number">2741123224968</span></span><br><span class="line">我的名字：xiaoming <span class="number">2741127144648</span></span><br><span class="line">对象销毁，xiaotang</span><br><span class="line">对象销毁，xiaoming</span><br></pre></td></tr></table></figure><h2 id="⛄面向对象三个基本特征"><a href="#⛄面向对象三个基本特征" class="headerlink" title="⛄面向对象三个基本特征"></a>⛄面向对象三个基本特征</h2><p>面向对象三大特性：</p><ol><li><p><strong>封装</strong>，根据职责将属性和方法封装到一个抽象的类中。</p><ul><li>定义类的准则</li></ul></li><li><p><strong>继承</strong>，实现代码的重用，相同的代码不需要重复的编写。</p><ul><li><p>设计类的技巧</p></li><li><p>子类针对自己特有的需求，编写特定的代码</p></li></ul></li><li><p><strong>多态</strong>，不同的子类对象调用相同的父类方法，产生不同的执行结果。</p><ul><li><p>多态可以增加代码的灵活度</p></li><li><p>以继承和重写父类方法为前提</p></li><li><p>是调用方法的技巧，不会影响到类的内部设计</p></li></ul></li></ol><h2 id="⛄封装"><a href="#⛄封装" class="headerlink" title="⛄封装"></a>⛄封装</h2><h3 id="👀封装概述"><a href="#👀封装概述" class="headerlink" title="👀封装概述"></a>👀封装概述</h3><ul><li><strong>封装</strong>是面向对象编程的一大特点；</li><li>面向对象编程的第一步，将<strong>属性</strong>和<strong>方法</strong>封装到一个抽象的<strong>类</strong>中；</li><li>外界使用<strong>类</strong>创建<strong>对象</strong>，然后让<strong>对象调用方法</strong>；</li><li>对象方法的<strong>细节</strong>都被<strong>封装</strong>在类的内部；</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Gun</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, model</span>):</span><br><span class="line">        <span class="comment"># 枪的型号</span></span><br><span class="line">        self.model = model</span><br><span class="line">        <span class="comment"># 子弹数量</span></span><br><span class="line">        self.bullet_count = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add_bullet</span>(<span class="params">self, count</span>):</span><br><span class="line">        self.bullet_count += count</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">shoot</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> self.bullet_count &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;没有子弹了&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.bullet_count -= <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%s发射子弹[%d]...&quot;</span>%(self.model, self.bullet_count))</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Soldier</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        <span class="comment"># 姓名</span></span><br><span class="line">        self.name = name</span><br><span class="line">        <span class="comment"># 士兵出事没有枪，None表示什么都没有</span></span><br><span class="line">        self.gun = <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fire</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> self.gun <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;%s没有枪...&quot;</span>% self.name)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;冲啊....[%s]&quot;</span>% self.name)</span><br><span class="line">        self.gun.add_bullet(<span class="number">50</span>)</span><br><span class="line">        self.gun.shoot()</span><br><span class="line">        </span><br><span class="line"><span class="comment"># 创建对象</span></span><br><span class="line">ak47 = Gun(<span class="string">&quot;ak47&quot;</span>)</span><br><span class="line">person = Soldier(<span class="string">&quot;xiaotang&quot;</span>)</span><br><span class="line">person.fire()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">20</span>)</span><br><span class="line">person.gun = ak47</span><br><span class="line">person.fire()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">xiaotang没有枪...</span><br><span class="line">********************</span><br><span class="line">冲啊....[xiaotang]</span><br><span class="line">ak47发射子弹[<span class="number">49</span>]...</span><br></pre></td></tr></table></figure><h3 id="👀is与-x3D-x3D-区别"><a href="#👀is与-x3D-x3D-区别" class="headerlink" title="👀is与&#x3D;&#x3D;区别"></a>👀is与&#x3D;&#x3D;区别</h3><p>（1）身份运算符</p><p>身份运算符用于<strong>比较</strong>两个对象的<strong>内存地址</strong>是否一致，<strong>是否是对同一个对象的引用</strong>。在<code>Python</code>中针对<code>None</code>比较时，建议使用<code>is</code>判断。</p><table><thead><tr><th>运算符</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td><code>is</code></td><td><code>is</code>是判断两个标识符是不是引用同一对象</td><td><code>x is y</code>，类似于<code>id(x) == id(y)</code></td></tr><tr><td><code>is not</code></td><td><code>is not</code>是判断两个标识符是不是引用不同对象</td><td><code>x is not y</code>，类似于<code>id(a) != id(y)</code></td></tr></tbody></table><p>（2）<code>is</code>与<code>==</code>区别</p><p><code>is</code>用于判断<strong>两个变量引用对象是否为同一个</strong>；</p><p><code>==</code>用于判断<strong>引用变量的值</strong>是否相等。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">b = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="built_in">print</span>(b <span class="keyword">is</span> a)</span><br><span class="line"><span class="built_in">print</span>(b == a)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><h3 id="👀私有属性和私有方法"><a href="#👀私有属性和私有方法" class="headerlink" title="👀私有属性和私有方法"></a>👀私有属性和私有方法</h3><ol><li><p>在实际开发中，<strong>对象</strong>的<strong>某些属性</strong>或<strong>方法</strong>可能只希望<strong>在对象的内部被使用</strong>，而<strong>不希望在外部被访问</strong>。</p><ul><li><p><strong>私有属性</strong>就是对象不希望公开的属性；</p></li><li><p><strong>私有方法</strong>就是对象不希望公开的方法；</p></li></ul></li><li><p>在定义属性或方法时，在属性名或者方法名前增加<strong>两个下划线</strong>，定义的就是<strong>私有属性或者方法</strong>。</p><ul><li><p>私有属性&#x2F;方法，在外界不能够被直接访问；</p></li><li><p>在对象的方法内部，是可以访问对象的私有属性&#x2F;方法的。</p></li></ul></li><li><p>伪私有属性和私有方法（不建议使用），Python中，并没有真正意义的私有。</p><ul><li><p>在给属性、方法命名时，实际是对名称做了一些特殊处理，使得外界无法访问到；</p></li><li><p><strong>处理方式</strong>：在名称前面加上<code>_类名</code>，即<code>_类名__名称</code>。</p></li></ul></li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">People</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">        self.__height = <span class="number">180</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__mimi</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;我的身高是%d&quot;</span>% self.__height)</span><br><span class="line"></span><br><span class="line">xiaotang = People(<span class="string">&quot;小汤&quot;</span>, <span class="number">20</span>)</span><br><span class="line"><span class="comment"># 私有属性，外部不能访问</span></span><br><span class="line"><span class="comment"># AttributeError: &#x27;People&#x27; object has no attribute &#x27;__height&#x27;</span></span><br><span class="line"><span class="comment"># print(xiaotang.__height)</span></span><br><span class="line"><span class="comment"># AttributeError: &#x27;People&#x27; object has no attribute &#x27;__mimi&#x27;</span></span><br><span class="line"><span class="comment"># xiaotang.__mimi()   </span></span><br><span class="line"><span class="built_in">print</span>(xiaotang._People__height)   <span class="comment"># 180</span></span><br><span class="line">xiaotang._People__mimi()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="number">180</span></span><br><span class="line">我的身高是<span class="number">180</span></span><br></pre></td></tr></table></figure><h3 id="👀单例设计模式"><a href="#👀单例设计模式" class="headerlink" title="👀单例设计模式"></a>👀单例设计模式</h3><ol><li><p>设计模式</p><ul><li><p><strong>设计模式</strong>是<strong>前人工作的总结和提炼</strong>，通常，被人们广泛流传的设计模式都是针对<strong>某一特定问题</strong>的成熟的解决方案；</p></li><li><p>使用<strong>设计模式</strong>是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。</p></li></ul></li><li><p>单例设计模式</p><ul><li><p><strong>目的</strong>–让类创建的对象，在系统中<strong>只有唯一的一个实例</strong>；</p></li><li><p>每一次执行<code>类名()</code>返回的对象，<strong>内存地址是相同的</strong>。</p></li></ul></li><li><p>单例设计模式的应用场景</p><ul><li><p>音乐播放对象</p></li><li><p>回收站对象</p></li><li><p>打印机对象</p></li></ul></li></ol><p>（1）<code>__new__</code>方法</p><ul><li><p>使用<code>类名()</code>创建对象时，<code>Python</code>的解释器首先会调用<code>__new__</code>方法为对象<strong>分配空间</strong>；</p></li><li><p><code>__new__</code>是一个由<code>object</code>基类提供的<strong>内置的静态方法</strong>，主要作用有两个：</p><ul><li><p>在内存中为对象<strong>分配空间</strong></p></li><li><p><strong>返回对象的引用</strong></p></li></ul></li><li><p><code>Python</code>的解释器获得对象的<strong>引用</strong>后，将引用作为第一个参数，传递给<code>__init__</code>方法。</p></li></ul><p>重写<code>__new__</code>方法的代码非常固定：</p><ul><li>重写<code>__new__</code>方法一定要<code>return super().__new__(cls)</code></li><li>否则<code>Python</code>的解释器得不到分配了空间的对象引用，就不会调用对象的初始化方法</li><li>注意：<code>__new__</code>是一个静态方法，在调用时需要<strong>主动传递</strong><code>cls</code>参数</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MusicPlayer</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">cls</span>):</span><br><span class="line">        <span class="comment"># 创建对象时，new方法会被自动调用</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;分配空间&quot;</span>)</span><br><span class="line">        <span class="comment"># 为对象分配空间，返回对象的引用</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>().__new__(cls)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;初始化&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建对象</span></span><br><span class="line">player = MusicPlayer()</span><br><span class="line"><span class="built_in">print</span>(player)      </span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">分配空间</span><br><span class="line">初始化</span><br><span class="line">&lt;__main__.MusicPlayer <span class="built_in">object</span> at <span class="number">0x000002343B97DD48</span>&gt;</span><br></pre></td></tr></table></figure><p>（2）<code>Python</code>中的单例</p><p>单例——让类创建的对象，在系统中只有唯一的一个实例</p><ul><li>定义一个<strong>类属性</strong>，初始值是<code>None</code>，用于记录<strong>单例对象的引用</strong>；</li><li>重写<code>__new__</code>方法；</li><li>如果<strong>类属性</strong><code>is None</code>，调用父类方法分配空间，并在类属性中记录结果；</li><li>返回<strong>类属性</strong>中记录的<strong>对象引用</strong>。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 单例设计模式实现</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MusicPlayers</span>():</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 记录第一个被创建对象的引用</span></span><br><span class="line">    instance = <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">cls</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;分配空间&quot;</span>)</span><br><span class="line">        <span class="comment"># 判断类属性是否为空对象</span></span><br><span class="line">        <span class="keyword">if</span> cls.instance <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="comment"># 调用父类的方法，为第一个对象分配空间</span></span><br><span class="line">            cls.instance = <span class="built_in">super</span>().__new__(cls)</span><br><span class="line">        <span class="keyword">return</span> cls.instance</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;初始化&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建多个实例,无论调用多少次创建对象类的方法，得到的对象内存地址都是相同的</span></span><br><span class="line">player1 = MusicPlayers()</span><br><span class="line">player2 = MusicPlayers()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(player1)</span><br><span class="line"><span class="built_in">print</span>(player2)   </span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">分配空间</span><br><span class="line">初始化</span><br><span class="line">分配空间</span><br><span class="line">初始化</span><br><span class="line">&lt;__main__.MusicPlayers <span class="built_in">object</span> at <span class="number">0x000002343B945248</span>&gt;</span><br><span class="line">&lt;__main__.MusicPlayers <span class="built_in">object</span> at <span class="number">0x000002343B945248</span>&gt;</span><br></pre></td></tr></table></figure><p>（3）存在的问题</p><p><strong>问题所在</strong></p><ul><li><p>在每次使用<code>类名()</code>创建对象时，<code>Python</code>的解释器都会自动调用两个方法。</p><ul><li><p><code>__new__</code>分配空间</p></li><li><p><code>__init__</code>对象初始化</p></li></ul></li><li><p>在上一小节对<code>__new__</code>方法改造之后，每次都会得到第一次被创建对象的引用。</p></li><li><p>但是：<strong>初始化方法还会被再次调用</strong>。</p></li></ul><p><strong>需求</strong>：让初始化动作只被执行一次。</p><p><strong>解决办法</strong></p><ul><li>定义一个类属性<code>init_flag</code>标记<strong>是否执行过初始化动作</strong>，初始值为<code>False</code>；</li><li>在<code>__init__</code>方法中，判断<code>init_flag</code>，如果为<code>False</code>就执行初始化动作；</li><li>然后将<code>init_flag</code>设置为<code>True</code>；</li><li>这样，再次自动调用<code>__init__</code>方法时，初始化动作就不会被再次执行了。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MPlayers</span>():</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 记录第一个被创建对象的引用</span></span><br><span class="line">    instance = <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 记录是否执行过初始化的动作</span></span><br><span class="line">    init_flag = <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">cls</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;分配空间&quot;</span>)</span><br><span class="line">        <span class="comment"># 判断类属性是否为空对象</span></span><br><span class="line">        <span class="keyword">if</span> cls.instance <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="comment"># 调用父类的方法，为第一个对象分配空间</span></span><br><span class="line">            cls.instance = <span class="built_in">super</span>().__new__(cls)</span><br><span class="line">        <span class="keyword">return</span> cls.instance</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> MPlayers.init_flag:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;初始化了，一次&quot;</span>)</span><br><span class="line">        MPlayers.init_flag = <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line"><span class="comment"># 创建多个实例,无论调用多少次创建对象类的方法，得到的对象内存地址都是相同的</span></span><br><span class="line">player3 = MPlayers()</span><br><span class="line">player4 = MPlayers()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(player3)</span><br><span class="line"><span class="built_in">print</span>(player4)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">分配空间</span><br><span class="line">初始化了，一次</span><br><span class="line">分配空间</span><br><span class="line">&lt;__main__.MPlayers <span class="built_in">object</span> at <span class="number">0x000001E149BB2F08</span>&gt;</span><br><span class="line">&lt;__main__.MPlayers <span class="built_in">object</span> at <span class="number">0x000001E149BB2F08</span>&gt;</span><br></pre></td></tr></table></figure><h2 id="⛄继承"><a href="#⛄继承" class="headerlink" title="⛄继承"></a>⛄继承</h2><h3 id="👀继承概述"><a href="#👀继承概述" class="headerlink" title="👀继承概述"></a>👀继承概述</h3><p>（1）继承的概念：<strong>子类</strong>拥有<strong>父类</strong>的所有<strong>方法</strong>和<strong>属性</strong>。</p><p>（2）继承的语法</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">类名</span>(<span class="title class_ inherited__">父类名</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p><strong>子类</strong>继承自<strong>父类</strong>，可以直接享受父类中已经封装好的方法，不需要再次开发；</p><p><strong>子类</strong>中应该根据职责，封装<strong>子类特有的属性和方法</strong>。</p><blockquote><p>子类        父类<br>派生类    基类</p></blockquote><p>（3）继承的传递性</p><ul><li>C类是B类继承，B类又从A类继承；</li><li>那么C类就具有B类和A类的所有属性和方法；</li><li>子类拥有父类以及父类的父类中封装的所有属性和方法。</li></ul><h3 id="👀方法重写"><a href="#👀方法重写" class="headerlink" title="👀方法重写"></a>👀方法重写</h3><p>（1）方法的重写</p><p><strong>子类</strong>拥有<strong>父类</strong>的所有<strong>方法</strong>和<strong>属性</strong>。</p><p><strong>子类</strong>继承自<strong>父类</strong>，可以直接享受父类中已经封装好的方法，不需要再次开发</p><p>（2）应用场景</p><p>当<strong>父类</strong>的方法实现不能满足子类需求时，可以对方法进行重写（<code>override</code>）</p><p>重写父类方法有两种情况：①覆盖父类的方法；②对父类方法进行扩展。</p><p>①覆盖父类的方法</p><ul><li>如果在开发中，<strong>父类的方法实现</strong>和<strong>子类的方法实现</strong>，<strong>完全不同</strong>；</li><li>就可以使用<strong>覆盖</strong>的方式，在子类中<strong>重新编写</strong>父类的方法实现；</li></ul><blockquote><p>【具体的实现方式】，就相当于在子类中定义了一个和父类同名的方法并且实现。</p><p>重写之后，在运行时，只会调用子类中重写的方法，而不再会调用父类封装的方法</p></blockquote><p>②对父类方法进行扩展</p><p>如果在开发中，子类的方法实现中包含父类的方法实现，父类原本封装的方法实现是子类方法的一部分。</p><p>使用扩展的方式：</p><ul><li>在子类中重写父类的方法；</li><li>在需要的位置使用<code>super().父类方法</code>来调用父类方法的执行；</li><li>代码其他的位置针对子类的需求，编写<strong>子类特有的代码</strong>实现。</li></ul><p>（3）<code>super</code></p><ul><li>在<code>Python</code>中<code>super</code>是一个特殊的类；</li><li><code>super()</code>就是使用<code>super</code>类创建出来的对象；</li><li>最常使用的场景就是在重写父类方法时，调用在父类中封装的方法实现。</li></ul><p>（4）调用父类方法的另外一种方式（知道）</p><p>在<code>Python 2.x</code>时，如果需要调用父类的方法,还可以使用以下方式：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">父类名.方法(self)</span><br></pre></td></tr></table></figure><ul><li>这种方式,目前在Python 3.x还支持这种方式</li><li>这种方法不推荐使用，因为一旦父类发生变化，方法调用位置的类名同样需要修改</li></ul><blockquote><p>提示：</p><p>在开发时，父类名和<code>super()</code>两种方式不要混用；</p><p>如果使用当前子类名调用方法，会形成递归调用，出现死循环。</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">People</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">language</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;地球语言:汉语、俄语、西班牙语、英语、德语...&quot;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(<span class="title class_ inherited__">People</span>):</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">language</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>().language()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%s是中国人，说汉语&quot;</span>%self.name)</span><br><span class="line">    </span><br><span class="line">xiaotang = Person(<span class="string">&quot;小汤&quot;</span>) </span><br><span class="line"><span class="built_in">print</span>(xiaotang.name)</span><br><span class="line">xiaotang.language()  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">小汤</span><br><span class="line">地球语言:汉语、俄语、西班牙语、英语、德语...</span><br><span class="line">小汤是中国人，说汉语</span><br></pre></td></tr></table></figure><h3 id="👀父类的私有属性和私有方法"><a href="#👀父类的私有属性和私有方法" class="headerlink" title="👀父类的私有属性和私有方法"></a>👀父类的私有属性和私有方法</h3><p>父类的私有属性和私有方法</p><ul><li>子类对象<strong>不能</strong>在自己的方法内部，直接访问父类的私有属性或私有方法；</li><li>子类对象可以通过父类的公有方法<strong>间接访问</strong>私有属性或私有方法。</li></ul><blockquote><p><strong>私有属性、方法</strong>是对象的隐私，不对外公开，<strong>外界</strong>以及<strong>子类</strong>都不能直接访问；</p><p><strong>私有属性、方法</strong>通常用于做一些内部的事情。</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">People</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        <span class="comment"># 私有属性</span></span><br><span class="line">        self.__num = <span class="number">8000000000</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">language</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;地球语言:汉语、俄语、西班牙语、英语、德语...&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 私有方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__protect</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;人数：%d，这是一个秘密&quot;</span>% self.__num)</span><br><span class="line">   </span><br><span class="line"><span class="comment"># 通过公有方法间接调用私有属性和私有方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">people_num</span>(<span class="params">self</span>):</span><br><span class="line">        self.__protect()</span><br><span class="line">    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(<span class="title class_ inherited__">People</span>):</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">language</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>().language()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%s是中国人，说汉语&quot;</span>%self.name)</span><br><span class="line">        <span class="comment"># 访问父类中私有方法,是访问不到的</span></span><br><span class="line">        <span class="comment"># self.__protect()</span></span><br><span class="line">        self.people_num()</span><br><span class="line">        </span><br><span class="line">xiaotang = Person(<span class="string">&quot;小汤&quot;</span>) </span><br><span class="line"><span class="built_in">print</span>(xiaotang.name)</span><br><span class="line"><span class="comment"># 访问父类中私有属性,是访问不到的</span></span><br><span class="line"><span class="comment"># print(xiaotang.__num)</span></span><br><span class="line">xiaotang.language()  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">小汤</span><br><span class="line">地球语言:汉语、俄语、西班牙语、英语、德语...</span><br><span class="line">小汤是中国人，说汉语</span><br><span class="line">人数：<span class="number">8000000000</span>，这是一个秘密</span><br></pre></td></tr></table></figure><h3 id="👀多继承"><a href="#👀多继承" class="headerlink" title="👀多继承"></a>👀多继承</h3><p>子类可以拥有多个父类，并且具有所有父类的属性和方法。</p><p>例如：孩子会继承父亲和母亲的特性</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 语法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">子类名</span>(父类名<span class="number">1</span>,父类名<span class="number">2.</span>..):</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p><strong>多继承的使用注意事项</strong></p><p>​    如果<strong>不同的父类</strong>中存在<strong>同名的方法</strong>，<strong>子类</strong>对象在调用方法时，会调用<strong>哪一个父类</strong>中的方法。开发时，应该尽量避免这种容易产生混淆的情况！如果父类之间存在同名的属性或方法，应该尽量避免使用多继承。</p><p><code>python</code>中的<code>MRO</code>—-方法搜索顺序（了解）</p><ul><li><code>python</code>中针对类提供了一个内置属性<code>__mro__</code>可以查看方法的搜索顺序。</li><li><code>MRO</code>是<code>method resolution order</code>，主要用于在<strong>多继承时判断方法、属性的调用路径</strong>。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(*.__mro__)</span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">(&lt;<span class="keyword">class</span> <span class="string">&#x27;__main__.*&#x27;</span>&gt;,&lt;<span class="keyword">class</span> <span class="string">&#x27;__main__.*&#x27;</span>&gt;,&lt;<span class="keyword">class</span> <span class="string">&#x27;object&#x27;</span>&gt;)</span><br></pre></td></tr></table></figure><ul><li>在搜索方法时，是按照<code>__mro__</code>的输出结果从左至右的顺序查找的；</li><li>如果在当前类中找到方法，就直接执行，不再搜索；</li><li>如果没有找到，就查找下一个类中是否有对应的方法，如果找到，就直接执行，不再搜索；</li><li>如果找到最后一个类，还没有找到方法，程序报错。</li></ul><h3 id="👀新式类与旧式-经典-类"><a href="#👀新式类与旧式-经典-类" class="headerlink" title="👀新式类与旧式(经典)类"></a>👀新式类与旧式(经典)类</h3><p><code>object</code> 是<code>Python</code>为所有对象提供的基类，提供有一些内置的属性和方法，可以使用<code>dir</code>函数查看。</p><ul><li>新式类：以<code>object</code>为基类的类，推荐使用；</li><li>经典类：不以<code>object</code>为基类的类，不推荐使用；</li><li>在<code>Python 3.x</code>中定义类时，如果没有指定父类，会默认使用<code>object</code>作为该类的基类–<code>Python 3.x</code>中定义的类都是新式类；</li><li>在<code>Python 2.x</code>中定义类时，如果没有指定父类，则不会以<code>object</code>作为基类。</li></ul><blockquote><p>​    新式类和经典类在多继承时–会影响到方法的搜索顺序</p></blockquote><p>为了保证编写的代码能够同时在<code>Python 2.x</code>和<code>Python 3.x</code>运行！今后在定义类时，如果没有父类，建议统一继承自<code>object</code>。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 语法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">类名</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><h2 id="⛄多态"><a href="#⛄多态" class="headerlink" title="⛄多态"></a>⛄多态</h2><p><strong>多态</strong>，不同的子类对象调用相同的父类方法，产生不同的执行结果。</p><ul><li><p>多态可以增加代码的灵活度</p></li><li><p>以继承和重写父类方法为前提</p></li><li><p>是调用方法的技巧，不会影响到类的内部设计</p></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">game</span>(<span class="params">self</span>):</span><br><span class="line">         <span class="built_in">print</span>(<span class="string">&quot;%s简单的玩耍&quot;</span>%self.name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">T_Dog</span>(<span class="title class_ inherited__">Dog</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">game</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%s在天上玩耍&quot;</span>%self.name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">game_with_dog</span>(<span class="params">self, dog</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%s和%s一起快乐的玩耍&quot;</span>%(self.name, dog.name))</span><br><span class="line">        dog.game()</span><br><span class="line"><span class="comment"># 定义一个狗对象</span></span><br><span class="line"><span class="comment"># wangcai = Dog(&quot;旺财&quot;)</span></span><br><span class="line">wangcai = T_Dog(<span class="string">&quot;飞天旺财&quot;</span>)</span><br><span class="line"><span class="comment"># 定义一个小明对象</span></span><br><span class="line">X_Ming = Person(<span class="string">&quot;小明&quot;</span>)</span><br><span class="line"><span class="comment"># 调用一起玩耍的方法</span></span><br><span class="line">X_Ming.game_with_dog(wangcai)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">小明和飞天旺财一起快乐的玩耍</span><br><span class="line">飞天旺财在天上玩耍</span><br></pre></td></tr></table></figure><h2 id="⛄类属性和类方法"><a href="#⛄类属性和类方法" class="headerlink" title="⛄类属性和类方法"></a>⛄类属性和类方法</h2><h3 id="👀类的结构"><a href="#👀类的结构" class="headerlink" title="👀类的结构"></a>👀类的结构</h3><p>（1）实例</p><p>使用<code>类名()</code>创建对象（分配空间、对象初始化）后，内存中就有了一个对象的实实在在的存在–实例。</p><ul><li>创建出来的<strong>对象</strong>叫做类的<strong>实例</strong>；</li><li>创建对象的<strong>动作</strong>叫做<strong>实例化</strong>；</li><li><strong>对象的属性</strong>叫做<strong>实例属性</strong>；</li><li><strong>对象调用的方法</strong>叫做<strong>实例方法</strong>。</li></ul><p>在程序执行时：</p><ul><li><p>对象各自拥有自己的<strong>实例属性</strong>；</p></li><li><p>调用对象方法，可以通过<code>self.</code></p><ul><li><p>访问自己的属性</p></li><li><p>调用自己的方法</p></li></ul></li></ul><p>结论</p><ul><li>每一个对象都有自己独立的内存空间，保存各自不同的属性；</li><li>多个对象的方法，在内存中只有一份，在调用方法时，需要把对象的引用传递到方法内部。</li></ul><p>（2）类是一个特殊的对象</p><blockquote><p><code>Python</code> 中一切皆对象：</p><ul><li><code>class AAA</code>：定义的类属于<strong>类对象</strong></li><li><code>obj1=AAA()</code> 属于<strong>实例对象</strong></li></ul></blockquote><ul><li><p>在程序运行时，<strong>类</strong>同样会被加载到内存；</p></li><li><p>在<code>Python</code>中，<strong>类</strong>是一个特殊的对象–类对象；</p></li><li><p>在程序运行时，<strong>类对象</strong>在内存中<strong>只有一份</strong>，使用一个类可以<strong>创建出很多个对象实例</strong>；</p></li><li><p>除了封装<strong>实例</strong>的<strong>属性</strong>和<strong>方法</strong>外，<strong>类对象</strong>还可以拥有自己的<strong>属性</strong>和<strong>方法</strong>：</p><ul><li><p>类属性</p></li><li><p>类方法</p></li></ul></li><li><p>通过<code>类名.</code>的方式可以<strong>访问类的属性</strong>或者<strong>调用类的方法</strong>。</p><ul><li><p><code>类名.类属性</code></p></li><li><p><code>类名.方法名()</code></p></li></ul></li></ul><h3 id="👀类属性和实例属性"><a href="#👀类属性和实例属性" class="headerlink" title="👀类属性和实例属性"></a>👀类属性和实例属性</h3><p>（1）概念和使用</p><ul><li><strong>类属性</strong>就是在类对象中定义的属性；</li><li>通常用来记录与这个类相关的<strong>特征</strong>；</li><li><strong>类属性</strong>不会用于记录具体对象的特征。</li></ul><p>（2）属性的获取机制</p><p>在<code>Python</code>中属性的获取存在一个向上查找机制。因此，要访问类属性有两种方式：</p><ul><li><code>类名.类属性</code></li><li><code>对象.类属性</code>(不推荐)，遵循向上查找机制（先在对象内部查找，没有就会向上查找类属性）</li></ul><blockquote><p>注意：如果使用【对象.类属性&#x3D;值赋值语句】，只会给对象添加一个属性，而不会影响到类属性的值。</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Tool</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="comment"># 使用赋值语句,定义类属性,记录创建工具对象的总数</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        <span class="comment"># 计数</span></span><br><span class="line">        Tool.count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建工具对象</span></span><br><span class="line">tool1 = Tool(<span class="string">&quot;钳子&quot;</span>)</span><br><span class="line">tool2 = Tool(<span class="string">&quot;斧头&quot;</span>)</span><br><span class="line">tool3 = Tool(<span class="string">&quot;锤子&quot;</span>)</span><br><span class="line"><span class="comment"># 使用Tool类创建了多少个对象</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;现在创建了%d个工具&quot;</span>% Tool.count)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">现在创建了<span class="number">3</span>个工具</span><br></pre></td></tr></table></figure><h3 id="👀类方法和静态方法"><a href="#👀类方法和静态方法" class="headerlink" title="👀类方法和静态方法"></a>👀类方法和静态方法</h3><p>（1）类方法</p><p><strong>类属性</strong>就是针对<strong>类对象</strong>定义的<strong>属性</strong></p><ul><li>使用赋值语句在<code>class</code>关键字下方可以定义类属性；</li><li>类属性用于记录与这个类相关的特征。</li></ul><p><strong>类方法</strong>就是针对<strong>类对象</strong>定义的<strong>方法</strong></p><ul><li>在<strong>类方法</strong>内部可以直接访问<strong>类属性</strong>或者<strong>调用其他的类方法</strong>。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 语法</span></span><br><span class="line"><span class="meta">@classmethod </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">类方法名</span>(<span class="params">cls</span>):</span><br><span class="line"><span class="keyword">pass</span></span><br></pre></td></tr></table></figure><ul><li><p>类方法需要用<strong>修饰器</strong><code>@classmethod</code>来标识,告诉解释器这是一个类方法。</p></li><li><p>类方法的<strong>第一个参数</strong>应该是<code>cls</code></p><ul><li><p>由<strong>哪一个类</strong>调用的方法，方法内的<code>cls</code>就是<strong>哪一个类的引用</strong>；</p></li><li><p>这个<strong>参数</strong>和<strong>实例方法</strong>的第一个参数是<code>self</code>类似；</p></li><li><p>提示：使用其他名称也可以，不过习惯使用<code>cls</code>。</p></li></ul></li><li><p>通过<code>类名.</code>调用<strong>类方法</strong>，调用方法时，不需要传递<code>cls</code>参数。</p></li><li><p>在方法内部</p><ul><li><p>可以通过<code>c1s.</code><strong>访问类的属性</strong></p></li><li><p>也可以通过<code>c1s.</code><strong>调用其他的类方法</strong></p></li></ul></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Tool</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="comment"># 使用赋值语句,定义类属性,记录创建工具对象的总数</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        <span class="comment"># 计数</span></span><br><span class="line">        Tool.count += <span class="number">1</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">show_tool_count</span>(<span class="params">cls</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;工具对象的总数:%d&quot;</span> % cls.count)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建工具对象</span></span><br><span class="line">tool1 = Tool(<span class="string">&quot;钳子&quot;</span>)</span><br><span class="line">tool2 = Tool(<span class="string">&quot;斧头&quot;</span>)</span><br><span class="line">tool3 = Tool(<span class="string">&quot;锤子&quot;</span>)</span><br><span class="line"><span class="comment"># 使用Tool类创建了多少个对象</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;现在创建了%d个工具&quot;</span>% Tool.count)</span><br><span class="line">Tool.show_tool_count()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">现在创建了<span class="number">3</span>个工具</span><br><span class="line">工具对象的总数:<span class="number">3</span></span><br></pre></td></tr></table></figure><blockquote><p>在类方法内部，可以直接使用<code>cls</code>访问类属性或者调用类方法。</p></blockquote><p>（2）静态方法</p><ul><li><p>在开发时，如果需要在类中封装一个方法，这个方法：</p><ul><li><p>既<strong>不需要</strong>访问<strong>实例属性</strong>或者调用<strong>实例方法</strong></p></li><li><p>也<strong>不需要</strong>访问<strong>类属性</strong>或者调用<strong>类方法</strong></p></li></ul></li><li><p>这个时候，可以把这个方法封装成一个<strong>静态方法</strong>语法如下。</p></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 语法</span></span><br><span class="line"><span class="meta">@staticmethod </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">静态方法名</span>():</span><br><span class="line"><span class="keyword">pass</span></span><br></pre></td></tr></table></figure><ul><li><p>静态方法需要用修饰器<code>@staticmethod</code> 来标识，告诉解释器这是一个静态方法。</p></li><li><p>通过<code>类名.</code>调用静态方法，不需要创建对象。</p></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Game</span>:</span><br><span class="line">    <span class="comment"># 类属性</span></span><br><span class="line">    top_score = <span class="number">100</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 实例属性,在初始化方法内部定义</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,player_name</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.name = player_name</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 静态方法</span></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">show_help</span>():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;帮助信息&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 类方法</span></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">show_top_score</span>(<span class="params">cls</span>):</span><br><span class="line">        <span class="comment"># print(&quot;历史最高分：%d&quot;%Game.top_score)</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;历史最高分：%d&quot;</span>%cls.top_score)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 实例方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">start_game</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%s开始的游戏&quot;</span>%self.name)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 【类名.】</span></span><br><span class="line">Game.show_help()</span><br><span class="line">Game.show_top_score()</span><br><span class="line"><span class="comment"># 创建对象，【对象.】</span></span><br><span class="line">Tom = Game(<span class="string">&quot;小汤&quot;</span>)</span><br><span class="line">Tom.start_game()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">帮助信息</span><br><span class="line">历史最高分：<span class="number">100</span></span><br><span class="line">小汤开始的游戏</span><br></pre></td></tr></table></figure><blockquote><p>小结</p><ol><li>实例方法–方法内部需要访问<strong>实例属性</strong></li><li>实例方法–方法内部可以使用<code>类名.</code>访问<strong>类属性</strong></li><li>类方法–方法内部<strong>只需要</strong>访问<strong>类属性</strong>，或<strong>类方法</strong></li><li>静态方法–方法内部，<strong>不需要访问</strong>实例属性和类属性</li></ol><p>如果方法内部即需要访问实例属性，又需要访问类属性，应该定义成什么方法？(实例方法)</p></blockquote><p>笔者不才，请多交流！！！</p><p>参考文献：黑马程序员《<code>Python</code>入门教程完整版》</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Python基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python小知识点</title>
      <link href="/2022/09/17/Python-Add05/"/>
      <url>/2022/09/17/Python-Add05/</url>
      
        <content type="html"><![CDATA[<h2 id="⛄变量的应用"><a href="#⛄变量的应用" class="headerlink" title="⛄变量的应用"></a>⛄变量的应用</h2><p>变量和数据都是保存在内存中的，在<code>Python</code>中函数的参数传递以及返回值都是通过引用传递的。</p><h3 id="👀引用的概念"><a href="#👀引用的概念" class="headerlink" title="👀引用的概念"></a>👀引用的概念</h3><p>在<code>Python</code>中：</p><ul><li>变量和数据是分开存储的；</li><li>数据保存在内存中的一个位置；</li><li>变量中保存着数据在内存中的地址；</li><li>变量中记录数据的地址，就叫作<strong>引用</strong>；</li><li>使用<strong>id()<strong>函数可以查看变量中保存数据所在的</strong>内存地址</strong>。</li></ul><blockquote><p>注意：如果变量已经被定义，当给一个变量赋值的时候，本质上是修改了数据的引用。</p><ul><li>变量不再对之前的数据引用；</li><li>变量改为对新赋值的数据引用。</li></ul></blockquote><h3 id="👀函数的参数和返回值的传递"><a href="#👀函数的参数和返回值的传递" class="headerlink" title="👀函数的参数和返回值的传递"></a>👀函数的参数和返回值的传递</h3><p>在<code>Python</code>中，函数的实参&#x2F;返回值都是通过引用来传递的。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">mytest</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">50</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;%d 在函数内的内存地址是%x&quot;</span> % (n,<span class="built_in">id</span>(n)))</span><br><span class="line">    </span><br><span class="line">    result = <span class="number">10000</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;返回值%d在函数内的内存地址是%x&quot;</span> % (result,<span class="built_in">id</span>(result)))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">50</span>)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">a = <span class="number">100</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;调用函数前，内存地址是%x&quot;</span> % <span class="built_in">id</span>(a))</span><br><span class="line">r = mytest(a)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;调用函数后，实参内存地址是%x&quot;</span> % <span class="built_in">id</span>(a))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;调用函数前，返回值内存地址是%x&quot;</span> % <span class="built_in">id</span>(r))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">调用函数前，内存地址是7ffd3378adf0</span><br><span class="line">**************************************************</span><br><span class="line"><span class="number">100</span> 在函数内的内存地址是7ffd3378adf0</span><br><span class="line">返回值<span class="number">10000</span>在函数内的内存地址是1cd96276b70</span><br><span class="line">**************************************************</span><br><span class="line">调用函数后，实参内存地址是7ffd3378adf0</span><br><span class="line">调用函数前，返回值内存地址是1cd96276b70</span><br></pre></td></tr></table></figure><h2 id="⛄可变和不可变类型"><a href="#⛄可变和不可变类型" class="headerlink" title="⛄可变和不可变类型"></a>⛄可变和不可变类型</h2><ol><li><p>不可变类型，内存中的数据不允许被修改：</p><ul><li><p>数字类型：<code>int</code>、<code>bool</code>、<code>float</code>、<code>complex</code>、<code>long</code></p></li><li><p>字符串：<code>str</code></p></li><li><p>元组：<code>tuple</code></p></li></ul></li><li><p>可变类型，内存中的数据可以被修改：</p><ul><li><p>列表：<code>list</code></p></li><li><p>字典：<code>dict</code>，字典中的<code>key</code>只能使用不可变类型的数据</p></li></ul></li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">emo_list = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;定义列表后内存地址是%d&quot;</span> % <span class="built_in">id</span>(demo_list))</span><br><span class="line"></span><br><span class="line">demo_list.append(<span class="number">10</span>)</span><br><span class="line">demo_list.remove(<span class="number">1</span>)</span><br><span class="line">demo_list[<span class="number">0</span>] = <span class="number">30</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;修改数据后内存地址是%d&quot;</span> % <span class="built_in">id</span>(demo_list))</span><br><span class="line"></span><br><span class="line">demo_dict = &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;小李子&quot;</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;定义字典后内存地址是%d&quot;</span> % <span class="built_in">id</span>(demo_dict))</span><br><span class="line"></span><br><span class="line">demo_dict[<span class="string">&quot;age&quot;</span>] = <span class="number">20</span></span><br><span class="line">demo_dict[<span class="string">&quot;name&quot;</span>] = <span class="string">&quot;小喜子&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;修改数据后内存地址是%d&quot;</span> % <span class="built_in">id</span>(demo_dict))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">定义列表后内存地址是<span class="number">1982499211272</span></span><br><span class="line">修改数据后内存地址是<span class="number">1982499211272</span></span><br><span class="line">定义字典后内存地址是<span class="number">1982498720808</span></span><br><span class="line">修改数据后内存地址是<span class="number">1982498720808</span></span><br></pre></td></tr></table></figure><p>可变类型的数据变化，是通过方法来实现的；如果给一个可变类型的变量，赋值一个新的数据，引用会修改：</p><ul><li>变量不再对之前的数据引用；</li><li>变量改为对新赋值的数据引用</li></ul><h2 id="⛄局部变量和全局变量"><a href="#⛄局部变量和全局变量" class="headerlink" title="⛄局部变量和全局变量"></a>⛄局部变量和全局变量</h2><p><strong>局部变量</strong>是在<strong>函数内部</strong>定义的变量，只能在函数内部使用；函数执行结束后，函数内部的局部变量，会被系统回收；不同的函数，可以定义相同名字的局部变量，但是彼此之间不会产生影响；</p><p>局部变量的生命周期：</p><ul><li>所谓<strong>生命周期</strong>就是变量从<strong>被创建</strong>到<strong>被系统回收</strong>的过程；</li><li>局部变量在函数执行时才会被创建；</li><li>函数执行结束后，局部变量被系统回收；</li><li>局部变量在生命周期内，可以用来存储函数内部临时使用到的数据。</li></ul><p><strong>全局变量</strong>是在<strong>函数外部</strong>定义的变量，所有函数内部都可以使用这个变量。（不推荐使用，不易维护）</p><blockquote><p>注意：函数执行时，需要处理变量时，会首先查找函数内部是否存在指定名称的局部变量，如果有，直接使用；如果没有，查找函数外部是否存在指定名称的全局变量，如果有，直接使用；如果还没有，程序报错！！！</p><p>注意：如果在函数内部定义了一个与全局变量同名的局部变量，只是变量名相同，不能直接修改全局变量的值。</p></blockquote><p>如果在函数中需要修改全局变量，需要使用<code>global</code>进行声明。</p><h2 id="⛄函数进阶"><a href="#⛄函数进阶" class="headerlink" title="⛄函数进阶"></a>⛄函数进阶</h2><h3 id="👀函数参数和返回值的作用"><a href="#👀函数参数和返回值的作用" class="headerlink" title="👀函数参数和返回值的作用"></a>👀函数参数和返回值的作用</h3><p>定义函数时，是否接收参数，或者是否返回结果，是根据实际的功能需求来确定的。</p><ul><li>如果函数内部处理的数据不确定，就可以将外界的数据以参数传递到函数内部；</li><li>如果希望一个函数执行完成后，向外界汇报执行结果，就可以增加函数的返回值。</li></ul><blockquote><p>如果全局变量的数据类型是一个可变类型，在函数内部可以使用方法修改全局变量的内容，变量的引用不会改变；在函数内部，通过赋值语句才会修改变量的引用。</p></blockquote><h3 id="👀函数的返回值进阶"><a href="#👀函数的返回值进阶" class="headerlink" title="👀函数的返回值进阶"></a>👀函数的返回值进阶</h3><ul><li>程序开发中，希望一个函数执行结束后，告诉调用者一个结果，以便调用者针对具体的结果做后续的处理；</li><li>返回值是函数完成工作后，最后给调用者的一个结果；</li><li>在函数中使用<code>return</code>关键字可以返回结果；</li><li>调用函数一方，可以使用变量来接收函数的返回结果。</li></ul><blockquote><ul><li>注意：如果一个函数执行后返回多个结果，可以利用元组，元祖括号可以省略；</li><li>返回结果也是一个元组，可以将元组返回值赋值给<strong>一个变量</strong>或者<strong>相同个数的多个变量</strong>。</li></ul></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">my_description</span>():</span><br><span class="line">    stu = <span class="string">&quot;00000001&quot;</span></span><br><span class="line">    name = <span class="string">&quot;xiaotang&quot;</span></span><br><span class="line">    age = <span class="number">20</span></span><br><span class="line">    height = <span class="number">180</span></span><br><span class="line">    <span class="comment"># return (stu, name, age, height) 括号可以省略</span></span><br><span class="line">    <span class="keyword">return</span> stu, name, age, height</span><br><span class="line">stu, name, age, height = my_description()</span><br><span class="line"><span class="built_in">print</span>(stu, name, age, height)</span><br><span class="line">my_des = my_description()</span><br><span class="line"><span class="built_in">print</span>(my_des)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">00000001 xiaotang <span class="number">20</span> <span class="number">180</span></span><br><span class="line">(<span class="string">&#x27;00000001&#x27;</span>, <span class="string">&#x27;xiaotang&#x27;</span>, <span class="number">20</span>, <span class="number">180</span>)</span><br></pre></td></tr></table></figure><p>例如：利用元组交换两个数字</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">10</span></span><br><span class="line">b = <span class="number">5</span></span><br><span class="line"><span class="comment"># (1)使用中间变量</span></span><br><span class="line">c = b</span><br><span class="line">b = a</span><br><span class="line">a = c</span><br><span class="line"><span class="built_in">print</span>(a, b)</span><br><span class="line"><span class="comment"># (2)不使用中间变量</span></span><br><span class="line">a = <span class="number">10</span></span><br><span class="line">b = <span class="number">5</span></span><br><span class="line">a = a + b</span><br><span class="line">b = a - b</span><br><span class="line">a = a - b</span><br><span class="line"><span class="built_in">print</span>(a, b)</span><br><span class="line">a = <span class="number">10</span></span><br><span class="line">b = <span class="number">5</span></span><br><span class="line"><span class="comment"># 利用元祖</span></span><br><span class="line">a, b = b, a</span><br><span class="line"><span class="built_in">print</span>(a, b)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="number">5</span> <span class="number">10</span></span><br><span class="line"><span class="number">5</span> <span class="number">10</span></span><br><span class="line"><span class="number">5</span> <span class="number">10</span></span><br></pre></td></tr></table></figure><h3 id="👀函数的参数进阶"><a href="#👀函数的参数进阶" class="headerlink" title="👀函数的参数进阶"></a>👀函数的参数进阶</h3><h4 id="（1）不可变和可变的参数"><a href="#（1）不可变和可变的参数" class="headerlink" title="（1）不可变和可变的参数"></a><strong>（1）不可变和可变的参数</strong></h4><p>在函数内部，针对参数使用赋值语句，不会影响调用函数时传递的实参变量。</p><ul><li>无论传递的参数是可变还是不可变，只要针对参数使用<strong>赋值语句</strong>，会在函数内部<strong>修改</strong>局部变量的引用，<strong>不会影响</strong>到外部变量的引用。</li><li>如果传递的参数是<strong>可变类型</strong>，在函数内部，使用<strong>方法</strong>修改了数据的内容，同样<strong>会影响</strong>到外部的数据。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">demo1</span>(<span class="params">num, num_list</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;函数内部&quot;</span>)</span><br><span class="line">    <span class="comment"># 赋值语句</span></span><br><span class="line">    num = <span class="number">200</span></span><br><span class="line">    num_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">    <span class="built_in">print</span>(num)</span><br><span class="line">    <span class="built_in">print</span>(num_list)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;函数执行完成&quot;</span>)</span><br><span class="line"></span><br><span class="line">gl_num = <span class="number">99</span></span><br><span class="line">gl_list = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">demo1(gl_num, gl_list)</span><br><span class="line"><span class="built_in">print</span>(gl_num)</span><br><span class="line"><span class="built_in">print</span>(gl_list)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">50</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">demo2</span>(<span class="params">num_list</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;函数内部&quot;</span>)</span><br><span class="line">    <span class="comment"># 赋值语句</span></span><br><span class="line">    num_list.extend([<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>])</span><br><span class="line">    <span class="built_in">print</span>(num_list)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;函数执行完成&quot;</span>)</span><br><span class="line"></span><br><span class="line">gl_list = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">demo2(gl_list)</span><br><span class="line"><span class="built_in">print</span>(gl_list)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">函数内部</span><br><span class="line"><span class="number">200</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">函数执行完成</span><br><span class="line"><span class="number">99</span></span><br><span class="line">[<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">**************************************************</span><br><span class="line">函数内部</span><br><span class="line">[<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br><span class="line">函数执行完成</span><br><span class="line">[<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br></pre></td></tr></table></figure><p>在<code>Python</code>中，列表变量调用<code>+=</code>本质上是在执行列表变量的<code>extend()</code>方法，不会修改变量的引用。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">demo3</span>(<span class="params">num, num_list</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;函数内部&quot;</span>)</span><br><span class="line">    <span class="comment"># 赋值语句</span></span><br><span class="line">    num = <span class="number">200</span></span><br><span class="line">    num_list += [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">    <span class="built_in">print</span>(num)</span><br><span class="line">    <span class="built_in">print</span>(num_list)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;函数执行完成&quot;</span>)</span><br><span class="line"></span><br><span class="line">gl_num = <span class="number">99</span></span><br><span class="line">gl_list = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">demo3(gl_num, gl_list)</span><br><span class="line"><span class="built_in">print</span>(gl_num)</span><br><span class="line"><span class="built_in">print</span>(gl_list)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">函数内部</span><br><span class="line"><span class="number">200</span></span><br><span class="line">[<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">函数执行完成</span><br><span class="line"><span class="number">99</span></span><br><span class="line">[<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure><h4 id="（2）缺省参数"><a href="#（2）缺省参数" class="headerlink" title="（2）缺省参数"></a><strong>（2）缺省参数</strong></h4><ul><li>定义函数时，可以给某个参数指定一个默认值，具有默认值的参数就叫做<strong>缺省参数</strong>；</li><li>调用函数时，如果没有传入<strong>缺省参数</strong>的值，则在函数内部使用定义函数时指定的<strong>参数默认值</strong>；</li><li>函数的缺省参数，将<strong>常见的值</strong>设置为参数的缺省值，从而简化函数的调用。</li></ul><p>例如：对列表排序的方法</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">num_list = [<span class="number">6</span>, <span class="number">4</span>, <span class="number">8</span>]</span><br><span class="line"><span class="comment"># 默认就是升序排序,因为这种应用需求更多</span></span><br><span class="line">num_list.sort()</span><br><span class="line"><span class="built_in">print</span>(num_list)</span><br><span class="line"><span class="comment"># 当需要降序排序时, 才需要传递&quot;reverse&quot;参数</span></span><br><span class="line">num_list.sort(reverse=<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(num_list)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[<span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>]</span><br><span class="line">[<span class="number">8</span>, <span class="number">6</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure><p>缺省参数的注意事项：</p><ul><li>缺省参数的定义位置，必须保证带有默认值的缺省参数在参数列表<strong>末尾</strong>；</li><li>调用带有多个缺省参数的函数，需要<strong>指定参数名</strong>，这样解释器才能知道对应关系。</li></ul><h4 id="（3）多值参数"><a href="#（3）多值参数" class="headerlink" title="（3）多值参数"></a><strong>（3）多值参数</strong></h4><ul><li><p>有时可能需要一个函数能够处理的<strong>参数个数是不确定的</strong>，这个时候，就可以使用<strong>多值参数</strong>。</p></li><li><p><code>python</code> 中有<strong>两种</strong>多值参数：</p><ul><li><p>参数名前增加<strong>一个</strong><code>*</code>，可以接收<strong>元组</strong></p></li><li><p>参数名前增加<strong>两个</strong><code>*</code>，可以接收<strong>字典</strong></p></li></ul></li><li><p>一般在给多值参数命名时，习惯使用以下两个名字</p><ul><li><p><code>*args</code>——存放<strong>元组</strong>参数，前面有<strong>一个</strong><code>*</code></p></li><li><p><code>**Kwargs</code>——存放<strong>字典</strong>参数，前面有<strong>两个</strong><code>*</code></p></li></ul></li><li><p><code>args</code>是<code>arguments</code>的缩写，有变量的含义</p></li><li><p><code>kw</code>是<code>keyword</code>的缩写，<code>kwargs</code> 可以记忆键值对参数</p></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">demo4</span>(<span class="params">num, *args, **kwargs</span>):</span><br><span class="line">    <span class="built_in">print</span>(num)</span><br><span class="line">    <span class="built_in">print</span>(args)</span><br><span class="line">    <span class="built_in">print</span>(kwargs)</span><br><span class="line">demo4(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, name=<span class="string">&quot;小明&quot;</span>, age=<span class="number">18</span>, gender=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line">(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;小明&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">18</span>, <span class="string">&#x27;gender&#x27;</span>: <span class="literal">True</span>&#125;</span><br></pre></td></tr></table></figure><h4 id="（4）元组和字典的拆包（了解）"><a href="#（4）元组和字典的拆包（了解）" class="headerlink" title="（4）元组和字典的拆包（了解）"></a><strong>（4）元组和字典的拆包（了解）</strong></h4><ul><li><p>在调用带有多值参数的函数时，如果希望：</p><ul><li><p>将一个<strong>元组</strong>变量，直接传递给<code>args</code></p></li><li><p>将一个<strong>字典</strong>变量，直接传递给<code>kwargs</code></p></li></ul></li><li><p>可以使用拆包，简化参数的传递，<strong>拆包</strong>的方式是：</p><ul><li><p>在<strong>元组</strong>变量前，增加<strong>一个</strong><code>*</code></p></li><li><p>在<strong>字典</strong>变量前，增加<strong>两个</strong><code>*</code></p></li></ul></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">demo5</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">    <span class="built_in">print</span>(args)</span><br><span class="line">    <span class="built_in">print</span>(kwargs)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 需要将一个元组变量/字典变量传递给函数对应的参数</span></span><br><span class="line">num = (<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line">dict_name = &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;小汤&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">20</span>&#125;</span><br><span class="line"><span class="comment"># 会把num, dict_name作为元组传递给args</span></span><br><span class="line">demo5(num, dict_name)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">50</span>)</span><br><span class="line"><span class="comment"># 元组和字典的拆包</span></span><br><span class="line">demo5(*num, **dict_name)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">((<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>), &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;小汤&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">20</span>&#125;)</span><br><span class="line">&#123;&#125;</span><br><span class="line">**************************************************</span><br><span class="line">(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line">&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;小汤&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">20</span>&#125;</span><br></pre></td></tr></table></figure><h3 id="👀递归函数"><a href="#👀递归函数" class="headerlink" title="👀递归函数"></a>👀递归函数</h3><p><strong>函数内部调用自己</strong>。函数内部可以调用其他函数，当然在函数内部也可以调用自己。</p><p>代码特点：</p><ul><li>函数内部的代码是相同的，只是针对参数不同，处理的结果不同</li><li>当参数满足一个条件时，函数不再执行。这个非常重要，通常被称为递归的出口，否则会出现死循环！</li></ul><p>例如：计算数字累加</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sum_number</span>(<span class="params">num</span>):</span><br><span class="line">    <span class="keyword">if</span> num == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    temp = sum_number(num - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> num + temp</span><br><span class="line"><span class="built_in">print</span>(sum_number(<span class="number">10</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="number">55</span></span><br></pre></td></tr></table></figure><p>笔者不才，请多交流！！！</p><p>参考文献：黑马程序员《Python入门教程完整版》</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Python基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python中的正则表达式详解</title>
      <link href="/2022/09/11/re/"/>
      <url>/2022/09/11/re/</url>
      
        <content type="html"><![CDATA[<h2 id="⛄正则表达式概述"><a href="#⛄正则表达式概述" class="headerlink" title="⛄正则表达式概述"></a>⛄正则表达式概述</h2><p>正则表达式（<code>Regular Expression</code>）是强大、便捷、高效的文本处理工具。正则表达式本身，加上如同一门袖珍编程语言的通用模式表示法（<code>general pattern notation</code>），赋予使用者描述和分析文本的能力。配合上特定工具提供的额外支持，正则表达式能够添加、删除、分离、叠加、插入和修整各种类型的文本和数据。</p><p>正则表达式使用单个字符串来描述、匹配一系列匹配某个句法规则的字符串。正则表达式是繁琐的，但它是强大的，学会之后的应用会让你除了提高效率外，会给你带来绝对的成就感。正则表达式的使用难度只相当于文本编辑器的搜索命令，但功能却与完整的文本处理语言一样强大。正则表达式的特点是：</p><ul><li>灵活性、逻辑性和功能性非常强；</li><li>可以迅速地用极简单的方式达到字符串的复杂控制；</li><li>对于刚接触的人来说，比较晦涩难懂。</li></ul><h2 id="⛄RE语法中特殊元素"><a href="#⛄RE语法中特殊元素" class="headerlink" title="⛄RE语法中特殊元素"></a>⛄<code>RE</code>语法中特殊元素</h2><h3 id="👀-匹配所有字符"><a href="#👀-匹配所有字符" class="headerlink" title="👀.匹配所有字符"></a>👀<code>.</code>匹配所有字符</h3><p><code>.</code>表示要匹配除了换行符之外的<strong>任何单个字符</strong>。其中点代表了任意的一个字符，注意是一个字符。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="built_in">str</span> = re.<span class="built_in">compile</span>(<span class="string">r&quot;.&quot;</span>).findall(<span class="string">&quot;xiaotangsmile&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[<span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;t&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;n&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;s&#x27;</span>, <span class="string">&#x27;m&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;e&#x27;</span>]</span><br></pre></td></tr></table></figure><h3 id="👀-重复匹配任意次"><a href="#👀-重复匹配任意次" class="headerlink" title="👀*重复匹配任意次"></a>👀<code>*</code>重复匹配任意次</h3><p><code>*</code> 表示匹配前面的子表达式<strong>任意次</strong>，包括<strong>0</strong>次。</p><blockquote><p>注意， .* 在正则表达式中非常常见，表示匹配任意字符任意次数。当然这个 * 前面不是非得是点，也可以是其它字符。</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">str1 = re.<span class="built_in">compile</span>(<span class="string">r&quot;ia*&quot;</span>).findall(<span class="string">&quot;xiaaaaaaaotangsmile&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(str1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[<span class="string">&#x27;iaaaaaaa&#x27;</span>, <span class="string">&#x27;i&#x27;</span>]</span><br></pre></td></tr></table></figure><h3 id="👀-重复匹配多次"><a href="#👀-重复匹配多次" class="headerlink" title="👀+重复匹配多次"></a>👀<code>+</code>重复匹配多次</h3><p><code>+</code>表示匹配前面的子表达式一次或多次，不包括0次。即：表示至少匹配1次</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">str2 = re.<span class="built_in">compile</span>(<span class="string">r&quot;ia+&quot;</span>).findall(<span class="string">&quot;xiaaaaaaaotangsmile&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(str2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[<span class="string">&#x27;iaaaaaaa&#x27;</span>]</span><br></pre></td></tr></table></figure><h3 id="👀-匹配0-1次"><a href="#👀-匹配0-1次" class="headerlink" title="👀?匹配0-1次"></a>👀<code>?</code>匹配0-1次</h3><p><code>?</code> 表示匹配前面的子表达式0次或1次。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">str3 = re.<span class="built_in">compile</span>(<span class="string">r&quot;ia?&quot;</span>).findall(<span class="string">&quot;xiaaaaaaaotangsmile&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(str3)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[<span class="string">&#x27;ia&#x27;</span>, <span class="string">&#x27;i&#x27;</span>]</span><br></pre></td></tr></table></figure><h3 id="👀-匹配指定次数"><a href="#👀-匹配指定次数" class="headerlink" title="👀{}匹配指定次数"></a>👀<code>&#123;&#125;</code>匹配指定次数</h3><p><code>&#123;&#125;</code>花括号表示前面的字符匹配 指定的次数。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">str4 = re.<span class="built_in">compile</span>(<span class="string">r&quot;ia&#123;2,5&#125;&quot;</span>).findall(<span class="string">&quot;xiaaaaaaaotangsmile&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(str4)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[<span class="string">&#x27;iaaaaa&#x27;</span>]</span><br></pre></td></tr></table></figure><h3 id="👀-匹配几个字符之一"><a href="#👀-匹配几个字符之一" class="headerlink" title="👀[]匹配几个字符之一"></a>👀<code>[]</code>匹配几个字符之一</h3><p><code>[]</code>方括号表示要匹配指定的几个字符之一。比如：</p><ul><li>[abc] 可以匹配 a, b, 或者c里面的任意一个字符，等价于 [a-c]；</li><li>[a-c] 中间的 -表示一个范围从a到c；</li><li>如果你想匹配所有的小写字母，可以使用[a-z]；</li></ul><ol><li>一些元字符在方括号内失去了本意，变得和普通字符一样了。例如：[evol.] 匹配 <code>evol.</code> 里面任意一个字符，这里 <code>.</code> 在括号里面不在表示匹配任意字符了，而就是表示匹配 <code>.</code> 这个字符。</li><li>如果在方括号中使用<code>^</code>，表示非方括号里面的字符集合。例如：<code>[^\d]</code>表示，选择非数字的字符。</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">str5 = re.<span class="built_in">compile</span>(<span class="string">r&quot;i[a-z]&quot;</span>).findall(<span class="string">&quot;xiaaaaaaaotangsmile&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(str5)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[<span class="string">&#x27;ia&#x27;</span>, <span class="string">&#x27;il&#x27;</span>]</span><br></pre></td></tr></table></figure><h3 id="👀贪婪模式和贪婪模式"><a href="#👀贪婪模式和贪婪模式" class="headerlink" title="👀贪婪模式和贪婪模式"></a>👀贪婪模式和贪婪模式</h3><p>在正则表达式中， ‘<code>*</code>‘, ‘<code>+</code>‘, ‘<code>?</code>‘ 都是贪婪地，使用他们时，会尽可能多的匹配内容。</p><p>解决这个问题，就需要使用非贪婪模式，也就是在星号后面加上<code>?</code> ，变成这样<code>&lt;.*?&gt;</code></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">str6 = re.<span class="built_in">compile</span>(<span class="string">r&quot;&lt;.*&gt;&quot;</span>).findall(<span class="string">&quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;Title&lt;/title&gt;&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(str6)</span><br><span class="line">str7 = re.<span class="built_in">compile</span>(<span class="string">r&quot;&lt;.*?&gt;&quot;</span>).findall(<span class="string">&quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;Title&lt;/title&gt;&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(str7)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[<span class="string">&#x27;&lt;html&gt;&lt;head&gt;&lt;title&gt;Title&lt;/title&gt;&#x27;</span>]</span><br><span class="line">[<span class="string">&#x27;&lt;html&gt;&#x27;</span>, <span class="string">&#x27;&lt;head&gt;&#x27;</span>, <span class="string">&#x27;&lt;title&gt;&#x27;</span>, <span class="string">&#x27;&lt;/title&gt;&#x27;</span>]</span><br></pre></td></tr></table></figure><h3 id="👀元字符转义"><a href="#👀元字符转义" class="headerlink" title="👀元字符转义"></a>👀元字符转义</h3><p>反斜杠 <code>\</code> 在正则表达式中有多种用途。</p><p>如果，我们这样写正则表达式 <code>.*.</code> ，聪明的你肯定发现不对劲。因为点是一个元字符，直接出现在正则表达式中，表示匹配任意的单个字符，不能表示<code>.</code>这个字符本身的意思了。</p><blockquote><p>怎么办呢？如果我们要搜索的内容本身就包含元字符，就可以使用<strong>反斜杠</strong>进行转义。这里我们就应用使用这样的表达式： <code>.*\.</code></p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">str8 = re.<span class="built_in">compile</span>(<span class="string">r&quot;[a-zA-Z0-9]*@[1-9]&#123;3&#125;\.com&quot;</span>).findall(<span class="string">&quot;xiao@163.cn,tangsmile@126.com&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(str8)</span><br><span class="line">str9 = re.<span class="built_in">compile</span>(<span class="string">r&quot;[\w]*@[1-9]&#123;3&#125;\.com&quot;</span>).findall(<span class="string">&quot;xiaoxiao@163.cn,tangsmile@126.com&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(str9)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[<span class="string">&#x27;tangsmile@126.com&#x27;</span>]</span><br><span class="line">[<span class="string">&#x27;tangsmile@126.com&#x27;</span>]</span><br></pre></td></tr></table></figure><h3 id="👀特殊字符类"><a href="#👀特殊字符类" class="headerlink" title="👀特殊字符类"></a>👀特殊字符类</h3><p>反斜杠后面接一些字符，表示匹配某种类型的一个字符。</p><table><thead><tr><th><strong>实例</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><code>\d</code></td><td>匹配任意一个数字字符。等价于[<code>0-9]</code>。</td></tr><tr><td><code>\D</code></td><td>匹配任意一个非数字字符。等价于[<code>^0-9</code>]。</td></tr><tr><td><code>\s</code></td><td>匹配任意一个空白字符，包括空格、制表符、换页符等等。等价于[<code>\f\n\r\t\v</code>]。</td></tr><tr><td><code>\S</code></td><td>匹配任意一个非空白字符。等价于[<code>^\f\n\r\t\v</code>]。</td></tr><tr><td><code>\w</code></td><td>匹配任意一个文字字符，包括大小写字母、数字、下划线。等价于[<code>A-Za-z0-9_</code>]。</td></tr><tr><td><code>\W</code></td><td>匹配任意一个非文字字符。等价于[<code>^A-Za-z0-9_</code>]。</td></tr></tbody></table><p>反斜杠也可以用在方括号里面，例如： [<code>\s,.</code>] 表示匹配 任何空白字符，或者逗号，或者点。</p><h3 id="👀起始、结尾位置和单-x2F-行模式"><a href="#👀起始、结尾位置和单-x2F-行模式" class="headerlink" title="👀起始、结尾位置和单&#x2F;行模式"></a>👀起始、结尾位置和单&#x2F;行模式</h3><p><code>^</code> 在方括号里面表示非；除此之外，<code>^</code>表示匹配文本的开头位置。</p><p>正则表达式可以设定单行模式和多行模式</p><ul><li>如果是单行模式，表示匹配整个文本的开头位置。</li><li>如果是多行模式，表示匹配文本每行的开头位置。</li></ul><p><code>$</code> 表示匹配文本的 结尾 位置。</p><ul><li>如果是单行模式，表示匹配整个文本的结尾位置。</li><li>如果是多行模式，表示匹配文本每行的结尾位置。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">content = <span class="string">&#x27;&#x27;&#x27;001-小汤-99</span></span><br><span class="line"><span class="string">002-小明-98</span></span><br><span class="line"><span class="string">003-小红-97&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># 注意，compile 的第二个参数 re.M ，指明了使用多行模式，</span></span><br><span class="line">str10 = re.<span class="built_in">compile</span>(<span class="string">r&#x27;^\d+&#x27;</span>, re.M).findall(content)</span><br><span class="line"><span class="built_in">print</span>(str10)</span><br><span class="line">str11 = re.<span class="built_in">compile</span>(<span class="string">r&#x27;^\d+&#x27;</span>).findall(content)</span><br><span class="line"><span class="built_in">print</span>(str11)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[<span class="string">&#x27;001&#x27;</span>, <span class="string">&#x27;002&#x27;</span>, <span class="string">&#x27;003&#x27;</span>]</span><br><span class="line">[<span class="string">&#x27;001&#x27;</span>]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">content = <span class="string">&#x27;&#x27;&#x27;001-小汤-99</span></span><br><span class="line"><span class="string">002-小明-98</span></span><br><span class="line"><span class="string">003-小红-97&#x27;&#x27;&#x27;</span></span><br><span class="line">str12 = re.<span class="built_in">compile</span>(<span class="string">r&#x27;\d+$&#x27;</span>, re.M).findall(content)</span><br><span class="line"><span class="built_in">print</span>(str12)</span><br><span class="line">str13 = re.<span class="built_in">compile</span>(<span class="string">r&#x27;\d+$&#x27;</span>).findall(content)</span><br><span class="line"><span class="built_in">print</span>(str13)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[<span class="string">&#x27;99&#x27;</span>, <span class="string">&#x27;98&#x27;</span>, <span class="string">&#x27;97&#x27;</span>]</span><br><span class="line">[<span class="string">&#x27;97&#x27;</span>]</span><br></pre></td></tr></table></figure><h3 id="👀-竖线"><a href="#👀-竖线" class="headerlink" title="👀|竖线"></a>👀<code>|</code>竖线</h3><p>竖线表示<strong>匹配其中之一</strong> 。特别要注意的是，竖线在正则表达式的优先级是最低的，这就意味着，竖线隔开的部分是一个整体。</p><p>比如，小明|王 表示要匹配：<strong>小明</strong>或者<strong>王</strong> ，而不是 <strong>小明</strong> 或者 <strong>小王</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">str14 = re.<span class="built_in">compile</span>(<span class="string">r&#x27;小汤|明|红|王&#x27;</span>).findall(<span class="string">&quot;小汤小明小红小王&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(str14)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[<span class="string">&#x27;小汤&#x27;</span>, <span class="string">&#x27;明&#x27;</span>, <span class="string">&#x27;红&#x27;</span>, <span class="string">&#x27;王&#x27;</span>]</span><br></pre></td></tr></table></figure><h3 id="👀-括号"><a href="#👀-括号" class="headerlink" title="👀()括号"></a>👀<code>()</code>括号</h3><p>括号称之为正则表达式的组选择。组就是把正则表达式匹配的内容里面 中的某些部分标记为某个组。我们可以在 正则表达式中标记多个组。</p><blockquote><p>为什么要有组的概念呢？因为我们往往需要提取已经匹配的内容里面的某些部分。</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">content = <span class="string">&#x27;&#x27;&#x27;001小汤,你最棒</span></span><br><span class="line"><span class="string">002小明,你更棒</span></span><br><span class="line"><span class="string">003小红,你较棒&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># 输出包含逗号</span></span><br><span class="line">str15 = re.<span class="built_in">compile</span>(<span class="string">r&#x27;^.*,&#x27;</span>).findall(content)</span><br><span class="line"><span class="built_in">print</span>(str15)</span><br><span class="line"><span class="comment"># 输出不包含逗号</span></span><br><span class="line">str16 = re.<span class="built_in">compile</span>(<span class="string">r&#x27;^(.*),&#x27;</span>).findall(content)</span><br><span class="line"><span class="built_in">print</span>(str16)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[<span class="string">&#x27;001小汤,&#x27;</span>]</span><br><span class="line">[<span class="string">&#x27;001小汤&#x27;</span>]</span><br></pre></td></tr></table></figure><h3 id="👀点匹配换行符"><a href="#👀点匹配换行符" class="headerlink" title="👀点匹配换行符"></a>👀点匹配换行符</h3><p>点是不匹配换行符的，可是有时候，特征字符串就是跨行的，比如要找出下面文字中所有的职位名称。</p><p>设置点也匹配换行符：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用re.S和re.DOTALL匹配出来的内容都是一样的,都表示包括换行符内容的匹配</span></span><br><span class="line"><span class="comment"># re.DOTALL</span></span><br><span class="line"><span class="comment"># re.S</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line">content = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">&lt;div class=&quot;el&quot;&gt;</span></span><br><span class="line"><span class="string">        &lt;p class=&quot;t1&quot;&gt;           </span></span><br><span class="line"><span class="string">            &lt;span&gt;</span></span><br><span class="line"><span class="string">                &lt;a&gt;Python开发工程师&lt;/a&gt;</span></span><br><span class="line"><span class="string">            &lt;/span&gt;</span></span><br><span class="line"><span class="string">        &lt;/p&gt;</span></span><br><span class="line"><span class="string">        &lt;span class=&quot;t2&quot;&gt;南京&lt;/span&gt;</span></span><br><span class="line"><span class="string">        &lt;span class=&quot;t3&quot;&gt;1.5-2万/月&lt;/span&gt;</span></span><br><span class="line"><span class="string">&lt;/div&gt;</span></span><br><span class="line"><span class="string">&lt;div class=&quot;el&quot;&gt;</span></span><br><span class="line"><span class="string">        &lt;p class=&quot;t1&quot;&gt;</span></span><br><span class="line"><span class="string">            &lt;span&gt;</span></span><br><span class="line"><span class="string">                &lt;a&gt;java开发工程师&lt;/a&gt;</span></span><br><span class="line"><span class="string">            &lt;/span&gt;</span></span><br><span class="line"><span class="string">&lt;/p&gt;</span></span><br><span class="line"><span class="string">        &lt;span class=&quot;t2&quot;&gt;苏州&lt;/span&gt;</span></span><br><span class="line"><span class="string">        &lt;span class=&quot;t3&quot;&gt;1.5-2/月&lt;/span&gt;</span></span><br><span class="line"><span class="string">&lt;/div&gt;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">str16 = re.<span class="built_in">compile</span>(<span class="string">r&#x27;class=\&quot;t1\&quot;&gt;.*?&lt;a&gt;(.*?)&lt;/a&gt;&#x27;</span>, re.S).findall(content)</span><br><span class="line"><span class="built_in">print</span>(str16)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[<span class="string">&#x27;Python开发工程师&#x27;</span>, <span class="string">&#x27;java开发工程师&#x27;</span>]</span><br></pre></td></tr></table></figure><h2 id="⛄常用的函数"><a href="#⛄常用的函数" class="headerlink" title="⛄常用的函数"></a>⛄常用的函数</h2><p><code>re</code>模块使<code>Python</code>语言拥有全部的正则表达式功能。</p><ul><li><code>compile()</code>函数根据一个模式字符串和可选的标志参数生成一个正则表达式对象,该对象拥有一系列方法用于正则表达式匹配和替换。</li><li><code>re</code> 模块也提供了与这些方法功能完全一致的函数，这些函数使用一个模式字符串做为它们的第一个参数。</li></ul><h3 id="👀re-match"><a href="#👀re-match" class="headerlink" title="👀re.match()"></a>👀re.match()</h3><p><code>re.match()</code>尝试从字符串的<strong>起始位置匹配一个模式</strong>，如果不是起始位置匹配成功的话，就返回<code>none</code>。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 函数语法</span></span><br><span class="line">re.match(pattern, string, flags=<span class="number">0</span>)</span><br><span class="line"><span class="comment"># 参数</span></span><br><span class="line">pattern 匹配的正则表达式</span><br><span class="line">string  要匹配的字符串。</span><br><span class="line">flags 标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等。</span><br></pre></td></tr></table></figure><p>匹配成功&#96;&#96;re.match()<code>方法**返回一个匹配的</code>Match<code>对象**，而不是匹配的正则表达式，否则返回</code>None<code>。通过</code>span()<code>可以获取匹配的位置，使用</code>group(num)<code>或</code>groups()&#96; 匹配对象函数来获取匹配表达式。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="comment"># 在起始位置匹配</span></span><br><span class="line"><span class="built_in">print</span>(re.match(<span class="string">&#x27;www&#x27;</span>, <span class="string">&#x27;www.runoob.com&#x27;</span>).span())</span><br><span class="line"><span class="comment"># 不在起始位置匹配</span></span><br><span class="line"><span class="built_in">print</span>(re.match(<span class="string">&#x27;com&#x27;</span>, <span class="string">&#x27;www.runoob.com&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">(<span class="number">0</span>, <span class="number">3</span>)</span><br><span class="line"><span class="literal">None</span></span><br></pre></td></tr></table></figure><h3 id="👀re-search"><a href="#👀re-search" class="headerlink" title="👀re,search()"></a>👀re,search()</h3><p><code>re.search()</code>扫描<strong>整个字符串并返回第一个成功的匹配</strong>。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 函数语法</span></span><br><span class="line">re.search(pattern, string, flags=<span class="number">0</span>)</span><br><span class="line"><span class="comment"># 参数</span></span><br><span class="line">pattern 匹配的正则表达式</span><br><span class="line">string  要匹配的字符串。</span><br><span class="line">flags 标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等。</span><br></pre></td></tr></table></figure><p>匹配成功<code>re.search()</code>方法<strong>返回一个匹配的<code>Match</code>对象</strong>，而不是匹配的正则表达式，否则返回<code>None</code>。通过<code>span()</code>可以获取匹配的位置，使用<code>group(num)</code> 或<code>groups()</code> 匹配对象函数来获取匹配表达式。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="comment"># 在起始位置匹配</span></span><br><span class="line"><span class="built_in">print</span>(re.search(<span class="string">&#x27;www&#x27;</span>, <span class="string">&#x27;www.runoob.com&#x27;</span>).span())</span><br><span class="line"><span class="comment"># 不在起始位置匹配</span></span><br><span class="line"><span class="built_in">print</span>(re.search(<span class="string">&#x27;com&#x27;</span>, <span class="string">&#x27;www.runoob.com&#x27;</span>).span())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">(<span class="number">0</span>, <span class="number">3</span>)</span><br><span class="line">(<span class="number">11</span>, <span class="number">14</span>)</span><br></pre></td></tr></table></figure><blockquote><p><code>re.match()</code>只匹配字符串的开始，如果字符串开始不符合正则表达式，则匹配失败，函数返回 <code>None</code>，而<code>re.search()</code>匹配整个字符串，直到找到一个匹配。</p></blockquote><h3 id="👀re-sub-检索和替换"><a href="#👀re-sub-检索和替换" class="headerlink" title="👀re.sub()检索和替换"></a>👀re.sub()检索和替换</h3><p><code>Python</code>的<code>re</code>模块提供了<code>re.sub()</code>用于替换字符串中的匹配项。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 函数语法：</span></span><br><span class="line">re.sub(pattern, repl, string, count=<span class="number">0</span>, flags=<span class="number">0</span>)</span><br><span class="line"><span class="comment"># 参数</span></span><br><span class="line">pattern: 正则中的模式字符串。</span><br><span class="line">repl: 替换的字符串，也可为一个函数。</span><br><span class="line">string: 要被查找替换的原始字符串。</span><br><span class="line">count: 模式匹配后替换的最大次数，默认<span class="number">0</span>表示替换所有的匹配。</span><br><span class="line">flags: 编译时用的匹配模式，数字形式。</span><br><span class="line"></span><br><span class="line"><span class="comment"># 前三个为必选参数，后两个为可选参数；返回替换后的字符串。</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re </span><br><span class="line">phone = <span class="string">&quot;2004-959-559 # 这是一个电话号码&quot;</span> </span><br><span class="line"><span class="comment"># 删除注释 </span></span><br><span class="line">num = re.sub(<span class="string">r&#x27;#.*$&#x27;</span>, <span class="string">&quot;&quot;</span>, phone) </span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;电话号码 : &quot;</span>, num) </span><br><span class="line"><span class="comment"># 移除非数字的内容 </span></span><br><span class="line">num = re.sub(<span class="string">r&#x27;\D&#x27;</span>, <span class="string">&quot;&quot;</span>, phone) </span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;电话号码 : &quot;</span>, num)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">电话号码 :  <span class="number">2004</span>-<span class="number">959</span>-<span class="number">559</span> </span><br><span class="line">电话号码 :  <span class="number">2004959559</span></span><br></pre></td></tr></table></figure><h3 id="👀compile"><a href="#👀compile" class="headerlink" title="👀compile()"></a>👀compile()</h3><p><code>compile()</code>函数用于编译正则表达式，生成一个正则表达式（<code>Pattern</code>）对象，供<code>match()</code>和 <code>search()</code>这两个函数使用。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 语法格式</span></span><br><span class="line">re.<span class="built_in">compile</span>(pattern[, flags])</span><br><span class="line"><span class="comment"># 参数</span></span><br><span class="line">pattern: 一个字符串形式的正则表达式</span><br><span class="line">flags: 可选，表示匹配模式，比如忽略大小写，多行模式等，具体参数为：</span><br><span class="line">re.I 忽略大小写</span><br><span class="line">re.L 表示特殊字符集\w,\W,\b,\B,\s,\S依赖于当前环境</span><br><span class="line">re.M 多行模式</span><br><span class="line">re.S 即为<span class="string">&#x27;.&#x27;</span>匹配包括换行符在内的任意字符（<span class="string">&#x27;.&#x27;</span>不包括换行符）</span><br><span class="line">re.U 表示特殊字符集\w,\W,\b,\B,\d,\D,\s,\S依赖于Unicode字符属性数据库</span><br><span class="line">re.X 为了增加可读性，忽略空格和<span class="string">&#x27; # &#x27;</span>后面的注释</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pattern = re.<span class="built_in">compile</span>(<span class="string">r&#x27;([a-z]+) ([a-z]+)&#x27;</span>, re.I) <span class="comment"># re.I表示忽略大小写 </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m = pattern.match(<span class="string">&#x27;Hello World Wide Web&#x27;</span>) </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>( m ) <span class="comment"># 匹配成功，返回一个 Match 对象 </span></span><br><span class="line">&lt;_sre.SRE_Match <span class="built_in">object</span> at <span class="number">0x10bea83e8</span>&gt; </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m.group(<span class="number">0</span>) <span class="comment"># 返回匹配成功的整个子串 </span></span><br><span class="line"><span class="string">&#x27;Hello World&#x27;</span> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m.span(<span class="number">0</span>)  <span class="comment"># 返回匹配成功的整个子串的索引 </span></span><br><span class="line">(<span class="number">0</span>, <span class="number">11</span>) </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m.group(<span class="number">1</span>) <span class="comment"># 返回第一个分组匹配成功的子串 </span></span><br><span class="line"><span class="string">&#x27;Hello&#x27;</span></span><br><span class="line"> &gt;&gt;&gt; m.span(<span class="number">1</span>) <span class="comment"># 返回第一个分组匹配成功的子串的索引</span></span><br><span class="line"> (<span class="number">0</span>, <span class="number">5</span>) </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m.group(<span class="number">2</span>) <span class="comment"># 返回第二个分组匹配成功的子串 </span></span><br><span class="line"><span class="string">&#x27;World&#x27;</span> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m.span(<span class="number">2</span>)  <span class="comment"># 返回第二个分组匹配成功的子串索引</span></span><br><span class="line"> (<span class="number">6</span>, <span class="number">11</span>) </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m.groups() <span class="comment"># 等价于 (m.group(1), m.group(2), ...) </span></span><br><span class="line">(<span class="string">&#x27;Hello&#x27;</span>, <span class="string">&#x27;World&#x27;</span>) </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m.group(<span class="number">3</span>) <span class="comment"># 不存在第三个分组</span></span><br><span class="line"> Traceback (most recent call last): File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt; IndexError: no such group</span><br></pre></td></tr></table></figure><h3 id="👀findall"><a href="#👀findall" class="headerlink" title="👀findall()"></a>👀findall()</h3><p>在字符串中找到正则表达式所匹配的所有子串，并<strong>返回一个列表</strong>，如果有多个匹配模式，则返回元组列表，如果没有找到匹配的，则返回空列表。</p><blockquote><p>注意： match()和search()是匹配一次，findall()匹配所有。</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 语法格式</span></span><br><span class="line">re.findall(pattern, string, flags=<span class="number">0</span>)</span><br><span class="line">或</span><br><span class="line">pattern.findall(string[, pos[, endpos]])</span><br><span class="line"><span class="comment"># 参数</span></span><br><span class="line">pattern 匹配模式。</span><br><span class="line">string  待匹配的字符串。</span><br><span class="line">pos 可选参数，指定字符串的起始位置，默认为 <span class="number">0</span>。</span><br><span class="line">endpos 可选参数，指定字符串的结束位置，默认为字符串的长度。</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># (1)查找字符串中的所有数字</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line">result1 = re.findall(<span class="string">r&#x27;\d+&#x27;</span>,<span class="string">&#x27;runoob 123 google 456&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(result1)</span><br><span class="line">pattern = re.<span class="built_in">compile</span>(<span class="string">r&#x27;\d+&#x27;</span>) <span class="comment"># 查找数字</span></span><br><span class="line">result2 = pattern.findall(<span class="string">&#x27;runoob 123 google 456&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(result2)</span><br><span class="line">result3 = pattern.findall(<span class="string">&#x27;run88oob123google456&#x27;</span>, <span class="number">0</span>, <span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(result3)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[<span class="string">&#x27;123&#x27;</span>, <span class="string">&#x27;456&#x27;</span>]</span><br><span class="line">[<span class="string">&#x27;123&#x27;</span>, <span class="string">&#x27;456&#x27;</span>]</span><br><span class="line">[<span class="string">&#x27;88&#x27;</span>, <span class="string">&#x27;12&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 多个匹配模式，返回元组列表</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line">result = re.findall(<span class="string">r&#x27;(\w+)=(\d+)&#x27;</span>, <span class="string">&#x27;set width=20 and height=10&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[(<span class="string">&#x27;width&#x27;</span>, <span class="string">&#x27;20&#x27;</span>), (<span class="string">&#x27;height&#x27;</span>, <span class="string">&#x27;10&#x27;</span>)]</span><br></pre></td></tr></table></figure><h3 id="👀re-finditer"><a href="#👀re-finditer" class="headerlink" title="👀re.finditer()"></a>👀re.finditer()</h3><p>和 <code>findall(</code>)类似，在字符串中找到正则表达式所匹配的所有子串，并把它们作为一个<strong>迭代器</strong>返回。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 语法格式</span></span><br><span class="line">re.finditer(pattern, string, flags=<span class="number">0</span>)</span><br><span class="line"><span class="comment"># 参数</span></span><br><span class="line">pattern 匹配的正则表达式</span><br><span class="line">string 要匹配的字符串。</span><br><span class="line">flags 标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等。</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">it = re.finditer(<span class="string">r&quot;\d+&quot;</span>,<span class="string">&quot;12a32bc43jf3&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(it)</span><br><span class="line"><span class="keyword">for</span> match <span class="keyword">in</span> it:</span><br><span class="line"><span class="built_in">print</span> (match.group())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">&lt;callable_iterator <span class="built_in">object</span> at <span class="number">0x000001FA199BA0C8</span>&gt;</span><br><span class="line"><span class="number">12</span> </span><br><span class="line"><span class="number">32</span> </span><br><span class="line"><span class="number">43</span> </span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><h3 id="👀re-split"><a href="#👀re-split" class="headerlink" title="👀re.split()"></a>👀re.split()</h3><p><code>split()</code>方法按照能够匹配的子串将字符串分割后，<strong>返回列表</strong>。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 语法格式</span></span><br><span class="line">re.split(pattern, string[, maxsplit=<span class="number">0</span>, flags=<span class="number">0</span>])</span><br><span class="line"><span class="comment"># 参数</span></span><br><span class="line">pattern 匹配的正则表达式</span><br><span class="line">string 要匹配的字符串。</span><br><span class="line">maxsplit 分割次数，maxsplit=<span class="number">1</span> 分割一次，默认为 <span class="number">0</span>，不限制次数。</span><br><span class="line">flags 标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等。</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="keyword">import</span> re </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.split(<span class="string">&#x27;\W+&#x27;</span>, <span class="string">&#x27;runoob, runoob, runoob.&#x27;</span>) </span><br><span class="line">[<span class="string">&#x27;runoob&#x27;</span>, <span class="string">&#x27;runoob&#x27;</span>, <span class="string">&#x27;runoob&#x27;</span>, <span class="string">&#x27;&#x27;</span>] </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.split(<span class="string">&#x27;(\W+)&#x27;</span>, <span class="string">&#x27; runoob, runoob, runoob.&#x27;</span>) </span><br><span class="line">[<span class="string">&#x27;&#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;runoob&#x27;</span>, <span class="string">&#x27;, &#x27;</span>, <span class="string">&#x27;runoob&#x27;</span>, <span class="string">&#x27;, &#x27;</span>, <span class="string">&#x27;runoob&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;&#x27;</span>] </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.split(<span class="string">&#x27;\W+&#x27;</span>, <span class="string">&#x27; runoob, runoob, runoob.&#x27;</span>, <span class="number">1</span>) </span><br><span class="line">[<span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;runoob, runoob, runoob.&#x27;</span>] </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.split(<span class="string">&#x27;ab*&#x27;</span>, <span class="string">&#x27;hello world&#x27;</span>) <span class="comment"># 对于一个找不到匹配的字符串而言，split 不会对其作出分割</span></span><br><span class="line">[<span class="string">&#x27;hello world&#x27;</span>]</span><br></pre></td></tr></table></figure><h3 id="👀正则表达式对象"><a href="#👀正则表达式对象" class="headerlink" title="👀正则表达式对象"></a>👀正则表达式对象</h3><p><strong>re.RegexObject</strong></p><ul><li><code>re.compile()</code> 返回 <code>RegexObject</code> 对象。</li></ul><p><strong>re.MatchObject</strong></p><ul><li><p><code>group()</code> 返回被 <code>RE</code> 匹配的字符串。</p><ul><li><p><code>start()</code> 返回匹配开始的位置</p></li><li><p><code>end()</code> 返回匹配结束的位置</p></li><li><p><code>span()</code> 返回一个元组包含匹配 (开始,结束) 的位置</p></li></ul></li></ul><h3 id="👀正则表达式修饰符-可选标志"><a href="#👀正则表达式修饰符-可选标志" class="headerlink" title="👀正则表达式修饰符-可选标志"></a>👀正则表达式修饰符-可选标志</h3><p>正则表达式可以包含一些可选标志修饰符来控制匹配的模式。修饰符被指定为一个可选的标志。多个标志可以通过按位 <code>OR(|)</code> 它们来指定。如<code>re.I</code> | <code>re.M</code> 被设置成 I 和 M 标志：</p><table><thead><tr><th align="center">修饰符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="center"><code>re.I</code></td><td align="left">使匹配对大小写不敏感</td></tr><tr><td align="center"><code>re.L</code></td><td align="left">做本地化识别（local-aware）匹配</td></tr><tr><td align="center"><code>re.M</code></td><td align="left">多行匹配，影响^和$</td></tr><tr><td align="center"><code>re.S</code></td><td align="left">使<code>.</code>匹配包括换行在内的所有字符</td></tr><tr><td align="center"><code>re.U</code></td><td align="left">根据<code>Unicode</code>字符集解析字符。这个标志影响<code>\w</code>，<code>\W</code>，<code>\b</code>，<code>\B</code></td></tr><tr><td align="center"><code>re.X</code></td><td align="left">该标志通过给予你更灵活的格式以便你将正则表达式写得更易于理解。</td></tr></tbody></table><h3 id="👀正则表达式实例"><a href="#👀正则表达式实例" class="headerlink" title="👀正则表达式实例"></a>👀正则表达式实例</h3><p>（1）字符匹配</p><table><thead><tr><th><strong>实例</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><code>python</code></td><td>匹配 “<code>python</code>“.</td></tr></tbody></table><p>（2）字符类</p><table><thead><tr><th><strong>实例</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><code>[Pp]ython</code></td><td>匹配 “<code>Python</code>“ 或 “<code>python</code>“</td></tr><tr><td><code>rub[ye]</code></td><td>匹配 “<code>ruby</code>“ 或 “<code>rube</code>“</td></tr><tr><td><code>[aeiou]</code></td><td>匹配中括号内的任意一个字母</td></tr><tr><td><code>[0-9]</code></td><td>匹配任何数字。类似于 [<code>0123456789</code>]</td></tr><tr><td><code>[a-z]</code></td><td>匹配任何小写字母</td></tr><tr><td><code>[A-Z]</code></td><td>匹配任何大写字母</td></tr><tr><td><code>[a-zA-Z0-9]</code></td><td>匹配任何字母及数字</td></tr><tr><td><code>[^aeiou]</code></td><td>除了<code>aeiou</code>字母以外的所有字符</td></tr><tr><td><code>[^0-9]</code></td><td>匹配除了数字外的字符</td></tr></tbody></table><p>（3）特殊字符类</p><table><thead><tr><th><strong>实例</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><code>.</code></td><td>匹配除 “<code>\n</code>“ 之外的任何单个字符。要匹配包括 ‘<code>\n</code>‘ 在内的任何字符，请使用象 ‘<code>[.\n]</code>‘ 的模式。</td></tr><tr><td><code>\d</code></td><td>匹配一个数字字符。等价于[<code>0-9</code>]。</td></tr><tr><td><code>\D</code></td><td>匹配一个非数字字符。等价于[<code>^0-9</code>]。</td></tr><tr><td><code>\s</code></td><td>匹配任何空白字符，包括空格、制表符、换页符等等。等价于[<code>\f\n\r\t\v</code>]。</td></tr><tr><td><code>\S</code></td><td>匹配任何非空白字符。等价于[<code>^\f\n\r\t\v</code>]。</td></tr><tr><td><code>\w</code></td><td>匹配包括下划线的任何单词字符。等价于[<code>A-Za-z0-9_</code>]。</td></tr><tr><td><code>\W</code></td><td>匹配任何非单词字符。等价于[<code>^A-Za-z0-9_</code>]。</td></tr></tbody></table><p>笔者不才，请多交流！！！</p><p>参考文献：正则表达式 - 教程|菜鸟教程</p>]]></content>
      
      
      <categories>
          
          <category> 正则表达式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 正则表达式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ERA5数据下载和批处理教程</title>
      <link href="/2022/09/08/ERA5-data/"/>
      <url>/2022/09/08/ERA5-data/</url>
      
        <content type="html"><![CDATA[<p><code>ERA5</code> 再分析数据是最新一代的再分析数据，由欧盟资助的哥白尼气候变化服务（<code>C3S</code>）创建，由 <code>ECMWF</code> 运营。同化了包括全球范围内不同区域和来源的遥感资料、地表与上层大气常规气象资料。它覆盖了 1950 年至今的历史时期，实现了实时更新，延迟约 3 个月。<code>ERA5</code> 在其前身 <code>ERA-Interim</code> 的基础上进行了大幅升级，在时间分辨率和空间分辨率上都有显著提高。</p><p><code>ERA5</code> 再分析资料提供了许多种类的要素，包括 2m 温度、2m 相对湿度、海平面气压、10m 风等地面要素以及温度、相对湿度、位势高度、风场等高空要素。</p><h2 id="⛄ERA5数据下载"><a href="#⛄ERA5数据下载" class="headerlink" title="⛄ERA5数据下载"></a>⛄ERA5数据下载</h2><p>本例子以<code>ERA5 monthly averaged data on single levels from 1959 to present</code>数据为基础，下载2017、2018、2019、2020、2021年ERA5再分析数据，并进行批处理。数据变量主要包括：</p><ul><li>2m_temperature</li><li>skin_temperature</li><li>total_precipitation</li></ul><h3 id="👀前期准备"><a href="#👀前期准备" class="headerlink" title="👀前期准备"></a>👀前期准备</h3><p>进入 <strong>Climate Data Store</strong>（CDS），<a href="https://cds.climate.copernicus.eu/cdsapp#!/home">官方网站</a>，<a href="https://cds.climate.copernicus.eu/user/register?destination=/%23!/home">注册新用户</a>（已有请忽略）</p><ul><li>选择需要的数据，以<a href="https://cds.climate.copernicus.eu/cdsapp#!/dataset/reanalysis-era5-single-levels-monthly-means">ERA5 monthly averaged data on single levels from 1959 to present</a>数据为例，</li><li>在<code>Download data</code>选项卡里面产品类型<code>Product type</code>和变量<code>Variable</code></li><li>选择对应的<code>Year</code>、<code>Month</code>、<code>Time</code>；地理区域<code>Geographical area</code>；格式<code>Format</code>为<code>NetCDF</code>；</li><li><code>Terms of use</code> 勾上对号<code>Licence to use Copernicus Products</code>；</li><li>最下面有三种下载方式①<code>Show API request</code>；②<code>Show Toolbox request</code>；③<code>Submit Form</code>。</li></ul><h3 id="👀Python方式下载"><a href="#👀Python方式下载" class="headerlink" title="👀Python方式下载"></a>👀Python方式下载</h3><p>点击<code>Show API request</code>，出现Python代码，是根据你选择的数据自动生成的API请求。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cdsapi</span><br><span class="line"></span><br><span class="line">c = cdsapi.Client()</span><br><span class="line"></span><br><span class="line">c.retrieve(</span><br><span class="line">    <span class="string">&#x27;reanalysis-era5-single-levels-monthly-means&#x27;</span>,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&#x27;product_type&#x27;</span>: <span class="string">&#x27;monthly_averaged_reanalysis&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;variable&#x27;</span>: [</span><br><span class="line">            <span class="string">&#x27;2m_temperature&#x27;</span>, <span class="string">&#x27;skin_temperature&#x27;</span>, <span class="string">&#x27;total_precipitation&#x27;</span>,</span><br><span class="line">        ],</span><br><span class="line">        <span class="string">&#x27;year&#x27;</span>: [</span><br><span class="line">            <span class="string">&#x27;2017&#x27;</span>, <span class="string">&#x27;2018&#x27;</span>, <span class="string">&#x27;2019&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;2020&#x27;</span>, <span class="string">&#x27;2021&#x27;</span>,</span><br><span class="line">        ],</span><br><span class="line">        <span class="string">&#x27;month&#x27;</span>: [</span><br><span class="line">            <span class="string">&#x27;01&#x27;</span>, <span class="string">&#x27;02&#x27;</span>, <span class="string">&#x27;03&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;04&#x27;</span>, <span class="string">&#x27;05&#x27;</span>, <span class="string">&#x27;06&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;07&#x27;</span>, <span class="string">&#x27;08&#x27;</span>, <span class="string">&#x27;09&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;10&#x27;</span>, <span class="string">&#x27;11&#x27;</span>, <span class="string">&#x27;12&#x27;</span>,</span><br><span class="line">        ],</span><br><span class="line">        <span class="string">&#x27;time&#x27;</span>: <span class="string">&#x27;00:00&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;area&#x27;</span>: [</span><br><span class="line">            <span class="number">60</span>, <span class="number">70</span>, <span class="number">0</span>,</span><br><span class="line">            <span class="number">140</span>,</span><br><span class="line">        ],</span><br><span class="line">        <span class="string">&#x27;format&#x27;</span>: <span class="string">&#x27;netcdf&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&#x27;download.nc&#x27;</span>)</span><br></pre></td></tr></table></figure><p>运行成功此代码，需要以下准备：</p><p>（1）安装cdsapi模块</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip install cdsapi</span><br></pre></td></tr></table></figure><p>（2）此时可能运行出错</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Exception: Missing/incomplete configuration file:C:\Users\Administrator/.cdsapirc</span><br></pre></td></tr></table></figure><p><strong>初步分析</strong>：在目标路径下缺少<code>.cdsapirc</code>文件，该文件里含有下载数据的<code>url</code>和<code>key</code></p><p><strong>解决方案</strong>：针对已注册的用户，进入<a href="https://cds.climate.copernicus.eu/api-how-to">How to use the CDS API</a>网站，获得<code>url</code>和<code>key</code></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">url: https://cds.climate.copernicus.eu/api/v2</span><br><span class="line">key: *****************************************(已隐藏)</span><br></pre></td></tr></table></figure><ul><li>新建<code>txt</code>文件，将自己的<code>url</code>和<code>key</code>复制进去，然后保存；</li><li>把<code>txt</code>文件名改为<code>.cdsapirc</code>(注意有<code>.</code>)，同时修改文件后缀名，即把<code>.txt</code>后缀删除；</li><li>将文件复制或剪切到之前报错的目标路径下；</li><li>运行Python程序，即可成功下载。</li></ul><h3 id="👀IDM下载器方式下载"><a href="#👀IDM下载器方式下载" class="headerlink" title="👀IDM下载器方式下载"></a>👀IDM下载器方式下载</h3><p>点击<code>Submit Form</code>，跳转界面到<code>Your requests</code>，会显示当前下载数据的请求状态，需要你耐心等待一会儿。</p><p>通过请求之后，即可通过<code>Internet Download Manager</code>（<code>IDM</code>）下载器下载（前提已安装）。</p><h2 id="⛄ERA5数据批处理"><a href="#⛄ERA5数据批处理" class="headerlink" title="⛄ERA5数据批处理"></a>⛄ERA5数据批处理</h2><p>ERA5数据批处理目标要求：</p><ul><li>读取nc文件；</li><li>查看并获取nc文件中对应变量的信息；</li><li>根据数据的经纬度，计算分辨率；</li><li>定义投影；</li><li>保存数据为tif格式。</li></ul><h3 id="👀流程步骤"><a href="#👀流程步骤" class="headerlink" title="👀流程步骤"></a>👀流程步骤</h3><p>（1）读取nc文件</p><p>安装对应的netCDF4模块</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip install netCDF4</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> netCDF4 <span class="keyword">as</span> nc</span><br><span class="line"><span class="comment"># 读取nc文件</span></span><br><span class="line">tep_data = nc.Dataset(input_path)</span><br></pre></td></tr></table></figure><p>（2）查看并获取nc文件中对应变量的信息</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看nc文件中的变量信息</span></span><br><span class="line"><span class="built_in">print</span>(tep_data.variables.keys())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取nc文件中对应变量的信息</span></span><br><span class="line">lon_data = tep_data.variables[<span class="string">&quot;longitude&quot;</span>][:]</span><br><span class="line">lat_data = tep_data.variables[<span class="string">&quot;latitude&quot;</span>][:]</span><br></pre></td></tr></table></figure><p>（3）根据数据的经纬度，计算分辨率</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"> <span class="comment"># 影像的左上角&amp;右下角坐标</span></span><br><span class="line">lonmin, latmax, lonmax, latmin = [lon_data.<span class="built_in">min</span>(), lat_data.<span class="built_in">max</span>(), lon_data.<span class="built_in">max</span>(), lat_data.<span class="built_in">min</span>()]</span><br><span class="line"><span class="comment"># print(lonmin, latmax, lonmax, latmin)</span></span><br><span class="line">    </span><br><span class="line"><span class="comment"># 分辨率计算</span></span><br><span class="line">num_lon = <span class="built_in">len</span>(lon_data)  </span><br><span class="line">num_lat = <span class="built_in">len</span>(lat_data)  </span><br><span class="line">lon_res = (lonmax - lonmin) / (<span class="built_in">float</span>(num_lon) - <span class="number">1</span>)</span><br><span class="line">lat_res = (latmax - latmin) / (<span class="built_in">float</span>(num_lat) - <span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(num_lon, num_lat)</span><br><span class="line"><span class="built_in">print</span>(lon_res, lat_res)</span><br></pre></td></tr></table></figure><p>（4）定义投影</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义投影</span></span><br><span class="line">proj = osr.SpatialReference()</span><br><span class="line">proj.ImportFromEPSG(<span class="number">4326</span>)  <span class="comment"># WGS84</span></span><br><span class="line">proj = proj.ExportToWkt()  <span class="comment"># 重点，转成wkt格式</span></span><br><span class="line"><span class="comment"># print(prj)     字符串</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义六参数，设置影像的显示范围和分辨率</span></span><br><span class="line"><span class="comment"># 影像左上角横坐标：geoTransform[0]</span></span><br><span class="line"><span class="comment"># 影像左上角纵坐标：geoTransform[3]</span></span><br><span class="line"><span class="comment"># 遥感图像的水平空间分辨率为geoTransform[1]</span></span><br><span class="line"><span class="comment"># 遥感图像的垂直空间分辨率为geoTransform[5]</span></span><br><span class="line"><span class="comment"># 通常geoTransform[5] 与 geoTransform[1]相等</span></span><br><span class="line"><span class="comment"># 如果遥感影像方向没有发生旋转，即上北、下南，则geoTransform[2] 与 row *geoTransform[4] 为零。</span></span><br><span class="line">geotransform = (lonmin, lon_res, <span class="number">0.0</span>, latmax, <span class="number">0.0</span>, -lat_res)</span><br></pre></td></tr></table></figure><p>（5）保存数据为tif格式，以2m_temperature（t2m）温度为例</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">t2m = tep_data.variables[<span class="string">&quot;t2m&quot;</span>][:]  </span><br><span class="line"><span class="comment"># 用np.array把数据转化成数组（矩阵）类型</span></span><br><span class="line">t2m_arr = np.asarray(t2m)</span><br><span class="line"><span class="comment">#年份</span></span><br><span class="line">yearlist = [<span class="number">2017</span>,<span class="number">2018</span>,<span class="number">2019</span>,<span class="number">2020</span>,<span class="number">2021</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(yearlist)):</span><br><span class="line">    year = yearlist[i]</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">12</span>*i, <span class="number">12</span>*(i+<span class="number">1</span>)):</span><br><span class="line">        month = (j % <span class="number">12</span>) + <span class="number">1</span></span><br><span class="line">        outputpath = output_path + <span class="built_in">str</span>(year) + <span class="string">&quot;_&quot;</span> + <span class="built_in">str</span>(month) + <span class="string">&quot;_t2m.tif&quot;</span></span><br><span class="line">        write_img(outputpath, proj, geotransform, t2m_arr[j])</span><br></pre></td></tr></table></figure><h3 id="👀结果文件展示"><a href="#👀结果文件展示" class="headerlink" title="👀结果文件展示"></a>👀结果文件展示</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">2017_1_t2m.tif</span><br><span class="line">2017_2_t2m.tif</span><br><span class="line">2017_3_t2m.tif</span><br><span class="line">2017_4_t2m.tif</span><br><span class="line">2017_5_t2m.tif</span><br><span class="line">2017_6_t2m.tif</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">2021_7_t2m.tif</span><br><span class="line">2021_8_t2m.tif</span><br><span class="line">2021_9_t2m.tif</span><br><span class="line">2021_10_t2m.tif</span><br><span class="line">2021_11_t2m.tif</span><br><span class="line">2021_12_t2m.tif</span><br></pre></td></tr></table></figure><p>以2017_1_t2m.tif结果为例，如下图：</p><p><img src="https://s2.loli.net/2022/12/10/UNrouOseVYvwRhL.jpg"></p><h3 id="👀完整参考代码"><a href="#👀完整参考代码" class="headerlink" title="👀完整参考代码"></a>👀完整参考代码</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> netCDF4 <span class="keyword">as</span> nc</span><br><span class="line"><span class="keyword">from</span> osgeo <span class="keyword">import</span> gdal, osr</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment">#1.2定义写图像文件的函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">write_img</span>(<span class="params">filename, im_proj, im_geotrans, im_data</span>):</span><br><span class="line">    <span class="comment"># 判断栅格数据的数据类型</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;int8&#x27;</span> <span class="keyword">in</span> im_data.dtype.name:</span><br><span class="line">        datatype = gdal.GDT_Byte</span><br><span class="line">    <span class="keyword">elif</span> <span class="string">&#x27;int16&#x27;</span> <span class="keyword">in</span> im_data.dtype.name:</span><br><span class="line">        datatype = gdal.GDT_UInt16</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        datatype = gdal.GDT_Float32</span><br><span class="line">    <span class="comment"># 判读数组维数</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(im_data.shape) == <span class="number">3</span>:</span><br><span class="line">        im_bands, im_height, im_width = im_data.shape</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        im_bands, (im_height, im_width) = <span class="number">1</span>, im_data.shape</span><br><span class="line">    <span class="comment"># 创建文件</span></span><br><span class="line">    driver = gdal.GetDriverByName(<span class="string">&quot;GTiff&quot;</span>)</span><br><span class="line">    dataset = driver.Create(filename, im_width, im_height, im_bands, datatype)</span><br><span class="line">    dataset.SetGeoTransform(im_geotrans)  <span class="comment"># 写入仿射变换参数</span></span><br><span class="line">    dataset.SetProjection(im_proj)  <span class="comment"># 写入投影</span></span><br><span class="line">    <span class="keyword">if</span> im_bands == <span class="number">1</span>:</span><br><span class="line">        dataset.GetRasterBand(<span class="number">1</span>).WriteArray(im_data)  <span class="comment"># 写入数组数据</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(im_bands):</span><br><span class="line">            dataset.GetRasterBand(i + <span class="number">1</span>).WriteArray(im_data[i])</span><br><span class="line">    <span class="keyword">del</span> dataset</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">nc_totif</span>(<span class="params">input_path, output_path</span>):</span><br><span class="line">    <span class="comment"># 读取nc文件</span></span><br><span class="line">    tep_data = nc.Dataset(input_path)</span><br><span class="line">    <span class="comment"># 获取nc文件中对应变量的信息</span></span><br><span class="line">    lon_data = tep_data.variables[<span class="string">&quot;longitude&quot;</span>][:]</span><br><span class="line">    lat_data = tep_data.variables[<span class="string">&quot;latitude&quot;</span>][:]</span><br><span class="line">    <span class="comment"># 影像的左上角&amp;右下角坐标</span></span><br><span class="line">    lonmin, latmax, lonmax, latmin = [lon_data.<span class="built_in">min</span>(), lat_data.<span class="built_in">max</span>(), lon_data.<span class="built_in">max</span>(), lat_data.<span class="built_in">min</span>()]</span><br><span class="line">    <span class="comment"># 分辨率计算</span></span><br><span class="line">    num_lon = <span class="built_in">len</span>(lon_data)  <span class="comment"># 281</span></span><br><span class="line">    num_lat = <span class="built_in">len</span>(lat_data)  <span class="comment"># 241</span></span><br><span class="line">    lon_res = (lonmax - lonmin) / (<span class="built_in">float</span>(num_lon) - <span class="number">1</span>)</span><br><span class="line">    lat_res = (latmax - latmin) / (<span class="built_in">float</span>(num_lat) - <span class="number">1</span>)</span><br><span class="line">    <span class="comment"># 定义投影</span></span><br><span class="line">    proj = osr.SpatialReference()</span><br><span class="line">    proj.ImportFromEPSG(<span class="number">4326</span>)  <span class="comment"># WGS84</span></span><br><span class="line">    proj = proj.ExportToWkt()  <span class="comment"># 重点，转成wkt格式</span></span><br><span class="line">    <span class="comment"># print(prj)     字符串</span></span><br><span class="line">    geotransform = (lonmin, lon_res, <span class="number">0.0</span>, latmax, <span class="number">0.0</span>, -lat_res)</span><br><span class="line">    <span class="comment"># 获取2m温度</span></span><br><span class="line">    t2m = tep_data.variables[<span class="string">&quot;t2m&quot;</span>][:]  <span class="comment"># (60, 241, 281)</span></span><br><span class="line">    t2m_arr = np.asarray(t2m)</span><br><span class="line">    <span class="comment">#年份</span></span><br><span class="line">    yearlist = [<span class="number">2017</span>,<span class="number">2018</span>,<span class="number">2019</span>,<span class="number">2020</span>,<span class="number">2021</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(yearlist)):</span><br><span class="line">        year = yearlist[i]</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">12</span>*i, <span class="number">12</span>*(i+<span class="number">1</span>)):</span><br><span class="line">            month = (j % <span class="number">12</span>) + <span class="number">1</span></span><br><span class="line">            outputpath = output_path + <span class="built_in">str</span>(year) + <span class="string">&quot;_&quot;</span> + <span class="built_in">str</span>(month) + <span class="string">&quot;_t2m.tif&quot;</span></span><br><span class="line">            write_img(outputpath, proj, geotransform, t2m_arr[j])</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># nc文件输入输出路径</span></span><br><span class="line">    input_path = <span class="string">&quot;D:/Study/Data_Process/ERA5/Code/Monthly_averaged_2017_2021.nc&quot;</span></span><br><span class="line">    output_path = <span class="string">&quot;D:/Study/Data_Process/ERA5/Code/数据转换/&quot;</span></span><br><span class="line">    <span class="comment"># 读取nc文件，转换为tif文件</span></span><br><span class="line">    nc_totif(input_path, output_path)</span><br></pre></td></tr></table></figure><p>笔者不才，多多交流！！！</p>]]></content>
      
      
      <categories>
          
          <category> ERA5 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ERA5 </tag>
            
            <tag> 数据处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python基础知识（04）</title>
      <link href="/2022/09/03/Python-Basic04/"/>
      <url>/2022/09/03/Python-Basic04/</url>
      
        <content type="html"><![CDATA[<h2 id="⛄字符串的定义"><a href="#⛄字符串的定义" class="headerlink" title="⛄字符串的定义"></a>⛄字符串的定义</h2><p>字符串就是一串字符，用途众多，是编程语言中表示文本的数据类型，如”Hello World”。在Python中可以使用一对双引号<code>&quot; &quot;</code>或者一对单引号<code>&#39;&#39;</code>定义一个字符串。虽然可以使用<code>\&quot;</code>或者<code>\&#39;</code>做字符串的转义，但是在实际开发中：</p><ul><li>如果字符串内部需要使用<code>&quot;</code>，可以使用<code>&#39;</code>定义字符串</li><li>如果字符串内部需要使用<code>&#39;</code>，可以使用<code>&quot;</code>定义字符串</li></ul><p>可以使用索引获取一个字符串中指定位置的字符，索引计数从0开始；也可以使用<code>for</code>循环遍历字符串中每一个字符。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">str1 = <span class="string">&quot;My name is &#x27;xiaotang&#x27;&quot;</span></span><br><span class="line">str2 = <span class="string">&#x27;My name is &quot;HeartLoveLife&quot;&#x27;</span></span><br><span class="line"><span class="comment"># len(字符串)获取字符串的长度</span></span><br><span class="line">str1_len = <span class="built_in">len</span>(str1)</span><br><span class="line">str2_len = <span class="built_in">len</span>(str2)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(str1, <span class="string">&quot;;&quot;</span>, str2)</span><br><span class="line"><span class="built_in">print</span>(str1_len, <span class="string">&quot;;&quot;</span>, str2_len)</span><br><span class="line"><span class="comment"># 字符串.count(字符串)统计小字符串在大字符串中出现的次数</span></span><br><span class="line"><span class="built_in">print</span>(str1.count(<span class="string">&quot;n&quot;</span>))</span><br><span class="line"><span class="comment"># 字符串[索引]从字符串中取出单个字符</span></span><br><span class="line"><span class="built_in">print</span>(str1[<span class="number">0</span>])</span><br><span class="line"><span class="comment"># 字符串.index(字符串)获得小字符串第一次出现的索引</span></span><br><span class="line"><span class="built_in">print</span>(str1.index(<span class="string">&quot;n&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">My name <span class="keyword">is</span> <span class="string">&#x27;xiaotang&#x27;</span> ; My name <span class="keyword">is</span> <span class="string">&quot;HeartLoveLife&quot;</span></span><br><span class="line"><span class="number">21</span> ; <span class="number">26</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line">M</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><h2 id="⛄字符串常用操作"><a href="#⛄字符串常用操作" class="headerlink" title="⛄字符串常用操作"></a>⛄字符串常用操作</h2><p>Python内置提供的方法有很多，使得在开发时，能够针对字符串进行更加灵活的操作，应对更多的开发需求。使用Python内置函数dir()返回字符串的属性、方法列表。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">str_list = <span class="built_in">dir</span>(<span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(str_list)</span><br><span class="line"></span><br><span class="line">[<span class="string">&#x27;__add__&#x27;</span>, <span class="string">&#x27;__class__&#x27;</span>, <span class="string">&#x27;__contains__&#x27;</span>, <span class="string">&#x27;__delattr__&#x27;</span>, <span class="string">&#x27;__dir__&#x27;</span>, <span class="string">&#x27;__doc__&#x27;</span>, <span class="string">&#x27;__eq__&#x27;</span>, <span class="string">&#x27;__format__&#x27;</span>, <span class="string">&#x27;__ge__&#x27;</span>, <span class="string">&#x27;__getattribute__&#x27;</span>, <span class="string">&#x27;__getitem__&#x27;</span>, <span class="string">&#x27;__getnewargs__&#x27;</span>, <span class="string">&#x27;__gt__&#x27;</span>, <span class="string">&#x27;__hash__&#x27;</span>, <span class="string">&#x27;__init__&#x27;</span>, <span class="string">&#x27;__init_subclass__&#x27;</span>, <span class="string">&#x27;__iter__&#x27;</span>, <span class="string">&#x27;__le__&#x27;</span>, <span class="string">&#x27;__len__&#x27;</span>, <span class="string">&#x27;__lt__&#x27;</span>, <span class="string">&#x27;__mod__&#x27;</span>, <span class="string">&#x27;__mul__&#x27;</span>, <span class="string">&#x27;__ne__&#x27;</span>, <span class="string">&#x27;__new__&#x27;</span>, <span class="string">&#x27;__reduce__&#x27;</span>, <span class="string">&#x27;__reduce_ex__&#x27;</span>, <span class="string">&#x27;__repr__&#x27;</span>, <span class="string">&#x27;__rmod__&#x27;</span>, <span class="string">&#x27;__rmul__&#x27;</span>, <span class="string">&#x27;__setattr__&#x27;</span>, <span class="string">&#x27;__sizeof__&#x27;</span>, <span class="string">&#x27;__str__&#x27;</span>, <span class="string">&#x27;__subclasshook__&#x27;</span>, <span class="string">&#x27;capitalize&#x27;</span>, <span class="string">&#x27;casefold&#x27;</span>, <span class="string">&#x27;center&#x27;</span>, <span class="string">&#x27;count&#x27;</span>, <span class="string">&#x27;encode&#x27;</span>, <span class="string">&#x27;endswith&#x27;</span>, <span class="string">&#x27;expandtabs&#x27;</span>, <span class="string">&#x27;find&#x27;</span>, <span class="string">&#x27;format&#x27;</span>, <span class="string">&#x27;format_map&#x27;</span>, <span class="string">&#x27;index&#x27;</span>, <span class="string">&#x27;isalnum&#x27;</span>, <span class="string">&#x27;isalpha&#x27;</span>, <span class="string">&#x27;isascii&#x27;</span>, <span class="string">&#x27;isdecimal&#x27;</span>, <span class="string">&#x27;isdigit&#x27;</span>, <span class="string">&#x27;isidentifier&#x27;</span>, <span class="string">&#x27;islower&#x27;</span>, <span class="string">&#x27;isnumeric&#x27;</span>, <span class="string">&#x27;isprintable&#x27;</span>, <span class="string">&#x27;isspace&#x27;</span>, <span class="string">&#x27;istitle&#x27;</span>, <span class="string">&#x27;isupper&#x27;</span>, <span class="string">&#x27;join&#x27;</span>, <span class="string">&#x27;ljust&#x27;</span>, <span class="string">&#x27;lower&#x27;</span>, <span class="string">&#x27;lstrip&#x27;</span>, <span class="string">&#x27;maketrans&#x27;</span>, <span class="string">&#x27;partition&#x27;</span>, <span class="string">&#x27;replace&#x27;</span>, <span class="string">&#x27;rfind&#x27;</span>, <span class="string">&#x27;rindex&#x27;</span>, <span class="string">&#x27;rjust&#x27;</span>, <span class="string">&#x27;rpartition&#x27;</span>, <span class="string">&#x27;rsplit&#x27;</span>, <span class="string">&#x27;rstrip&#x27;</span>, <span class="string">&#x27;split&#x27;</span>, <span class="string">&#x27;splitlines&#x27;</span>, <span class="string">&#x27;startswith&#x27;</span>, <span class="string">&#x27;strip&#x27;</span>, <span class="string">&#x27;swapcase&#x27;</span>, <span class="string">&#x27;title&#x27;</span>, <span class="string">&#x27;translate&#x27;</span>, <span class="string">&#x27;upper&#x27;</span>, <span class="string">&#x27;zfill&#x27;</span>]</span><br></pre></td></tr></table></figure><h3 id="👀-判断类型"><a href="#👀-判断类型" class="headerlink" title="👀 判断类型"></a>👀 判断类型</h3><table><thead><tr><th align="left">方法</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">string.isspace()</td><td align="left">如果string中只包含空格，则返回True</td></tr><tr><td align="left">string.isalnum()</td><td align="left">如果string至少有一个字符并且所有字符都是字母或数字则返回True</td></tr><tr><td align="left">string.isalpha()</td><td align="left">如果string至少有一个字符并且所有字符都是字母则返回True</td></tr><tr><td align="left">string.isdecimal()</td><td align="left">如果 string只包含数字则返回True，<code>全角数字</code></td></tr><tr><td align="left">string.isdigit()</td><td align="left">如果 string只包含数字则返回True，<code>全角数字</code></td></tr><tr><td align="left">string.isnumeric()</td><td align="left">如果 string只包含数字则返回True，<code>全角数字</code>，<code>汉字数字</code></td></tr><tr><td align="left">string.istitle()</td><td align="left">如果 string是标题化的（每个单词的首字母大写）则返回True</td></tr><tr><td align="left">string.islower()</td><td align="left">如果string中包含至少一个区分大小写的字符，并且所有这些（区分大小写的）字符都是小写，则返回True</td></tr><tr><td align="left">string.isupper()</td><td align="left">如果 string中包含至少一个区分大小写的字符，并且所有这些（区分大小写的）字符都是大写，则返回True</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">str_space = <span class="string">&quot;   &quot;</span> </span><br><span class="line"><span class="built_in">print</span>(str_space.isspace())</span><br><span class="line"></span><br><span class="line">str1 = <span class="string">&quot;a_&quot;</span></span><br><span class="line">str2 = <span class="string">&quot;a9527&quot;</span></span><br><span class="line"><span class="built_in">print</span>(str1.isalnum(), str2.isalnum())</span><br><span class="line"></span><br><span class="line">str3 = <span class="string">&quot;a9527&quot;</span></span><br><span class="line">str4 = <span class="string">&quot;abc&quot;</span></span><br><span class="line"><span class="built_in">print</span>(str3.isalpha(), str4.isalpha())</span><br><span class="line"></span><br><span class="line">str5 = <span class="string">&quot;9527&quot;</span></span><br><span class="line">str6 = <span class="string">&quot;1&quot;</span></span><br><span class="line">str7 = <span class="string">&quot;一&quot;</span></span><br><span class="line"><span class="built_in">print</span>(str5.isdecimal(), str6.isdigit(), str7.isnumeric())</span><br><span class="line"></span><br><span class="line">str8 = <span class="string">&quot;Xiaotang&quot;</span></span><br><span class="line"><span class="built_in">print</span>(str8.istitle())</span><br><span class="line"></span><br><span class="line">str9 = <span class="string">&quot;xiaotang&quot;</span></span><br><span class="line">str10 = <span class="string">&quot;XIAOTANG&quot;</span></span><br><span class="line"><span class="built_in">print</span>(str9.islower(), str10.isupper())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="literal">False</span> <span class="literal">True</span></span><br><span class="line"><span class="literal">False</span> <span class="literal">True</span></span><br><span class="line"><span class="literal">True</span> <span class="literal">True</span> <span class="literal">True</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="literal">True</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><h3 id="👀-查找和替换"><a href="#👀-查找和替换" class="headerlink" title="👀 查找和替换"></a>👀 查找和替换</h3><table><thead><tr><th align="left">方法</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">string.startswith(str)</td><td align="left">检查字符串是否是以str开头，是则返回True</td></tr><tr><td align="left">string.endswith(str)</td><td align="left">检查字符串是否是以str结束，是则返回True</td></tr><tr><td align="left">string.find(str,start&#x3D;0,end&#x3D;len(string))</td><td align="left">检测str是否包含在string中，如果start和end指定范围，则检查是否包含在指定范围内，如果是返回开始的索引值，否则返回-1</td></tr><tr><td align="left">string.rfind(str,start&#x3D;0,end&#x3D;len(string))</td><td align="left">类似于find()，不过是从右边开始查找</td></tr><tr><td align="left">string.index(str,start&#x3D;0,end&#x3D;len(string))</td><td align="left">跟find()方法类似，不过如果str不在string会报错</td></tr><tr><td align="left">string.rindex(str,start&#x3D;0,end&#x3D;len(string))</td><td align="left">类似于index()，不过是从右边开始</td></tr><tr><td align="left">string.replace(old_str,new_str,num&#x3D;string.count(old))</td><td align="left">把string中的old_str替换成new_str，如果num指定，则替换不超过num次</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">str1 = <span class="string">&quot;his name is xiaotang, see you&quot;</span></span><br><span class="line"><span class="built_in">print</span>(str1.startswith(<span class="string">&quot;his&quot;</span>), str1.endswith(<span class="string">&quot;you&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(str1.find(<span class="string">&quot;is&quot;</span>, <span class="number">0</span>, <span class="number">5</span>), str1.rfind(<span class="string">&quot;is&quot;</span>), str1.find(<span class="string">&quot;iss&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(str1.index(<span class="string">&quot;is&quot;</span>), str1.rindex(<span class="string">&quot;is&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(str1.replace(<span class="string">&quot;xiaotang&quot;</span>, <span class="string">&quot;heartlovelife&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="literal">True</span> <span class="literal">True</span></span><br><span class="line"><span class="number">1</span> <span class="number">9</span> -<span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">9</span></span><br><span class="line">his name <span class="keyword">is</span> heartlovelife, see you</span><br></pre></td></tr></table></figure><h3 id="👀-大小写转换"><a href="#👀-大小写转换" class="headerlink" title="👀 大小写转换"></a>👀 大小写转换</h3><table><thead><tr><th align="left">方法</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">string.capitalize()</td><td align="left">把字符串的第一个字符大写</td></tr><tr><td align="left">string.title()</td><td align="left">把字符串的每个单词首字母大写</td></tr><tr><td align="left">string.lower()</td><td align="left">转换string中所有大写字符为小写</td></tr><tr><td align="left">string.upper()</td><td align="left">转换string中的小写字母为大写</td></tr><tr><td align="left">string.swapcase()</td><td align="left">翻转string中的大小写</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">str1 = <span class="string">&quot;xiao tang heLLo heLLo&quot;</span></span><br><span class="line"><span class="built_in">print</span>(str1.capitalize())</span><br><span class="line"><span class="built_in">print</span>(str1.title())</span><br><span class="line"><span class="built_in">print</span>(str1.lower())</span><br><span class="line"><span class="built_in">print</span>(str1.upper())</span><br><span class="line"><span class="built_in">print</span>(str1.swapcase())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">Xiao tang hello hello</span><br><span class="line">Xiao Tang Hello Hello</span><br><span class="line">xiao tang hello hello</span><br><span class="line">XIAO TANG HELLO HELLO</span><br><span class="line">XIAO TANG HEllO HEllO</span><br></pre></td></tr></table></figure><h3 id="👀-文本对齐"><a href="#👀-文本对齐" class="headerlink" title="👀 文本对齐"></a>👀 文本对齐</h3><table><thead><tr><th align="left">方法</th><th>说明</th></tr></thead><tbody><tr><td align="left">string.ljust(width，[填充字符])</td><td>返回一个原字符串左对齐，并使用填充字符（默认空格）填充至长度width的新字符串</td></tr><tr><td align="left">string.rjust(width，[填充字符])</td><td>返回一个原字符串右对齐，并使用填充字符（默认空格）填充至长度width的新字符串</td></tr><tr><td align="left">string.center(width，[填充字符])</td><td>返回一个原字符串居中，并使用填充字符（默认空格）填充至长度width的新字符串</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">str1 = <span class="string">&quot;-xiaotang hello hello-&quot;</span></span><br><span class="line"><span class="built_in">print</span>(str1.ljust(<span class="number">50</span>,<span class="string">&quot;a&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(str1.rjust(<span class="number">50</span>,<span class="string">&quot;b&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(str1.center(<span class="number">50</span>,<span class="string">&quot;a&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">-xiaotang hello hello-aaaaaaaaaaaaaaaaaaaaaaaaaaaa</span><br><span class="line">bbbbbbbbbbbbbbbbbbbbbbbbbbbb-xiaotang hello hello-</span><br><span class="line">aaaaaaaaaaaaaa-xiaotang hello hello-aaaaaaaaaaaaaa</span><br></pre></td></tr></table></figure><h3 id="👀去除空白字符"><a href="#👀去除空白字符" class="headerlink" title="👀去除空白字符"></a>👀去除空白字符</h3><table><thead><tr><th align="left">方法</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">string.lstrip()</td><td align="left">截掉string左边（开始）的空白字符</td></tr><tr><td align="left">string.rstrip()</td><td align="left">截掉string右边（末尾）的空白字符</td></tr><tr><td align="left">string.strip()</td><td align="left">截掉 string左右两边的空白字符</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">str1 = <span class="string">&quot;   xiaotangxiaotang   &quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;=&quot;</span>*<span class="number">5</span>, str1.lstrip(), <span class="string">&quot;=&quot;</span>*<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;=&quot;</span>*<span class="number">5</span>, str1.rstrip(), <span class="string">&quot;=&quot;</span>*<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;=&quot;</span>*<span class="number">5</span>, str1.strip(), <span class="string">&quot;=&quot;</span>*<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">===== xiaotangxiaotang    =====</span><br><span class="line">=====    xiaotangxiaotang =====</span><br><span class="line">===== xiaotangxiaotang =====</span><br></pre></td></tr></table></figure><h3 id="👀拆分和连接"><a href="#👀拆分和连接" class="headerlink" title="👀拆分和连接"></a>👀拆分和连接</h3><table><thead><tr><th align="left">方法</th><th>说明</th></tr></thead><tbody><tr><td align="left">string.partition(str)</td><td>把字符串string分成一个3元素的元组（str前面，str，str 后面）</td></tr><tr><td align="left">string.rpartition(str)</td><td>类似于partition()方法，不过是从右边开始查找</td></tr><tr><td align="left">string.split(str&#x3D;””,num)</td><td>以str为分隔符拆分string，返回列表；如果num有指定值，则仅分隔num+1个子字符串，str默认包含’r’，’t’，’n’和空格</td></tr><tr><td align="left">string.splitlines()</td><td>按照行（’r’，’n’，’rn’）分隔，返回一个包含各行作为元素的列表</td></tr><tr><td align="left">string.join(seq)</td><td>以string作为分隔符，将seq（要连接的元素序列）中所有的元素合并为一个新的字符串</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">str1 = <span class="string">&quot;xiaotang=or=xiaoming=or=xiaolizi&quot;</span></span><br><span class="line">str2 = <span class="string">&quot;xiaotang=or=xiaoming=or=xiaolizi\nxiaotang&quot;</span></span><br><span class="line">str3 = (<span class="string">&quot;I&quot;</span>,<span class="string">&quot;love&quot;</span>,<span class="string">&quot;you&quot;</span>)</span><br><span class="line">str4 = [<span class="string">&quot;I&quot;</span>,<span class="string">&quot;love&quot;</span>,<span class="string">&quot;you&quot;</span>]</span><br><span class="line"><span class="built_in">print</span>(str1.partition(<span class="string">&quot;or&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(str1.rpartition(<span class="string">&quot;or&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(str1.split(<span class="string">&quot;=&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(str2.splitlines())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;@&quot;</span>.join(str3))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;#&quot;</span>.join(str4))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">(<span class="string">&#x27;xiaotang=&#x27;</span>, <span class="string">&#x27;or&#x27;</span>, <span class="string">&#x27;=xiaoming=or=xiaolizi&#x27;</span>)</span><br><span class="line">(<span class="string">&#x27;xiaotang=or=xiaoming=&#x27;</span>, <span class="string">&#x27;or&#x27;</span>, <span class="string">&#x27;=xiaolizi&#x27;</span>)</span><br><span class="line">[<span class="string">&#x27;xiaotang&#x27;</span>, <span class="string">&#x27;or&#x27;</span>, <span class="string">&#x27;xiaoming&#x27;</span>, <span class="string">&#x27;or&#x27;</span>, <span class="string">&#x27;xiaolizi&#x27;</span>]</span><br><span class="line">[<span class="string">&#x27;xiaotang=or=xiaoming=or=xiaolizi&#x27;</span>, <span class="string">&#x27;xiaotang&#x27;</span>]</span><br><span class="line">I@love@you</span><br><span class="line">I<span class="comment">#love#you</span></span><br></pre></td></tr></table></figure><h3 id="👀字符串的切片"><a href="#👀字符串的切片" class="headerlink" title="👀字符串的切片"></a>👀字符串的切片</h3><p><strong>切片</strong>方法适用于<strong>字符串</strong>、<strong>列表</strong>、<strong>元组</strong></p><ul><li><strong>切片</strong>使用<strong>索引值</strong>来限定范围，从一个大的字符串中切出小的字符串</li><li><strong>列表</strong>和<strong>元组</strong>都是有序的集合，都能够<strong>通过索引值</strong>获取对应的数据</li><li><strong>字典</strong>是一个无序的集合，是使用<strong>键值对</strong>保存数据</li></ul><p>注意事项：</p><ul><li>指定的区间属于左闭右开型<code>[开始索引，结束索引]</code>相当于从起始位开始，到结束位的前一位结束（<strong>不包含结束位本身</strong>）</li><li>从头开始，<strong>开始索引</strong>数字可以省略，冒号不能省略</li><li>到末尾结束，<strong>结束索引</strong>数字可以省略，冒号不能省略</li><li>步长默认为1，如果连续切片，数字和冒号都可以省略</li><li>不仅支持<strong>顺序索引</strong>，还支持<strong>倒序索引</strong>；所谓倒序索引就是从右向左计算索引，最右边的索引值是**-1**，依次递减。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">str</span> = <span class="string">&quot;xiaotang9527helloworld&quot;</span></span><br><span class="line"><span class="comment"># 截取3~6位置的字符串,相当于索引为[2:5],因为不包含末尾,所以为[2,6]</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[<span class="number">2</span>:<span class="number">6</span>])</span><br><span class="line"><span class="comment"># 截取3~末尾的字符串</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[<span class="number">2</span>:])</span><br><span class="line"><span class="comment"># 截取从开始~6位置的字符串,6位置相当于索引为5,因为不包含末尾,所以为[:6]</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[:<span class="number">6</span>])</span><br><span class="line"><span class="comment"># 取完整的字符串</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[:])</span><br><span class="line"><span class="comment"># 从开始位置,每隔一个字符截取字符串</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[::<span class="number">2</span>])</span><br><span class="line"><span class="comment"># 倒序切片</span></span><br><span class="line"><span class="comment"># -1表示倒数第一个字符</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[-<span class="number">1</span>])</span><br><span class="line"><span class="comment"># 截取3-末尾的字符串(不包含最后一个字符)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[<span class="number">2</span>:-<span class="number">1</span>])</span><br><span class="line"><span class="comment"># 截取字符串末尾两个字符</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[-<span class="number">2</span>:])</span><br><span class="line"><span class="comment"># 字符串的逆序</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[::-<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">aota</span><br><span class="line">aotang9527helloworld</span><br><span class="line">xiaota</span><br><span class="line">xiaotang9527helloworld</span><br><span class="line">xatn92hlool</span><br><span class="line">d</span><br><span class="line">aotang9527helloworl</span><br><span class="line">ld</span><br><span class="line">dlrowolleh7259gnatoaix</span><br></pre></td></tr></table></figure><h2 id="⛄公共方法及特殊用法"><a href="#⛄公共方法及特殊用法" class="headerlink" title="⛄公共方法及特殊用法"></a>⛄公共方法及特殊用法</h2><h3 id="👀内置函数"><a href="#👀内置函数" class="headerlink" title="👀内置函数"></a>👀内置函数</h3><table><thead><tr><th>函数</th><th>描述</th><th>备注</th></tr></thead><tbody><tr><td>len(item)</td><td>计算容器中元素个数</td><td></td></tr><tr><td>del(item)</td><td>删除变量</td><td>del有两种方式</td></tr><tr><td>max(item)</td><td>返回容器中元素最大值</td><td>如果是字典，只针对key比较</td></tr><tr><td>min(item)</td><td>返回容器中元素最小值</td><td>如果是字典，只针对key比较</td></tr><tr><td>cmp(item1,item2)</td><td>比较两个值，-1小于&#x2F;0相等&#x2F;1大于</td><td>Python3.x取消了cmp函数</td></tr></tbody></table><h3 id="👀运算符特殊用法"><a href="#👀运算符特殊用法" class="headerlink" title="👀运算符特殊用法"></a>👀运算符特殊用法</h3><table><thead><tr><th>运算符</th><th>表达式</th><th>结果</th><th>描述</th><th>支持数据类型</th></tr></thead><tbody><tr><td>+</td><td>[1,2] + [3,4]</td><td>[1,2,3,4]</td><td>合并</td><td>字符串、列表、元组</td></tr><tr><td>*</td><td>[“a”] * 2</td><td>[“a”,”a”]</td><td>重复</td><td>字符串、列表、元组</td></tr><tr><td>in</td><td>2 in (1,2,3)</td><td>True</td><td>元素是否存在</td><td>字符串、列表、元组、字典</td></tr><tr><td>not in</td><td>5 not in(1,2,3)</td><td>True</td><td>元素是否不存在</td><td>字符串、列表、元组、字典</td></tr></tbody></table><blockquote><p><code>in</code> 在对字典操作时，判断的是字典的键；<code>in</code>和<code>not in</code>被称为成员运算符，用于测试序列中是否包含指定的成员。</p></blockquote><h3 id="👀完成的for循环语法·"><a href="#👀完成的for循环语法·" class="headerlink" title="👀完成的for循环语法·"></a>👀完成的for循环语法·</h3><p>在Python中完整的<code>for</code>循环语法如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> 变量 <span class="keyword">in</span> 集合:</span><br><span class="line">循环体代码</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">没有通过<span class="keyword">break</span>退出循环，循环结束后，会执行的代码</span><br></pre></td></tr></table></figure><p>应用场景</p><ol><li>在迭代遍历嵌套的数据类型时，例如一个列表包含了多个字典</li><li>需求：判断某一个字典中，是否存在指定的值</li></ol><ul><li>如果存在，提示并且退出循环</li><li>如果不存在，在循环整体结束后，希望得到一个统一的提示</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 第一种</span></span><br><span class="line">stu = [</span><br><span class="line">       &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;xiaotang&quot;</span>,</span><br><span class="line">        <span class="string">&quot;age&quot;</span>: <span class="string">&quot;25&quot;</span>,</span><br><span class="line">        <span class="string">&quot;gender&quot;</span>: <span class="literal">True</span>,</span><br><span class="line">        <span class="string">&quot;height&quot;</span>: <span class="number">180</span>,</span><br><span class="line">        <span class="string">&quot;weight&quot;</span>: <span class="number">66</span>&#125;,</span><br><span class="line">       &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;xiaoming&quot;</span>,</span><br><span class="line">        <span class="string">&quot;age&quot;</span>: <span class="string">&quot;26&quot;</span>,</span><br><span class="line">        <span class="string">&quot;gender&quot;</span>: <span class="literal">True</span>,</span><br><span class="line">        <span class="string">&quot;height&quot;</span>: <span class="number">179</span>,</span><br><span class="line">        <span class="string">&quot;weight&quot;</span>: <span class="number">65</span>&#125;</span><br><span class="line">       ]</span><br><span class="line">find_name = <span class="string">&quot;xiaotang&quot;</span></span><br><span class="line"><span class="keyword">for</span> stu_dict <span class="keyword">in</span> stu:</span><br><span class="line">    <span class="built_in">print</span>(stu_dict)</span><br><span class="line">    <span class="comment"># 判断当前遍历的字典中姓名是否为find_name</span></span><br><span class="line">    <span class="keyword">if</span> stu_dict[<span class="string">&quot;name&quot;</span>] == find_name:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;找到阿汤了&quot;</span>)</span><br><span class="line">        <span class="comment"># 如果找到,直接退出循环,不需对后续的数据进行比较</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;怎么搞的，没有找到！！&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;循环结束&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;xiaotang&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="string">&#x27;25&#x27;</span>, <span class="string">&#x27;gender&#x27;</span>: <span class="literal">True</span>, <span class="string">&#x27;height&#x27;</span>: <span class="number">180</span>, <span class="string">&#x27;weight&#x27;</span>: <span class="number">66</span>&#125;</span><br><span class="line">找到阿汤了</span><br><span class="line">循环结束</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二种</span></span><br><span class="line">stu = [</span><br><span class="line">       &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;xiaotang&quot;</span>,</span><br><span class="line">        <span class="string">&quot;age&quot;</span>: <span class="string">&quot;25&quot;</span>,</span><br><span class="line">        <span class="string">&quot;gender&quot;</span>: <span class="literal">True</span>,</span><br><span class="line">        <span class="string">&quot;height&quot;</span>: <span class="number">180</span>,</span><br><span class="line">        <span class="string">&quot;weight&quot;</span>: <span class="number">66</span>&#125;,</span><br><span class="line">       &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;xiaoming&quot;</span>,</span><br><span class="line">        <span class="string">&quot;age&quot;</span>: <span class="string">&quot;26&quot;</span>,</span><br><span class="line">        <span class="string">&quot;gender&quot;</span>: <span class="literal">True</span>,</span><br><span class="line">        <span class="string">&quot;height&quot;</span>: <span class="number">179</span>,</span><br><span class="line">        <span class="string">&quot;weight&quot;</span>: <span class="number">65</span>&#125;</span><br><span class="line">       ]</span><br><span class="line">find_name = <span class="string">&quot;xiaotang1&quot;</span></span><br><span class="line"><span class="keyword">for</span> stu_dict <span class="keyword">in</span> stu:</span><br><span class="line">    <span class="built_in">print</span>(stu_dict)</span><br><span class="line">    <span class="comment"># 判断当前遍历的字典中姓名是否为find_name</span></span><br><span class="line">    <span class="keyword">if</span> stu_dict[<span class="string">&quot;name&quot;</span>] == find_name:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;找到阿汤了&quot;</span>)</span><br><span class="line">        <span class="comment"># 如果找到,直接退出循环,不需对后续的数据进行比较</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;怎么搞的，没有找到！！&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;循环结束&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;xiaotang&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="string">&#x27;25&#x27;</span>, <span class="string">&#x27;gender&#x27;</span>: <span class="literal">True</span>, <span class="string">&#x27;height&#x27;</span>: <span class="number">180</span>, <span class="string">&#x27;weight&#x27;</span>: <span class="number">66</span>&#125;</span><br><span class="line">&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;xiaoming&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="string">&#x27;26&#x27;</span>, <span class="string">&#x27;gender&#x27;</span>: <span class="literal">True</span>, <span class="string">&#x27;height&#x27;</span>: <span class="number">179</span>, <span class="string">&#x27;weight&#x27;</span>: <span class="number">65</span>&#125;</span><br><span class="line">怎么搞的，没有找到！！</span><br><span class="line">循环结束</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Python基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python基础知识（03）</title>
      <link href="/2022/08/07/Python-Basic03/"/>
      <url>/2022/08/07/Python-Basic03/</url>
      
        <content type="html"><![CDATA[<p>作为一个实用主义的学习者，最关心的问题一定是【我为什么要选择学<code>Python</code>，学会之后我可以用来做什么？】首先，对于初学者来说，比起其它编程语言，<code>Python</code>更容易上手。<code>Python</code>的设计哲学是优雅、明确、简单。</p><blockquote><p>在官方的The Zen of Python《Python之禅》中：There should be one – and preferably only one – obvious way to do it.</p></blockquote><p><code>Python</code>追求的是找到最好的解决方案。</p><h2 id="⛄函数"><a href="#⛄函数" class="headerlink" title="⛄函数"></a>⛄函数</h2><p>所谓函数，就是把具有独立功能的代码块组织为一个小模块，在需要的时候调用。</p><p>函数的使用包含两个步骤：</p><p>（1）定义函数——封装独立的功能；</p><p>（2）调用函数——享受封装的成果；</p><p>函数的作用，在开发程序时，使用函数可以提高编写的效率以及代码的重用。其实我们早已掌握了函数的用法，例如：</p><blockquote><p><code>print</code>() ：是一个放入对象就能将结果打印的函数；</p><p><code>input</code>()：是一个可以让用户输入信息的函数；</p><p><code>len</code>()：是一个可以测量对象长度的函数；</p><p><code>int</code>()：是一个可以将字符串类型的数字转换成是整数类型的函数。</p></blockquote><p>通过观察其实不难发现，<code>Python</code>中所谓的函数就是把你要处理的对象放到一个名字后面的括号里就可以了。</p><h3 id="👀函数的定义"><a href="#👀函数的定义" class="headerlink" title="👀函数的定义"></a>👀函数的定义</h3><p>定义函数的格式如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">函数名</span>（参数<span class="number">1</span>，参数<span class="number">2</span>）:</span><br><span class="line">函数封装的代码</span><br><span class="line"><span class="keyword">return</span> </span><br></pre></td></tr></table></figure><p>（1）<code>def</code>：是英文<code>define</code>的缩写。</p><p>（2）函数名称：应该能够表达函数封装代码的功能，方便后续的调用。</p><p>（3）函数名称的命名应该符合标识符的命名规则。</p><p>​①可以由字母、下划线和数字组成</p><p>​②不能以数字开头</p><p>​③不能与关键字重名</p><blockquote><p>函数调用：调用函数很简单的，通过<code>函数名（）</code>即可完成对函数的调用；函数调用应该放在函数定义的下方。</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">say_hello</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;hello world_1&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;hello world_2&quot;</span>)</span><br><span class="line"><span class="comment"># 只有在调用函数时，之前定义的函数才会执行</span></span><br><span class="line"><span class="comment"># 函数执行完成之后，会重新回到之前的程序中，继续执行后续的代码</span></span><br><span class="line">say_hello()</span><br></pre></td></tr></table></figure><h3 id="👀函数的参数"><a href="#👀函数的参数" class="headerlink" title="👀函数的参数"></a>👀函数的参数</h3><p><strong>函数</strong>，把<strong>具有独立功能的代码块</strong>组织为一个小模块，在需要的时候调用。</p><p><strong>函数的参数</strong>，增加函数的通用性，针对相同数据处理逻辑，能够适应更多的数据。</p><p>（1）在函数内部，把参数当做变量使用，进行需要的数据处理；</p><p>（2）函数调用时，按照函数定义的参数顺序，把希望在函数内部处理的数据，通过参数传递。</p><blockquote><p>形参：定义函数时，小括号中的参数，是用来接收参数用的，在函数内部作为变量使用；</p><p>实参：调用函数时，小括号中的参数，是用来把数据传递到函数内部用的。</p></blockquote><p>函数返回值。在程序开发中，有时候，会希望一个函数执行结束后，告诉调用者一个结果，以便调用者针对具体的结果做后续的处理。</p><p>返回值是函数完成工作后，最后给调用者的一个结果；在函数中使用<code>return</code>关键字可以返回结果；调用函数一方，可以使用变量来接收函数的返回结果。</p><blockquote><p>注意：return表示返回，后续的代码都不会被执行。</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sum</span>(<span class="params">num1, num2</span>):</span><br><span class="line">    <span class="keyword">return</span> num1 + num2</span><br><span class="line"><span class="comment"># 调用函数，并使用result变量接收计算结果</span></span><br><span class="line">result = <span class="built_in">sum</span>(<span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;计算结果是%d&quot;</span>%result)</span><br></pre></td></tr></table></figure><h2 id="⛄数据结构"><a href="#⛄数据结构" class="headerlink" title="⛄数据结构"></a>⛄数据结构</h2><p>   <code>Python</code> 有四种数据结构，分别是：列表、字典、元组，集合。每种数据结构都有自己的特点，并且都有着独到的用处。为了避免过早地陷入细枝末节，我们先从整体上来认识一下这四种数据结构：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">list</span> = [vall,val2,val3,val4]</span><br><span class="line"><span class="built_in">dict</span> = &#123;key1:vall,key2:val2&#125;</span><br><span class="line"><span class="built_in">tuple</span> = (vall,val2,val3,val4)</span><br><span class="line"><span class="built_in">set</span> = &#123;vall,val2,val3,val4&#125;</span><br></pre></td></tr></table></figure><p>从最容易识别的特征上来说，列表中的元素使用方括号扩起来，字典和集合是花括号，而元组则是圆括号。其中字典中的元素是均带有”:”的<code>key</code>与<code>value</code>的对应关系组。</p><p><code>Python</code>中数据类型可以分为<strong>数字型</strong>和<strong>非数字型</strong></p><p>（1）数字型</p><ul><li><p>整型（<code>int</code>）</p></li><li><p>浮点型（<code>float</code>）</p></li><li><p>布尔型（<code>bool</code>）</p><ul><li>真<code>True</code>非<code>0</code>数——<strong>非零即真</strong></li><li>假<code>False</code>  0</li></ul></li><li><p>复数型（<code>complex</code>）主要用于科学计算，例如：平面场问题、波动问题、电感电容等问题</p></li></ul><p>（2）非数字型</p><ul><li>字符串</li><li>列表</li><li>元组</li><li>字典</li></ul><p>（3）在<code>Python</code>中，所有非数字型变量都支持以下特点</p><ul><li>都是一个序列<code>sequence</code>，也可以理解为容器</li><li>取值<code>[]</code></li><li>遍历<code>for in</code></li><li>计算长度、最大&#x2F;最小值、比较、删除</li><li>链接<code>+</code>和重复<code>*</code></li><li>切片</li></ul><h3 id="👀列表"><a href="#👀列表" class="headerlink" title="👀列表"></a>👀列表</h3><p>列表具有的最显著的特征：</p><ul><li>列表中的每一个元素都是<strong>可变</strong>的；</li><li>列表中的元素是<strong>有序</strong>的，也就是说每一个元素都有一个位置；</li><li>列表可以容纳<code>Python</code>中的任何对象。</li></ul><p>列表中的元素是可变的，这意味着我们可以在列表中添加、删除和修改元素。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Weekday = [<span class="string">&quot;Monday&quot;</span>, <span class="string">&quot;Tuesday&quot;</span>, <span class="string">&quot;Wednesday&quot;</span>, <span class="string">&quot;Thursday&quot;</span>, <span class="string">&quot;Friday&quot;</span>, <span class="string">&quot;Sunday&quot;</span>]</span><br><span class="line"><span class="built_in">print</span>(Weekday[<span class="number">0</span>])</span><br></pre></td></tr></table></figure><p><code>List</code>（列表）是<code>Python</code>中使用最频繁的数据类型，在其他语言中通常叫做数组。专门用于存储一串信息；列表用<code>[]</code>定义，数据之间使用<code>,</code>分隔；列表的索引从0开始。</p><blockquote><p>索引就是数据在列表中的位置编号，索引又可以被称为下标。从列表中取值时，如果超出索引范围，程序会报错</p></blockquote><table><thead><tr><th align="center">序号</th><th align="center">分类</th><th align="center">关键字&#x2F;函数&#x2F;方法</th><th align="center">说明描述</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">增加</td><td align="center">列表.<code>insert</code>(索引，数据)</td><td align="center">在指定位置插入数据</td></tr><tr><td align="center"></td><td align="center"></td><td align="center">列表.<code>append</code>(数据)</td><td align="center">在末尾追加数据</td></tr><tr><td align="center"></td><td align="center"></td><td align="center">列表.<code>extend</code>(列表2)</td><td align="center">将列表2的数据追加到列表</td></tr><tr><td align="center">2</td><td align="center">修改</td><td align="center">列表[索引] &#x3D; 数据</td><td align="center">修改指定索引的数据</td></tr><tr><td align="center">3</td><td align="center">删除</td><td align="center"><code>del</code> 列表[索引]</td><td align="center">删除指定索引的数据</td></tr><tr><td align="center"></td><td align="center"></td><td align="center">列表.<code>remove</code>[数据]</td><td align="center">删除第一个出现的指定数据</td></tr><tr><td align="center"></td><td align="center"></td><td align="center">列表.<code>pop</code></td><td align="center">删除末尾数据</td></tr><tr><td align="center"></td><td align="center"></td><td align="center">列表.<code>pop</code>(索引)</td><td align="center">删除指定索引数据</td></tr><tr><td align="center"></td><td align="center"></td><td align="center">列表.<code>clear</code></td><td align="center">清空列表</td></tr><tr><td align="center">4</td><td align="center">统计</td><td align="center"><code>len</code>(列表)</td><td align="center">列表长度</td></tr><tr><td align="center"></td><td align="center"></td><td align="center">列表.<code>count</code>(数据)</td><td align="center">数据在列表中出现的次数</td></tr><tr><td align="center">5</td><td align="center">排序</td><td align="center">列表.<code>sort</code>()</td><td align="center">升序排序</td></tr><tr><td align="center"></td><td align="center"></td><td align="center">列表.<code>sort</code>(<code>reverse</code> &#x3D; <code>True</code>)</td><td align="center">降序排序</td></tr><tr><td align="center"></td><td align="center"></td><td align="center">列表.<code>reverse</code>()</td><td align="center">逆序、反转</td></tr></tbody></table><p><strong><code>del</code>关键字</strong></p><ul><li>使用<code>del</code>关键字（<code>delete</code>）同样可以删除列表中元素；</li><li><code>del</code>关键字本质上是用来将一个变量从内存中删除的；</li><li>如果使用<code>del</code>关键字将变量从内存中删除，后续的代码就不能再使用这个变量了。</li></ul><p>在日常开发中，要从列表删除数据，建议使用列表提供的方法。</p><p><strong>循环遍历</strong></p><p>遍历就是从头到尾依次从列表中获取数据；在循环体内部针对每一个元素，执行相同的操作。在<code>Python</code>中为了提高列表的遍历效率，专门提供的迭代<code>iteration</code>遍历。使用<code>for</code>就能实现迭代遍历。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> name_list:</span><br><span class="line">    <span class="built_in">print</span>(name)</span><br></pre></td></tr></table></figure><p><strong>应用场景</strong></p><p>尽管Python的列表中可以存储不同类型的数据。但是在开发中，更多的应用场景是</p><ul><li>列表存储相同类型的数据</li><li>通过迭代遍历，在循环体内部，针对列表中的每一项元素，执行相同的操作</li></ul><h3 id="👀元组（Tuple）"><a href="#👀元组（Tuple）" class="headerlink" title="👀元组（Tuple）"></a>👀元组（Tuple）</h3><p>元组其实可以理解成一个稳固版的列表，因为元组是<strong>不可修改</strong>的，因此在列表中的存在的方法均不可以使用在元组上，但是元组是可以被查看索引的，方式就和列表一样：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">letters = (<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>, <span class="string">&quot;e&quot;</span>, <span class="string">&quot;f&quot;</span>, <span class="string">&quot;g&quot;</span>, <span class="string">&quot;h&quot;</span>)</span><br><span class="line">letter[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>（1）<code>Tuple</code>（元组）与列表类似，不同之处在于元组的元素不能修改</p><ul><li><p>元组表示多个元素组成的序列</p></li><li><p>元组在<code>Python</code>开发中，有特定的应用场景</p></li></ul><p>（2）用于存储一串信息，数据之间使用<code>,</code>分隔</p><p>（3）元组用<code>（）</code>定义</p><p>（4）元组的索引从<code>0</code>开始，索引就是数据在元组中的位置编号</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">info_tuple = (<span class="string">&quot;zhangsan&quot;</span>,<span class="number">18</span>,<span class="number">1.75</span>)</span><br><span class="line"><span class="comment"># 创建空元组</span></span><br><span class="line">first_tuple = ()</span><br><span class="line"><span class="comment"># 元组中只包含一个元素时，需要在元素后面添加逗号</span></span><br><span class="line">second_tuple = (<span class="number">50</span>,)</span><br></pre></td></tr></table></figure><blockquote><p>元组的索引值是从0开始的，<code>len</code>(元组)获取元组的长度n+1，元组.<code>count</code>(数据)数据在元组中出现的次数。</p></blockquote><ul><li>元组[索引]表示从列表中取值</li><li>元组.<code>index</code>[数据]表示获得数据第一次出现的索引。</li></ul><p><strong>循环遍历</strong></p><p>取值就是从元组中获取存储在指定位置的数据。</p><p>遍历就是从头到尾依次从元组中获取数据。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> name_tuple:</span><br><span class="line">    <span class="built_in">print</span>(item)</span><br></pre></td></tr></table></figure><blockquote><p>在<code>Python</code>中，可以使用<code>for</code> 循环遍历所有非数字型类型的变量：列表、元组、字典以及字符串提示：在实际开发中，除非能够确认元组中的数据类型，否则针对元组的循环遍历需求并不是很多</p></blockquote><p><strong>应用场景</strong></p><p>尽管可以使用<code>for in</code> 遍历元组。但是在开发中，更多的应用场景是：</p><ul><li>函数的参数和返回值，一个函数可以接收任意多个参数，或者一次返回多个数据（可以利用元组保存数据，即返回值默认是以元组形式保存的）；</li><li>格式化字符串，格式化字符串后面的（）本质上就是一个元组；</li><li>让列表不可以被修改，以保护数据安全。</li></ul><p><strong>元组和列表之间的转换</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用list函数可以把元组转换成列表</span></span><br><span class="line"><span class="built_in">list</span>(元组)</span><br><span class="line"><span class="comment"># 使用tuple函数可以把列表转换成元组</span></span><br><span class="line"><span class="built_in">tuple</span>(列表)</span><br></pre></td></tr></table></figure><h3 id="👀字典-Dictionary"><a href="#👀字典-Dictionary" class="headerlink" title="👀字典(Dictionary)"></a>👀字典(Dictionary)</h3><p>编程世界中其实有很多概念都基于现实生活的原型，字典这种数据结构的特征也正如现实世界中的字典一样，使用名称一内容进行数据的构建，在<code>Python</code>中分别对应着键（<code>key</code>）-值（<code>value</code>），习惯上称之为键值对。</p><p>字典的特征总结如下：</p><ul><li>字典中数据必须是以键值对的形式出现的；</li><li>逻辑上讲，键是不能重复的，而值可以重复；</li><li>字典中的键（<code>key</code>）是不可变的，也就是无法修改的；而值（<code>value</code>）是可变的，可修改的，可以是任何对象。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">xiaotang = &#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;xiaotang&quot;</span>,</span><br><span class="line">    <span class="string">&quot;age&quot;</span>: <span class="number">18</span>,</span><br><span class="line">    <span class="string">&quot;gender&quot;</span>: <span class="literal">True</span>,</span><br><span class="line">    <span class="string">&quot;height&quot;</span>: <span class="number">1.80</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（1）<code>dictionary</code>（字典）是除列表以外<code>Python</code>之中最灵活的数据类型</p><p>（2）字典同样可以用来存储多个数据</p><ul><li>通常用于存储描述一个物体的相关信息</li></ul><p>（3）字典和列表的区别</p><ul><li><strong>列表</strong>是<strong>有序</strong>的对象集合</li><li><strong>字典</strong>是<strong>无序</strong>的对象集合</li></ul><p>（4）字典用<code>&#123;&#125;</code>定义</p><p>（5）字典使用键值对存储数据，键值对之间使用<code>,</code>分隔</p><ul><li><p>键<code>key</code>是索引</p></li><li><p>值<code>value</code>是数据</p></li><li><p>键和值之间使用<code>:</code>分隔</p></li><li><p>键必须是唯一的</p></li><li><p>值可以取任何数据类型，但键只能使用字符串、数字或元组</p></li></ul><p><strong>字典的常用操作</strong></p><table><thead><tr><th align="center">关键字&#x2F;函数&#x2F;方法</th><th align="center">描述说明</th></tr></thead><tbody><tr><td align="center"><code>len</code>(字典)</td><td align="center">获取字典的键值对数量</td></tr><tr><td align="center">字典.<code>keys</code>()</td><td align="center">所有<code>key</code>列表</td></tr><tr><td align="center">字典.<code>values</code>()</td><td align="center">所有<code>value</code>列表</td></tr><tr><td align="center">字典.<code>items</code>()</td><td align="center">所有（<code>key</code>，<code>value</code>）元组列表</td></tr><tr><td align="center">字典[<code>key</code>]</td><td align="center">可以从字典中取值，<code>key</code>不存在会报错</td></tr><tr><td align="center">字典.<code>get(key)</code></td><td align="center">可以从字典中取值，<code>key</code>不存在不会报错</td></tr><tr><td align="center"><code>del</code> 字典<code>[key]</code></td><td align="center">删除指定键值对，<code>key</code>不存在会报错</td></tr><tr><td align="center">字典.<code>pop(key)</code></td><td align="center">删除指定键值对，<code>key</code>不存在会报错</td></tr><tr><td align="center">字典.<code>popitem()</code></td><td align="center">随机删除一个键值对</td></tr><tr><td align="center">字典.<code>clear()</code></td><td align="center">清空字典</td></tr><tr><td align="center">字典<code>[key]</code> &#x3D; <code>value</code></td><td align="center">如果<code>key</code>存在，修改数据<br />如果<code>key</code>不存在，新建键值对</td></tr><tr><td align="center">字典.<code>setdefault</code>(<code>key</code>, <code>value</code>)</td><td align="center">如果<code>key</code>存在，不会修改数据<br />如果<code>key</code>不存在，新建键值对</td></tr><tr><td align="center">字典1.<code>update</code>(字典2)</td><td align="center">将字典2的数据合并到字典1</td></tr></tbody></table><p><strong>循环遍历</strong></p><p>遍历就是依次从字典中获取所有键值对。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> item_key <span class="keyword">in</span> name_dic:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;%s: %s&quot;</span> % (item_key, name_dic[item_key]))</span><br></pre></td></tr></table></figure><blockquote><p>在实际开发中，由于字典中每一个键值对保存数据的类型是不同的，所以针对字典的循环遍历需求并不是很多。</p></blockquote><p><strong>应用场景</strong></p><p>尽管可以使用<code>for in</code>遍历字典。但是在开发中，更多的应用场景是：</p><ul><li>使用多个键值对，存储描述一个物体的相关信息——描述更复杂的数据信息</li><li>将多个字典放在一个列表中，再进行遍历，在循环体内部针对每一个字典进行相同的处理</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">card_list=[</span><br><span class="line">    &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;张三”，</span></span><br><span class="line"><span class="string">&quot;</span>qq<span class="string">&quot;: &quot;</span><span class="number">12345</span><span class="string">&quot;，</span></span><br><span class="line"><span class="string">&quot;</span>phone<span class="string">&quot;: &quot;</span><span class="number">110</span><span class="string">&quot;&#125;，</span></span><br><span class="line"><span class="string">&#123;&quot;</span>name<span class="string">&quot;: &quot;</span>李四<span class="string">&quot;，</span></span><br><span class="line"><span class="string">            &quot;</span>qq<span class="string">&quot;: &quot;</span><span class="number">54321</span><span class="string">&quot;，</span></span><br><span class="line"><span class="string">&quot;</span>phone<span class="string">&quot;: &quot;</span><span class="number">10086</span><span class="string">&quot;&#125;</span></span><br><span class="line"><span class="string">          ]</span></span><br></pre></td></tr></table></figure><h3 id="👀集合-Set"><a href="#👀集合-Set" class="headerlink" title="👀集合(Set)"></a>👀集合(Set)</h3><p>集合则更接近数学上集合的概念。每一个集合中的元素是<strong>无序的</strong>、<strong>不重复</strong>的任意对象，我们可以通过集合去判断数据的从属关系，有时还可以通过集合把数据结构中重复的元素减掉。</p><p>集合不能被切片也不能被索引，除了做集合运算之外，集合元素可以被添加还有删除。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">item_set = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;</span><br><span class="line">item_add(<span class="number">5</span>)</span><br><span class="line">item_discard(<span class="number">5</span>)</span><br></pre></td></tr></table></figure><p>参考文献：</p><p>《编程小白的第1本Python入门书》侯爵</p><p>《Python入门教程完整版》黑马程序员</p><p>《Python基础教程（第3版）》 Magnus Lie Hetland（著）袁国忠（译）</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Python基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python基础知识（02）</title>
      <link href="/2022/07/12/Python-Basic02/"/>
      <url>/2022/07/12/Python-Basic02/</url>
      
        <content type="html"><![CDATA[<p>编程语言是最有意思的，如果要实现一个复杂的功能或程序，条件语句和循环语句必不可少。除了常见的顺序结构，<code>if-elif-else</code>是常见的条件语句，当你写出这样的语句的时候，就意味着你告诉了计算机什么时候该怎么做，或者什么是不用做的。<code>for</code>循环和<code>while</code>循环是常见的循环语句，循环作为编程语言中最强力的特性之一，能够帮助我们做很多重复性的事情，比如批量命名、批量操作等。</p><h2 id="⛄顺序结构"><a href="#⛄顺序结构" class="headerlink" title="⛄顺序结构"></a>⛄顺序结构</h2><p>在我们最开始编写的基础程序中，语句都是逐条执行的。即从上而下，顺序执行代码。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = <span class="string">&quot;xiaotang&quot;</span></span><br><span class="line">name_describe =<span class="string">&quot;this is My name&quot;</span></span><br><span class="line">age = <span class="number">20</span></span><br><span class="line">age_describe = <span class="string">&quot;this is My age&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;=&quot;</span>*<span class="number">50</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;this is a line&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;this is another block&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hello World&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;My friends&quot;</span>)</span><br><span class="line">......</span><br></pre></td></tr></table></figure><h2 id="⛄分支结构"><a href="#⛄分支结构" class="headerlink" title="⛄分支结构"></a>⛄分支结构</h2><h3 id="👀布尔值"><a href="#👀布尔值" class="headerlink" title="👀布尔值"></a>👀布尔值</h3><p>现在，如果想更进一步，让程序选择是否执行特定的语句块，该怎么办呢？在介绍分支语句之前，我们先了解一下布尔值的用武之地，布尔值（<code>True</code>和<code>False</code>）作为一种变量的类型，实际上，<code>True</code>和<code>False</code>不过是0和1的别名，虽然看起来不同，但作用是相同的。换而言之，标准值<code>False</code>和<code>None</code>、各种类型（包括浮点数、复数等）的数值0、空序列（如空字符串、空元组和空列表）以及空映射（如空字典）都被视为假，而其他各种值都被视为真，包括特殊值<code>True</code>。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="literal">True</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="literal">False</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="literal">True</span> == <span class="number">1</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="literal">False</span> == <span class="number">0</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="literal">True</span> + <span class="literal">False</span> + <span class="number">20</span></span><br><span class="line"><span class="number">21</span></span><br></pre></td></tr></table></figure><blockquote><p>因此，如果你看到一个返回1或0的表达式（可能是使用较旧的<code>Python</code>版本编写的），就知道这实际上意味着<code>True</code>或<code>False</code>。</p></blockquote><p>布尔值<code>True</code>和<code>False</code>属于类型<code>bool</code>，而<code>bool</code>与<code>list</code>、<code>str</code>和<code>tuple</code>一样，可用来转换其他的值。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">bool</span>(<span class="string">&quot;I think, there I am&quot;</span>)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">bool</span>(<span class="number">20</span>)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">bool</span>(<span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">bool</span>(<span class="number">0</span>)</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure><blockquote><p>鉴于任何值都可用作布尔值，因此你几乎不需要显式地进行转换（<code>Python</code>会自动转换）。</p></blockquote><h3 id="👀if语句"><a href="#👀if语句" class="headerlink" title="👀if语句"></a>👀if语句</h3><p>真值可合并，至于如何合并稍后再讲，先来看看真值可用来做什么。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = <span class="built_in">input</span>(<span class="string">&quot;请输入你的语句：&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> name.endswith(<span class="string">&quot;wow!!&quot;</span>)：</span><br><span class="line"><span class="built_in">print</span>（<span class="string">&quot;hello xiaotang wow!!&quot;</span>）</span><br></pre></td></tr></table></figure><blockquote><p><code>endswith()</code>方法用于判断字符串是否以指定后缀结尾，如果以指定后缀结尾返回<code>True</code>，否则返回<code>False</code>。可选参数”<code>start</code>“和”<code>end</code>“为检索字符串的开始与结束位置。</p></blockquote><p>这就是if语句，让你能够有条件地执行代码。这意味着如果条件（<code>if</code>和冒号之间的表达式）为前面定义的真，就执行后续代码块（这里是一条<code>print</code>语句）；如果条件为假，就不执行（你应该猜到了）。</p><h3 id="👀else子句"><a href="#👀else子句" class="headerlink" title="👀else子句"></a>👀else子句</h3><p>在前一节的示例中，如果你输入以Gumby结尾的名字，方法<code>name.endswith</code>将返回<code>True</code>，导致后续代码块执行——打印问候语。如果你愿意，可使用else子句增加一种选择（之所以叫子句是因为<code>else</code>不是独立的语句，而是if语句的一部分）。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = <span class="built_in">input</span>(<span class="string">&quot;请输入你的语句：&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> name.endswith(<span class="string">&quot;wow!!&quot;</span>)：</span><br><span class="line"><span class="built_in">print</span>（<span class="string">&quot;hello xiaotang wow!!&quot;</span>）</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello people&quot;</span>)</span><br></pre></td></tr></table></figure><p>在这里，如果没有执行第一个代码块（因为条件为假），将进入第二个代码块。这个示例表明，<code>Python</code>代码很容易理解，不是吗？如果从if开始将代码大声朗读出来，听起来将像普通句子一样（也可能不那么普通）。</p><p>还有一个与<code>if</code>语句很像的“亲戚”，它就是条件表达式——C语言中三目运算符的<code>Python</code>版本。下面的表达式使用<code>if</code>和<code>else</code>确定其值：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">status = <span class="string">&quot;friend&quot;</span> <span class="keyword">if</span> name.endswith(<span class="string">&quot;wow!!&quot;</span>) <span class="keyword">else</span> <span class="string">&quot;people&quot;</span></span><br></pre></td></tr></table></figure><p>如果条件（紧跟在if后面）为真，表达式的结果为提供的第一个值（这里为”<code>friend</code>“），否则为第二个值（这里为”<code>people</code>“）。</p><h3 id="👀elif子句"><a href="#👀elif子句" class="headerlink" title="👀elif子句"></a>👀elif子句</h3><p>要检查多个条件，可使用<code>elif</code>。<code>elif</code>是<code>else if</code>的缩写，由一个<code>if</code>子句和一个<code>else</code>子句组合而成，也就是包含条件的<code>else</code>子句。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">num = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;Enter a number: &#x27;</span>)) </span><br><span class="line"><span class="keyword">if</span> num &gt; <span class="number">0</span>: </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;The number is positive&#x27;</span>) </span><br><span class="line"><span class="keyword">elif</span> num &lt; <span class="number">0</span>: </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;The number is negative&#x27;</span>) </span><br><span class="line"><span class="keyword">else</span>: </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;The number is zero&#x27;</span>) </span><br></pre></td></tr></table></figure><h3 id="👀代码块嵌套"><a href="#👀代码块嵌套" class="headerlink" title="👀代码块嵌套"></a>👀代码块嵌套</h3><p>下面穿插点额外的内容。你可将if语句放在其他if语句块中，如下所示：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> 条件 <span class="number">1</span>：</span><br><span class="line"><span class="comment"># 条件1满足执行的代码</span></span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> 条件<span class="number">1</span>基础上的条件<span class="number">2</span>：</span><br><span class="line">    <span class="comment"># 条件2满足时，执行的代码</span></span><br><span class="line">        ......</span><br><span class="line"><span class="comment"># 条件2不满足的处理</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 条件2不满足时，执行的代码</span></span><br><span class="line"><span class="comment"># 条件1不满足的处理</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="comment"># 条件1不满足时，执行的代码</span></span><br><span class="line">    ......</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = <span class="built_in">input</span>(<span class="string">&#x27;What is your name? &#x27;</span>) </span><br><span class="line"><span class="keyword">if</span> name.endswith(<span class="string">&#x27;Gumby&#x27;</span>): </span><br><span class="line"><span class="keyword">if</span> name.startswith(<span class="string">&#x27;Mr.&#x27;</span>): </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Hello, Mr. Gumby&#x27;</span>) </span><br><span class="line"><span class="keyword">elif</span> name.startswith(<span class="string">&#x27;Mrs.&#x27;</span>): </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Hello, Mrs. Gumby&#x27;</span>) </span><br><span class="line"><span class="keyword">else</span>: </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Hello, Gumby&#x27;</span>) </span><br><span class="line"><span class="keyword">else</span>: </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Hello, stranger&#x27;</span>) </span><br></pre></td></tr></table></figure><p>在这里，如果名字以Gumby结尾，就同时检查名字开头，这是在第一个代码块中使用一条独立的if语句完成的。请注意，这里还使用了<code>elif</code>。最后一个分支（<code>else</code>子句）没有指定条件——如果没有选择其他分支，就选择最后一个分支。如果需要，这里的两个<code>else</code>子句都可省略。如果省略里面的<code>else</code>子句，将忽略并非以Mr.或Mrs.打头的名字（假设名字为Gumby）。如果省略外面的<code>else</code>子句，将忽略陌生人。</p><h2 id="⛄循环结构"><a href="#⛄循环结构" class="headerlink" title="⛄循环结构"></a>⛄循环结构</h2><p>至此，你知道了如何在条件为真（或假）时执行操作，但如何重复操作多次呢？例如，你可能想创建一个程序，要打印1~100的所有数。当然，你可能会想到：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="number">5</span>)</span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line"><span class="built_in">print</span>(<span class="number">98</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="number">99</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="number">100</span>)</span><br></pre></td></tr></table></figure><p>但如果你愿意使用笨办法，就不会求助于<code>Python</code>了，不是吗？</p><p>循环的作用就是让<strong>指定的代码</strong>重复的执行。</p><h3 id="👀while循环"><a href="#👀while循环" class="headerlink" title="👀while循环"></a>👀while循环</h3><p>为避免前述示例所示的繁琐代码，可以使用<code>while</code>循环快速地打印出1~100的所有数。<code>while</code>循环最常用的应用场景就是让<strong>执行的代码</strong>按照<strong>指定的次数重复</strong>执行。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = <span class="number">1</span> </span><br><span class="line"><span class="keyword">while</span> x &lt;= <span class="number">100</span>: </span><br><span class="line"><span class="built_in">print</span>(x) </span><br><span class="line">x += <span class="number">1</span></span><br></pre></td></tr></table></figure><p>就像上面那样做，不太复杂，不是吗？你还可以使用循环来确保用户输入名字，如下所示：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = <span class="string">&#x27;&#x27;</span> </span><br><span class="line"><span class="keyword">while</span> <span class="keyword">not</span> name: </span><br><span class="line">name = <span class="built_in">input</span>(<span class="string">&#x27;Please enter your name: &#x27;</span>) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Hello, &#123;&#125;!&#x27;</span>.<span class="built_in">format</span>(name)) </span><br></pre></td></tr></table></figure><p>请尝试运行这些代码，并在要求你输入名字时直接按回车键。你会看到提示信息再次出现，因为name还是为空字符串，这相当于假。</p><blockquote><p>如果你只是输入一个空格字符（将其作为你的名字），结果将如何呢？程序将接受这个名字，因为包含一个空格字符的字符串不是空的，因此不会将name视为假。这无疑是这个小程序的一个瑕疵，但很容易修复：只需将<code>while not name</code>改为<code>while not name or name.isspace()</code>或<code>while not name.strip()</code>即可。</p><p><code>isspace()</code>方法：如果字符串中的所有字符均为空格字符，则返回”<code>True</code>“，否则，返回”<code>False</code>“;</p><p><code>strip()</code>方法：用于移除字符串头尾指定的字符（默认为空格或换行符）或字符序列。该方法只能删除开头或结尾的字符，不能删除中间部分的字符。</p></blockquote><p><strong>while循环语句基本语法</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">初始条件设置--通常是重复执行的计数器</span><br><span class="line"><span class="keyword">while</span> 条件（判断计数器是否达到目标次数）：</span><br><span class="line">条件满足时，做的事情<span class="number">1</span></span><br><span class="line">    条件满足时，做的事情<span class="number">2</span></span><br><span class="line">    条件满足时，做的事情<span class="number">3</span></span><br><span class="line">    ......</span><br><span class="line">    处理条件（例如：计数器 + <span class="number">1</span>）</span><br></pre></td></tr></table></figure><p><code>while</code>语句以及缩进部分是一个<strong>完整的代码块</strong>。例子：打印100遍<code>Hello Python</code></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1 初始条件设置--通常是重复执行的计数器</span></span><br><span class="line">i = <span class="number">1</span></span><br><span class="line"><span class="comment"># 2 使用while判断条件</span></span><br><span class="line"><span class="keyword">while</span> i &lt;= <span class="number">5</span>：</span><br><span class="line"><span class="comment"># 要重复执行的代码</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello Python&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 处理计数器 i</span></span><br><span class="line">    i = i + <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;循环结束后 i = %d&quot;</span> % i)</span><br></pre></td></tr></table></figure><p>注意：循环结束后，之前定义的计数器条件的数值时依旧存在的。</p><blockquote><p>死循环，由于程序员的问题，忘记在循环内部<strong>修改循环的判断条件</strong>，导致<strong>循环持续执行</strong>，程序无法终止。</p></blockquote><h3 id="👀for循环"><a href="#👀for循环" class="headerlink" title="👀for循环"></a>👀for循环</h3><p><code>while</code>语句非常灵活，可用于在条件为真时反复执行代码块。这在通常情况下很好，但有时候你可能想根据需要进行定制。一种这样的需求是为序列（或其他可迭代对象）中每个元素执行代码块。</p><blockquote><p>基本上，可迭代对象是可使用for循环进行遍历的对象。就目前而言，只需将可迭代对象视为序列即可。</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">words = [<span class="string">&#x27;this&#x27;</span>, <span class="string">&#x27;is&#x27;</span>, <span class="string">&#x27;an&#x27;</span>, <span class="string">&#x27;ex&#x27;</span>, <span class="string">&#x27;parrot&#x27;</span>] </span><br><span class="line"><span class="keyword">for</span> word <span class="keyword">in</span> words: </span><br><span class="line"><span class="built_in">print</span>(word) </span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">numbers = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>] </span><br><span class="line"><span class="keyword">for</span> number <span class="keyword">in</span> numbers: </span><br><span class="line"><span class="built_in">print</span>(number)</span><br></pre></td></tr></table></figure><p>鉴于迭代（也就是遍历）特定范围内的数是一种常见的任务，<code>Python</code>提供了一个创建范围的内置函数。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">range</span>(<span class="number">0</span>, <span class="number">10</span>) </span><br><span class="line"><span class="built_in">range</span>(<span class="number">0</span>, <span class="number">10</span>) </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">0</span>, <span class="number">10</span>)) </span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>] </span><br></pre></td></tr></table></figure><p>范围类似于切片。它们包含起始位置（这里为0），但不包含结束位置（这里为10）。在很多情况下，你都希望范围的起始位置为0。实际上，如果只提供了一个位置，将把这个位置视为结束位置，并假定起始位置为0。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">range</span>(<span class="number">10</span>) </span><br><span class="line"><span class="built_in">range</span>(<span class="number">0</span>, <span class="number">10</span>) </span><br></pre></td></tr></table></figure><p>下面的程序打印数1～100：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> number <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">101</span>): </span><br><span class="line"><span class="built_in">print</span>(number) </span><br></pre></td></tr></table></figure><p>（1）迭代字典</p><p>要遍历字典的所有关键字，可像遍历序列那样使用普通的for语句。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d = &#123;<span class="string">&#x27;x&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;y&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;z&#x27;</span>: <span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> d:</span><br><span class="line"><span class="built_in">print</span>(key, <span class="string">&#x27;corresponds to&#x27;</span>, d[key])</span><br></pre></td></tr></table></figure><p>也可使用<code>keys</code>等字典方法来获取所有的键。如果只对值感兴趣，可使用<code>d.values</code>。你可能还记得，<code>d.items</code>以元组的方式返回键值对。<code>for</code>循环的优点之一是，可在其中使用序列解包。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> key, value <span class="keyword">in</span> d.items(): </span><br><span class="line"><span class="built_in">print</span>(key, <span class="string">&#x27;corresponds to&#x27;</span>, value)</span><br></pre></td></tr></table></figure><p>（2）遍历列表</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">names = [<span class="string">&#x27;anne&#x27;</span>, <span class="string">&#x27;beth&#x27;</span>, <span class="string">&#x27;george&#x27;</span>, <span class="string">&#x27;damon&#x27;</span>]</span><br><span class="line">ages = [<span class="number">12</span>, <span class="number">45</span>, <span class="number">32</span>, <span class="number">102</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(names)):</span><br><span class="line"><span class="built_in">print</span>(names[i], <span class="string">&#x27;is&#x27;</span>, ages[i], <span class="string">&#x27;years old&#x27;</span>) </span><br></pre></td></tr></table></figure><h3 id="👀break和continue"><a href="#👀break和continue" class="headerlink" title="👀break和continue"></a>👀break和continue</h3><p><code>break</code>和<code>continue</code>是专门在循环中使用的关键字。</p><blockquote><p><code>break</code>：在循环过程中，如果某一条件满足后，不希望执行循环，可以使用<code>break</code>退出循环；</p><p><code>continue</code>：在循环过程中，如果某一条件满足后，不希望执行循环，但又不退出循环，可以使用<code>continue</code>跳过当次循环。即：在整个循环中，只有某些条件，不需要执行循环代码，而其它条件都需要执行。</p></blockquote><h3 id="👀练习"><a href="#👀练习" class="headerlink" title="👀练习"></a>👀练习</h3><p>（1）打印小星星</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 打印小星星</span></span><br><span class="line">i = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> i &lt;= <span class="number">5</span>:</span><br><span class="line">    j = <span class="number">1</span></span><br><span class="line">    <span class="comment"># 在循环内部，再增加一个循环，实现每一行的星星打印</span></span><br><span class="line">    <span class="keyword">while</span> j &lt;= i:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>,end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">        j += <span class="number">1</span></span><br><span class="line">    <span class="comment"># 每一行星号输出完成后，再增加一个换行</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&quot;</span>)</span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">*</span><br><span class="line">**</span><br><span class="line">***</span><br><span class="line">****</span><br><span class="line">*****</span><br></pre></td></tr></table></figure><blockquote><p>默认情况下，<code>print()</code>函数输出内容之后，会自动在内容末尾增加换行；如果不希望末尾增加换行，可以在<code>print()</code>函数输出内容的后面增加，<code>end=&quot;&quot;</code>；其中””中间可以指定<code>print()</code>函数输出内容之后，继续希望显示的内容。</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 向控制台输出内容结束之后，不会换行</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>,end=<span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="comment"># 单纯的换行</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&quot;</span>)</span><br></pre></td></tr></table></figure><p>（2）打印九九乘法表</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 打印九九乘法表</span></span><br><span class="line">i = <span class="number">1</span></span><br><span class="line"><span class="comment"># 最大打印9行</span></span><br><span class="line"><span class="keyword">while</span> i &lt;= <span class="number">9</span>:</span><br><span class="line">    <span class="comment"># 定义起始列</span></span><br><span class="line">    j = <span class="number">1</span></span><br><span class="line">    <span class="comment"># 最大打印i列</span></span><br><span class="line">    <span class="keyword">while</span> j &lt;= i:</span><br><span class="line">        <span class="comment"># 转义字符，\t在控制台输出一个制表符，协助在输出文件时，垂直方向保持对齐</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%d*%d=%d&quot;</span>%(j,i,i*j),end=<span class="string">&quot;\t&quot;</span>)</span><br><span class="line">        j += <span class="number">1</span></span><br><span class="line">    <span class="comment"># 一行打印完成后，换行</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&quot;</span>)</span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="number">1</span>*<span class="number">1</span>=<span class="number">1</span></span><br><span class="line"><span class="number">1</span>*<span class="number">2</span>=<span class="number">2</span>   <span class="number">2</span>*<span class="number">2</span>=<span class="number">4</span></span><br><span class="line"><span class="number">1</span>*<span class="number">3</span>=<span class="number">3</span>   <span class="number">2</span>*<span class="number">3</span>=<span class="number">6</span>   <span class="number">3</span>*<span class="number">3</span>=<span class="number">9</span></span><br><span class="line"><span class="number">1</span>*<span class="number">4</span>=<span class="number">4</span>   <span class="number">2</span>*<span class="number">4</span>=<span class="number">8</span>   <span class="number">3</span>*<span class="number">4</span>=<span class="number">12</span>  <span class="number">4</span>*<span class="number">4</span>=<span class="number">16</span></span><br><span class="line"><span class="number">1</span>*<span class="number">6</span>=<span class="number">6</span>   <span class="number">2</span>*<span class="number">6</span>=<span class="number">12</span>  <span class="number">3</span>*<span class="number">6</span>=<span class="number">18</span>  <span class="number">4</span>*<span class="number">6</span>=<span class="number">24</span>  <span class="number">5</span>*<span class="number">6</span>=<span class="number">30</span>  <span class="number">6</span>*<span class="number">6</span>=<span class="number">36</span></span><br><span class="line"><span class="number">1</span>*<span class="number">7</span>=<span class="number">7</span>   <span class="number">2</span>*<span class="number">7</span>=<span class="number">14</span>  <span class="number">3</span>*<span class="number">7</span>=<span class="number">21</span>  <span class="number">4</span>*<span class="number">7</span>=<span class="number">28</span>  <span class="number">5</span>*<span class="number">7</span>=<span class="number">35</span>  <span class="number">6</span>*<span class="number">7</span>=<span class="number">42</span>  <span class="number">7</span>*<span class="number">7</span>=<span class="number">49</span></span><br><span class="line"><span class="number">1</span>*<span class="number">8</span>=<span class="number">8</span>   <span class="number">2</span>*<span class="number">8</span>=<span class="number">16</span>  <span class="number">3</span>*<span class="number">8</span>=<span class="number">24</span>  <span class="number">4</span>*<span class="number">8</span>=<span class="number">32</span>  <span class="number">5</span>*<span class="number">8</span>=<span class="number">40</span>  <span class="number">6</span>*<span class="number">8</span>=<span class="number">48</span>  <span class="number">7</span>*<span class="number">8</span>=<span class="number">56</span>  <span class="number">8</span>*<span class="number">8</span>=<span class="number">64</span></span><br><span class="line"><span class="number">1</span>*<span class="number">9</span>=<span class="number">9</span>   <span class="number">2</span>*<span class="number">9</span>=<span class="number">18</span>  <span class="number">3</span>*<span class="number">9</span>=<span class="number">27</span>  <span class="number">4</span>*<span class="number">9</span>=<span class="number">36</span>  <span class="number">5</span>*<span class="number">9</span>=<span class="number">45</span>  <span class="number">6</span>*<span class="number">9</span>=<span class="number">54</span>  <span class="number">7</span>*<span class="number">9</span>=<span class="number">63</span>  <span class="number">8</span>*<span class="number">9</span>=<span class="number">72</span>  <span class="number">9</span>*<span class="number">9</span>=<span class="number">81</span></span><br></pre></td></tr></table></figure><blockquote><p><code>\t</code> 在控制台输出一个制表符，协助在输出文本时垂直方向保持对齐</p><p><code>\n</code> 在控制台输出一个换行符</p><p>制表符的功能是在不使用表格的情况下在垂直方向按列对齐文本。</p></blockquote><h2 id="⛄转义字符"><a href="#⛄转义字符" class="headerlink" title="⛄转义字符"></a>⛄转义字符</h2><p>转义字符是很多程序语言、数据格式和通信协议的形式文法的一部分。对于一个给定的字母表，一个转义字符的目的是开始一个字符序列，使得转义字符开头的该字符序列具有不同于该字符序列单独出现时的语义。因此转义字符开头的字符序列被叫做转义序列。</p><p>转义序列通常有两种功能。第一个是编码一个句法上的实体，如设备命令或者无法被字母表直接表示的特殊数据。第二种功能，也叫字符引用，用于表示无法在当前上下文中被键盘录入的字符（如字符串中的回车符），或者在当前上下文中会有不期望的含义的字符（如C语言字符串中的双引号字符”，不能直接出现，必须用转义序列表示）。在后面那种情况，转义序列是一种由转义字符自身和一个被引用的字符组成的一个二合字母（<code>digraph</code>）情形。</p><table><thead><tr><th align="center">转义字符</th><th align="center">描述说明</th></tr></thead><tbody><tr><td align="center">\\</td><td align="center">反斜杠符号</td></tr><tr><td align="center">&#39;</td><td align="center">单引号</td></tr><tr><td align="center">&quot;</td><td align="center">双引号</td></tr><tr><td align="center">\n</td><td align="center">换行</td></tr><tr><td align="center">\t</td><td align="center">横向制表符</td></tr><tr><td align="center">\r</td><td align="center">回车</td></tr></tbody></table><p>参考文献：</p><p>《编程小白的第1本Python入门书》侯爵</p><p>《Python基础教程（第3版）》 Magnus Lie Hetland（著）袁国忠（译）</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Python基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python基础知识（01）</title>
      <link href="/2022/07/09/Python-Basic01/"/>
      <url>/2022/07/09/Python-Basic01/</url>
      
        <content type="html"><![CDATA[<p>1999年，吉多·范罗苏姆向<code>DARPA</code>提交了一条名为”<code>Computer Programming for Everybody</code>“的资金申请，并在后来说明了他对<code>Python</code>的目标：</p><ul><li>一门简单直观的语言并与主要竞争者一样强大</li><li>开源，以便任何人都可以为它做贡献</li><li>代码像纯英语那样容易理解</li><li>适用于短期开发的日常任务</li></ul><p>计算机不能直接理解任何除<strong>机器语言</strong>以外的语言，所以必须要把程序员所写的程序语言翻译成机器语言，计算机才能执行程序。将其他语言翻译成机器语言的工具，被称为<strong>编译器</strong>。</p><p>编译器翻译的方式有两种：一个是<strong>编译</strong>，另外一个是<strong>解释</strong>。两种方式之间的区别在于翻译时间点的不同。当编译器以解释方式运行的时候，也称之为<strong>解释器</strong>。</p><ul><li><strong>编译型语言</strong>：程序在执行之前需要一个专门的编译过程，把程序编译成为机器语言的文件，运行时不需要重新翻译，直接使用编译的结果就行了。程序执行效率高，依赖编译器，跨平台性差些。如<code>C</code>、<code>C++</code>。</li><li><strong>解释型语言</strong>：解释型语言编写的程序不进行预先编译，以文本方式存储程序代码，会将代码一句一句直接运行。在发布程序时，看起来省了道编译工序，但是在运行程序的时候，必须先解释再运行</li></ul><blockquote><p>编译型语言和解释型语言对比</p><ul><li>速度——编译型语言比解释型语言执行速度快</li><li>跨平台性——解释型语言比编译型语言跨平台性好</li></ul></blockquote><h2 id="⛄Python-概述"><a href="#⛄Python-概述" class="headerlink" title="⛄Python 概述"></a>⛄Python 概述</h2><h3 id="👀Python特点"><a href="#👀Python特点" class="headerlink" title="👀Python特点"></a>👀Python特点</h3><ul><li><code>Python</code> 是完全面向对象的语言</li></ul><ol><li><p>函数、模块、数字、字符串都是对象，在<code>Python</code>中一切皆对象</p></li><li><p>完全支持继承、重载、多重继承</p></li><li><p>支持重载运算符，也支持泛型设计</p></li></ol><ul><li><code>Python</code> 拥有一个强大的标准库，</li></ul><ol><li><code>Python</code>语言的核心只包含数字、字符串、列表、字典、文件等常见类型和函数，而由<code>Python</code>标准库提供了系统管理、网络通信、文本处理、数据库接口、图形系统、<code>XML</code>处理等额外的功能。</li><li><code>Python</code> 社区提供了大量的第三方模块，使用方式与标准库类似。它们的功能覆盖科学计算、人工智能、机器学习、<code>Web</code>开发、数据库接口、图形系统多个领域。</li></ol><h3 id="👀Python程序执行方式"><a href="#👀Python程序执行方式" class="headerlink" title="👀Python程序执行方式"></a>👀Python程序执行方式</h3><ul><li><code>Python</code>解释器</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用Python2.x解释器</span></span><br><span class="line">python xxx.py</span><br><span class="line"><span class="comment"># 使用Python3.x解释器</span></span><br><span class="line">python3 xxx.py</span><br><span class="line"></span><br><span class="line"><span class="comment"># 其他语言Python解释器</span></span><br><span class="line">CPython       <span class="comment"># 官方版本的C语言实现</span></span><br><span class="line">Jython        <span class="comment"># 可以运行在Java平台</span></span><br><span class="line">IronPython    <span class="comment"># 可以运行在.NET和Mono平台</span></span><br><span class="line">PyPy          <span class="comment"># Python实现的，支持JIT即时编译</span></span><br></pre></td></tr></table></figure><ul><li>交互式运行<code>Python</code>程序</li></ul><p>直接在终端中运行解释器，而不输入要执行的文件名；在<code>Python</code>的<code>Shell</code>中直接输入<code>Python</code>的代码，会立即看到程序执行结果。优缺点：适合于学习&#x2F;验证<code>Python</code>语法或者局部代码；代码不能保存，不适合运行太大的程序。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">退出官方的解释器</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">(1) 直接输入<span class="built_in">exit</span>()</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; <span class="built_in">exit</span>()</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">(2)使用热键退出</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在python解释器中，使用热键ctrl+d可以退出解释器</span></span><br></pre></td></tr></table></figure><ul><li><code>IPython</code></li></ul><p><code>Ipython</code>中的“<code>I</code>”代表交互<code>interactive</code></p><p>特点：<code>IPython</code>是一个<code>python</code>的交互式<code>shell</code>，比默认的<code>python shell</code>好用得多。<code>IPython</code>是基于<code>BSD</code>开源的。</p><ol><li>支持自动补全；</li><li>自动缩进；</li><li>支持<code>bash shell</code>命令；</li><li>内置了许多很有用的功能和函数。</li></ol><blockquote><p>单行注释，行注释，以#开头</p><p>多行注释，块注释，一对连续的三个引号</p></blockquote><h2 id="⛄Python基础知识（快速入门）"><a href="#⛄Python基础知识（快速入门）" class="headerlink" title="⛄Python基础知识（快速入门）"></a>⛄Python基础知识（快速入门）</h2><h3 id="👀标识符和关键字"><a href="#👀标识符和关键字" class="headerlink" title="👀标识符和关键字"></a>👀标识符和关键字</h3><p><strong>标识符</strong>就是程序员定义变量名、函数名。</p><blockquote><p>命名规则：在<code>Python</code>中，<strong>标识符</strong>（名称）只能由字母、数字和下划线（<code>_</code>）构成；不能以数字开头；不能与<strong>关键字</strong>重名；区分大小写。</p></blockquote><p><strong>关键字</strong>就是在<code>Python</code>内部已经使用的标识符；<strong>关键字</strong>具有特殊的功能和含义；开发者不允许定义和关键字相同名字的标识符。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 通过以下命令查看可以查看Python中的关键字</span></span><br><span class="line"><span class="keyword">import</span> keyword             <span class="comment"># import关键字可以导入一个“工具包”</span></span><br><span class="line"><span class="built_in">print</span>(keyword.kwlist)</span><br></pre></td></tr></table></figure><h3 id="👀变量"><a href="#👀变量" class="headerlink" title="👀变量"></a>👀变量</h3><p>变量是表示（或指向）特定值的名称。例如，可以使用名称<code>X</code>来表示<code>6</code>。不同于其它一些语言，使用Python变量前必须给它赋值，因为Python变量没有默认值。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Python中的标识符是区分大小写的</span></span><br><span class="line">x = <span class="number">6</span>    <span class="comment"># 赋值，表示将6赋给了变量x，等号（=）用来给变量赋值；</span></span><br><span class="line"><span class="comment"># 变量赋值之后，就可在表达式中使用它</span></span><br></pre></td></tr></table></figure><p>在定义变量时，为了保证代码格式，<code>=</code>的左右应该各保留一个空格；在<code>Python</code>中，如果变量名需要<strong>两个</strong>或<strong>多个单词</strong>组成时，可以按照以下方式命名：</p><ul><li>每个单词都使用小写字母；</li><li>单词与单词之间使用<code>_</code>下划线连接，例如：<code>first_name</code>&#x2F;<code>last_name</code>。</li></ul><p><strong>驼峰命名法</strong>，当变量名是由两个或多个单词组成时，还可以利用驼峰命名法来命名。</p><p>小驼峰式命名法：第一个单词以小写字母开始，后续单词的首字母大写。例如：<code>firstName</code>&#x2F;<code>lastName</code>。</p><p>大驼峰式命名法：每一个单词的首字母都采用大写字母。例如：<code>FirstName</code>&#x2F;<code>LastName</code>。</p><h3 id="👀变量的类型"><a href="#👀变量的类型" class="headerlink" title="👀变量的类型"></a>👀变量的类型</h3><p>首先，在内存中创建一个变量，会包括：</p><ul><li>变量的名称</li><li>变量保存的数据</li><li>变量存储数据的类型</li><li>变量的地址</li></ul><p>在Python中定义变量是<strong>不需要指定类型</strong>，数据类型可以分为数字型和非数字型；</p><table><thead><tr><th align="center">数字型</th><th align="center">非数字型</th></tr></thead><tbody><tr><td align="center">整型（<code>int</code>)</td><td align="center">字符串（<code>string</code>）</td></tr><tr><td align="center">浮点型（<code>float</code>)</td><td align="center">列表（<code>list</code>）</td></tr><tr><td align="center">布尔型（<code>bool</code>：<code>True</code>非0、<code>False</code>）</td><td align="center">元组（<code>tuple</code>不能修改）</td></tr><tr><td align="center">复数型（主要用于科学计算）</td><td align="center">字典（<code>dict</code>:键和值）</td></tr></tbody></table><h3 id="👀不同类型变量之间的计算"><a href="#👀不同类型变量之间的计算" class="headerlink" title="👀不同类型变量之间的计算"></a>👀不同类型变量之间的计算</h3><ol><li><p>数字型变量之间可以直接计算</p><p>在<code>Python</code>中，两个数字型变量是可以直接进行算术运算的，如果变量是<code>bool</code>型，在计算时：</p><ul><li><p><code>True</code>对应的数字是1</p></li><li><p><code>False</code>对应的数字是0</p></li></ul></li><li><p>字符串变量之间使用<code>+</code>拼接字符串</p><p>在Python中，字符串之间可以使用<code>+</code>拼接生成新的字符串。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">first_name = <span class="string">&quot;张&quot;</span></span><br><span class="line">last_name = <span class="string">&quot;三&quot;</span></span><br><span class="line">Name = first_name + last_name</span><br><span class="line"><span class="comment"># 输出“张三”</span></span><br></pre></td></tr></table></figure></li><li><p>字符串变量可以和整数使用<code>*</code>重复拼接相同的字符串</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;%&quot;</span> * <span class="number">10</span></span><br><span class="line"><span class="comment"># 输出“%%%%%%%%%%”</span></span><br></pre></td></tr></table></figure></li><li><p>数字型变量和字符串之间不能进行其它计算</p></li></ol><h3 id="👀变量的输入"><a href="#👀变量的输入" class="headerlink" title="👀变量的输入"></a>👀变量的输入</h3><p>所谓<strong>输入</strong>，就是用<strong>代码</strong>获取用户通过<strong>键盘输入的信息</strong>。例如：输入密码</p><p>在<code>Python</code>中，如果要获取用户在<strong>键盘</strong>上的输入信息，需要使用到<code>input</code>函数。</p><p>（1）关于函数</p><table><thead><tr><th align="center">函数</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center"><code>print(x)</code></td><td align="center">将<code>x</code>输出到控制台</td></tr><tr><td align="center"><code>type(x)</code></td><td align="center">查看<code>x</code>的变量类型</td></tr></tbody></table><p>（2）<code>input</code>函数实现键盘输入</p><p>在<code>Python</code>中可以使用<code>input</code>函数从键盘中等待用户的输入；</p><p>用户输入的任何内容，<code>Python</code>都认为是一个字符串；</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">字符串变量 = <span class="built_in">input</span>(<span class="string">&quot;提示信息：&quot;</span>)</span><br><span class="line">浮点数变量 = <span class="built_in">float</span>(<span class="built_in">input</span>(<span class="string">&quot;提示信息：&quot;</span>))</span><br><span class="line">整数型变量 = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;提示信息：&quot;</span>))</span><br></pre></td></tr></table></figure><p>（3）类型转换函数</p><table><thead><tr><th align="center">函数</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center"><code>int(x)</code></td><td align="center">将<code>x</code>转换为一个整数</td></tr><tr><td align="center"><code>float(x)</code></td><td align="center">将<code>x</code>转换为一个浮点数</td></tr></tbody></table><h3 id="👀变量的格式化输出"><a href="#👀变量的格式化输出" class="headerlink" title="👀变量的格式化输出"></a>👀变量的格式化输出</h3><p>在<code>Python</code>中可以使用<code>print</code>函数将信息输出到控制台；如果希望输出文字信息的同时，一起输出数据，就需要使用到<strong>格式化操作符</strong>。</p><p><code>%</code>被称为格式化操作符，专门用于处理字符串中的格式。</p><ul><li><p>包含<code>%</code>的字符串，被称为<strong>格式化字符串</strong>；</p></li><li><p><code>%</code>和不同的<strong>字符</strong>连用，<strong>不同类型的数据</strong>需要使用<strong>不同的格式化字符</strong>。</p></li></ul><table><thead><tr><th align="center">格式化字符</th><th align="center">含义说明</th></tr></thead><tbody><tr><td align="center"><code>%s</code></td><td align="center">字符串</td></tr><tr><td align="center"><code>%d</code></td><td align="center">有符号十进制整数，<code>%06d</code>表示输出的整数显示位数，不足的地方使用<code>0</code>补全</td></tr><tr><td align="center"><code>%f</code></td><td align="center">浮点数，<code>%.2f</code>表示小数点后只显示两位</td></tr><tr><td align="center"><code>%%</code></td><td align="center">输出<code>%</code></td></tr></tbody></table><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 语法格式</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;格式化字符串&quot;</span> % 变量<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;格式化字符串&quot;</span> % （变量<span class="number">1</span>，变量<span class="number">2.</span>..）)</span><br><span class="line"></span><br><span class="line">name = <span class="string">&quot;小明&quot;</span></span><br><span class="line">student = 000001</span><br><span class="line">scale = <span class="number">10.00</span>%</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;我的名字叫%s&quot;</span> % name)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;我的学号是%06d&quot;</span> % student)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;数据比例是%.2f%%&quot;</span> % (scale * <span class="number">100</span>)</span><br></pre></td></tr></table></figure><h2 id="⛄运算符"><a href="#⛄运算符" class="headerlink" title="⛄运算符"></a>⛄运算符</h2><p>运算符主要包括：</p><ul><li>算术运算符</li><li>比较（关系）运算符</li><li>逻辑运算符</li><li>赋值运算符</li><li>运算符的优先级</li></ul><h3 id="👀算术运算符"><a href="#👀算术运算符" class="headerlink" title="👀算术运算符"></a>👀算术运算符</h3><p>算术运算符是完成基本的算术运算使用的符号，用来处理四则运算。</p><table><thead><tr><th align="center">运算符</th><th align="center">描述</th><th align="center">实例</th></tr></thead><tbody><tr><td align="center"><code>+</code></td><td align="center">加</td><td align="center"><code>30 + 20 = 50</code></td></tr><tr><td align="center"><code>-</code></td><td align="center">减</td><td align="center"><code>30 - 20 = 10</code></td></tr><tr><td align="center"><code>*</code></td><td align="center">乘（也可计算字符串重复次数）</td><td align="center"><code>30 * 20 = 600</code></td></tr><tr><td align="center"><code>/</code></td><td align="center">除</td><td align="center"><code>30 / 20 = 1.5</code></td></tr><tr><td align="center"><code>//</code></td><td align="center">取整除</td><td align="center"><code>9 // 2 = 4</code></td></tr><tr><td align="center"><code>%</code></td><td align="center">取余数</td><td align="center"><code>9 % 2 = 1</code></td></tr><tr><td align="center"><code>**</code></td><td align="center">幂</td><td align="center"><code>2 ** 3 = 8</code></td></tr></tbody></table><h3 id="👀比较（关系）运算符"><a href="#👀比较（关系）运算符" class="headerlink" title="👀比较（关系）运算符"></a>👀比较（关系）运算符</h3><table><thead><tr><th align="center">运算符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="center"><code>==</code></td><td align="left">检查两个操作数的值是否<strong>相等</strong>，如果是，则条件成立，返回<code>True</code></td></tr><tr><td align="center"><code>!=</code></td><td align="left">检查两个操作数的值是否<strong>不相等</strong>，如果是，则条件成立，返回<code>True</code></td></tr><tr><td align="center"><code>&gt;</code></td><td align="left">检查左操作数的值是否<strong>大于</strong>右操作数的值，如果是，则条件成立，返回<code>True</code></td></tr><tr><td align="center"><code>&lt;</code></td><td align="left">检查左操作数的值是否<strong>小于</strong>右操作数的值，如果是，则条件成立，返回<code>True</code></td></tr><tr><td align="center"><code>&gt;=</code></td><td align="left">检查左操作数的值是否<strong>大于或等于</strong>右操作数的值，如果是，则条件成立，返回<code>True</code></td></tr><tr><td align="center"><code>&lt;=</code></td><td align="left">检查左操作数的值是否<strong>小于或等于</strong>右操作数的值，如果是，则条件成立，返回<code>True</code></td></tr></tbody></table><h3 id="👀逻辑运算符"><a href="#👀逻辑运算符" class="headerlink" title="👀逻辑运算符"></a>👀逻辑运算符</h3><table><thead><tr><th align="center">运算符</th><th align="center">逻辑表达式</th><th>描述</th></tr></thead><tbody><tr><td align="center"><code>and</code></td><td align="center"><code>x and y</code></td><td>只有<code>x</code>和<code>y</code>的值都为<code>True</code>，才会返回<code>True</code><br />否则只要<code>x</code>或者<code>y</code>有一个值为<code>False</code>，就返回<code>False</code></td></tr><tr><td align="center"><code>or</code></td><td align="center"><code>a or y</code></td><td>只要<code>x</code>或者<code>y</code>有一个值为<code>True</code>，就返回True<br />只有<code>x</code>和<code>y</code>的值都为<code>False</code>，才会返回<code>False</code></td></tr><tr><td align="center"><code>not</code></td><td align="center"><code>not x</code></td><td>如果<code>x</code>为<code>True</code>，返回<code>False</code><br />如果<code>x</code>为<code>False</code>，返回<code>True</code></td></tr></tbody></table><h3 id="👀-赋值运算符"><a href="#👀-赋值运算符" class="headerlink" title="👀 赋值运算符"></a>👀 赋值运算符</h3><p>在<code>Python</code>中，使用&#x3D;可以给变量赋值；在算术运算时，为了简化代码的编写，<code>python</code>还提供了一系列与算术运算符对应的赋值运算符。注意：赋值运算符中间不能使用空格。</p><table><thead><tr><th align="center">运算符</th><th align="center">描述</th><th>实例</th></tr></thead><tbody><tr><td align="center"><code>=</code></td><td align="center">简单的赋值运算符</td><td>c &#x3D; a + b将a + b的运算结果赋值为c</td></tr><tr><td align="center"><code>+=</code></td><td align="center">加法赋值运算符</td><td>c +&#x3D; a等效于c &#x3D; c + a</td></tr><tr><td align="center"><code>-=</code></td><td align="center">减法赋值运算符</td><td>c -&#x3D; a等效于c &#x3D; c - a</td></tr><tr><td align="center"><code>*=</code></td><td align="center">乘法赋值运算符</td><td>c *&#x3D; a等效于c &#x3D;c * a</td></tr><tr><td align="center"><code>/=</code></td><td align="center">除法赋值运算符</td><td>c &#x2F;&#x3D; a等效于c &#x3D; c  &#x2F;a</td></tr><tr><td align="center"><code>//=</code></td><td align="center">取整除赋值运算符</td><td>c &#x2F;&#x2F;&#x3D; a等效于c &#x3D; c &#x2F;&#x2F; a</td></tr><tr><td align="center"><code>%=</code></td><td align="center">取模（余数）赋值运算符</td><td>c %&#x3D; a等效于c &#x3D; c % a</td></tr><tr><td align="center"><code>**=</code></td><td align="center">幂赋值运算符</td><td>c **&#x3D; a等效于c &#x3D; c ** a</td></tr></tbody></table><h3 id="👀-运算符的优先级"><a href="#👀-运算符的优先级" class="headerlink" title="👀 运算符的优先级"></a>👀 运算符的优先级</h3><p>优先级由高到低顺序排列：</p><table><thead><tr><th align="center">运算符</th><th>描述</th></tr></thead><tbody><tr><td align="center"><code>**</code></td><td>幂（最高优先级）</td></tr><tr><td align="center"><code>*</code>  <code>/</code>  <code>%</code>  <code>//</code></td><td>乘、除、取余数、取整数</td></tr><tr><td align="center"><code>+</code>  <code>-</code></td><td>加法、减法</td></tr><tr><td align="center"><code>&lt;=</code>  <code>&lt;</code>  <code>&gt;</code>  <code>&gt;=</code></td><td>比较运算符</td></tr><tr><td align="center"><code>==</code>  <code>!=</code></td><td>等于运算符</td></tr><tr><td align="center"><code>=</code>  <code>%=</code>  <code>/=</code>  <code>//=</code>  <code>-=</code>  <code>+=</code>  <code>*=</code></td><td>赋值运算符</td></tr><tr><td align="center"><code>not</code> <code>or</code> <code>and</code></td><td>逻辑运算符</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Python基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（一）Google Earth Engine概述</title>
      <link href="/2022/05/16/GEE01/"/>
      <url>/2022/05/16/GEE01/</url>
      
        <content type="html"><![CDATA[<p><code>Google Earth Engine (GEE)</code> 是由谷歌公司开发的众多应用之一。借助谷歌公司超强的服务器运算能力以及与 <code>NASA</code> 的合作关系，<code>GEE</code> 平台将<code>Landsat</code>、<code>MODIS</code>、 <code>Sentinel</code> 等可以公开获取的遥感图像数据存储在谷歌的磁盘阵列中，使得 <code>GEE</code> 用户可以方便的提取、调用和分析海量的遥感大数据资源。</p><p><code>GEE</code>它是一个集科学分析以及地理信息数据可视化的综合性平台。简单的说，<code>GEE</code>是一个“遥感大数据”分析和呈现的平台。作为<strong>地理云计算服务平台</strong>，<code>GEE</code> 将地理数据分析算法封装成函数接口的形式提供给用户，通过互联网可以使用户快速地访问海量的影像数据以及其他空间数据，而不需要下载到本地，在云端实现当前地理空间数据分析的全部流程。通过云计算还可以使共享的计算机软硬件资源和地理大数据，按需求提供给用户使用，使任何用户都可以使用服务商提供的多平台软硬件资源和地理大数据，开展常规个人计算机无法实现的地理计算和数据分析。</p><blockquote><p><code>GEE</code> 在设计之初就是为了服务科研人员而构建的，因此在概念上可以将 <code>GEE</code> 视为一种工具，类似于菜刀之于厨师或者猎枪之于猎手，而不应该将其当作一种复杂的计算机编程平台。</p></blockquote><p><code>GEE</code>包含图形用户界面和应用程序编程接口。<code>GEE</code> 是一个主要依靠编码命令进行空间分析和操作的平台，但 <code>GEE</code> 也有适合界面操作的平台：<code>GEE</code> 的图形用户界面(<code>Graphical User Interface, GUI</code>)。<code>GEE</code> 的 <code>GUI</code> 的优点在于符合人的操作直觉，并且对新用户友好，缺点是功能较少，可以实现的空间分析有限。<code>GEE</code> 的应用程序编程接口(<code>Application Programming Interface, API</code>)是 <code>GEE</code> 的核心功能所在，也是 <code>GEE</code> 用户最为关注的平台，与 <code>GUI</code> 相比，<code>API</code> 可以调用 <code>GEE</code> 平台中的所有数据和功能。可以说，学习 <code>GEE</code> 就是学习 <code>GEE</code> 的 <code>API</code>。</p><p><code>GEE</code> 中存储着海量的遥感数据，熟悉这些数据能够让用户更加便捷的实现空间和地理分析目标。总体上，<code>GEE</code> 的数据可以分为 4 个种类：栅格数据，栅格集数据，矢量数据，矢量集数据。</p><h2 id="⛄栅格数据"><a href="#⛄栅格数据" class="headerlink" title="⛄栅格数据"></a>⛄栅格数据</h2><p><code>GEE</code> 中的栅格数据主要包括来源自遥感卫星的数据和空间插值数据产品。</p><table><thead><tr><th align="center">数据集</th><th align="center">空间分辨率</th><th align="center">时间分辨率</th><th align="center">时间覆盖</th><th align="center">空间覆盖</th></tr></thead><tbody><tr><td align="center"><strong>Landsat</strong></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">Landsat 8 OLI&#x2F;TIRS</td><td align="center">30m</td><td align="center">16day</td><td align="center">2013-Now</td><td align="center">Global</td></tr><tr><td align="center">Landsat 7 ETM+</td><td align="center">30m</td><td align="center">16day</td><td align="center">2000-Now</td><td align="center">Global</td></tr><tr><td align="center">Landsat 5 TM</td><td align="center">30m</td><td align="center">16day</td><td align="center">1984-2012</td><td align="center">Global</td></tr><tr><td align="center">Landsat 4–8 surface reflectance</td><td align="center">30m</td><td align="center">16day</td><td align="center">1984-Now</td><td align="center">Global</td></tr><tr><td align="center"><strong>Sentinel</strong></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">Sentinel 1 A&#x2F;B ground range detected</td><td align="center">10m</td><td align="center">6day</td><td align="center">2014-Now</td><td align="center">Global</td></tr><tr><td align="center">Sentinel 2A MSI</td><td align="center">20m</td><td align="center">10day</td><td align="center">2015-Now</td><td align="center">Global</td></tr><tr><td align="center"><strong>MODIS</strong></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">MOD08 atmosphere</td><td align="center">1°</td><td align="center">daily</td><td align="center">2000-Now</td><td align="center">Global</td></tr><tr><td align="center">MOD09 surface reflectance</td><td align="center">500m</td><td align="center">1&#x2F;8day</td><td align="center">2000-Now</td><td align="center">Global</td></tr><tr><td align="center">MOD10 snow cover</td><td align="center">500m</td><td align="center">1day</td><td align="center">2000-Now</td><td align="center">Global</td></tr><tr><td align="center">MOD11 temperature and emissivity</td><td align="center">1000m</td><td align="center">1&#x2F;8day</td><td align="center">2000-Now</td><td align="center">Global</td></tr><tr><td align="center">MCD12 Land cover</td><td align="center">500m</td><td align="center">Annual</td><td align="center">2000-Now</td><td align="center">Global</td></tr><tr><td align="center">MOD13 Vegetation indices</td><td align="center">500&#x2F;250m</td><td align="center">16day</td><td align="center">2000-Now</td><td align="center">Global</td></tr><tr><td align="center">MOD14 Thermal anomalies &amp; fire</td><td align="center">1000m</td><td align="center">8day</td><td align="center">2000-Now</td><td align="center">Global</td></tr><tr><td align="center">MCD15 Leaf area index&#x2F;FPAR</td><td align="center">500m</td><td align="center">4day</td><td align="center">2000-Now</td><td align="center">Global</td></tr><tr><td align="center">MOD17 Gross primary productivity</td><td align="center">500m</td><td align="center">8day</td><td align="center">2000-Now</td><td align="center">Global</td></tr><tr><td align="center">MCD43 BRDF-adjusted reflectance</td><td align="center">1000&#x2F;500m</td><td align="center">8&#x2F;16day</td><td align="center">2000-Now</td><td align="center">Global</td></tr><tr><td align="center">MOD44 veg. cover conversion</td><td align="center">250m</td><td align="center">Annual</td><td align="center">2000-Now</td><td align="center">Global</td></tr><tr><td align="center">MCD45 thermal anomalies and fire</td><td align="center">500m</td><td align="center">30day</td><td align="center">2000-Now</td><td align="center">Global</td></tr><tr><td align="center"><strong>ASTER</strong></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">L1 T radiance</td><td align="center">15&#x2F;30&#x2F;90m</td><td align="center">1day</td><td align="center">2000-Now</td><td align="center">Global</td></tr><tr><td align="center">Global emissivity</td><td align="center">100m</td><td align="center">Once</td><td align="center">2000-2010</td><td align="center">Global</td></tr><tr><td align="center">Other imagery</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">PROBA-V top of canopy reflectance</td><td align="center">100&#x2F;300m</td><td align="center">2day</td><td align="center">2013-Now</td><td align="center">Global</td></tr><tr><td align="center">EO-1 hyperion hyperspectral radiance</td><td align="center">30m</td><td align="center">Targeted</td><td align="center">2001-Now</td><td align="center">Global</td></tr><tr><td align="center">DMSP-OLS nighttime lights</td><td align="center">1km</td><td align="center">Annual</td><td align="center">1992-2013</td><td align="center">Global</td></tr><tr><td align="center">USDA NAIP aerial imagery</td><td align="center">1m</td><td align="center">Sub-annual</td><td align="center">2003-2015</td><td align="center">CONUS</td></tr><tr><td align="center"><strong>地形</strong></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">Shuttle Radar Topography Mission</td><td align="center">30m</td><td align="center">single</td><td align="center">2000</td><td align="center">60°N–54°S</td></tr><tr><td align="center">USGS GMTED2010</td><td align="center">10m</td><td align="center">single</td><td align="center">Multiple</td><td align="center">US</td></tr><tr><td align="center">USGS National Elevation Dataset</td><td align="center">7.5″</td><td align="center">single</td><td align="center">Multiple</td><td align="center">83°N–57°S</td></tr><tr><td align="center">GTOPO30</td><td align="center">30″</td><td align="center">single</td><td align="center">Multiple</td><td align="center">Global</td></tr><tr><td align="center">ETOPO1</td><td align="center">1′</td><td align="center">single</td><td align="center">Multiple</td><td align="center">Global</td></tr></tbody></table><p>注：来源 <code>Google Earth Engine: Planetary-scale geospatial analysis for everyone [J]. Remote Sensing of Environment</code> </p><p><code>GEE</code> 中其他的主要栅格产品包括土地利用数据，气象数据和人口数据等。这些数据与遥感影像数据相比，主要用来反映某些社会因子的空间分布，或者反映地表以上空间的自然特征。</p><table><thead><tr><th align="center">数据集</th><th align="center">空间分辨率</th><th align="center">时间分辨率</th><th align="center">时间覆盖</th><th align="center">空间覆盖</th></tr></thead><tbody><tr><td align="center"><strong>土地利用</strong></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">GlobCover</td><td align="center">300m</td><td align="center">Non-periodic</td><td align="center">2009</td><td align="center">90°N–65°S</td></tr><tr><td align="center">USGS National Landcover Database</td><td align="center">30m</td><td align="center">Non-periodic</td><td align="center">1992-2011</td><td align="center">CONUS</td></tr><tr><td align="center">UMD global forest change</td><td align="center">30m</td><td align="center">Annual</td><td align="center">2000-2014</td><td align="center">80°N–57°S</td></tr><tr><td align="center">JRC global surface water</td><td align="center">300m</td><td align="center">Monthly</td><td align="center">1984-2015</td><td align="center">78°N–60°S</td></tr><tr><td align="center">GLCF tree cover</td><td align="center">30m</td><td align="center">5year</td><td align="center">2000-2010</td><td align="center">Global</td></tr><tr><td align="center">USDA NASS cropland data layer</td><td align="center">30m</td><td align="center">Annual</td><td align="center">1997-2015</td><td align="center">CONUS</td></tr><tr><td align="center"><strong>气象</strong></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">Global precipitation measurement</td><td align="center">6′</td><td align="center">3h</td><td align="center">2014-Now</td><td align="center">Global</td></tr><tr><td align="center">TRMM 3B42 precipitation</td><td align="center">15′</td><td align="center">3h</td><td align="center">1985-2015</td><td align="center">50°N–50°S</td></tr><tr><td align="center">CHIRPS precipitation</td><td align="center">3′</td><td align="center">5day</td><td align="center">1981-Now</td><td align="center">50°N–50°S</td></tr><tr><td align="center">NLDAS-2</td><td align="center">7.5′</td><td align="center">1h</td><td align="center">1979-Now</td><td align="center">North America</td></tr><tr><td align="center">GLDAS-2</td><td align="center">15′</td><td align="center">3h</td><td align="center">1948-2010</td><td align="center">Global</td></tr><tr><td align="center">NCEP reanalysis</td><td align="center">2.5°</td><td align="center">6h</td><td align="center">1948-Now</td><td align="center">Global</td></tr><tr><td align="center">ORNL DAYMET weather</td><td align="center">1km</td><td align="center">12 Images</td><td align="center">1980-Now</td><td align="center">North America</td></tr><tr><td align="center">GRIDMET</td><td align="center">4km</td><td align="center">1day</td><td align="center">1979-Now</td><td align="center">CONUS</td></tr><tr><td align="center">NCEP global forecast system</td><td align="center">15′</td><td align="center">6h</td><td align="center">2015-Now</td><td align="center">Global</td></tr><tr><td align="center">NCEP climate forecast system</td><td align="center">12′</td><td align="center">6h</td><td align="center">1979-Now</td><td align="center">Global</td></tr><tr><td align="center">WorldClim</td><td align="center">30″</td><td align="center">12 Images</td><td align="center">1960-1990</td><td align="center">Global</td></tr><tr><td align="center">NEX downscaled climate projections</td><td align="center">1km</td><td align="center">1day</td><td align="center">1950-2099</td><td align="center">North America</td></tr><tr><td align="center"><strong>人口</strong></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">WorldPop</td><td align="center">100m</td><td align="center">5year</td><td align="center">Multiple</td><td align="center">2010–2015</td></tr><tr><td align="center">GPWv4</td><td align="center">30″</td><td align="center">5year</td><td align="center">2000-2020</td><td align="center">85°N–60°S</td></tr></tbody></table><p>注：来源 <code>Google Earth Engine: Planetary-scale geospatial analysis for everyone [J]. Remote Sensing of Environment</code></p><h2 id="⛄矢量数据"><a href="#⛄矢量数据" class="headerlink" title="⛄矢量数据"></a>⛄矢量数据</h2><p>简单来说，矢量数据可以理解为点、线和面类型的数据。在处理空间问题时，常常需要确定某个地理要素的位置(例如某区域商店的位置)，或者某些线状地物的位置(河流、道路等)，以及某些面状物的分布(行政边界等)。在确定矢量空间要素空间特征的基础上，再给这些空间要素贴上标签(名称，面积，权属等)，那么就得到了包含一定信息的矢量数据。我们通常将这种矢量数据成为“特征矢量”(<code>Feature</code>)，将其空间形状称为“地理特征”(<code>Geometry</code>)，将贴上去的标签信息称为“属性”(<code>Property</code>)。我们分别从<code>ArcGIS</code>和<code>GEE</code> 中添加并查看<code>Feature</code>的信息，以此加深对矢量数据的理解。</p><h2 id="⛄数据类型和参数类型"><a href="#⛄数据类型和参数类型" class="headerlink" title="⛄数据类型和参数类型"></a>⛄数据类型和参数类型</h2><h3 id="👀GEE-的数据类型-String-Number"><a href="#👀GEE-的数据类型-String-Number" class="headerlink" title="👀GEE 的数据类型 (String, Number)"></a>👀GEE 的数据类型 (<code>String</code>, <code>Number</code>)</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">显示：<span class="title function_">print</span>(string)</span><br><span class="line">创建：ee.<span class="title class_">String</span>()</span><br><span class="line">修改：string.<span class="title function_">cat</span>()string.<span class="title function_">replace</span>()</span><br><span class="line">段落：string.<span class="title function_">split</span>() string.<span class="property">match</span></span><br><span class="line">查询：string.<span class="title function_">slice</span>() string.<span class="title function_">length</span>()</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">创建：ee.<span class="title class_">Number</span>()</span><br><span class="line">修改：number.<span class="title function_">uint8</span>() number.<span class="title class_">Uint8</span>() number.<span class="title function_">int8</span>() number.<span class="title function_">toInt8</span>()……</span><br><span class="line">比较：number.<span class="title function_">eq</span>() number.<span class="title function_">neq</span>()……</span><br><span class="line">    number.<span class="title function_">and</span>() number.<span class="title function_">or</span>() ee.<span class="property">Algorithms</span>.<span class="title class_">IsEqua</span>()……</span><br><span class="line">运算：number.<span class="title function_">abs</span>() number.<span class="title function_">round</span>() number.<span class="title function_">pow</span>()……</span><br><span class="line">字位：number.<span class="title function_">bitwiseAnd</span>() number.<span class="title function_">bitwiseOr</span>() number.<span class="title function_">bitwise_and</span>()</span><br><span class="line">    number.<span class="title function_">bitwise_or</span>() number.<span class="title function_">leftShift</span>() number.<span class="title function_">right_shift</span>()……</span><br></pre></td></tr></table></figure><h3 id="👀GEE-的数据类型-Dictionary，List，Array"><a href="#👀GEE-的数据类型-Dictionary，List，Array" class="headerlink" title="👀GEE 的数据类型(Dictionary，List，Array)"></a>👀GEE 的数据类型(<code>Dictionary</code>，<code>List</code>，<code>Array</code>)</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">创建：ee.<span class="title class_">Dicionary</span>()</span><br><span class="line">修改：dictionary.<span class="title function_">combine</span>() dinctionary.<span class="title function_">set</span>()</span><br><span class="line">查询：dictionary.<span class="title function_">keys</span>() dictionary.<span class="title function_">get</span>() dictionary.<span class="title function_">values</span>()</span><br><span class="line">对比：dictionary.<span class="title function_">contains</span>()</span><br><span class="line">尺寸：dictionary.<span class="title function_">size</span>()</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">创建：ee.<span class="title class_">List</span>() list.<span class="title function_">repeat</span>() list.<span class="title function_">sequence</span>()</span><br><span class="line">修改：list.<span class="title function_">set</span>() list.<span class="title function_">replaceAll</span>() list.<span class="title function_">add</span>() list.<span class="title function_">insert</span>() list.<span class="title function_">zip</span>()</span><br><span class="line">list.<span class="title function_">reverse</span>() list.<span class="title function_">rotate</span>() list.<span class="title function_">sort</span>() list.<span class="title function_">swap</span>() list.<span class="title function_">flatten</span>()</span><br><span class="line">查询：list.<span class="title function_">get</span>() list.<span class="title function_">remove</span>() list.<span class="title function_">removeAll</span>()</span><br><span class="line">比较：list.<span class="title function_">equals</span>() list.<span class="title function_">contains</span>() list.<span class="title function_">containsALL</span>() list. <span class="title function_">indexOf</span>()          </span><br><span class="line">list.<span class="title function_">indexOfSubList</span>() list.<span class="title function_">lastIndexOfSubList</span>() list.<span class="title function_">frequency</span>()</span><br><span class="line">其他：list.<span class="title function_">map</span>() list.<span class="title function_">iterate</span>() list.<span class="title function_">length</span>() list.<span class="title function_">size</span>()</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">创建：ee.<span class="title class_">Array</span>() ee.<span class="property">Array</span>.<span class="title function_">identity</span>() ee.<span class="property">Array</span>.<span class="title function_">repeat</span>()</span><br><span class="line">修改：array.<span class="title function_">mask</span>()array.<span class="title function_">transpose</span>() array.<span class="title function_">uint8</span>()array.<span class="title class_">Uint8</span>()</span><br><span class="line">数学：array.<span class="title function_">eq</span>() array.<span class="title function_">and</span>() array.<span class="title function_">or</span>() array.<span class="title function_">round</span>()</span><br><span class="line">array.<span class="title function_">bitwiseAnd</span>() array.<span class="title function_">leftShift</span>() </span><br></pre></td></tr></table></figure><h3 id="👀GEE-的数据类型-Geometry，Feature，FeatureCollection"><a href="#👀GEE-的数据类型-Geometry，Feature，FeatureCollection" class="headerlink" title="👀GEE 的数据类型(Geometry，Feature，FeatureCollection)"></a>👀GEE 的数据类型(<code>Geometry</code>，<code>Feature</code>，<code>FeatureCollection</code>)</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">创建：ee.<span class="property">Geometry</span>.<span class="title class_">Point</span>() ee.<span class="property">Geometry</span>.<span class="title class_">Multipoint</span>() 绘图工具 ……</span><br><span class="line">几何：<span class="title class_">Geometry</span>.<span class="title function_">transform</span>() geometry.<span class="title function_">centroid</span>() geometry.<span class="title function_">simplify</span>()            </span><br><span class="line">geometry.<span class="title function_">bounds</span>() geometry.<span class="title function_">buffer</span>() geometry.<span class="title function_">union</span>() ……</span><br><span class="line">查询：geometry.<span class="title function_">geometries</span>() geometry.<span class="title function_">coordinates</span>() geometry.<span class="title function_">length</span>() </span><br><span class="line">geometry.<span class="title function_">area</span>() geometry.<span class="title function_">perimeter</span>() geometry.<span class="title function_">distance</span>() </span><br><span class="line">转换：geometry.<span class="title function_">toGeoJSON</span>()</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">创建：ee.<span class="title class_">Feature</span>()绘图工具</span><br><span class="line">编辑：<span class="title class_">Feature</span>.<span class="title function_">select</span>() <span class="title class_">Feature</span>.<span class="title function_">transform</span>() <span class="title class_">Feature</span>.<span class="property">set</span>/<span class="title function_">setMulti</span>()</span><br><span class="line">几何：<span class="title class_">Feature</span>.<span class="property">centroid</span>/simplify/bounds/convexHull/<span class="title function_">buffer</span>()</span><br><span class="line"><span class="title class_">Feature</span>.<span class="property">union</span>/intersection/difference/<span class="title function_">symmetricDifference</span>()</span><br><span class="line">提取：<span class="title class_">Feature</span>.<span class="title function_">geometry</span>() <span class="title class_">Feature</span>.<span class="title function_">get</span>() <span class="title class_">Feature</span>.<span class="property">Length</span>/<span class="title class_">Area</span>/<span class="title class_">Perimeter</span>()</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">创建：<span class="variable constant_">GEE</span>自带 上传 <span class="title class_">FushionTable</span> ee.<span class="title class_">FeatureCollection</span>() .<span class="title function_">randomPoints</span>() 手绘…</span><br><span class="line">编辑：.<span class="title function_">filterMetadata</span>() .<span class="title function_">limit</span>() .<span class="title function_">filterDate</span>() .<span class="title function_">filterBounds</span>() .<span class="title function_">filter</span>() </span><br><span class="line">    .<span class="title function_">select</span>() .<span class="title function_">distinct</span>() .<span class="title function_">union</span>() .<span class="title function_">merge</span>() .<span class="title function_">set</span>() .<span class="title function_">remap</span>() .<span class="title function_">sort</span>()</span><br><span class="line">    .<span class="title function_">makeArray</span>()</span><br><span class="line">转换：.<span class="title function_">geometry</span>() .<span class="title function_">reduceToImage</span>()</span><br><span class="line">查询：.<span class="title function_">first</span>() .<span class="title function_">toList</span>() .<span class="title function_">aggregate_first</span>() .<span class="title function_">aggregate_array</span>()</span><br><span class="line">统计：.<span class="property">aggregate_stats</span>/_histogram/_count/_count_distinct       </span><br><span class="line">    .<span class="property">aggregate_max</span>/_min/_sum/_mean/_product          </span><br><span class="line">    .<span class="property">aggregate_sample_var</span>/_total_var/_sample_sd/_total_sd/</span><br><span class="line">其他: .<span class="title function_">map</span>()</span><br></pre></td></tr></table></figure><h3 id="👀GEE-的数据类型-Image，ImageCollection"><a href="#👀GEE-的数据类型-Image，ImageCollection" class="headerlink" title="👀GEE 的数据类型 (Image，ImageCollection)"></a>👀GEE 的数据类型 (<code>Image</code>，<code>ImageCollection</code>)</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">创建: <span class="variable constant_">GEE</span>自带 用户上传 ee.<span class="title function_">image</span>()/<span class="title function_">constant</span>() ee.<span class="property">Image</span>.<span class="title function_">pixelLonLat</span>() </span><br><span class="line">编辑: .<span class="title function_">mask</span>() .<span class="title function_">clip</span>() .<span class="title function_">select</span>() .<span class="title function_">slice</span>() .<span class="title function_">addBands</span>() .<span class="title function_">reproject</span>() .<span class="title function_">rbgtohsv</span>()         </span><br><span class="line">    .<span class="title function_">hsvtorbg</span>() .<span class="title function_">unit8</span>() .<span class="title function_">cast</span>() .<span class="title function_">set</span>() .<span class="title function_">setMulti</span>() .<span class="title function_">remap</span>() .<span class="title function_">where</span>()   </span><br><span class="line">    .<span class="title function_">metadata</span>() .<span class="title function_">clamp</span>() .<span class="title function_">unitScale</span>() .<span class="title function_">interpolate</span>() .<span class="title function_">eq</span>()…… .<span class="title function_">abs</span>()…… .<span class="title function_">sin</span>() …… </span><br><span class="line">    .<span class="title function_">bitWiseAnd</span>()…… .<span class="title function_">reduce</span>()</span><br><span class="line">地形: image.<span class="title function_">derivative</span>() ee.<span class="property">Terrain</span>.<span class="title function_">products</span>() ee.<span class="property">Algorithm</span>.<span class="title class_">Terrain</span>()</span><br><span class="line">     ee.<span class="property">Terrain</span>.<span class="title function_">slope</span>() ee.<span class="property">Terrain</span>.<span class="title function_">aspect</span>() ee.<span class="property">Terrain</span>.<span class="title function_">fillMinima</span>()  </span><br><span class="line"> ee.<span class="property">Terrain</span>.<span class="title function_">hillshade</span>() ee.<span class="property">Terrain</span>.<span class="title function_">hillshadow</span>() ee.<span class="property">Algorithm</span>.<span class="title class_">Hillshadow</span>()</span><br><span class="line">纹理: .<span class="title function_">entropy</span>() .<span class="title class_">Texture</span>() .<span class="title function_">zeroCrossing</span>() .<span class="property">ee</span>.<span class="property">Algorithms</span>.<span class="title class_">CannyEdgeDetector</span>()   </span><br><span class="line">    ee.<span class="property">Algorithms</span>.<span class="title class_">HoughTransform</span>()</span><br><span class="line">邻域: .<span class="title function_">focal_max</span>() .<span class="title function_">focal_min</span>() .<span class="title function_">focal_median</span>() .<span class="title function_">focal_mode</span>() .<span class="title function_">convolve</span>()                </span><br><span class="line">    .<span class="title function_">reduceNeighborhood</span>()</span><br><span class="line">转换: .<span class="property">Image</span>.<span class="title class_">ToVector</span>() <span class="title class_">Image</span>.<span class="title class_">ToArray</span>() <span class="title class_">Image</span>.<span class="title function_">arrayFlatten</span>()</span><br><span class="line">其他: .<span class="title class_">CrossCorrelation</span>() .<span class="title function_">distance</span>() <span class="title class_">Export</span>.<span class="title function_">image</span>()</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">创建: ee.<span class="title class_">ImageCollection</span>() ee.<span class="property">ImageCollection</span>.<span class="title function_">load</span>()</span><br><span class="line">筛选: .<span class="title function_">limit</span>() .<span class="title function_">filterMetadata</span>() .<span class="title function_">filterDate</span>() .<span class="title function_">filterBounds</span>() .<span class="title function_">filter</span>() .<span class="title function_">select</span>()     </span><br><span class="line">.<span class="title function_">distinct</span>() .<span class="title function_">comnibe</span>() .<span class="title function_">unit8</span>()…… .<span class="title function_">set</span>() .<span class="title function_">setMulti</span>()</span><br><span class="line">求值: .<span class="title function_">mosaic</span>() .<span class="property">and</span>/<span class="title function_">or</span>() .<span class="property">sum</span>/product/max/min/mean/mode/median/<span class="title function_">count</span>()</span><br><span class="line">转换: .<span class="title function_">first</span>() .<span class="title function_">toList</span>() .<span class="title function_">toArray</span>()     </span><br></pre></td></tr></table></figure><h3 id="👀GEE-的数据类型-Landsat-Images-ConfusionMarix"><a href="#👀GEE-的数据类型-Landsat-Images-ConfusionMarix" class="headerlink" title="👀GEE 的数据类型 (Landsat Images, ConfusionMarix)"></a>👀GEE 的数据类型 (<code>Landsat Images</code>, <code>ConfusionMarix</code>)</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">LansatCollection</span>.<span class="title function_">qualityMosaic</span>()</span><br><span class="line"><span class="title class_">LansatCollection</span>.<span class="title function_">unmixing</span>()</span><br><span class="line"><span class="title class_">LansatCollection</span>.<span class="title function_">normalizedDifference</span>()</span><br><span class="line">ee.<span class="property">Algorithms</span>.<span class="property">Landsat</span>.<span class="title function_">simpleCloudScore</span>()</span><br><span class="line">ee.<span class="property">Algorithms</span>.<span class="property">Landsat</span>.<span class="title function_">simpleComposite</span>()</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">创建: ee.<span class="title class_">ConfusionMatrix</span>() </span><br><span class="line">转换: <span class="title class_">ConfusionMatrix</span>.<span class="title function_">array</span>()</span><br><span class="line">精度: .<span class="title function_">kappa</span>() .<span class="title function_">accuracy</span>() .<span class="title function_">producersAccuracy</span>() .<span class="title function_">consumersAccuracy</span>() .<span class="title function_">order</span>()</span><br></pre></td></tr></table></figure><h3 id="👀GEE-的参数类型-Date-DateRange"><a href="#👀GEE-的参数类型-Date-DateRange" class="headerlink" title="👀GEE 的参数类型 (Date, DateRange)"></a>👀GEE 的参数类型 (<code>Date</code>, <code>DateRange</code>)</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">创建：ee.<span class="title class_">Date</span>() ee.<span class="property">Algorithms</span>.<span class="title class_">Date</span>() ee.<span class="property">Date</span>.<span class="title function_">fromYMD</span>() ee.<span class="property">Date</span>.<span class="title function_">parse</span>()</span><br><span class="line">编辑：<span class="title class_">Date</span>.<span class="title function_">advance</span>() <span class="title class_">Date</span>.<span class="title function_">update</span>()</span><br><span class="line">调整：<span class="title class_">Date</span>.<span class="title function_">format</span>() <span class="title class_">Date</span>.<span class="title function_">milis</span>() <span class="title class_">Date</span>.<span class="title function_">getRange</span>()</span><br><span class="line">提取：<span class="title class_">Date</span>.<span class="title function_">get</span>() <span class="title class_">Date</span>.<span class="title function_">gerFraction</span>() <span class="title class_">Date</span>.<span class="title function_">unitRation</span>() <span class="title class_">Date</span>.<span class="title function_">difference</span>()</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">创建: ee.<span class="title class_">DateRange</span>() ee.<span class="property">DateRange</span>.<span class="title function_">unbounded</span>()</span><br><span class="line">联并: <span class="title class_">DateRange</span>.<span class="title class_">Union</span>() <span class="title class_">DateRange</span>.<span class="title function_">intersection</span>()</span><br><span class="line">查询: <span class="title class_">DateRange</span>.<span class="title function_">start</span>() <span class="title class_">DateRange</span>.<span class="title function_">end</span>()</span><br><span class="line">判断: .<span class="title function_">intersencts</span>() .<span class="title function_">contains</span>() .<span class="title function_">inEmpty</span>() .<span class="title function_">isUnbounded</span>()</span><br></pre></td></tr></table></figure><h3 id="👀GEE-的参数类型-Filter，Join"><a href="#👀GEE-的参数类型-Filter，Join" class="headerlink" title="👀GEE 的参数类型 (Filter，Join)"></a>👀GEE 的参数类型 (<code>Filter</code>，<code>Join</code>)</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">创建：ee.<span class="property">Filter</span>.<span class="title function_">eq</span>() ee.<span class="property">Filter</span>.<span class="title function_">neq</span>() ee.<span class="property">Filter</span>.<span class="title function_">ge</span>() ee.<span class="property">Filter</span>.<span class="title function_">gte</span>() ee.<span class="property">Filter</span>.<span class="title function_">le</span>() </span><br><span class="line">ee.<span class="property">Filter</span>.<span class="title function_">lte</span>() ee.<span class="property">Filter</span>.<span class="title function_">maxDifference</span>()</span><br><span class="line">字段：ee.<span class="property">Filter</span>.<span class="title function_">stringContains</span>() ee.<span class="property">Filter</span>.<span class="title class_">StarsWith</span>() ee.<span class="property">Filter</span>.<span class="title class_">EndWith</span>() </span><br><span class="line">ee.<span class="property">Filter</span>.<span class="title class_">Rangecontains</span>() ee.<span class="property">Filter</span>.<span class="title function_">listContains</span>() ee.<span class="property">Filter</span>.<span class="title function_">inList</span>()</span><br><span class="line">时间：ee.<span class="property">Filter</span>.<span class="title function_">calendarRange</span>() ee.<span class="title class_">FilterDateRangeContains</span>() </span><br><span class="line">ee.<span class="property">Filter</span>.<span class="title function_">dayOfYear</span>()</span><br><span class="line">转换：ee.<span class="property">Filter</span>.<span class="title function_">and</span>() ee.<span class="property">Filter</span>.<span class="title function_">or</span>() ee.<span class="property">Filter</span>.<span class="title function_">not</span>() ee.<span class="title class_">Filter</span>()</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ee.<span class="property">Join</span>.<span class="title function_">simple</span>() ee.<span class="property">Join</span>.<span class="title function_">inverted</span>() ee.<span class="property">Join</span>.<span class="title function_">inner</span>()</span><br><span class="line">ee.<span class="property">Join</span>.<span class="title function_">saveAll</span>() ee.<span class="property">Join</span>.<span class="title function_">saveBest</span>() ee.<span class="property">Join</span>.<span class="title function_">saveFirst</span>()</span><br><span class="line"><span class="title class_">Spatial</span> <span class="title class_">Joins</span> (ee.<span class="property">Filter</span>.<span class="property">withinDistance</span>/ee.<span class="property">Filter</span>.<span class="property">intersects</span>)</span><br></pre></td></tr></table></figure><h3 id="👀GEE-的参数类型-Reducer，Kernel，Algorithm"><a href="#👀GEE-的参数类型-Reducer，Kernel，Algorithm" class="headerlink" title="👀GEE 的参数类型 (Reducer，Kernel，Algorithm)"></a>👀GEE 的参数类型 (<code>Reducer</code>，<code>Kernel</code>，<code>Algorithm</code>)</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">创建: ee.<span class="property">Reducer</span>.<span class="title function_">count</span>() .<span class="title function_">countEvery</span>() .<span class="title function_">first</span>() .<span class="title function_">histogram</span>() .<span class="title function_">allNonZero</span>() </span><br><span class="line">    .<span class="title function_">anyNonZero</span>() .<span class="title function_">frequencyHistrogram</span>() .<span class="title function_">toList</span>() .<span class="title function_">toCollection</span>()</span><br><span class="line">数学: <span class="title function_">sum</span>() .<span class="title function_">product</span>() .<span class="title function_">mean</span>() .<span class="title function_">variance</span>() .<span class="title function_">std_dev</span>() .<span class="title function_">sampleVariance</span>()       </span><br><span class="line">    .<span class="title function_">sampleStdDev</span>() .<span class="title function_">max</span>() .<span class="title function_">min</span>() .<span class="title function_">minMax</span>() .<span class="title function_">median</span>() .<span class="title function_">mode</span>()         </span><br><span class="line">    .<span class="title function_">intervalMean</span>() .<span class="title function_">percentile</span>() .<span class="title function_">linearFit</span>()</span><br><span class="line">转换: .<span class="title function_">setOutputs</span>() .<span class="title function_">getOutputs</span>() .<span class="title function_">combine</span>() .<span class="title function_">repeat</span>() .<span class="title function_">repeat</span>()      </span><br><span class="line">     .<span class="title function_">group</span>() .<span class="title function_">unweighted</span>() .<span class="title function_">splitWeights</span>()</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">创建: ee.<span class="property">Kernel</span>.<span class="title function_">roberts</span>() ee.<span class="property">Kernel</span>.<span class="title function_">prewitt</span>() ee.<span class="property">Kernel</span>.<span class="title function_">sobel</span>()    </span><br><span class="line">ee.<span class="property">Kernel</span>.<span class="title function_">compass</span>() ee.<span class="property">Kernel</span>.<span class="title function_">kirsch</span>() ee.<span class="property">Kernel</span>.<span class="title function_">laplacian4</span>()</span><br><span class="line">ee.<span class="property">Kernel</span>.<span class="title function_">laplacian8</span>() ee.<span class="property">Kernel</span>.<span class="title function_">euclidean</span>() ee.<span class="property">Kernel</span>.<span class="title function_">gaussian</span>()</span><br><span class="line">ee.<span class="property">Kernel</span>.<span class="title function_">manhattan</span>() ee.<span class="property">Kernel</span>.<span class="title function_">chebyshev</span>() ee.<span class="property">Kernel</span>.<span class="title function_">circle</span>()      </span><br><span class="line">ee.<span class="property">Kernel</span>.<span class="title function_">octagon</span>() ee.<span class="property">Kernel</span>.<span class="title function_">square</span>() ee.<span class="property">Kernel</span>.<span class="title function_">diamond</span>() ee.<span class="property">Kernel</span>.<span class="title function_">cross</span>()</span><br><span class="line">ee.<span class="property">Kernel</span>.<span class="title function_">plus</span>() ee.<span class="property">Kernel</span>.<span class="title function_">fixed</span>()</span><br><span class="line">编辑: <span class="title class_">Kernel</span>.<span class="title function_">rotate</span>() kernel.<span class="title function_">add</span>() <span class="title function_">print</span>(<span class="title class_">Kernel</span>)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Algorithm</span>,算法的目的是减少重复运算，我们可将其理解为一个“小程序”，借助这个小程序可以对数据集内的每一个数据都进行同样的操作。下边是算法的语法格式：</span><br><span class="line"><span class="keyword">function</span> 函数名(变量)</span><br><span class="line">   &#123; 操作 &#125;</span><br><span class="line">算法的核心在于操作的编写。编写操作时要注意两点，第一，应该按照目标数据集确定变量名，比如针对栅格数据集的操作变量可以写作 <span class="title class_">Image</span> 或者 img，这样能够提高操作的可读性。第二，操作必须包含 <span class="keyword">return</span> 命令以告诉 <span class="variable constant_">GEE</span> 算法的目的是什么。</span><br></pre></td></tr></table></figure><h2 id="⛄GEE平台优势与应用"><a href="#⛄GEE平台优势与应用" class="headerlink" title="⛄GEE平台优势与应用"></a>⛄GEE平台优势与应用</h2><p>随着云计算技术的不断发展，<code>GEE</code> 从2008 年提出构想不断发展至今天，已经成为提供覆盖全球的地理空间数据的集成、处理、可视化和综合分析一站式解决方案的云端共享平台，总结GEE的平台具有如下优势：</p><ul><li><strong>免费向非商业用户提供使用</strong>。<code>GEE</code>面向全球科研人员、学生、教育工作者等提供非商业性质用户提供免费服务。</li><li><strong>算法高集成度以及可定制性</strong>。在算法集成方面，提供了持续更新的智能算法以及可供研究者定制的功能接口，这将激励研究者不断尝试新的算法来实现科学构想，而不只是停留在理论层面，这将进一步促进平台的智能化发展，很多以往难以解决的问题都将开启新的思路。</li><li><strong>后台处理运算能力强</strong>。使用<code>GEE</code>平台，用户可以比较方便地处理全球影像数据，解决了用户受限自己本地机器运算能力不强，以及存储空间不足的问题，能够高校、快速地处理大范围的影像。</li><li><strong>完整的生态开发环境</strong>。目前<code>GEE</code> 已经拥有一个完整而良好的开发生态环境，开发者和平台核心团队人员可以通过论坛，会议等多种形式进行深入甲流，探讨各种问题，除了现有的工具资源，用户还可以利用GEE提供的开发包做二次开发，满足更多的需求，实现更加强大的功能。</li></ul><p><code>GEE</code>被广泛应用于各个领域，涵盖全球森林变化，全球地表水变化、作物产量估算、稻田制图、城市测绘、洪水测绘、火灾恢复和疟疾风险绘图等等不同主题。它还被整合到许多第三方应用中，例如分析物种栖息地范围（<code>Map of Life</code>）、监测气候（<code>Climate Engine</code>）和评估土地利用变化（<code>Collect Earth</code>）等等。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://www.aisoutu.com/a/776592">遥感云计算平台:Google Earth Engine</a></li><li>遥感大数据工具（<code>Google Earth Engine</code>）基础教程，作者：王金柱</li></ol>]]></content>
      
      
      <categories>
          
          <category> GEE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GEE </tag>
            
            <tag> API </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo之常见的问题及小技巧</title>
      <link href="/2022/05/13/Hexo-problem/"/>
      <url>/2022/05/13/Hexo-problem/</url>
      
        <content type="html"><![CDATA[<h2 id="⛄提高GitHub-访问速度"><a href="#⛄提高GitHub-访问速度" class="headerlink" title="⛄提高GitHub 访问速度"></a>⛄提高GitHub 访问速度</h2><p>将<code>Hexo</code>项目托管在<code>GitHub</code>数据仓库中，面临的问题通常就是<code>GitHub</code>访问速度比较慢。本人通过搜索资料、不断尝试，发现通过修改 <code>hosts</code> 文件可以进行加速，访问速度得到了有效的提高，亲测有效。手动把<code>cdn</code>和<code>ip</code>地址绑定，具体的步骤为：</p><p>第一步：获取 <code>GitHub</code> 的 global.ssl.fastly 地址</p><p>访问入口：<a href="https://ipaddress.com/website/github.global.ssl.fastly.net#ipinfo">点击进入</a></p><p>获得<code>IP Address</code>：<code>199.232.69.194</code></p><p>第二步：获取 <code>github.com</code> 的地址</p><p>访问入口：<a href="https://ipaddress.com/website/github.com#ipinfo">点击进入</a></p><p>获得<code>IP Address</code>：<code>140.82.113.4</code></p><p>第三步：修改 <code>hosts</code> 文件映射上面查找到的 <code>IP</code></p><p>①首先，针对<code>windows</code>系统，修改<code>C:\Windows\System32\drivers\etc\hosts</code>文件的权限，指定可写入：右击-&gt;<code>hosts</code>-&gt;属性-&gt;安全-&gt;编辑-&gt;点击Users-&gt;在Users的权限”写入“后面打勾，点击确定。</p><p>②然后，右击-&gt;<code>hosts</code>-&gt;打开方式-&gt;选定记事本（或者Notepad++、EmEditor工具）-&gt;在末尾处添加以下内容：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">199.232.69.194 github.global.ssl.fastly.net</span><br><span class="line">140.82.113.4 github.com</span><br></pre></td></tr></table></figure><h2 id="⛄Hexo常见问题"><a href="#⛄Hexo常见问题" class="headerlink" title="⛄Hexo常见问题"></a>⛄Hexo常见问题</h2><h3 id="👀问题一，hexo命令运行出错"><a href="#👀问题一，hexo命令运行出错" class="headerlink" title="👀问题一，hexo命令运行出错"></a>👀问题一，hexo命令运行出错</h3><p><strong>①问题描述</strong>：运行Hexo报错hexo : 无法加载文件hexo.ps1，因为在此系统上禁止运行脚本</p><p>使用如下命令安装 <code>Hexo</code>成功：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure><p>运行<code>hexo -v、hexo clean、hexo g、hexo s、hexo d</code>会出现错误：</p><figure class="highlight plaintext"><figcaption><span>bash</span></figcaption><table><tr><td class="code"><pre><span class="line">PS C:\Users\Desktop\heartlovelife&gt; hexo s</span><br><span class="line">hexo : 无法加载文件 C:\Users\AppData\Roaming\npm\hexo.ps1，因为在此系统上禁止运行脚本。有关详细信息，请参阅 https:/go.microsoft.com/fwlink/?LinkID</span><br><span class="line">=135170 中的 about_Execution_Policies。</span><br><span class="line">所在位置 行:1 字符: 1</span><br><span class="line">+ hexo s</span><br><span class="line">+ ~~~~</span><br><span class="line">    + CategoryInfo          : SecurityError: (:) []，PSSecurityException</span><br><span class="line">    + FullyQualifiedErrorId : UnauthorizedAccess</span><br></pre></td></tr></table></figure><p><strong>②解决方案</strong>：针对<code>windows</code>系统，设置-&gt;隐私和安全性-&gt;开发者选项-&gt;允许本地<code>PowerShell</code>脚本在为签名的情况下运行。</p><h3 id="👀问题二，-hexo-init初始化失败"><a href="#👀问题二，-hexo-init初始化失败" class="headerlink" title="👀问题二， hexo init初始化失败"></a>👀问题二， <code>hexo init</code>初始化失败</h3><p><strong>①问题描述</strong>：<code>WARN Failed to install dependencies. Please run ‘npm install’ manually!</code></p><p><strong>②解决方案</strong>：如果我们输入命令<code>npm install</code>还是会出现错误，这时我们需要修改<code>npm</code>的镜像：</p><figure class="highlight plaintext"><figcaption><span>bash</span></figcaption><table><tr><td class="code"><pre><span class="line">npm -v</span><br><span class="line"># 修改镜像</span><br><span class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br><span class="line"># 初始化</span><br><span class="line">hexo init</span><br><span class="line"># 利用cnpm执行cnpm install</span><br><span class="line">cnpm install </span><br></pre></td></tr></table></figure><h3 id="👀问题三，hexo-d部署失败"><a href="#👀问题三，hexo-d部署失败" class="headerlink" title="👀问题三，hexo d部署失败"></a>👀问题三，<code>hexo d</code>部署失败</h3><p><strong>①问题描述</strong>：<code>fatal: unable to auto-detect email address....</code></p><figure class="highlight plaintext"><figcaption><span>bash</span></figcaption><table><tr><td class="code"><pre><span class="line">fatal: unable to auto-detect email address</span><br><span class="line">error:src refspec HEAD does not match any</span><br><span class="line">error:failed to push some refs to &quot;*******&quot;</span><br><span class="line">FATAL &#123;</span><br><span class="line">err:Error:Spawn failed</span><br><span class="line">.......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>②解决方案</strong>：在文件浏览器中勾选显示隐藏的项目，进入我们的博客目录</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">D:\Blog_Hexo\Blog\.deploy_git\.git</span><br></pre></td></tr></table></figure><p>找到config文件，添加</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[user]</span><br><span class="line">email = 3086786161@qq.com</span><br><span class="line">name = HeartLoveLife</span><br><span class="line">[core]</span><br><span class="line">repositoryformatversion = 0</span><br><span class="line">filemode = false</span><br><span class="line">bare = false</span><br><span class="line">logallrefupdates = true</span><br><span class="line">symlinks = false</span><br><span class="line">ignorecase = true</span><br><span class="line">[branch &quot;main&quot;]</span><br><span class="line">remote = https://github.com/HeartLoveLife/HeartLoveLife.github.io.git</span><br><span class="line">merge = refs/heads/main</span><br></pre></td></tr></table></figure><h3 id="👀问题四，hexo-s出现警告"><a href="#👀问题四，hexo-s出现警告" class="headerlink" title="👀问题四，hexo s出现警告"></a>👀问题四，<code>hexo s</code>出现警告</h3><p><strong>①问题描述</strong>：<code>Accessing non-existent property &#39;*&#39; of module exports inside circular dependency</code></p><figure class="highlight plaintext"><figcaption><span>bash</span></figcaption><table><tr><td class="code"><pre><span class="line">INFO  Start processing</span><br><span class="line">INFO  Hexo is running at http://localhost:4000/ . Press Ctrl+C to stop.</span><br><span class="line">(node:60224) Warning: Accessing non-existent property &#x27;lineno&#x27; of module exports inside circular dependency</span><br><span class="line">(Use `node --trace-warnings ...` to show where the warning was created)</span><br><span class="line">(node:60224) Warning: Accessing non-existent property &#x27;column&#x27; of module exports inside circular dependency</span><br><span class="line">(node:60224) Warning: Accessing non-existent property &#x27;filename&#x27; of module exports inside circular dependency</span><br><span class="line">(node:60224) Warning: Accessing non-existent property &#x27;lineno&#x27; of module exports inside circular dependency</span><br><span class="line">(node:60224) Warning: Accessing non-existent property &#x27;column&#x27; of module exports inside circular dependency</span><br><span class="line">(node:60224) Warning: Accessing non-existent property &#x27;filename&#x27; of module exports inside circular dependency</span><br></pre></td></tr></table></figure><p><strong>②解决方案</strong>：出现警告，是因为<code>node</code>版本太高，切换成低版本的<code>node</code>来安装<code>Hexo</code>就可以了</p><h2 id="⛄Hexo更换主题"><a href="#⛄Hexo更换主题" class="headerlink" title="⛄Hexo更换主题"></a>⛄Hexo更换主题</h2><p>在博客的项目文件夹下打开<code>git bash</code>执行命令，以<code>hexo-theme-butterfly</code>主题为例</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone -b master https://github.com/jerryc127/hexo-theme-butterfly.git themes/butterfly</span><br></pre></td></tr></table></figure><p>运行成功之后，在项目文件夹<code>source</code>中可以查看到新的主题<code>themes</code>文件夹：<code>butterfly</code></p><p>在博客的项目文件夹下，修改<code>_config.yml</code>配置文件如下:</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># theme: landscape  默认主题</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">butterfly</span></span><br></pre></td></tr></table></figure><p>此时主题还不能正常配置使用，需要安装<code>pug</code> 以及<code>stylus</code> 的渲染器:</p><figure class="highlight plaintext"><figcaption><span>bash</span></figcaption><table><tr><td class="code"><pre><span class="line"># npm install hexo-renderer-pug hexo-renderer-stylus --save</span><br><span class="line">cnpm install hexo-renderer-pug hexo-renderer-stylus --save</span><br></pre></td></tr></table></figure><p>执行<code>hexo s</code>部署到本地运行</p><figure class="highlight plaintext"><figcaption><span>bash</span></figcaption><table><tr><td class="code"><pre><span class="line"># 清除缓存b.json 和已生成的静态文件 public</span><br><span class="line">hexo clean</span><br><span class="line"># 生成静态页面到默认设置的 public 文件夹</span><br><span class="line">hexo g</span><br><span class="line"># 启动本地服务器，用于预览</span><br><span class="line">hexo s</span><br><span class="line"># 自动生成网站静态文件，并部署到设定的仓库或上传部署至服务端</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>默认地址：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://localhost:4000/</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客Blog框架简介</title>
      <link href="/2022/05/12/Blog/"/>
      <url>/2022/05/12/Blog/</url>
      
        <content type="html"><![CDATA[<p>简言之，<a href="https://baike.baidu.com/item/%E5%8D%9A%E5%AE%A2/124?fromtitle=blog&fromid=70149&fr=aladdin">Blog</a>就是以网络作为载体，简易迅速便捷地发布自己的心得，及时有效轻松地与他人进行交流，再集丰富多彩的个性化展示于一体的综合性平台。</p><h2 id="⛄博客搭建的方式"><a href="#⛄博客搭建的方式" class="headerlink" title="⛄博客搭建的方式"></a>⛄博客搭建的方式</h2><p>总体来说，Blog搭建的方式可以分为静态博客和动态博客。顾名思义，静态博客：博文内容是通过文档（如：.md文件等）记录的（一个独立的文件），通过生成工具编译成最终的<code>hml</code>、<code>css</code>、<code>js</code>等静态文件，然后部署在静态Server服务器上或<code>Web托管</code>至数据<code>仓库</code>（如：<code>Github</code>），即可在互联网中被访问，不需要数据库的支撑。动态博客：是以数据库技术为基础，其博文内容是通过数据库记录存储的，主要特点体现在<code>交互性</code>；<code>动</code>不是指网页中的页面元素或特效在动，而是与后台数据库进行交互和数据传递（如：注册登录、评论、用户管理等）。</p><p>常见的博客框架：</p><h3 id="👀静态框架"><a href="#👀静态框架" class="headerlink" title="👀静态框架"></a>👀静态框架</h3><ul><li><p>Hexo (<a href="https://hexo.io/zh-cn/">https://hexo.io/zh-cn/</a>)</p></li><li><p>Hugo (<a href="https://www.gohugo.cn/">https://www.gohugo.cn/</a>)</p></li><li><p>VuePress (<a href="https://www.vuepress.cn/">https://www.vuepress.cn/</a>)</p></li><li><p>Jekyll (<a href="https://www.jekyll.com.cn/">https://www.jekyll.com.cn/</a>)</p></li></ul><h3 id="👀动态框架"><a href="#👀动态框架" class="headerlink" title="👀动态框架"></a>👀动态框架</h3><ul><li><p>WordPress  (<a href="https://wordpress.org/">https://wordpress.org/</a>)</p></li><li><p>Typecho (<a href="https://typecho.org/">https://typecho.org/</a>)</p></li><li><p>Halo (<a href="https://halo.run/">https://halo.run/</a>)</p></li><li><p>Solo (<a href="https://b3log.org/solo/">https://b3log.org/solo/</a>)</p></li></ul><h2 id="⛄框架简介"><a href="#⛄框架简介" class="headerlink" title="⛄框架简介"></a>⛄框架简介</h2><h3 id="👀Hexo"><a href="#👀Hexo" class="headerlink" title="👀Hexo"></a>👀Hexo</h3><p><code>Hexo</code> 是一个基于<code>Node.js</code>的快速、简洁且高效的静态博客框架。Hexo 使用 <a href="http://daringfireball.net/projects/markdown/">Markdown</a>（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。Hexo具有丰富的主题、插件系统。</p><p><strong>优点：</strong></p><ul><li>纯静态博客，部署简单、成本低廉、运行优化非常高效。</li><li>Hexo 静态博客框架可以在云端，也可以在本地电脑上甚至手机上。</li><li>Hexo 框架的博客网站没有网站后台，不存在后台安全漏洞的问题。</li><li>因为是纯静态的，几乎所有的 CDN 服务都可以完美的加速提升浏览速度。</li><li>搜索引擎对纯静态网站有天然的青睐度，收录、权重优先权明显。</li><li>纯静态网站会让网络攻击成本大大的增加也就是说纯静态网站被攻击的可能性更低了。</li></ul><h3 id="👀Hugo"><a href="#👀Hugo" class="headerlink" title="👀Hugo"></a>👀Hugo</h3><p><code>Hugo</code> 被称为是世界上最快的构建网站的框架。Hugo 是一个快速且现代的静态网站生成器，采用 Go 编程语言开发，Hugo 的设计目标是让创建网站重新变得有趣。Hugo 是一个通用的网站框架。从技术上讲，Hugo 是一个<a href="https://www.gohugo.cn/about/benefits/">静态站点生成器</a>。与动态构建页面的系统不同，Hugo 在创建或更新内容时构建页面。由于网站的浏览频率远高于编辑频率，因此 Hugo 旨在为您的网站最终用户提供最佳的浏览体验，并为网站作者提供理想的写作体验。使用 Hugo 构建的网站非常快速和安全。Hugo 构建的网站可以托管在任何地方，包括 <a href="https://netlify.com/">Netlify</a>、<a href="https://www.heroku.com/">Heroku</a>、<a href="https://www.godaddy.com/">GoDaddy</a>、<a href="https://www.dreamhost.com/">DreamHost</a>、<a href="https://pages.github.com/">GitHub Pages</a>、<a href="https://about.gitlab.com/features/pages/">GitLab Pages</a>、<a href="https://surge.sh/">Surge</a>、<a href="https://www.aerobatic.com/">Aerobatic</a>、<a href="https://firebase.google.com/docs/hosting/">Firebase</a>、<a href="https://cloud.google.com/storage/">Google Cloud Storage</a>、<a href="https://aws.amazon.com/s3/">Amazon S3</a>、<a href="https://www.rackspace.com/cloud/files">Rackspace</a>、<a href="https://docs.microsoft.com/en-us/azure/storage/blobs/storage-blob-static-website">Azure</a>, 和 <a href="https://aws.amazon.com/cloudfront/">CloudFront</a>，并且与 CDN 更配。Hugo 网站在运行时不需要数据库或依赖于诸如 Ruby、Python 或 PHP 等昂贵的运行时环境。我们认为 Hugo 是一个理想的网站创建工具，具有几乎即时的构建时间，能够在网站修改时即刻重建。</p><p><strong>优点：</strong></p><ul><li>飞快的构建速度。在等待网站构建时有多无聊？Hugo 是同类中最快的工具。每个页面的构建时间小于一毫秒时，网站的平均构建时间不到一秒钟。</li><li>健壮的内容管理。灵活性为王。Hugo 是内容战略家的梦想。Hugo 支持无限的内容类型、分类、菜单、动态 API 驱动的内容等，所有这些都无需插件。</li><li>短代码(shortcodes)。Hugo 短代增强了 Markdown 的能力。我们喜欢 Markdown 语法的漂亮、简洁，但有时我们需要更多的灵活性。Hugo 短代码满足了美观和灵活的需求。</li><li>内置模板。Hugo 提供的通用模式让您的工作迅速完成。Hugo 提供了预制的模板，可以快速完成 SEO、评论、统计和其他功能。一行代码，完成所有工作。</li><li>支持多语言和 i18n。原生支持多语言。Hugo 为多语言站点提供了完整的 i18n 支持，并且与 Hugo 用户喜欢的单语言站点的开发体验完全相同。</li><li>定制输出。HTML 够吗？Hugo 允许以多种格式输出您的内容，包括 JSON 或 AMP，并使您可以轻松创建自己的内容。</li></ul><h3 id="👀VuePress"><a href="#👀VuePress" class="headerlink" title="👀VuePress"></a>👀VuePress</h3><p><code>VuePress</code> 由两部分组成：第一部分是一个<a href="https://github.com/vuejs/vuepress/tree/master/packages/%40vuepress/core">极简静态网站生成器 (opens new window)</a>，它包含由 Vue 驱动的<a href="https://www.vuepress.cn/theme/">主题系统</a>和<a href="https://www.vuepress.cn/plugin/">插件 API</a>，另一个部分是为书写技术文档而优化的<a href="https://www.vuepress.cn/theme/default-theme-config.html">默认主题</a>，它的诞生初衷是为了支持 Vue 及其子项目的文档需求。每一个由 VuePress 生成的页面都带有预渲染好的 HTML，也因此具有非常好的加载性能和搜索引擎优化（SEO）。同时，一旦页面被加载，Vue 将接管这些静态内容，并将其转换成一个完整的单页应用（SPA），其他的页面则会只在用户浏览到的时候才按需加载。</p><p>事实上，一个 VuePress 网站是一个由 <a href="http://vuejs.org/">Vue (opens new window)</a>、<a href="https://github.com/vuejs/vue-router">Vue Router (opens new window)</a>和 <a href="http://webpack.js.org/">webpack (opens new window)</a>驱动的单页应用。如果你以前使用过 Vue 的话，当你在开发一个自定义主题的时候，你会感受到非常熟悉的开发体验，你甚至可以使用 Vue DevTools 去调试你的自定义主题。在构建时，我们会为应用创建一个服务端渲染（SSR）的版本，然后通过虚拟访问每一条路径来渲染对应的HTML。这种做法的灵感来源于 <a href="https://nuxtjs.org/">Nuxt (opens new window)</a>的 <code>nuxt generate</code> 命令，以及其他的一些项目，比如 <a href="https://www.gatsbyjs.org/">Gatsby (opens new window)</a>。</p><p><strong>优点：</strong></p><ul><li>简洁至上。以 Markdown 为中心的项目结构，以最少的配置帮助你专注于写作。</li><li>Vue 驱动。享受 Vue + webpack 的开发体验，可以在 Markdown 中使用 Vue 组件，又可以使用 Vue 来开发自定义主题。</li><li>高性能。VuePress 会为每个页面预渲染生成静态的 HTML，同时，每个页面被加载的时候，将作为 SPA 运行。</li></ul><h3 id="👀Jekyll"><a href="#👀Jekyll" class="headerlink" title="👀Jekyll"></a>👀Jekyll</h3><p><code>Jekyll</code> 是一个静态网站生成器。用你喜欢的标记语言书写内容并交给 Jekyll 处理，它将利用模板为你创建一个静态网站。你可以调整你想要的网址样式、在网站上显示哪些数据等等。jekyll是一个简单的免费的Blog生成工具，类似WordPress。但是和WordPress又有很大的不同，原因是jekyll只是一个生成静态网页的工具，不需要<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%BA%93/103728">数据库</a>支持。但是可以配合第三方服务,例如Disqus。最关键的是jekyll可以免费部署在Github上，而且可以绑定自己的域名。</p><p><strong>优点：</strong></p><ul><li>简单。无需数据库、评论功能或频繁的版本更新—只需关注<em>你的内容</em>。</li><li>静态。只用 <a href="https://daringfireball.net/projects/markdown/">Markdown</a>、<a href="https://github.com/Shopify/liquid/wiki">Liquid</a>、HTML &amp; CSS g就可以构建可部署的静态网站。</li><li>博客。原生支持自定义链接、分类、静态页、文章以及自定义布局。</li></ul><h3 id="👀WordPress"><a href="#👀WordPress" class="headerlink" title="👀WordPress"></a>👀WordPress</h3><p><code>WordPress</code>是一款能让您建立出色网站、博客或应用程序的开源软件。WordPress是使用<a href="https://baike.baidu.com/item/PHP/9337">PHP</a>语言开发的博客平台，用户可以在支持PHP和MySQL数据库的<a href="https://baike.baidu.com/item/%E6%9C%8D%E5%8A%A1%E5%99%A8/100571">服务器</a>上架设属于自己的网站。也可以把 WordPress当作一个<a href="https://baike.baidu.com/item/%E5%86%85%E5%AE%B9%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/2683135">内容管理系统</a>（CMS）来使用。WordPress是一款<a href="https://baike.baidu.com/item/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/5466014">个人博客</a>系统，并逐步演化成一款内容管理系统软件，它是使用PHP语言和<a href="https://baike.baidu.com/item/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93/10991669">MySQL数据库</a>开发的，用户可以在支持 PHP 和 MySQL数据库的服务器上使用自己的博客。WordPress有许多第三方开发的免费模板，安装方式简单易用。不过要做一个自己的模板，则需要你有一定的专业知识。比如你至少要懂的<a href="https://baike.baidu.com/item/%E6%A0%87%E5%87%86%E9%80%9A%E7%94%A8%E6%A0%87%E8%AE%B0%E8%AF%AD%E8%A8%80/6805073">标准通用标记语言</a>下的一个应用<a href="https://baike.baidu.com/item/HTML">HTML</a>、<a href="https://baike.baidu.com/item/CSS/5457">CSS</a>、PHP等相关知识。</p><p><strong>优点：</strong></p><ul><li>WordPress 功能强大、扩展性强、生态丰富，这主要得益于其插件众多，易于扩充功能，基本上一个完整网站该有的功能，通过其第三方插件都能实现所有功能。</li><li>wordpress搭建的博客对seo搜索引擎友好，收录也快，排名靠前。</li><li>适合DIY，如果你是喜欢丰富内容的网站，那么wordpress可以很好地符合你的胃口。</li><li>主题很多，网站上一大片都是wordpress的主题，各色各样，应有尽有！</li><li>wordpress备份和网站转移比较方便，原站点使用站内工具导出后，使用WordPress Importer插件就能方便地将内容导入新网站。</li><li>wordpress有强大的社区支持，有上千万的开发者贡献和审查wordpress，所以wordpress是安全并且活跃的。</li></ul><h3 id="👀Typecho"><a href="#👀Typecho" class="headerlink" title="👀Typecho"></a>👀Typecho</h3><p><code>Typecho</code>是由type和echo两个词合成的，来自于开发团队的头脑风暴。Typecho基于PHP5开发，支持多种数据库，是一款内核强健﹑扩展方便﹑体验友好﹑运行流畅的轻量级开源博客程序。选用Typecho，搭建独一无二个人<a href="https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E6%97%A5%E5%BF%97/87941">网络日志</a>发布平台，享受创作的快乐。</p><p><strong>优点：</strong></p><ul><li>轻量高效。仅仅 7 张数据表，加上不足 400KB 的代码，就实现了完整的插件与模板机制。超低的 CPU 和内存使用率，足以发挥主机的最高性能。</li><li>先进稳定。原生支持 Markdown 排版语法，易读更易写。支持 BAE&#x2F;GAE&#x2F;SAE 等各类云主机，即使面对突如其来的高访问量，也能轻松应对。</li><li>简洁友好。精心打磨过的操作界面，依然是你熟悉的面孔，更多了一份成熟与贴心。每一个像素的剪裁，都只为离完美更进一步。</li></ul><h3 id="👀Halo"><a href="#👀Halo" class="headerlink" title="👀Halo"></a>👀Halo</h3><p><code>Halo</code>是一款基于<code>Java</code>语言，使用<a href="https://baike.baidu.com/item/Spring%20Boot/20249767?fr=aladdin">Spring Boot</a>框架开发的博客系统，致力于打造最好的 Java 博客系统，且只想安安静静的做一个博客系统。</p><p><strong>优点：</strong></p><ul><li>代码开源。我们的所有代码开源在 <a href="https://github.com/halo-dev">GitHub</a> 上且处于积极维护状态，截止目前已经发布了 <a href="https://github.com/halo-dev/halo/releases">81</a> 个版本。您也可以在上面提交您的问题或者参与代码贡献。</li><li>易于部署。采用了程序与用户配置分离的方式，迁移和备份成本大大降低。您只需要一条命令即可运行成功，同时也支持 Docker 部署。</li><li>REST API。提供了完善的 <a href="https://api.halo.run/content-api.html">Content API</a> 和 <a href="https://api.halo.run/admin-api.html">Admin API</a>，你可以用于开发单页面模板，微信小程序，各种系统的插件等。</li><li>模板系统完善的模板系统，支持自定义配置，支持在线安装和更新。开发主题也十分方便，欢迎大家参与主题的开发。</li><li>附件系统。支持本地上传，阿里云 OSS&#x2F;又拍云 OSS&#x2F;七牛云 OSS&#x2F;SM.MS 等云存储，你可以更方便的管理你文章中的附件。</li><li>评论系统拥有独立的评论插件，使用 Vue 开发，只需在页面引入构建好的 JS 文件即可，完美地和主题相结合。目前已有多款评论组件，你可以非常方便的切换。</li></ul><h3 id="👀Solo"><a href="#👀Solo" class="headerlink" title="👀Solo"></a>👀Solo</h3><p><code>Solo</code> 是一款基于Java语言有后台管理的，小而美的博客系统，专为程序员设计</p><p><strong>优点：</strong></p><ul><li>Markdown 编辑器支持三种编辑模式：所见即所得 &#x2F; 即时渲染 &#x2F; 分屏预览。</li><li><a href="https://ld246.com/article/1498490209748">Hexo &#x2F; Jekyll &#x2F; Markdown 导入</a>。</li><li>SQL &#x2F; JSON &#x2F; Markdown 导出。</li><li>拉取 GitHub 仓库和自动备份。</li><li>内置 HTTPS+CDN 文件存储。</li><li>支持生成导出静态站点，用于发布 GitHub Pages。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Blog </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
