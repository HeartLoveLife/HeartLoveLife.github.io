<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>IDL语法基础（01）</title>
      <link href="/2022/10/30/IDL-Basic01/"/>
      <url>/2022/10/30/IDL-Basic01/</url>
      
        <content type="html"><![CDATA[<h2 id="⛄IDL简介"><a href="#⛄IDL简介" class="headerlink" title="⛄IDL简介"></a>⛄<code>IDL</code>简介</h2><p>交互式数据语言——<code>IDL</code>（<code>Interactive Data Language</code>）是进行应用程序开发、科学数据分析与可视化表达的理想工具。<code>IDL</code>是基于矩阵运算的计算机语言，它语法简单，自带大量的功能函数，用很少的几行代码就能实现其它语言很难实现的功能。利用IDL可以快速地进行科学数据读写、三维数据可视化、数值运算和三维图形建模等。<code>IDL</code>可以应用在地球科学（包括气象、水文、海洋、土壤和地质等），医学影像、图像处理、<code>GIS</code>系统、软件开发、测试、天文、航空航天、信息处理、数学统计与分析以及环境工程等领域。<code>IDL</code>的优势：</p><ul><li>数据访问 —— 灵活的数据输入、输出方式。在科学研究中，将会使用大量不同格式的数据。IDL 基本上支持各种数据格式，并提供了大量的数据读写工具，免除数据读写的烦恼，可以将更多的精力投入到数据分析。</li><li>数据分析 —— 强大的图像处理、信号处理和数据统计分析能力。<code>IDL</code> 集成了完善的数据分析、数据统计、图像处理和信号处理软件包。项目应用 <code>IDL</code> 可以节省大量时间。使用传统的 <code>C</code> 或者 <code>FORTRAN</code> 语言需要数天或数周的项目，使用 <code>IDL</code> 可以在数小时内完成。</li><li>数据可视化 —— 先进的图形技术和强大的可视化能力。从简单的二维绘图、三维绘图、体数据可视化、图像显示、动画显示等，到利用 <code>OpenGL</code>硬件加速功能进行交互式的三维图形浏览，以及支持多处理器快速进行体数据渲染，使用 <code>IDL</code>可以轻松获得丰富的可视化效果。从直接图形法到对象图形法，再到快速可视化函数，<code>IDL</code> 提供了丰富的可视化过程和函数供用户调用，使用少量代码即可实现复杂的可视化结果。</li><li>软件开发 —— 跨平台支持、全新且统一的开发环境、有效的数据管理手段。</li><li>集成 —— 灵活的外部语言接口。<code>IDL</code> 是一个灵活的、可扩展的用于可视化、分析和开发的工具，能够轻松的与其他的软件工具集成。<code>IDL</code> 能够将其他编程语言的代码和函数导入，也可以将 <code>IDL</code> 实现的功能集成到其他语言编写的应用程序中去。</li><li>程序共享 —— 灵活多样的程序发布方式和轻松的成果共享。</li></ul><p><code>IDL</code>的帮助提供了详细的使用说明和函数功能描述，学会使用帮助是快速入门和解决问题的最佳途径。帮助的启动方式有以下三种：</p><ul><li>点击主菜单[帮助]下的[选中项目帮助]和[帮助内容]功能菜单；</li><li>工作台编辑代码时按 <code>F1</code> 或选择一个函数后按 <code>F1</code>，则启动帮助；</li><li>命令行中输入<code>?</code>回车后启动帮助。</li></ul><blockquote><p>注意事项：</p><p>（1）<code>IDL</code>不区分大小写；</p><p>（2）分号”;”表示注释内容的开始；</p><p>（3）符号”<code>$</code>“，续行符；符号”<code>&amp;</code>“，续命令符；</p><p>（4）创建<code>IDL</code>变量不需要事先声明，直接赋值，并且变量随时可以进行数据类型和维数的动态改变；</p><p>（5）科学计数法：<code>a = 6.63e-34，b = 2.998e8</code></p><p>（6）<code>help</code>命令可以帮助用户跟踪变量类型和大小。对于标量，显示变量的名称、类型和值；对于数组型变量，显示变量名称、类型和大小。</p></blockquote><h2 id="⛄IDL语法基础"><a href="#⛄IDL语法基础" class="headerlink" title="⛄IDL语法基础"></a>⛄<code>IDL</code>语法基础</h2><h3 id="👀数据类型"><a href="#👀数据类型" class="headerlink" title="👀数据类型"></a>👀数据类型</h3><p><code>IDL</code>中有17种基本数据类型。基本数据类型的名称、类型代码、字节大小、创建方式和范围，以及类型转换等。</p><table><thead><tr><th>数据类型</th><th align="center">代码</th><th align="center">字节数</th><th align="center">范围</th><th>创建变量</th><th>类型转换</th></tr></thead><tbody><tr><td>字节型</td><td align="center">1</td><td align="center">1</td><td align="center"><code>0~255</code></td><td><code>Var=0B</code></td><td><code>byte()</code></td></tr><tr><td>16位有符号整型</td><td align="center">2</td><td align="center">2</td><td align="center"><code>-32768~32767</code></td><td><code>Var=0</code></td><td><code>fix()</code></td></tr><tr><td>32位有符号长整型</td><td align="center">3</td><td align="center">4</td><td align="center"><code>-2^31~2^31-1</code></td><td><code>Var=0L</code></td><td><code>long()</code></td></tr><tr><td>64位有符号整型</td><td align="center">14</td><td align="center">8</td><td align="center"><code>-2^63~2^63-1</code></td><td><code>Var=0LL</code></td><td><code>long64()</code></td></tr><tr><td>16位无符号整型</td><td align="center">12</td><td align="center">2</td><td align="center"><code>0~65535</code></td><td><code>Var=0U</code></td><td><code>uint()</code></td></tr><tr><td>32位无符号长整型</td><td align="center">13</td><td align="center">4</td><td align="center"><code>0~2^32-1</code></td><td><code>Var=0UL</code></td><td><code>ulong()</code></td></tr><tr><td>64位无符号整型</td><td align="center">15</td><td align="center">8</td><td align="center"><code>0~2^64-1</code></td><td><code>Var==0ULL</code></td><td><code>ulong64()</code></td></tr><tr><td>浮点型</td><td align="center">4</td><td align="center">4</td><td align="center"><code>-10^38~2^38</code></td><td><code>Var=0.0</code></td><td><code>float()</code></td></tr><tr><td>双精度浮点型</td><td align="center">5</td><td align="center">8</td><td align="center"><code>-10^308~2^308</code></td><td><code>Var=0.0D</code></td><td><code>double()</code></td></tr><tr><td>复数</td><td align="center">6</td><td align="center">8</td><td align="center"><code>-10^38~2^38</code></td><td><code>Var=Complex(0.0,0.0)</code></td><td><code>complex()</code></td></tr><tr><td>双精度复数</td><td align="center">9</td><td align="center">16</td><td align="center"><code>-10^308~2^308</code></td><td><code>Var=Dcomplex(0.0D,0.0D)</code></td><td><code>dcomplex()</code></td></tr><tr><td>字符串</td><td align="center">7</td><td align="center">0~32767</td><td align="center"><code>None</code></td><td><code>Var=&#39; &#39;或Var=&quot; &quot;</code></td><td><code>string()</code></td></tr><tr><td>结构体</td><td align="center">8</td><td align="center">复合类型</td><td align="center"><code>None</code></td><td><code>St1=&#123;&#125;</code></td><td></td></tr><tr><td>指针</td><td align="center">10</td><td align="center">4</td><td align="center"><code>None</code></td><td><code>Var=Ptr_New()</code></td><td></td></tr><tr><td>对象</td><td align="center">11</td><td align="center">4</td><td align="center"><code>None</code></td><td><code>Var=Obj_New()</code></td><td></td></tr><tr><td>链表</td><td align="center">11</td><td align="center">复合类型</td><td align="center"><code>None</code></td><td><code>Ls=List()</code></td><td></td></tr><tr><td>哈希表</td><td align="center">11</td><td align="center">复合类型</td><td align="center"><code>None</code></td><td><code>Hs=Hash()</code></td><td></td></tr></tbody></table><p>变量的类型代码通过<code>Size(var, /type)</code>来获得，如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IDL&gt; a=10</span><br><span class="line">IDL&gt; print,size(a,/type)</span><br><span class="line">           2</span><br><span class="line">IDL&gt; b=10.0</span><br><span class="line">IDL&gt; print,size(b,/type)</span><br><span class="line">           4</span><br><span class="line">IDL&gt; c=10L</span><br><span class="line">IDL&gt; print,size(c,/type)</span><br><span class="line">           3</span><br></pre></td></tr></table></figure><h3 id="👀常量和变量"><a href="#👀常量和变量" class="headerlink" title="👀常量和变量"></a>👀常量和变量</h3><p>常量。常量是不能修改的固定值，分为整型常量、浮点型常量、复数型常量和字符型常量等类型。</p><p>变量。<code>IDL</code> 中的变量分为局部变量和系统变量。在 <code>IDL</code> 程序中，二者的区别在于生命周期不一样，局部变量仅仅在所在的函数或过程中有效，而系统变量则在始终有效或某个程序的周期中有效。</p><p>（1）命名规则</p><p>变量名称的最大长度不超过 255 个字符，变量的首位只能是字母和下划线，中后部只能是字母、数字、下划线<code>_</code>和连接符<code>$</code>。如下正确：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">abc_3$dok_24_bit IDL_type variable _day_month_year</span><br><span class="line">如下错误：</span><br><span class="line">abc.cha one%file 4_lists $file</span><br></pre></td></tr></table></figure><p>变量相关函数 <code>IDL_VALIDNAME</code>。该函数用来检测字符串是否可以作为 <code>IDL</code> 下的变量，并能够将无效字符转换为“<code>_</code>”并返回变量。调用格式为 <code>IDL_VALIDNAME ( String [, /CONVERT_ALL] [, /CONVERT_SPACES])</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IDL&gt; print,IDL_VALIDNAME(&#x27;idl&#x27;)</span><br><span class="line">idl</span><br><span class="line">IDL&gt; print,IDL_VALIDNAME(&#x27;i d l&#x27;, /CONVERT_SPACES)</span><br><span class="line">i_d_l</span><br><span class="line">IDL&gt; print,IDL_VALIDNAME(&#x27;16ENVIIDL&#x27;, /CONVERT_ALL)</span><br><span class="line">_16ENVIIDL</span><br></pre></td></tr></table></figure><p>判断变量是否已经被定义，可以使用<code>N_Elements</code>函数，示例代码如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IDL&gt; a=1</span><br><span class="line">IDL&gt; ;变量已经定义        </span><br><span class="line">IDL&gt; print,N_Elements(a)</span><br><span class="line">           1</span><br><span class="line">IDL&gt; ;变量没有定义</span><br><span class="line">IDL&gt; print,N_Elements(aa)</span><br><span class="line">           0</span><br></pre></td></tr></table></figure><p>（2）变量类型转换</p><p>变量可以通过类型转换函数进行强制类型转换。</p><table><thead><tr><th>类型转换</th><th>函数名称</th><th>操作</th><th>结果</th></tr></thead><tbody><tr><td>字节型</td><td><code>BYTE</code></td><td>BYTE(1.2)</td><td>1B</td></tr><tr><td>整型</td><td><code>FIX</code></td><td>FIX(2.5)</td><td>2</td></tr><tr><td>无符号整型</td><td><code>UINT</code></td><td>UINT([5.5,-3])</td><td>5 65533</td></tr><tr><td>长整型</td><td><code>LONG</code></td><td>LONG(65538.5)</td><td>65538</td></tr><tr><td>无符号长整型</td><td><code>ULONG</code></td><td>ULONG([5.5,-3])</td><td>5 4294967293</td></tr><tr><td>64 位长整型</td><td><code>LONG64</code></td><td>LONG64([5.5,-3])</td><td>5 -3</td></tr><tr><td>无符号 64 位长整型</td><td><code>ULONG64</code></td><td>ULONG64([5.5,-3])</td><td>5 18446744073709551613</td></tr><tr><td>浮点型</td><td><code>FLOAT</code></td><td>FLOAT([5.5,-3])</td><td>5.50000 -3.00000</td></tr><tr><td>双精度类型</td><td><code>DOUBLE</code></td><td>DOUBLE([5.5,-3])</td><td>5.5000000 -3.0000000</td></tr><tr><td>复数类型</td><td><code>COMPLEX</code></td><td>COMPLEX(1, 2)</td><td>(1.00000, 2.00000)</td></tr><tr><td>双精度复数类型</td><td><code>DCOMPLEX</code></td><td>DCOMPLEX(1, 2)</td><td>(1.0000000, 2.0000000)</td></tr></tbody></table><p>在进行数据的转换中需要注意转换后的数据的界限问题。如下面操作：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IDL&gt; ;整型转换为浮点</span><br><span class="line">IDL&gt; print,float(1)</span><br><span class="line">      1.00000</span><br><span class="line"></span><br><span class="line">IDL&gt; ;浮点数取整</span><br><span class="line">IDL&gt; print,fix(1.3+1.8)</span><br><span class="line">       3</span><br><span class="line"> </span><br><span class="line">IDL&gt; ;fix还可以指定输出类型</span><br><span class="line">IDL&gt; help,fix(1.3,type=5)</span><br><span class="line">&lt;Expression&gt;    DOUBLE    =        1.3000000</span><br><span class="line"></span><br><span class="line">IDL&gt; ;出现这个错误是因为整型变量是16Bit的，最大值为32767，此种情况下用长整型强制转换函数long(a)。</span><br><span class="line">IDL&gt; a=33000</span><br><span class="line">IDL&gt; print,fix(a)</span><br><span class="line">  -32536</span><br><span class="line"></span><br><span class="line">IDL&gt; ;注意整型变量的运算，如除法运算</span><br><span class="line">IDL&gt; ;结果是1，原因在于参与运算的两个数字为整数，运算结果依然是整数。</span><br><span class="line">IDL&gt; result = 8/5</span><br><span class="line">IDL&gt; print,result</span><br><span class="line">IDL&gt; ;在运算时需要增加强制类型转换，将整形类型转换为浮点类型。</span><br><span class="line">IDL&gt; result = 8/float(5)</span><br><span class="line">IDL&gt; print,result</span><br><span class="line">      1.60000</span><br><span class="line">IDL&gt; result = 8*1.0/5</span><br><span class="line">IDL&gt; print,result</span><br><span class="line">      1.60000</span><br></pre></td></tr></table></figure><p>浮点类型和双精度类型的取整操作函数如下：</p><table><thead><tr><th>函数名称</th><th>功能</th><th>操作</th><th>结果</th></tr></thead><tbody><tr><td><code>floor</code></td><td>向下取整</td><td>floor(2.4)<br />floor(2.5)</td><td>2<br />2</td></tr><tr><td><code>ceil</code></td><td>向上取整</td><td>floor(2.4)<br />floor(2.5)</td><td>3<br />3</td></tr><tr><td><code>round</code></td><td>四舍五入</td><td>floor(2.4)<br />floor(2.5)</td><td>2<br />3</td></tr></tbody></table><p>（3）变量类型的动态性</p><p>在使用的过程中，可以随时修改变量类型，即变量类型具备动态性。该特性使得<code>IDL</code>在数学运算中将低精度类型提升为高精度类型，确保计算结果具备足够的精度。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IDL&gt; num=6</span><br><span class="line">IDL&gt; help,num</span><br><span class="line">NUM             INT       =        6</span><br><span class="line">IDL&gt; num=num*1.1</span><br><span class="line">IDL&gt; help,num</span><br><span class="line">NUM             FLOAT     =       6.60000</span><br></pre></td></tr></table></figure><p>（4）系统变量</p><p>系统变量分为预定义系统变量和自定义系统变量。预定义系统变量是<code>IDL</code>中预先定义的系统变量，一般情况下不允许修改，包括常数变量、图形变量、系统配置和错误处理；自定义系统变量是用户创建的系统变量。</p><h3 id="👀数组"><a href="#👀数组" class="headerlink" title="👀数组"></a>👀数组</h3><p>程序设计中，为了处理方便， 把具有相同类型的若干变量按有序的形式组织起来。这些按序排列的同类数据元素的集合称为数组。<code>IDL</code> 是面向矩阵的第四代语言，对数组的维数为0～8 维，在数组的处理时非常的灵活、高效。</p><blockquote><p>注意，IDL 中数组下标的顺序先是列标，后是行标。</p></blockquote><h4 id="👁创建数组"><a href="#👁创建数组" class="headerlink" title="👁创建数组"></a>👁创建数组</h4><p>（1）赋值创建</p><p>通过方括号<code>[]</code>赋值创建数组。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IDL&gt; arr = [1,2,3]</span><br><span class="line">IDL&gt; help,arr</span><br><span class="line">ARR             INT       = Array[3]</span><br><span class="line">IDL&gt; arr = [[1,2,3],[4,5,6]]</span><br><span class="line">IDL&gt; help,arr</span><br><span class="line">ARR             INT       = Array[3, 2]</span><br><span class="line">IDL&gt; arr</span><br><span class="line">       1       2       3</span><br><span class="line">       4       5       6</span><br></pre></td></tr></table></figure><p>（2）函数创建</p><p>利用数组创建函数可创建不同类型或维数的数组。</p><p><strong>通用函数</strong>，可以用 <code>IDL</code> 的通用函数进行全零数组或索引数组的创建。</p><table><thead><tr><th>数据类型</th><th>创建全0数组</th><th>创建索引数组</th></tr></thead><tbody><tr><td>字节型</td><td><code>bytArr()</code></td><td><code>bindgen()</code></td></tr><tr><td>16位有符号整型</td><td><code>intarr()</code></td><td><code>indgen()</code></td></tr><tr><td>32位有符号长整型</td><td><code>lonarr()</code></td><td><code>lindgen()</code></td></tr><tr><td>64位有符号整型</td><td><code>lon64arr()</code></td><td><code>l64indgen()</code></td></tr><tr><td>16位无符号整型</td><td><code>uintarr()</code></td><td><code>uindgen()</code></td></tr><tr><td>32位无符号长整型</td><td><code>ulongarr()</code></td><td><code>ulindgen()</code></td></tr><tr><td>64位无符号整型</td><td><code>ulon64arr()</code></td><td><code>ul64indgen()</code></td></tr><tr><td>浮点型</td><td><code>fltarr()</code></td><td><code>findgen()</code></td></tr><tr><td>双精度浮点型</td><td><code>dblarr()</code></td><td><code>dindgen()</code></td></tr><tr><td>复数</td><td><code>complexarr()</code></td><td><code>cindgen()</code></td></tr><tr><td>双精度复数</td><td><code>dcomplexarr()</code></td><td><code>dcindgen()</code></td></tr><tr><td>字符串</td><td><code>strarr()</code></td><td><code>sindgen()</code></td></tr><tr><td>指针</td><td><code>ptrarr()</code></td><td></td></tr><tr><td>对象</td><td><code>objarr()</code></td><td></td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IDL&gt; num = findgen(20)</span><br><span class="line">IDL&gt; num</span><br><span class="line">      0.00000000       1.0000000       2.0000000       3.0000000       4.0000000         5.0000000   6.0000000       7.0000000       8.0000000       9.0000000         10.000000       11.000000   12.000000       13.000000       14.000000               15.000000       16.000000       17.00000018.000000       19.000000</span><br></pre></td></tr></table></figure><p><strong>常规函数</strong>，<code>MAKE_ARRAY()</code>函数：是在程序运行过程中创建特定的数组。</p><p>调用格式为： <code>Result = MAKE_ARRAY ( [D1 [, ..., D8]] [, /INDEX] [, DIMENSION = vector] [, /NOZERO] [, SIZE=vector] [, TYPE=type_code] [, VALUE=value] )</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IDL&gt; a = Make_array(4,5,/Integer,Value=6)</span><br><span class="line">IDL&gt; a</span><br><span class="line">       6       6       6       6</span><br><span class="line">       6       6       6       6</span><br><span class="line">       6       6       6       6</span><br><span class="line">       6       6       6       6</span><br><span class="line">       6       6       6       6</span><br></pre></td></tr></table></figure><blockquote><p>创建特殊数组：<code>RANDOMU()</code>函数返回一个或多个均匀分布的浮点型数组，值在[0,1]之间。<code>RANDOMN()</code>函数返回一个或多个正态分布的浮点型数组，这些数的平均为零，标准偏差为 1 。</p></blockquote><h4 id="👁数组存储"><a href="#👁数组存储" class="headerlink" title="👁数组存储"></a>👁数组存储</h4><p><code>IDL</code>中的矢量和数组均是以先行后列顺序存储的(<code>IDL</code>最初是设计用来处理行扫描的卫星数据)，下标值的起始值是 0。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IDL&gt; array = indgen(4,3)</span><br><span class="line">IDL&gt; array</span><br><span class="line">       0       1       2       3</span><br><span class="line">       4       5       6       7</span><br><span class="line">       8       9      10      11</span><br></pre></td></tr></table></figure><h4 id="👁数组访问"><a href="#👁数组访问" class="headerlink" title="👁数组访问"></a>👁数组访问</h4><p>（1）下标方式</p><p>可以使用下标来存取该数组中的每一个元素。按照“<code>数组名[下标]</code>”或“<code>数组名（下标）</code>”对数组中元素进行存取，数组下标起始值为0。因为函数的调用方式为“<code>函数名（参数）</code>”，为避免混淆，数组下标使用时一般使用<code>[]</code>。其中-1为最后一个元素的下标，可根据下标值依次获取元素。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IDL&gt; arr = indgen(9)</span><br><span class="line">IDL&gt; arr</span><br><span class="line">       0       1       2       3       4       5       6       7       8</span><br><span class="line">IDL&gt; arr(3)</span><br><span class="line">       3</span><br><span class="line">IDL&gt; arr[3]</span><br><span class="line">       3</span><br><span class="line">IDL&gt; arr[-1]</span><br><span class="line">       8</span><br><span class="line">IDL&gt; arr[-5:-1]</span><br><span class="line">       4       5       6       7       8</span><br></pre></td></tr></table></figure><p>（2）向量方式</p><p>下标可以通过向量方式表示。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IDL&gt; arr = indgen(9)+5</span><br><span class="line">IDL&gt; arr</span><br><span class="line">       5       6       7       8       9      10      11      12      13</span><br><span class="line">IDL&gt; index = [0,2,4,6,8]</span><br><span class="line">IDL&gt; arr[index]</span><br><span class="line">       5       7       9      11      13</span><br><span class="line">;对30行20列的索引数组取出第6~10列中第12~15行的数据，可以通过“:”方式</span><br><span class="line">IDL&gt; arr1 = indgen(20,30)</span><br><span class="line">IDL&gt; select_arr1 = arr1[5:9,11:14]</span><br><span class="line">IDL&gt; select_arr1</span><br><span class="line">     225     226     227     228     229</span><br><span class="line">     245     246     247     248     249</span><br><span class="line">     265     266     267     268     269</span><br><span class="line">     285     286     287     288     289 </span><br><span class="line">;对30行20列的索引数组取出第10行的数据，可以通过“*”方式</span><br><span class="line">IDL&gt; vec_10 = arr1[*,9]</span><br><span class="line">IDL&gt; vec_10</span><br><span class="line">     180     181     182     183     184     185     186     187     188     189     190 191 192     193     194     195     196     197     198     199</span><br></pre></td></tr></table></figure><h4 id="👁数组运算"><a href="#👁数组运算" class="headerlink" title="👁数组运算"></a>👁数组运算</h4><p>（1）求大、求小和求余</p><p>数组的求大(<code>&lt;</code>)、求小(<code>&gt;</code>)和求余(<code>mod</code>)操作返回的是同维数组的计算结果。数组求大（&lt;<code>value</code>）是将数组中小于<code>value</code>的元素赋为<code>value</code>；求小（&gt;<code>value</code>）是将数组中大于<code>value</code>的值赋为<code>value</code>；数组求余（<code>mod</code>)是计算数组中各元素的余数。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IDL&gt; a = indgen(8)+3</span><br><span class="line">IDL&gt; a</span><br><span class="line">       3       4       5       6       7       8       9      10</span><br><span class="line">IDL&gt; a&gt;6</span><br><span class="line">       6       6       6       6       7       8       9      10</span><br><span class="line">IDL&gt; a</span><br><span class="line">       3       4       5       6       7       8       9      10</span><br><span class="line">IDL&gt; a&lt;6</span><br><span class="line">       3       4       5       6       6       6       6       6</span><br></pre></td></tr></table></figure><p>（2）数组与数运算<br>数组与数的运算遵循的基本规律是，数组中的每个元素与数进行运算。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IDL&gt; a = indgen(8)</span><br><span class="line">IDL&gt; a</span><br><span class="line">       0       1       2       3       4       5       6       7</span><br><span class="line">IDL&gt; a = indgen(8)+5</span><br><span class="line">IDL&gt; a</span><br><span class="line">       5       6       7       8       9      10      11      12</span><br></pre></td></tr></table></figure><p>（3）数组与数组运算<br>数组与数组的运算，结果的元素个数与运算的最小数组个数一致，多维数组需要转换为一维数组来运算。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IDL&gt; arr = [2,4,6,8]</span><br><span class="line">IDL&gt; arr1  = [4.5]</span><br><span class="line">IDL&gt; arr + arr1</span><br><span class="line">       6.5000000</span><br><span class="line">IDL&gt; arr1  = [5,6]</span><br><span class="line">IDL&gt; arr + arr1</span><br><span class="line">       7      10</span><br><span class="line">IDL&gt; arr2 = [[1,3,5],[2,4,6]]</span><br><span class="line">IDL&gt; arr3 = [[1,2],[3,4]]</span><br><span class="line">IDL&gt; arr2 + arr3</span><br><span class="line">       2       5</span><br><span class="line">       8       6</span><br></pre></td></tr></table></figure><p>（4）数组合并</p><p>数组与数组的合并需要两个数组的行数或列数相同。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IDL&gt; a = indgen(2,5)</span><br><span class="line">IDL&gt; b = indgen(4,5)</span><br><span class="line">IDL&gt; ;行数相同，可直接使用[]</span><br><span class="line">IDL&gt; c = [a,b]</span><br><span class="line">IDL&gt; c</span><br><span class="line">       0       1       0       1       2       3</span><br><span class="line">       2       3       4       5       6       7</span><br><span class="line">       4       5       8       9      10      11</span><br><span class="line">       6       7      12      13      14      15</span><br><span class="line">       8       9      16      17      18      19</span><br><span class="line">IDL&gt; ;列数相同，需要使用[[],[]]</span><br><span class="line">IDL&gt; d = indgen(2,3)</span><br><span class="line">IDL&gt; e = [[a],[d]]</span><br><span class="line">IDL&gt; e</span><br><span class="line">       0       1</span><br><span class="line">       2       3</span><br><span class="line">       4       5</span><br><span class="line">       6       7</span><br><span class="line">       8       9</span><br><span class="line">       0       1</span><br><span class="line">       2       3</span><br><span class="line">       4       5</span><br></pre></td></tr></table></figure><h4 id="👁相关函数"><a href="#👁相关函数" class="headerlink" title="👁相关函数"></a>👁相关函数</h4><p>（1）数组信息 <code>Size()</code></p><p><code>Size()</code>函数能够返回数组的结构信息，调用格式为 <code>Result = SIZE(变量, [/KeyWords])</code>。输入变量可以是常量、数组、字符串、结构体、指针和对象等任何数据类型。不设置关键字时，函数返回变量的基本信息：变量维数、每一维的数值元素个数（维数），变量类型代码、元素总个数。设置关键字<code>N_Dimensions</code>、<code>N_Elements</code>、<code>Dimensions</code>、<code>Tname</code>和<code>Type</code>，则依次返回数组的维数、元素个数、每一维的维数、类型名称和类型代码信息。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IDL&gt; data = indgen(4,5)</span><br><span class="line">IDL&gt; size(data)</span><br><span class="line">           2           4           5           2          20</span><br><span class="line">IDL&gt; size(data,/N_dimensions)</span><br><span class="line">           2</span><br><span class="line">IDL&gt; size(data,/N_elements)</span><br><span class="line">          20</span><br><span class="line">IDL&gt; size(data,/Dimensions)</span><br><span class="line">           4           5</span><br><span class="line">IDL&gt; size(data,/Tname)</span><br><span class="line">INT</span><br></pre></td></tr></table></figure><p>（2）条件查找</p><p><code>WHERE()</code>函数返回满足指定条件（即数组表达式）数组元素的下标所组成的一维数组。调用格式为：</p><p> <code>Result =WHERE(数组表达式 [, count] [, COMPLEMENT=变量 1] [, /L64] [, NCOMPLEMENT=变量 2])</code>。</p><p>关键字：count 返回的是符合指定条件的个数；变量 1 是不满足条件的数组的下标信息；变量 2 是不满足条件的数组的个数；</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IDL&gt; a = indgen(10)+3</span><br><span class="line">IDL&gt; a</span><br><span class="line">       3       4       5       6       7       8       9      10      11      12</span><br><span class="line">IDL&gt; B = WHERE(a GT 6, count, COMPLEMENT=B_C, NCOMPLEMENT=count_c)</span><br><span class="line">IDL&gt; count</span><br><span class="line">           6</span><br><span class="line">IDL&gt; B</span><br><span class="line">           4           5           6           7           8           9</span><br><span class="line">IDL&gt; count_c</span><br><span class="line">           4</span><br><span class="line">IDL&gt; B_C</span><br><span class="line">           0           1           2           3</span><br></pre></td></tr></table></figure><p>（3）大小调整</p><p><code>Reform()</code>函数可以使数组在元素个数不修改的前提下，改变数组的维数，方便了数组的动态使用。调用格式：</p><blockquote><p><code>Result = REFORM(Array, D1 [, ..., D8] [, 关键字] )</code></p></blockquote><p><code>Rebin()</code>函数可以修改数组的维数大小，将维数调整为 <code>D1 [, ..., D8]</code>指定的维数，且大小必须原数据的大小的整数倍，默认抽样算法是双线性内插。调用格式：</p><blockquote><p><code>Result = REBIN(数组, D1 [, ..., D8] [, /SAMPLE] )</code><br><code>SAMPLE</code>：设置该关键字则使用最近临值抽样法。</p></blockquote><p><code>Congrid()</code>函数可以调整数组为同维任意大小的数组，默认在处理一维或二维数组时默认是最近邻重采样方式，处理三维数组时默认是双线性内插值。在数据缩小操作时，<code>Rebin</code> 做了插值处理，而 <code>Congrid</code> 仅仅是重新采样。调用格式为：</p><blockquote><p><code>Result = Congrid(数组, X,Y,Z [,关键字] )</code><br><code>INTERP</code>：抽样采用线性内插法；<br><code>CUBIC</code>：采用卷积内插法。</p></blockquote><p><code>EXPAND</code> 用来对二维数组进行大小修改，采用双线性内插算法。调用格式：</p><blockquote><p><code>EXPAND, A, Nx, Ny, Result[, FILLVAL=value] [, MAXVAL=value]</code> </p><p>其中 <code>A</code> 为源数组，<code>Nx</code>、<code>Ny</code> 为修改后的维数，<code>Result</code> 为修改后的数组，<code>FILLVAL</code> 是填充数据，默认为-1；<code>MAXVAL</code> 是数据的最大值，大于该值的赋为 <code>FILLVAL</code>。</p></blockquote><p><code>INTERPOLATE()</code>函数可以调整数组为同维任意大小的数组，并能够任意定位插值点。调用格式：</p><blockquote><p><code>INTERPOLATE(数组, X[, Y [, Z]] [, 关键字] )</code></p><p>其中，<code>X [, Y [, Z]]</code>为待调整数组下标索引，可以是单个变量或数组，若<code>X</code>为0.5，则表示计算下标[0]和下标[1]中间位置的数值；<br><code>GRID</code> 关键字：采用网格插值方式生成插值点，否则按线性方式生成；<br><code>Missing</code> 关键字：插值点坐标超出数组自身坐标范围时赋予该值。</p></blockquote><p>（4）数组反转</p><p><code>Reverse()</code>函数可以对数组进行反转。调用格式：</p><blockquote><p><code>result = Reverse(数组, index[, 关键字] )</code><br><code>index</code> 是反转的数组的维数索引，它不能大于数组的维数。</p></blockquote><p>（5）数组转置 Transpose()<br><code>Transpose ()</code>函数可以对数组进行反转。调用格式：</p><blockquote><p><code>result = Transpose(数组, [P])</code><br>关键字：<code>P</code> 是调整后的维数数组列表，如不设置则完全反转。</p></blockquote><p>（6）数组旋转</p><p>①<code>Rotate()</code>函数</p><p><code>Rotate()</code>函数可以以 <code>90°</code>整倍数的角度对数组进行旋转操作。调用格式：</p><blockquote><p><code>result = Rotate (数组, direction )</code><br><code>Direction</code>：该关键字为整数，范围 <code>0-7</code>，分别代表的图像旋转方式。</p></blockquote><p>②<code>Rot()</code>函数</p><p><code>Rot()</code>函数可以以任意的角度对数组进行旋转操作并能进行放大、缩小操作。调用格式：</p><blockquote><p><code>result = Rot(数组, Angle, [Mag, X0, Y0],[关键字])</code><br><code>Angle</code>：该关键字数组旋转地角度，单位为度(°)。<br><code>Mag</code>：为放大的倍数；<br><code>X0</code>：为旋转中心的 <code>X</code> 坐标，默认为列中心；<br><code>Y0</code>：为旋转中心的 <code>Y</code> 坐标，默认为行中心；<br><code>PIVOT</code>：该关键字控制旋转后<code>(X0,Y0)</code>点是否仍然在原图像中的位置，不设置则<code>(X0,Y0)</code>点在图像的中心位置。</p></blockquote><p>（7）数组平移</p><p><code>Shift()</code>函数是按指定的平移量 <code>S1、…、Sn</code>，分别对数组的第 <code>1、…、n</code> 维进行平移后生成新数组。其中 <code>Si</code> 为正表示向前平移；<code>Si</code> 为负表示向后平移。调用格式：</p><blockquote><p><code>result = Shift(数组，S1、…、Sn)</code></p></blockquote><p>（8）数组排序<br><code>Sort()</code>函数返回排序后的<strong>数组索引</strong>。调用格式：</p><blockquote><p><code>result = Sort(数组[, /L64])</code></p></blockquote><p>（9）数组唯一调整 （求不同值）<br><code>Uniq()</code>函数返回数组中<strong>相邻元素不同值</strong>的<strong>索引</strong>。该函数<strong>只能发现相邻值</strong>，若不相邻，则会认为是两个值。如果先对数组进行排序，则可求出数组中包含的不同值。调用格式为：</p><blockquote><p><code>result = UNIQ(数组 [, Index] )</code></p></blockquote><p>（10）判断数组</p><p><code>Array_Equal()</code>函数进行数组相同的判断。调用格式：</p><blockquote><p><code>result = Array_Equal(数组, /关键字)</code><br><code>result</code>：返回 0 或 1。<br><code>NO_TYPECONV</code>：添加该关键字，用于将两数组转换为同一类型，判断数据类型是否相同；为1时，数组可直接比较，不转换数据类型。</p></blockquote><p>（11）元素个数</p><p><code>N_Elements()</code>函数返回数组元素的个数。调用格式：</p><blockquote><p><code>result = N_Elements(数组)</code></p></blockquote><p>（12）求最值</p><p><code>Max()</code>函数返回满足数组元素的最大值。调用格式：</p><blockquote><p><code>result = Max(数组 [,关键字], min =变量 1)。</code><br><code>result</code>：返回的是数组的最大值；<br><code>变量 1</code>：返回的是数组的最小值；</p></blockquote><p><code>Min()</code>函数返回满足数组元素的最小值。调用格式：</p><blockquote><p><code>result = Min(数组 [,关键字], max =变量 1)。</code><br><code>result</code>：返回的是数组的最小值；<br><code>变量 1</code>：返回的是数组的最大值；</p></blockquote><p>（13）求和</p><p>Total()函数返回满足数组元素和，并可以通过关键字进行求和选项的控制。调用格式：</p><blockquote><p><code>result = Total(数组, Dimension, [,关键字])。</code><br><code>result</code>：返回的是数组元素求和结果；<br><code>Dimension</code>：数组求和元素的行列控制；<br><code>CUMULATIVE</code>：设置该关键字后，返回结果与原数组一致，第 <code>i</code> 个元素的值为 <code>0-i</code> 值的和；<br><code>Double</code>：返回双精度类型结果；<br><code>Integer</code>：返回整型数据结果；<br><code>PRESERVE_TYPE</code>：返回结果类型与原数组类型一致，设置该关键字的时，&#x2F;double 等关键字无效。</p></blockquote><p>（14）乘积计算<br><code>Product()</code>函数计算数组中所有或部分元素的乘积。调用格式：</p><blockquote><p><code>result = Product(数组, Dimension, [,关键字])。</code><br>关键字控制与 total 函数的关键字基本一致。</p></blockquote><p>（15）其它运算</p><p><code>Factorial()</code>函数计算满足数组元素阶乘。调用格式：</p><blockquote><p><code>result = Factorial(数组, [,关键字])。</code><br>关键字-<code>Stirling</code>：返回结果为Stirling近似值。</p></blockquote><p><code>Mean()</code>函数计算数组元素的平均值。调用格式为：</p><blockquote><p><code>result = Mean(数组, [,关键字])。</code></p></blockquote><p><code>Variance()</code>函数计算数组元素的方差。调用格式：</p><blockquote><p><code>result = Variance(数组, [,关键字])。</code></p></blockquote><p><code>Stddev()</code>函数计算数组元素的方差。调用格式：</p><blockquote><p><code>result = Variance(数组, [,关键字])。</code></p></blockquote><p><code>Moment()</code>函数计算数组元素的平均值、方差、倾斜度及频率曲线峰态。调用格式：</p><blockquote><p><code>result = Moment(数组, [,关键字])。</code></p></blockquote><h4 id="👁矩阵运算"><a href="#👁矩阵运算" class="headerlink" title="👁矩阵运算"></a>👁矩阵运算</h4><p>矩阵间的运算，遵循以下两个法则（注意与线性代数矩阵运算的区别和联系）：</p><p><code>A#B</code> 表示 A 的列乘以 B 的行，要求A的行数必须跟B的列数一致。</p><p><code>A##B</code> 表示 A 的行乘以 B 的列，要求A的列数必须跟B的行数一致。</p><h3 id="👀字符串"><a href="#👀字符串" class="headerlink" title="👀字符串"></a>👀字符串</h3><p>字符串和字符串数组的创建可以通过直接赋值或函数来实现。在IDL中字符串用双引号<code>&quot; &quot;</code>或单引号<code>&#39;&#39;</code>括起来表示。但以<code>&quot;</code>为首的字符串的首字符不能为数字，因为以<code>&quot;</code>开头的数字串代表一个8进制。</p><p>字符串连接直接用加号<code>&quot;+&quot;</code>。字符串操作在文件读取、命令行输入以及窗口参数输入时经常被用到。字符串操作都是通过字符串处理函数来实现的。</p><table><thead><tr><th>函数名</th><th>函数描述</th></tr></thead><tbody><tr><td><code>STRCMP(str1, str2, N, /FOLD_CASE)</code></td><td>对两个字符串进行比较，如果 N 存在，只对前 N 个进行比较，<code>/FOLD_CASE</code> 表示模糊比较</td></tr><tr><td><code>STRCOMPRESS(str1)</code></td><td>删除字符串 <code>str1</code> 中的空格</td></tr><tr><td><code>STREGEX()</code></td><td>正则表达式</td></tr><tr><td><code>STRJOIN()</code></td><td>字符串相连接</td></tr><tr><td><code>STRLEN(）</code></td><td>返回字符串的长度</td></tr><tr><td><code>STRLOWCASE(）</code></td><td>将所有的大写字母改写成小写字母</td></tr><tr><td><code>STRMATCH(Str1,str2)</code></td><td>字符串 <code>Str1</code> 中是否存在 <code>Str2</code>，可以使用通配符</td></tr><tr><td><code>STRMID(Str1,po1,Len,REVERSE_OFFSET)</code></td><td>从字符串 <code>po1</code> 开始取出 <code>Len</code> 个字符。字符串的第一个字符的位置为 0</td></tr><tr><td><code>STRPOS(Exp_Str1,Sea_Str2,Pos,&lt;br /&gt;REVERSE_OFFSET,/REVERSE_SEARCH] )</code></td><td>从一个字符串中查找与另外一个字符串完全匹配的起始点所在的位置。<code>Pos</code>是查找点的起始位置，默认值 为0、1（如果指定<code>/REVERSE_SEARCH]</code>）；指定时，则表示从开始的Pos起，或者从末尾开始的<code>Pos</code> 起（如果指定 <code>REVERSE_OFFSET</code> ）</td></tr><tr><td><code>STRPUT,Des_Var_str,Sou_str,Pos</code></td><td>将字符串<code>Sou_str</code>插入到字符串<code>Des_Var_str</code>之中，<code>POS</code>插入点的位置，默认值为 0，依次将字符串Sou_str覆盖插入到<code>Des_Var_str</code>中。<code>Sou_str</code> 不为字符串，则按默认格式自动转化从 <code>POS</code> 处开始插入<code>Des_Var_str</code>，如果插入值的位置超过了 <code>Des_Var</code> 的最大长度，则自然截断</td></tr><tr><td><code>STRSPLIT(Str1)</code></td><td>根据特定要求拆分字符串<code>str1</code>；</td></tr><tr><td><code>STRTRIM(str,Flag)</code></td><td>移去字符串中的空格。<code>Flag</code>：0(移去右边空格），1(移去左边空格），2（移去两边的空格）</td></tr><tr><td><code>STRUPCASE(）</code></td><td>将所有的小写字母改写成大写字母</td></tr></tbody></table><h3 id="👀其它数据类型"><a href="#👀其它数据类型" class="headerlink" title="👀其它数据类型"></a>👀其它数据类型</h3><p><strong>结构体</strong>：创建结构体时用大括号<code>&#123;&#125;</code>，同时需要赋予结构体名称。</p><blockquote><p>注意：通过<code>&quot;help, struct1, /structure&quot;</code>语句可以查看结构体<code>struct1</code>的基本信息。通过结构体<code>&quot;变量名.成员名&quot;</code>或<code>&quot;变量名.(index)&quot;</code>的方式访问。</p></blockquote><p><strong>指针</strong>：指针用指针函数<code>Ptr_New()</code>来创建，通过<code>&quot;*&quot;</code>+指针变量名来访问。</p><blockquote><p>指针赋值与变量赋值不一样，指针赋值是使两个指针指向同一个堆向量，修改任意一个会影响另一个。</p></blockquote><p><strong>对象</strong>：对象是数据（属性）和程序（方法）封装在一起的实体。<code>IDL</code>中用<code>Obj_New</code>函数或<code>ObjArr</code>函数来创建对象。<code>ObjArr()</code>函数用来创建对象数组；<code>Obj_New()</code>函数用来创建某一特定类的对象。</p><blockquote><p>调用对象、销毁对象、处理函数</p></blockquote><p><strong>链表</strong>：链表（<code>list</code>)是一个复合数据类型，它可以包含变量、数组、结构体、指针、对象、链表和哈希表等数据类型。链表中的元素是有次序的，可以通过索引来进行编辑操作。</p><blockquote><p>链表是由<code>list()</code>函数来创建。链表访问与数组访问一样，通过下标索引来实现。创建链表、访问链表、增加链表、删除链表、链表反转、转为数组、链表连接、链表比较、销毁链表</p></blockquote><p><strong>哈希表</strong>：哈希表（<code>Hash</code>)是一个高效的复合数据类型，可以包含变量、数组、结构体、指针、对象、链表和哈希表等数据类型。哈希表的特点是关键字（<code>keys</code>）与值对应，通过链表函数或关键字快速访问处理。</p><blockquote><p>哈希表创建通过创建函数<code>Hash()</code>创建；元素访问是根据关键字；哈希表元素添加与数组元素的添加类似；其他操作：关键字输出、关键字查询、删除哈希表、转换为结构体、哈希表组合、哈希表比较、销毁哈希表。</p></blockquote><h3 id="👀运算符"><a href="#👀运算符" class="headerlink" title="👀运算符"></a>👀运算符</h3><ul><li>数学运算符</li></ul><blockquote><p>加（<code>+</code>）、减（<code>-</code>）、增运算（<code>++</code>）、减运算（<code>--</code>）、乘（<code>*</code>）、除（<code>/</code>）、幂（<code>^</code>）、取余（<code>mod</code>）、取小（<code>&lt;</code>）、取大（<code>&gt;</code>）</p></blockquote><ul><li>逻辑运算符</li></ul><blockquote><p>逻辑与（<code>&amp;&amp;</code>）、逻辑或（<code>||</code>）、逻辑非（<code>~</code>）</p></blockquote><ul><li>位运算符</li></ul><blockquote><p>位加符（<code>AND</code>）、位取反符（<code>NOT</code>）、位或符（<code>OR</code>）、位异或符（<code>XOR</code>）</p></blockquote><ul><li>关系运算符</li></ul><blockquote><p>等于（<code>EQ</code>）、不等于（<code>NE</code>）、大于等于（<code>GE</code>）、大于（<code>GT</code>）、小于等于（<code>LE</code>）、小于（<code>LT</code>）。返回值是真（<code>1</code>）假（<code>0</code>）</p></blockquote><ul><li>数组（矩阵）运算符</li></ul><blockquote><p>数组乘（<code>#</code>）是第一个数组的列元素乘以第二个数组的行元素并求和。</p><p>矩阵乘（<code>##</code>）与数组乘类似，区别是行乘以列。</p></blockquote><ul><li>其它运算符</li></ul><blockquote><p>圆括号<code>()</code>用来对表达式进行组合或一系列表达式控制优先级。</p><p>方括号<code>[]</code>用来数组连接或对数组进行元素调用。</p><p>条件运算符是<code>？:</code>，<code>value = expr1 ? expr2 : expr3</code> 如果 <code>expr1</code> 是 <code>true</code>，那么 <code>value</code> 等于 <code>expr2</code> ，否则 <code>value</code> &#x3D;等于<code>expr3</code>。</p><p>对象方法调用符<code>.</code>或<code>-&gt;</code>两种，对象可以通过这两种符号来调用相关的方法。</p><p>指针调用符为<code>*</code>，引用格式为<code>*指针变量名</code>。</p></blockquote><ul><li>运算符优先级</li></ul><table><thead><tr><th align="center">优先级</th><th align="left">操作符</th></tr></thead><tbody><tr><td align="center">一级（最高）</td><td align="left"><code>()</code> (公式表达式)<br /><code>[]</code> (数组连接)</td></tr><tr><td align="center">二级</td><td align="left"><code>.</code> (结构体域表达式)<br /><code>[]</code> (数组元素调用)<br /><code>()</code> (函数引用)</td></tr><tr><td align="center">三级</td><td align="left"><code>*</code> (指针调用)<br /><code>^</code> (幂函数)<br /><code>++</code> (增函数)<br /><code>--</code> (减函数)</td></tr><tr><td align="center">四级</td><td align="left"><code>*</code> (乘)<br /><code>#</code> 和 <code>##</code> (矩阵乘)<br /><code>/</code>(除)<br /><code>MOD</code> (取余数)</td></tr><tr><td align="center">五级</td><td align="left"><code>+</code> (加)<br /><code>-</code> (减和取反)<br /><code>&lt;</code> (求小)<br /><code>&gt;</code> (求大)<br /><code>NOT</code> (位取反)<br /><code>~</code> (逻辑取反)</td></tr><tr><td align="center">六级</td><td align="left"><code>EQ</code> (等于) <br/><code>NE</code> (不等于)<br /><code>LE</code> (小于等于) <br/><code>LT</code> (小于) <br/><code>GE</code> (大于等于) <br/><code>GT</code> (大于)</td></tr><tr><td align="center">七级</td><td align="left"><code>AND</code> (位与) <br/><code>OR</code> (位或) <br/><code>XOR</code> (位异或)</td></tr><tr><td align="center">八级</td><td align="left"><code>&amp;&amp;</code> (逻辑与)</td></tr><tr><td align="center">九级</td><td align="left"><code>?:</code> (条件表达式)</td></tr></tbody></table><h3 id="👀其他符号"><a href="#👀其他符号" class="headerlink" title="👀其他符号"></a>👀其他符号</h3><p><code>$</code>续行符：续行符主要应用在一条语句过长或参数过多时进行格式化显示；</p><p><code>&amp;</code>同行符：使用了同行符相当于两行代码写在一行之中；</p><p><code>;</code>注释符：此符号之后的该行所有代码都将看做是注释，不参与编译运行。</p><p>笔者不才，请多交流！！！</p>]]></content>
      
      
      <categories>
          
          <category> IDL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ENVI </tag>
            
            <tag> IDL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python异常处理-模块Model/Package-文件处理</title>
      <link href="/2022/09/25/Ex-Model-File/"/>
      <url>/2022/09/25/Ex-Model-File/</url>
      
        <content type="html"><![CDATA[<h2 id="⛄异常处理"><a href="#⛄异常处理" class="headerlink" title="⛄异常处理"></a>⛄异常处理</h2><p>编写计算机程序时，通常能够区分<strong>正常</strong>和<strong>异常</strong>（不正常）情况。异常事件可能是错误（如试图除以零），也可能是通常不会发生的事情。为处理这些异常事件，可在每个可能发生这些事件的地方都使用条件语句。例如，对于每个除法运算，都检查除数是否为零。然而，这样做不仅效率低下、缺乏灵活性，还可能导致程序难以卒读。你可能很想忽略这些异常事件，希望它们不会发生，但<code>Python</code>提供功能强大的替代解决方案——异常处理机制。</p><p><code>Python</code>使用异常对象来表示异常状态，并在遇到错误时引发异常。异常对象未被处理（或捕获）时，程序将终止并显示一条错误消息（<code>traceback</code>）。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">1</span>]:<span class="number">1</span>/<span class="number">0</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;ipython-input-2-9e1622b385b6&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    <span class="number">1</span>/<span class="number">0</span></span><br><span class="line">ZeroDivisionError: division by zero</span><br></pre></td></tr></table></figure><p>如果异常只能用来显示错误消息，就没多大意思了。但事实上，每个异常都是某个类的实例。你能以各种方式引发和捕获这些实例，从而逮住错误并采取措施，而不是放任整个程序失败。</p><h3 id="👀异常的概念"><a href="#👀异常的概念" class="headerlink" title="👀异常的概念"></a>👀异常的概念</h3><ul><li>程序在运行时，如果<code>Python解释器</code>遇到到一个错误，会停止程序的执行，并且提示一些错误信息，这就是<strong>异常</strong>。</li><li>程序停止执行并且提示错误信息这个动作，我们通常称之为：<strong>抛出(<code>raise</code>)异常</strong>。</li></ul><blockquote><p>程序开发时，很难将所有的特殊情况，都处理的面面俱到，通过<strong>异常捕获</strong>可以针对突发事件做集中的处理，从而保证程序的<strong>稳定性和健壮性</strong>。</p></blockquote><h3 id="👀捕获异常"><a href="#👀捕获异常" class="headerlink" title="👀捕获异常"></a>👀捕获异常</h3><p>（1）简单的捕获异常语法</p><p>在程序开发中，如果对某些代码的执行不能确定是否正确，可以增加<code>try(尝试)</code>来<strong>捕获异常</strong>。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 捕获异常最简单的语法格式</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line"><span class="comment"># 尝试执行的代码</span></span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line"><span class="comment"># 出现错误的处理</span></span><br></pre></td></tr></table></figure><ul><li><code>try</code>尝试，下方编写要尝试代码，不确定是否能够正常执行的代码。</li><li><code>except</code>如果不是，下方编写尝试失败的代码。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># 提示用户输入一个数字</span></span><br><span class="line">    num = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入数字：&quot;</span>))</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;请输入正确的数字&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果样例</span></span><br><span class="line">请输入数字：<span class="number">1</span></span><br><span class="line"></span><br><span class="line">请输入数字：a</span><br><span class="line">请输入正确的数字</span><br></pre></td></tr></table></figure><p>（2）错误类型捕获及完整语法</p><p>在程序执行时，可能会遇到<strong>不同类型的异常</strong>，并且需要<strong>针对不同类型的异常</strong>，<strong>做出不同的响应</strong>，这个时候，就需要捕获错误类型了。</p><p><strong>捕获未知错误</strong></p><ul><li>在开发时，<strong>要预判到所有可能出现的错误</strong>，还是有一定难度的。</li><li>如果希望程序<strong>无论出现任何错误</strong>，都不会因为<code>Python解释器</code><strong>抛出异常而被终止</strong>，可以再增加一个<code>except</code>。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 语法</span></span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> result:</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;未知错误%s&quot;</span>%result)</span><br></pre></td></tr></table></figure><p>异常捕获完整语法：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 语法</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># 尝试执行的代码</span></span><br><span class="line">    <span class="keyword">pass</span> </span><br><span class="line"><span class="keyword">except</span> 错误类型<span class="number">1</span>:</span><br><span class="line">    <span class="comment"># 针对错误类型1,对应的代码处理</span></span><br><span class="line">    <span class="keyword">pass</span> </span><br><span class="line"><span class="keyword">except</span>(错误类型<span class="number">2</span>, 错误类型<span class="number">3</span>):</span><br><span class="line">    <span class="comment"># 针对错误类型2和3,对应的代码处理</span></span><br><span class="line">    <span class="keyword">pass</span> </span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> result:</span><br><span class="line">    <span class="comment"># 捕获未知错误</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;未知错误%s&quot;</span>%result)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="comment"># 只有没有异常时才会执行的代码</span></span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="comment"># 无论是否有异常，都会执行的代码</span></span><br></pre></td></tr></table></figure><p>完整捕获异常的例子：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># 提示用户输入一个数字</span></span><br><span class="line">    num = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入数字：&quot;</span>))</span><br><span class="line">    result = <span class="number">8</span> / num</span><br><span class="line">    <span class="built_in">print</span>(result)</span><br><span class="line"><span class="keyword">except</span> ValueError:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;请输入正确的数字&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> ZeroDivisionError:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;除0错误&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> result:</span><br><span class="line">    <span class="comment"># 捕获未知错误</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;未知错误%s&quot;</span>%result)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;正常执行&quot;</span>)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;执行完成，但是不保证正确&quot;</span>)   </span><br></pre></td></tr></table></figure><h3 id="👀异常的传递"><a href="#👀异常的传递" class="headerlink" title="👀异常的传递"></a>👀异常的传递</h3><ul><li><strong>异常的传递</strong>——当<strong>函数&#x2F;方法</strong>执行<strong>出现异常</strong>，会将异常传递给函数&#x2F;方法的调用一方；</li><li>如果<strong>传递到主程序</strong>，仍然<strong>没有异常处理</strong>，程序才会被终止。</li></ul><blockquote><ul><li>在开发中，可以在<strong>主函数</strong>中增加<strong>异常捕获</strong>；</li><li>而在主函数中调用的其他函数，只要出现异常，都会传递到主函数的<strong>异常捕获</strong>中；</li><li>这样就不需要在代码中，增加大量的<strong>异常捕获</strong>，能够保证代码的整洁和健壮性。</li></ul></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">demo1</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入一个整数：&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">demo2</span>():</span><br><span class="line">    <span class="keyword">return</span> demo1()</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">print</span>(demo2())</span><br><span class="line"><span class="keyword">except</span> ValueError:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;请输入正确的数字&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> result:</span><br><span class="line">    <span class="comment"># 捕获未知错误</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;未知错误%s&quot;</span>%result)</span><br></pre></td></tr></table></figure><h3 id="👀抛出raise异常"><a href="#👀抛出raise异常" class="headerlink" title="👀抛出raise异常"></a>👀抛出<code>raise</code>异常</h3><p><strong>应用场景</strong></p><ul><li>在开发中，除了<strong>代码执行出错</strong><code>Python解释器</code>会抛出异常之外；</li><li>还可以根据应用程序特有的业务需求<strong>主动抛出异常</strong>。</li></ul><p><strong>示例</strong></p><ul><li>提示用户输入密码，如果长度少于8，抛出异常。</li></ul><p><strong>注意</strong></p><ul><li>当前函数只负责提示用户输入密码，如果密码长度不正确，需要其他的函数进行额外处理；</li><li>因此可以<strong>抛出异常</strong>，由其他需要处理的函数<strong>捕获异常</strong>。</li></ul><p><strong>抛出异常</strong></p><ul><li><p><code>Python</code>中提供了一个<code>Exception</code> 异常类。</p></li><li><p>在开发时，如果满足<strong>特定业务需求</strong>时，希望抛出异常，可以：</p><ul><li><p>创建一个<code>Exception</code>的对象</p></li><li><p>使用<code>raise</code>关键字抛出异常对象</p></li></ul></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">input_passward</span>():</span><br><span class="line">    <span class="comment"># 提示输入密码</span></span><br><span class="line">    pwd = <span class="built_in">input</span>(<span class="string">&quot;请输入密码：&quot;</span>)</span><br><span class="line">    <span class="comment"># 判断，如果密码长度≥8，返回用户输入的密码</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(pwd) &gt;= <span class="number">8</span>:</span><br><span class="line">        <span class="keyword">return</span> pwd</span><br><span class="line">    <span class="comment"># 如果密码长度&lt;8，主动抛出异常</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;主动抛出异常&quot;</span>)</span><br><span class="line">    <span class="comment"># 1.创建异常对象，可以使用错误信息字符串作为参数</span></span><br><span class="line">    ex = Exception(<span class="string">&quot;密码长度不够&quot;</span>)</span><br><span class="line">    <span class="comment"># 2.抛出异常</span></span><br><span class="line">    <span class="keyword">raise</span> ex</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">print</span>(input_passward())</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> result:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;异常为:%s&quot;</span> % result)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果样例</span></span><br><span class="line">请输入密码：<span class="number">123</span></span><br><span class="line">主动抛出异常</span><br><span class="line">异常为:密码长度不够</span><br></pre></td></tr></table></figure><h2 id="⛄模块和包-Package"><a href="#⛄模块和包-Package" class="headerlink" title="⛄模块和包(Package)"></a>⛄模块和包(Package)</h2><h3 id="👀模块"><a href="#👀模块" class="headerlink" title="👀模块"></a>👀模块</h3><p>（1）模块的概念</p><p>模块是<code>Python</code>程序架构的一个核心概念</p><ul><li>每一个以扩展名<code>py</code>结尾的<code>Python</code>源代码文件都是一个<strong>模块</strong>，文件名就是<strong>模块名</strong>；</li><li><strong>模块名</strong>同样也是一个标识符，需要符合标识符的命名规则(字母、数字、下划线，不能以数字开头)；</li><li>在模块中定义的<strong>全局变量</strong>、<strong>函数</strong>、<strong>类</strong>都是提供给外界直接使用的工具；</li><li><strong>模块</strong>就好比是<strong>工具包</strong>，要想使用这个工具包中的工具，就需要先<strong>导入</strong>这个模块。</li></ul><p>（2）模块导入方式</p><p>① <code>import</code>导入</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> 模块名<span class="number">1</span>, 模块名<span class="number">2</span></span><br></pre></td></tr></table></figure><blockquote><p>提示：在导入模块时，<code>PEP8</code>建议每个导入应该独占一行</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> 模块名<span class="number">1</span></span><br><span class="line"><span class="keyword">import</span> 模块名<span class="number">2</span></span><br></pre></td></tr></table></figure><p>导入之后，通过<code>模块名.</code>使用模块提供的工具–全局变量、函数、类。如果模块的名字太长，可以使用<code>as</code>指定模块的名称，以方便在代码中的使用。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> 模块名 <span class="keyword">as</span> 模块别名</span><br></pre></td></tr></table></figure><blockquote><p>注意：<strong>模块别名</strong>应该符合<strong>大驼峰命名法</strong></p></blockquote><p>② <code>from..import</code>导入</p><ul><li>如果希望从某一个模块中，导入部分工具，就可以使用<code>from..import</code>的方式；</li><li><code>import 模块名</code>是<strong>一次性</strong>把模块中<strong>所有工具全部导入</strong>，并且通过<strong>模块名&#x2F;别名</strong>访问。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 从模块导入某一个工具</span></span><br><span class="line"><span class="keyword">from</span> 模块名<span class="number">1</span> <span class="keyword">import</span> 工具名</span><br></pre></td></tr></table></figure><p>导入之后</p><ul><li>不需要通过<code>模块名.</code>；</li><li>可以直接使用<code>模块提供的工具</code>——全局变量、函数、类。</li></ul><p>注意</p><p>如果两个模块，存在<strong>同名的函数</strong>，那么<strong>后导入模块的函数</strong>，会<strong>覆盖掉先导入的函数</strong>。</p><ul><li>开发时<code>import</code>代码应该统一写在<strong>代码的顶部</strong>，更容易及时发现冲突；</li><li>一旦发现冲突，可以使用<code>as</code>关键字<strong>给其中一个工具起一个别名</strong>。</li></ul><p>③ <code>from...import *</code> (知道)</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 从模块导入所有工具</span></span><br><span class="line"><span class="keyword">from</span> 模块名<span class="number">1</span> <span class="keyword">import</span> *</span><br></pre></td></tr></table></figure><blockquote><p>注意：这种方式不推荐使用，不需要通过<code>模块名.</code>调用，因为函数重名并没有任何提示，出现问题不好排查。</p></blockquote><p>（3）模块的搜索顺序</p><p><code>Python</code>的解释器在导入模块时，会：</p><ul><li>搜索<strong>当前目录</strong>指定模块名的文件，如果有就直接导入；</li><li>如果没有，再搜索<strong>系统目录</strong>。</li></ul><blockquote><p>在开发时，给文件起名，不要和系统的模块文件重名</p></blockquote><p><code>Python</code>中每一个模块都有一个内置属性<code>__file__</code>可以查看模块的<strong>完整路径</strong>。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="comment"># 生成一个0~18的数字</span></span><br><span class="line">rand = random.randint(e,<span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(rand)</span><br></pre></td></tr></table></figure><blockquote><p>注意：如果当前目录下，存在一个<code>random.py</code>的文件，程序就无法正常执行了！这个时候，<code>Python</code>的解释器会加载当前目录下的<code>random.py</code>而不会加载系统的<code>random</code>模块。</p></blockquote><p>（4）每一个文件都应该是可以被导入的</p><ul><li>一个独立的<code>Python</code>文件就是一个<strong>模块</strong>；</li><li>在导入文件时，文件中<strong>所有没有任何缩进的代码</strong>都会被执行一遍！</li></ul><p>实际开发场景</p><ul><li>在实际开发中，每一个模块都是独立开发的，大多都有专人负责；</li><li>开发人员通常会在模块下方增加一些<strong>测试代码</strong>，仅在模块内使用，而被导入到其他文件中不需要执行。</li></ul><p><code>__name__</code>属性</p><ul><li><code>__name__</code>属性可以做到，测试模块的代码<strong>只在测试情况下被运行</strong>，而在被<strong>导入时不会被执行</strong>！</li><li><code>__name__</code>是<code>Python</code>的一个内置属性，记录着一个字符串；</li><li>如果是被其他文件导入的，<code>__name__</code>就是模块名；</li><li>如果是当前执行的程序，<code>__name__</code>是<code>__main__</code>。</li></ul><p>​    在很多<code>Python</code>文件中都会看到以下格式的代码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 导入模块</span></span><br><span class="line"><span class="comment"># 定义全局变量</span></span><br><span class="line"><span class="comment"># 定义类</span></span><br><span class="line"><span class="comment"># 定义函数</span></span><br><span class="line">        </span><br><span class="line"><span class="comment"># 在代码的最下方</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line"><span class="comment">#...</span></span><br><span class="line"><span class="keyword">pass</span></span><br><span class="line"><span class="comment"># 根据_name判断是否执行下方代码</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">main()</span><br></pre></td></tr></table></figure><h3 id="👀包-Package"><a href="#👀包-Package" class="headerlink" title="👀包(Package)"></a>👀包(<code>Package</code>)</h3><ul><li><strong>包</strong>是一个<strong>包含多个模块</strong>的<strong>特殊目录</strong>；</li><li>目录下有一个<strong>特殊的文件</strong><code>__init__.py</code>；</li><li>包名的<strong>命名方式</strong>和变量名一致，小写字母、下划线等。</li></ul><blockquote><p>好处：使用<code>import 包名</code>可以一次性导入包中所有的模块。</p></blockquote><p> <code>__init__.py</code>，要在外界使用包中的模块，需要在<code>__init__.py</code>中指定对外界提供的模块列表。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 从当前目录导入模块列表</span></span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> 模块名<span class="number">1</span></span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> 模块名<span class="number">2</span></span><br></pre></td></tr></table></figure><h2 id="⛄文件处理"><a href="#⛄文件处理" class="headerlink" title="⛄文件处理"></a>⛄文件处理</h2><h3 id="👀文件的概念"><a href="#👀文件的概念" class="headerlink" title="👀文件的概念"></a>👀文件的概念</h3><ul><li>计算机的文件，就是存储在某种长期储存设备上的一段数据。</li><li>文件的存储方式：是以二进制的方式保存在磁盘上。</li></ul><h3 id="👀文件的基本操作"><a href="#👀文件的基本操作" class="headerlink" title="👀文件的基本操作"></a>👀文件的基本操作</h3><p>文本文件和二进制文件，在计算机中操作文件的套路非常固定，一共包含三个步骤：</p><ul><li><p>打开文件</p></li><li><p>读、写文件</p><ul><li><p>读，将文件内容读入内存</p></li><li><p>写，将内存内容写入文件</p></li></ul></li><li><p>关闭文件</p></li></ul><p>在<code>Python</code>中要操作文件需要记住1个函数和3个方法</p><table><thead><tr><th>序号</th><th>函数&#x2F;方法</th><th>说明</th></tr></thead><tbody><tr><td>01</td><td><code>open</code></td><td>打开文件，并且返回文件操作对象</td></tr><tr><td>02</td><td><code>read</code></td><td>将文件内容读取到内存</td></tr><tr><td>03</td><td><code>write</code></td><td>将指定内容写入文件</td></tr><tr><td>04</td><td><code>close</code></td><td>关闭文件</td></tr></tbody></table><blockquote><p><code>open</code>函数负责打开文件，并且返回文件对象；</p><p><code>read</code>&#x2F;<code>write</code>&#x2F;<code>close</code>三个方法都需要通过<strong>文件对象</strong>调用。</p></blockquote><h3 id="👀read-方法"><a href="#👀read-方法" class="headerlink" title="👀read()方法"></a>👀<code>read()</code>方法</h3><ul><li><p><code>open</code>函数的第一个参数是要打开的文件名(文件名区分大小写)。</p><ul><li><p>如果文件<strong>存在</strong>，返回文件操作对象；</p></li><li><p>如果文件<strong>不存在</strong>，会抛出异常。</p></li></ul></li><li><p><code>read</code>方法可以一次性<strong>读入</strong>并<strong>返回</strong>文件的<strong>所有内容</strong>。</p></li><li><p><code>close</code>方法负责<strong>关闭文件</strong>。</p><ul><li>如果忘记关闭文件，会造成系统资源消耗，而且会影响到后续对文件的访问。</li></ul></li><li><p>注意：<code>read</code>方法执行后，会把<strong>文件指针</strong>移动到<strong>文件的末尾</strong>。</p></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1.打开-文件名需要注意大小写</span></span><br><span class="line">file = <span class="built_in">open</span>(<span class="string">&quot;README&quot;</span>)</span><br><span class="line"><span class="comment"># 2.读取</span></span><br><span class="line">text = file.read()</span><br><span class="line"><span class="built_in">print</span>(text)</span><br><span class="line"><span class="comment"># 3.关闭</span></span><br><span class="line">file.close()</span><br></pre></td></tr></table></figure><blockquote><p>提示：在开发中，通常会先编写打开和关闭的代码，再编写中间针对文件的读&#x2F;写操作！使用 <code>with</code> 关键字系统会自动调用 <code>f.close()</code> 方法， <code>with</code> 的作用等效于 <code>try/finally</code> 语句是一样的。</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 打开文件</span></span><br><span class="line">filename=<span class="built_in">open</span>(<span class="string">&quot;file.txt&quot;</span>)</span><br><span class="line"><span class="comment"># 读取文件内容</span></span><br><span class="line">text = filename.read()</span><br><span class="line"><span class="built_in">print</span>(text)</span><br><span class="line"><span class="comment"># 如果执行了一次read方法,读取了所有内容,那么再次调用read方法,还能够获得到内容吗？读取不到</span></span><br><span class="line"><span class="comment"># 当执行了read方法后,文件指针会移动到读取内容的末尾</span></span><br><span class="line">text1 = filename.read()</span><br><span class="line"><span class="built_in">print</span>(text1)</span><br><span class="line"><span class="comment"># 关闭文件</span></span><br><span class="line">filename.close()</span><br></pre></td></tr></table></figure><p>文件指针（知道）</p><ul><li><strong>文件指针</strong>标记<strong>从哪个位置开始读取数据</strong>；</li><li><strong>第一次打开</strong>文件时，通常<strong>文件指针会指向文件的开始位置</strong>；</li><li>当执行了<code>read</code>方法后，<strong>文件指针</strong>会移动到<strong>读取内容的末尾</strong>；<ul><li>默认情况下会移动到<strong>文件末尾</strong>。</li></ul></li></ul><blockquote><p>思考：</p><p>如果执行了一次<code>read</code>方法，读取了所有内容，那么再次调用<code>read</code>方法，还能够获得到内容吗？</p><p>不能，第一次读取之后，文件指针移动到了文件末尾，再次调用不会读取到任何的内容。</p></blockquote><h3 id="👀打开文件的方式"><a href="#👀打开文件的方式" class="headerlink" title="👀打开文件的方式"></a>👀打开文件的方式</h3><p><code>open</code>函数默认以只读方式打开文件，并且返回文件对象语法如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;文件名&quot;</span>,<span class="string">&quot;访问方式&quot;</span>)</span><br></pre></td></tr></table></figure><p>访问方式说明</p><table><thead><tr><th align="center">访问方式</th><th align="left">说明</th></tr></thead><tbody><tr><td align="center"><code>r</code></td><td align="left">以只读方式打开文件。<br />文件的指针将会放在文件的开头，这是默认模式。如果文件不存在，抛出异常。</td></tr><tr><td align="center"><code>w</code></td><td align="left">以只写方式打开文件。<br />如果文件存在会被覆盖。如果文件不存在，创建新文件。</td></tr><tr><td align="center"><code>a</code></td><td align="left">以追加方式打开文件。<br />如果该文件已存在，文件指针将会放在文件的结尾。如果文件不存在，创建新文件进行写入。</td></tr><tr><td align="center"><code>r+</code></td><td align="left">以读写方式打开文件。<br />文件的指针将会放在文件的开头。如果文件不存在，抛出异常。</td></tr><tr><td align="center"><code>w+</code></td><td align="left">以读写方式打开文件。<br />如果文件存在会被覆盖。如果文件不存在，创建新文件。</td></tr><tr><td align="center"><code>a+</code></td><td align="left">以读写方式打开文件。<br />如果该文件已存在，文件指针将会放在文件的结尾。如果文件不存在，创建新文件进行写入。</td></tr></tbody></table><blockquote><p>提示：频繁的移动文件指针，会影响文件的读写效率，开发中更多会以只读、只写的方式来操作文件。</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 写入文件</span></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;README&quot;</span>, <span class="string">&quot;w&quot;</span>)</span><br><span class="line"></span><br><span class="line">f.write(<span class="string">&quot;hello python \n&quot;</span>)</span><br><span class="line">f.write(<span class="string">&quot;我是谁&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭文件</span></span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure><h3 id="👀按行读取文件内容"><a href="#👀按行读取文件内容" class="headerlink" title="👀按行读取文件内容"></a>👀按行读取文件内容</h3><ul><li><code>read</code>方法默认会把文件的<strong>所有内容一次性读取到内存</strong>；</li><li>如果文件太大，对内存的占用会非常严重。</li></ul><p><code>readline</code>方法</p><ul><li><code>readline</code>方法可以一次读取一行内容；</li><li>方法执行后，会把文件指针移动到下一行，准备再次读取。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 读取大文件的正确方法</span></span><br><span class="line"><span class="comment"># 打开文件</span></span><br><span class="line">file=<span class="built_in">open</span>(<span class="string">&quot;README&quot;</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="comment"># 读取一行内容</span></span><br><span class="line">    text=file.readline()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 判断是否读到内容</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> text:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment"># 每读取一行的末尾已经有了一个&#x27;\n&#x27;</span></span><br><span class="line">    <span class="built_in">print</span>(text,end=<span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="comment"># 关闭文件</span></span><br><span class="line">file.close()</span><br></pre></td></tr></table></figure><h3 id="👀文件-x2F-目录常用管理操作os"><a href="#👀文件-x2F-目录常用管理操作os" class="headerlink" title="👀文件&#x2F;目录常用管理操作os"></a>👀文件&#x2F;目录常用管理操作<code>os</code></h3><ul><li>在<strong>终端&#x2F;文件浏览器</strong>中可以执行常规的<strong>文件&#x2F;目录</strong>管理操作，例如：<ul><li>创建、重命名、删除、改变路径、查看目录内容、……</li></ul></li><li>在<code>Python</code>中，如果希望通过程序实现上述功能，需要导入<code>os</code>模块。</li></ul><p>文件操作</p><table><thead><tr><th align="center">序号</th><th>方法名</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td align="center">01</td><td><code>rename</code></td><td>重命名文件</td><td><code>os.rename(源文件名，目标文件名)</code></td></tr><tr><td align="center">02</td><td><code>remove</code></td><td>删除文件</td><td><code>os.remove(文件名)</code></td></tr></tbody></table><p>目录操作</p><table><thead><tr><th align="center">序号</th><th>方法名</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td align="center">01</td><td><code>listdir</code></td><td>目录列表</td><td><code>os.listdir(目录名)</code></td></tr><tr><td align="center">02</td><td><code>mkdir</code></td><td>创建目录</td><td><code>os.mkdir(目录名)</code></td></tr><tr><td align="center">03</td><td><code>rmdir</code></td><td>删除目录</td><td><code>os.rmdir(目录名)</code></td></tr><tr><td align="center">04</td><td><code>getcwd</code></td><td>获取当前目录</td><td><code>os.getcwd()</code></td></tr><tr><td align="center">05</td><td><code>chdir</code></td><td>修改工作目录</td><td><code>os.chdir(目标目录)</code></td></tr><tr><td align="center">06</td><td><code>path.isdir</code></td><td>判断是否是文件</td><td><code>os.path.isdir(文件路径)</code></td></tr></tbody></table><blockquote><p>提示：文件或者目录操作都支持<strong>相对路径</strong>和<strong>绝对路径</strong>。其他操作，可以具体了解<code>os</code>模块详细内容。</p></blockquote><p>文本文件的编码格式（科普）。文本文件存储的内容是基于字符编码的文件,常见的编码有<code>ASCII</code>编码，<code>UNICODE</code>编码等。</p><ul><li><code>Python 2.x</code>默认使用<code>ASCII</code>编码</li><li><code>Python 3.x</code>默认使用<code>UTF-8</code>编码</li></ul><p><code>unicode</code>字符串</p><ul><li>在<code>Python2.x</code>中，即使指定了文件使用<code>UTF-8</code>的编码格式，但是在遍历字符时，仍然会以字节为单位遍历字符串；</li><li>要能够正确的遍历字符串，在定义字符串时，需要在字符串的引号前，增加一个小写字母<code>u</code>，告诉解释器这是一个<code>unicode</code>字符串(使用<code>UTF-8</code>编码格式的字符串)。</li></ul><h2 id="⛄eval-函数"><a href="#⛄eval-函数" class="headerlink" title="⛄eval()函数"></a>⛄<code>eval()</code>函数</h2><p><code>eval()</code>函数十分强大，将<strong>字符串</strong>当成<strong>有效的表达式</strong>来求值并<strong>返回计算结果</strong>，但是不能滥用。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 基本的数学计算</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">eval</span>(<span class="string">&quot;1+1&quot;</span>))</span><br><span class="line"><span class="comment"># 字符串重复</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">eval</span>(<span class="string">&quot;&#x27;*&#x27;*10&quot;</span>))</span><br><span class="line"><span class="comment"># 将字符串转换成列表</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="built_in">eval</span>(<span class="string">&quot;[1,2,3,4,5]&quot;</span>)))</span><br><span class="line"><span class="comment"># 将字符串转换成字典</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="built_in">eval</span>(<span class="string">&quot;&#123;&#x27;name&#x27;:&#x27;xiaoming&#x27;,&#x27;age&#x27;:18&#125;&quot;</span>)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line">**********</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;list&#x27;</span>&gt;</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;dict&#x27;</span>&gt;</span><br></pre></td></tr></table></figure><p>笔者不才，请多交流！！！</p><p>参考文献：黑马程序员《<code>Python</code>入门教程完整版》</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Python基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python面向对象详解</title>
      <link href="/2022/09/18/Python-OOP/"/>
      <url>/2022/09/18/Python-OOP/</url>
      
        <content type="html"><![CDATA[<h2 id="⛄面向对象基本概念"><a href="#⛄面向对象基本概念" class="headerlink" title="⛄面向对象基本概念"></a>⛄面向对象基本概念</h2><p>面向过程和面向对象，是两种不同的编程方式。</p><h3 id="👀面向过程"><a href="#👀面向过程" class="headerlink" title="👀面向过程"></a>👀面向过程</h3><ol><li>把完成某一个需求的所有步骤，<strong>从头到尾</strong>逐步实现；</li><li>根据开发需求，将某些功能独立的代码封装成一个又一个函数；</li><li>最后完成的代码，就是<strong>顺序</strong>地调用不同的函数。</li></ol><p>特点：</p><ul><li>注重<strong>步骤与过程</strong>，不注重职责分工；</li><li>如果需求复杂，代码会变得很复杂；</li><li>开发复杂项目，没有固定的套路，开发难度很大！</li></ul><h3 id="👀面向对象"><a href="#👀面向对象" class="headerlink" title="👀面向对象"></a>👀面向对象</h3><p>相比较函数，面向对象是更大的封装，根据职责在一个对象中封装多个方法。</p><ol><li>在完成某一个需求前，首先确定<strong>职责</strong>——<strong>要做的事情（方法）</strong>；</li><li>根据<strong>职责</strong>确定不同的<strong>对象</strong>，在<strong>对象</strong>内部封装不同的<strong>方法</strong>（多个）；</li><li>最后完成的代码，就是顺序地让<strong>不同的对象</strong>调用<strong>不同的方法</strong>。</li></ol><p>特点</p><ul><li>注重<strong>对象和职责</strong>，不同的对象承担不同的职责；</li><li>更加适合应对复杂的需求变化，是专门应对复杂项目开发，提供的固定套路；</li><li>需要在面向过程基础上，再学习一些面向对象的语法。</li></ul><h2 id="⛄类和对象"><a href="#⛄类和对象" class="headerlink" title="⛄类和对象"></a>⛄类和对象</h2><h3 id="👀类和对象的概念"><a href="#👀类和对象的概念" class="headerlink" title="👀类和对象的概念"></a>👀类和对象的概念</h3><p>类和对象是面向对象编程的两个核心概念。</p><p>（1）类</p><ol><li><p><strong>类</strong>是对一群具有<strong>相同特征</strong>或者<strong>行为</strong>的事物的一个统称，是抽象的，不能直接使用。</p><ul><li><p><strong>特征</strong>被称为<strong>属性</strong>；</p></li><li><p><strong>行为</strong>被称为<strong>方法</strong>；</p></li></ul></li><li><p><strong>类</strong>就相当于制造飞机时的图纸，是一个模板，是<strong>负责创建对象</strong>的</p></li></ol><p>（2）对象</p><ol><li><p><strong>对象</strong>是<strong>由类创建出来的一个具体存在</strong>，可以直接使用。</p></li><li><p>由<strong>哪一个类</strong>创建出来的<strong>对象</strong>，就拥有在<strong>哪一个类</strong>中定义的：</p><ul><li><p>属性</p></li><li><p>方法</p></li></ul></li><li><p><strong>对象</strong>就相当于用图纸制造的飞机。在程序开发中，应该<strong>先有类</strong>，<strong>再有对象</strong>。</p></li></ol><p>（3）类和对象的关系</p><ol><li><strong>类是模板</strong>，对象是根据类这个模板创建出来的，应该<strong>先有类</strong>，<strong>再有对象</strong>。</li><li>类只有一个，而对象可以有很多个<ul><li><strong>不同的对象</strong>之间<strong>属性</strong>可能会各不相同</li></ul></li><li><strong>类</strong>中定义了什么属性和方法，对象中就有什么属性和方法，不可能多，也不可能少。</li></ol><h3 id="👀类的设计"><a href="#👀类的设计" class="headerlink" title="👀类的设计"></a>👀类的设计</h3><p>在程序开发中，要设计一个类，通常需要满足一下三个要素：</p><ol><li><strong>类名</strong>这类事物的名字，满足<strong>大驼峰命名法</strong>；</li><li><strong>属性</strong>这类事物具有什么样的特征；</li><li><strong>方法</strong>这类事物具有什么样的行为。</li></ol><blockquote><p>大驼峰命名法：HelloWorld，每一个单词的首字母大写；单词与单词之间没有下划线。</p></blockquote><p>（1）类名的确定</p><p>名词提炼法分析整个业务流程，出现的名词，通常就是找到的类。</p><p>（2）属性和方法的确定</p><ul><li><strong>对象的特征描述</strong>，通常可以定义成<strong>属性</strong>；</li><li><strong>对象具有的行为</strong>（<strong>动词</strong>），通常可以定义成<strong>方法</strong>。</li></ul><blockquote><p>提示：需求中没有涉及的属性或者方法在设计类时，不需要考虑。</p></blockquote><h2 id="⛄面向对象基础语法"><a href="#⛄面向对象基础语法" class="headerlink" title="⛄面向对象基础语法"></a>⛄面向对象基础语法</h2><h3 id="👀dir-内置函数"><a href="#👀dir-内置函数" class="headerlink" title="👀dir()内置函数"></a>👀dir()内置函数</h3><p>在<code>Python</code>中对象几乎是无所不在的，我们之前学习的<strong>变量</strong>、<strong>数据</strong>、<strong>函数</strong>都是对象。</p><p>在<code>Python</code>中可以使用以下两个方法验证：</p><ol><li>在<strong>标识符&#x2F;数据</strong>后输入一个<code>.</code>，然后按下<code>TAB</code>键，<code>ipython</code>会提示该对象能够调用的<strong>方法列表</strong>。</li><li>使用内置函数<code>dir()</code>传入<strong>标识符&#x2F;数据</strong>，可以查看对象内的<strong>所有属性及方法</strong>。</li></ol><blockquote><p>提示：<code>__方法名__</code>格式的方法是<code>Python</code> 提供的<strong>内置方法&#x2F;属性</strong>。</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">__new__|方法|创建对象时，会被自动调用</span><br><span class="line">__init__|方法|对象被初始化时，会被自动调用</span><br><span class="line">__del__|方法|对象被从内存中销毁前，会被自动调用</span><br><span class="line">__str__|方法|返回对象的描述信息，<span class="built_in">print</span>函数输出使用</span><br></pre></td></tr></table></figure><h3 id="👀定义简单的类"><a href="#👀定义简单的类" class="headerlink" title="👀定义简单的类"></a>👀定义简单的类</h3><p>面向对象是更大的封装，在一个类中封装多个方法，这样通过这个类创建出来的对象，就可以直接调用这些方法了！！</p><p>（1）定义只包含方法的类</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 类名的命名格式符合大驼峰命名法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">类名</span>：</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">方法1</span>(<span class="params">self, 参数列表</span>)：</span><br><span class="line">      <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">方法2</span>(<span class="params">self, 参数列表</span>)：</span><br><span class="line">      <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>方法的定义格式和之前学习过的函数几乎一样；区别在于第一个参数必须是<code>self</code>。</p><p>（2）创建对象</p><p>当一个类定义完成之后，要使用这个类来创建对象：</p><p><code>对象变量 = 类名（）</code></p><h3 id="👀self的使用"><a href="#👀self的使用" class="headerlink" title="👀self的使用"></a>👀<code>self</code>的使用</h3><p>在<code>Python</code>中，给对象设置属性，只需要在类的外部的代码中直接通过<code>.</code>设置一个属性即可（这种方式虽然简单，但是不推荐使用）。</p><ul><li>在类封装的方法内部，<code>self</code>就表示当前调用方法的对象自己；</li><li>由哪一个对象调用的方法，方法内的<code>self</code>就是哪一个对象的引用；</li><li>调用方法时，程序员不需要传递<code>self</code>参数；</li><li>在方法内部，可以通过<code>self.</code>访问对象的属性，可以通过<code>self.</code>调用其它对象方法；</li></ul><blockquote><p>在类的外部，通过<code>变量名.</code>访问对象的属性和方法；</p><p>在类封装的方法中，通过<code>self.</code>访问对象的属性和方法。</p></blockquote><h3 id="👀-init-方法"><a href="#👀-init-方法" class="headerlink" title="👀__init__方法"></a>👀<code>__init__</code>方法</h3><p>在日常开发中，不推荐在<strong>类的外部</strong>给对象增加属性；如果在运行时，没有找到属性，程序会报错；对象应该包含有哪些属性，应该<strong>封装在类的内部</strong>。</p><ol><li><p>当使用<code>类名()</code>创建对象时，会自动执行以下操作：</p><ul><li><p>为对象在内存中分配空间——创建对象</p></li><li><p>为对象的属性设置初始值——初始化方法（<code>__init__</code>）</p></li></ul></li><li><p>这个初始化方法就是<code>__init__</code>方法，<code>__init__</code>是对象的内置方法</p></li></ol><p><code>__init__</code>方法是专门用来定义一个类具有哪些属性的方法！在<code>__init__</code>方法内部使用<code>self.属性名 = 属性的初始值</code>就可以<strong>定义属性</strong>。</p><p>在开发中，如果希望在创建对象的同时，就设置对象的属性，可以对<code>__init__</code>方法进行改造：</p><ul><li>把希望设置的属性值，定义成<code>__init__</code>方法的参数</li><li>在方法内部使用<code>se1f.属性 = 形参</code>接收外部传递的参数</li><li>在创建对象时，使用<code>类名（属性1，属性2..…）</code>调用</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">People</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;初始化方法%s&quot;</span> % self.name)</span><br><span class="line">xt = People(<span class="string">&quot;xiaotang&quot;</span>)</span><br><span class="line">xm = People(<span class="string">&quot;xiaoming&quot;</span>)</span><br><span class="line"><span class="comment"># 使用id()函数查看数据在内存中的地址</span></span><br><span class="line"><span class="built_in">print</span>(xt, <span class="built_in">id</span>(xt))</span><br><span class="line"><span class="built_in">print</span>(xm, <span class="built_in">id</span>(xm))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">初始化方法xiaotang</span><br><span class="line">初始化方法xiaoming</span><br><span class="line">&lt;__main__.People <span class="built_in">object</span> at <span class="number">0x0000027E373FC408</span>&gt; <span class="number">2741116060680</span></span><br><span class="line">&lt;__main__.People <span class="built_in">object</span> at <span class="number">0x0000027E37E98348</span>&gt; <span class="number">2741127185224</span></span><br></pre></td></tr></table></figure><h3 id="👀-del-和-str-方法"><a href="#👀-del-和-str-方法" class="headerlink" title="👀__del__和__str__方法"></a>👀<code>__del__</code>和<code>__str__</code>方法</h3><p>（1）<code>__del__</code>方法</p><ol><li><p>在<code>Python</code>中</p><ul><li><p>当使用<code>类名()</code>创建对象时，为对象分配完空间后，<strong>自动</strong>调用<code>__init__</code>方法；</p></li><li><p>当一个对象被从内存中销毁前，<strong>自动</strong>调用<code>__del__</code>方法。</p></li></ul></li><li><p>应用场景</p><ul><li><p><code>__init__</code>改造初始化方法，可以让创建对象更加灵活；</p></li><li><p><code>__del__</code>如果希望在对象被销毁前，再做一些事情，可以考虑一下<code>__del__</code>方法。</p></li></ul></li><li><p>生命周期</p><ul><li><p>一个对象从调用<code>类名()</code>创建，生命周期开始；</p></li><li><p>一个对象的<code>__del__</code>方法一旦被调用，生命周期结束；</p></li><li><p>在对象的生命周期内，可以访问对象属性，或者让对象调用方法。</p></li></ul></li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">People</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;初始化方法%s&quot;</span> % self.name)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__del__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;对象销毁，%s&quot;</span> % self.name)</span><br><span class="line">xt = People(<span class="string">&quot;xiaotang&quot;</span>)</span><br><span class="line">xm = People(<span class="string">&quot;xiaoming&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(xt, <span class="built_in">id</span>(xt))</span><br><span class="line"><span class="built_in">print</span>(xm, <span class="built_in">id</span>(xm))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">初始化方法xiaotang</span><br><span class="line">初始化方法xiaoming</span><br><span class="line">&lt;__main__.People <span class="built_in">object</span> at <span class="number">0x0000027E37EC63C8</span>&gt; <span class="number">2741127373768</span></span><br><span class="line">&lt;__main__.People <span class="built_in">object</span> at <span class="number">0x0000027E37EC6448</span>&gt; <span class="number">2741127373896</span></span><br><span class="line">对象销毁，xiaotang</span><br><span class="line">对象销毁，xiaoming</span><br></pre></td></tr></table></figure><p>（2）<code>__str__</code>方法</p><ul><li>在<code>Python</code>中，使用<code>print</code> 输出对象变量，默认情况下，会输出这个变量<strong>引用的对象</strong>是由<strong>哪一个类创建的对象</strong>，以及在<strong>内存中的地址</strong>（<strong>十六进制表示</strong>）；</li><li>如果在开发中，希望使用<code>print</code>输出<code>对象变量</code>时，能够打印<strong>自定义的内容</strong>，就可以利用<code>__str__</code>这个内置方法了。</li></ul><p>注意：<code>__str__</code>方法必须返回一个字符串</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">People</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;初始化方法%s&quot;</span> % self.name)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__del__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;对象销毁，%s&quot;</span> % self.name)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;我的名字：%s&quot;</span> % self.name</span><br><span class="line">xt = People(<span class="string">&quot;xiaotang&quot;</span>)</span><br><span class="line">xm = People(<span class="string">&quot;xiaoming&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(xt, <span class="built_in">id</span>(xt))</span><br><span class="line"><span class="built_in">print</span>(xm, <span class="built_in">id</span>(xm))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果（对比上一条代码的输出结果）</span></span><br><span class="line">初始化方法xiaotang</span><br><span class="line">初始化方法xiaoming</span><br><span class="line">我的名字：xiaotang <span class="number">2741123224968</span></span><br><span class="line">我的名字：xiaoming <span class="number">2741127144648</span></span><br><span class="line">对象销毁，xiaotang</span><br><span class="line">对象销毁，xiaoming</span><br></pre></td></tr></table></figure><h2 id="⛄面向对象三个基本特征"><a href="#⛄面向对象三个基本特征" class="headerlink" title="⛄面向对象三个基本特征"></a>⛄面向对象三个基本特征</h2><p>面向对象三大特性：</p><ol><li><p><strong>封装</strong>，根据职责将属性和方法封装到一个抽象的类中。</p><ul><li>定义类的准则</li></ul></li><li><p><strong>继承</strong>，实现代码的重用，相同的代码不需要重复的编写。</p><ul><li><p>设计类的技巧</p></li><li><p>子类针对自己特有的需求，编写特定的代码</p></li></ul></li><li><p><strong>多态</strong>，不同的子类对象调用相同的父类方法，产生不同的执行结果。</p><ul><li><p>多态可以增加代码的灵活度</p></li><li><p>以继承和重写父类方法为前提</p></li><li><p>是调用方法的技巧，不会影响到类的内部设计</p></li></ul></li></ol><h2 id="⛄封装"><a href="#⛄封装" class="headerlink" title="⛄封装"></a>⛄封装</h2><h3 id="👀封装概述"><a href="#👀封装概述" class="headerlink" title="👀封装概述"></a>👀封装概述</h3><ul><li><strong>封装</strong>是面向对象编程的一大特点；</li><li>面向对象编程的第一步，将<strong>属性</strong>和<strong>方法</strong>封装到一个抽象的<strong>类</strong>中；</li><li>外界使用<strong>类</strong>创建<strong>对象</strong>，然后让<strong>对象调用方法</strong>；</li><li>对象方法的<strong>细节</strong>都被<strong>封装</strong>在类的内部；</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Gun</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, model</span>):</span><br><span class="line">        <span class="comment"># 枪的型号</span></span><br><span class="line">        self.model = model</span><br><span class="line">        <span class="comment"># 子弹数量</span></span><br><span class="line">        self.bullet_count = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add_bullet</span>(<span class="params">self, count</span>):</span><br><span class="line">        self.bullet_count += count</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">shoot</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> self.bullet_count &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;没有子弹了&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.bullet_count -= <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%s发射子弹[%d]...&quot;</span>%(self.model, self.bullet_count))</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Soldier</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        <span class="comment"># 姓名</span></span><br><span class="line">        self.name = name</span><br><span class="line">        <span class="comment"># 士兵出事没有枪，None表示什么都没有</span></span><br><span class="line">        self.gun = <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fire</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> self.gun <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;%s没有枪...&quot;</span>% self.name)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;冲啊....[%s]&quot;</span>% self.name)</span><br><span class="line">        self.gun.add_bullet(<span class="number">50</span>)</span><br><span class="line">        self.gun.shoot()</span><br><span class="line">        </span><br><span class="line"><span class="comment"># 创建对象</span></span><br><span class="line">ak47 = Gun(<span class="string">&quot;ak47&quot;</span>)</span><br><span class="line">person = Soldier(<span class="string">&quot;xiaotang&quot;</span>)</span><br><span class="line">person.fire()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">20</span>)</span><br><span class="line">person.gun = ak47</span><br><span class="line">person.fire()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">xiaotang没有枪...</span><br><span class="line">********************</span><br><span class="line">冲啊....[xiaotang]</span><br><span class="line">ak47发射子弹[<span class="number">49</span>]...</span><br></pre></td></tr></table></figure><h3 id="👀is与-x3D-x3D-区别"><a href="#👀is与-x3D-x3D-区别" class="headerlink" title="👀is与&#x3D;&#x3D;区别"></a>👀is与&#x3D;&#x3D;区别</h3><p>（1）身份运算符</p><p>身份运算符用于<strong>比较</strong>两个对象的<strong>内存地址</strong>是否一致，<strong>是否是对同一个对象的引用</strong>。在<code>Python</code>中针对<code>None</code>比较时，建议使用<code>is</code>判断。</p><table><thead><tr><th>运算符</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td><code>is</code></td><td><code>is</code>是判断两个标识符是不是引用同一对象</td><td><code>x is y</code>，类似于<code>id(x) == id(y)</code></td></tr><tr><td><code>is not</code></td><td><code>is not</code>是判断两个标识符是不是引用不同对象</td><td><code>x is not y</code>，类似于<code>id(a) != id(y)</code></td></tr></tbody></table><p>（2）<code>is</code>与<code>==</code>区别</p><p><code>is</code>用于判断<strong>两个变量引用对象是否为同一个</strong>；</p><p><code>==</code>用于判断<strong>引用变量的值</strong>是否相等。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">b = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="built_in">print</span>(b <span class="keyword">is</span> a)</span><br><span class="line"><span class="built_in">print</span>(b == a)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><h3 id="👀私有属性和私有方法"><a href="#👀私有属性和私有方法" class="headerlink" title="👀私有属性和私有方法"></a>👀私有属性和私有方法</h3><ol><li><p>在实际开发中，<strong>对象</strong>的<strong>某些属性</strong>或<strong>方法</strong>可能只希望<strong>在对象的内部被使用</strong>，而<strong>不希望在外部被访问</strong>。</p><ul><li><p><strong>私有属性</strong>就是对象不希望公开的属性；</p></li><li><p><strong>私有方法</strong>就是对象不希望公开的方法；</p></li></ul></li><li><p>在定义属性或方法时，在属性名或者方法名前增加<strong>两个下划线</strong>，定义的就是<strong>私有属性或者方法</strong>。</p><ul><li><p>私有属性&#x2F;方法，在外界不能够被直接访问；</p></li><li><p>在对象的方法内部，是可以访问对象的私有属性&#x2F;方法的。</p></li></ul></li><li><p>伪私有属性和私有方法（不建议使用），Python中，并没有真正意义的私有。</p><ul><li><p>在给属性、方法命名时，实际是对名称做了一些特殊处理，使得外界无法访问到；</p></li><li><p><strong>处理方式</strong>：在名称前面加上<code>_类名</code>，即<code>_类名__名称</code>。</p></li></ul></li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">People</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">        self.__height = <span class="number">180</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__mimi</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;我的身高是%d&quot;</span>% self.__height)</span><br><span class="line"></span><br><span class="line">xiaotang = People(<span class="string">&quot;小汤&quot;</span>, <span class="number">20</span>)</span><br><span class="line"><span class="comment"># 私有属性，外部不能访问</span></span><br><span class="line"><span class="comment"># AttributeError: &#x27;People&#x27; object has no attribute &#x27;__height&#x27;</span></span><br><span class="line"><span class="comment"># print(xiaotang.__height)</span></span><br><span class="line"><span class="comment"># AttributeError: &#x27;People&#x27; object has no attribute &#x27;__mimi&#x27;</span></span><br><span class="line"><span class="comment"># xiaotang.__mimi()   </span></span><br><span class="line"><span class="built_in">print</span>(xiaotang._People__height)   <span class="comment"># 180</span></span><br><span class="line">xiaotang._People__mimi()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="number">180</span></span><br><span class="line">我的身高是<span class="number">180</span></span><br></pre></td></tr></table></figure><h3 id="👀单例设计模式"><a href="#👀单例设计模式" class="headerlink" title="👀单例设计模式"></a>👀单例设计模式</h3><ol><li><p>设计模式</p><ul><li><p><strong>设计模式</strong>是<strong>前人工作的总结和提炼</strong>，通常，被人们广泛流传的设计模式都是针对<strong>某一特定问题</strong>的成熟的解决方案；</p></li><li><p>使用<strong>设计模式</strong>是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。</p></li></ul></li><li><p>单例设计模式</p><ul><li><p><strong>目的</strong>–让类创建的对象，在系统中<strong>只有唯一的一个实例</strong>；</p></li><li><p>每一次执行<code>类名()</code>返回的对象，<strong>内存地址是相同的</strong>。</p></li></ul></li><li><p>单例设计模式的应用场景</p><ul><li><p>音乐播放对象</p></li><li><p>回收站对象</p></li><li><p>打印机对象</p></li></ul></li></ol><p>（1）<code>__new__</code>方法</p><ul><li><p>使用<code>类名()</code>创建对象时，<code>Python</code>的解释器首先会调用<code>__new__</code>方法为对象<strong>分配空间</strong>；</p></li><li><p><code>__new__</code>是一个由<code>object</code>基类提供的<strong>内置的静态方法</strong>，主要作用有两个：</p><ul><li><p>在内存中为对象<strong>分配空间</strong></p></li><li><p><strong>返回对象的引用</strong></p></li></ul></li><li><p><code>Python</code>的解释器获得对象的<strong>引用</strong>后，将引用作为第一个参数，传递给<code>__init__</code>方法。</p></li></ul><p>重写<code>__new__</code>方法的代码非常固定：</p><ul><li>重写<code>__new__</code>方法一定要<code>return super().__new__(cls)</code></li><li>否则<code>Python</code>的解释器得不到分配了空间的对象引用，就不会调用对象的初始化方法</li><li>注意：<code>__new__</code>是一个静态方法，在调用时需要<strong>主动传递</strong><code>cls</code>参数</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MusicPlayer</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">cls</span>):</span><br><span class="line">        <span class="comment"># 创建对象时，new方法会被自动调用</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;分配空间&quot;</span>)</span><br><span class="line">        <span class="comment"># 为对象分配空间，返回对象的引用</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>().__new__(cls)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;初始化&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建对象</span></span><br><span class="line">player = MusicPlayer()</span><br><span class="line"><span class="built_in">print</span>(player)      </span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">分配空间</span><br><span class="line">初始化</span><br><span class="line">&lt;__main__.MusicPlayer <span class="built_in">object</span> at <span class="number">0x000002343B97DD48</span>&gt;</span><br></pre></td></tr></table></figure><p>（2）<code>Python</code>中的单例</p><p>单例——让类创建的对象，在系统中只有唯一的一个实例</p><ul><li>定义一个<strong>类属性</strong>，初始值是<code>None</code>，用于记录<strong>单例对象的引用</strong>；</li><li>重写<code>__new__</code>方法；</li><li>如果<strong>类属性</strong><code>is None</code>，调用父类方法分配空间，并在类属性中记录结果；</li><li>返回<strong>类属性</strong>中记录的<strong>对象引用</strong>。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 单例设计模式实现</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MusicPlayers</span>():</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 记录第一个被创建对象的引用</span></span><br><span class="line">    instance = <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">cls</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;分配空间&quot;</span>)</span><br><span class="line">        <span class="comment"># 判断类属性是否为空对象</span></span><br><span class="line">        <span class="keyword">if</span> cls.instance <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="comment"># 调用父类的方法，为第一个对象分配空间</span></span><br><span class="line">            cls.instance = <span class="built_in">super</span>().__new__(cls)</span><br><span class="line">        <span class="keyword">return</span> cls.instance</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;初始化&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建多个实例,无论调用多少次创建对象类的方法，得到的对象内存地址都是相同的</span></span><br><span class="line">player1 = MusicPlayers()</span><br><span class="line">player2 = MusicPlayers()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(player1)</span><br><span class="line"><span class="built_in">print</span>(player2)   </span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">分配空间</span><br><span class="line">初始化</span><br><span class="line">分配空间</span><br><span class="line">初始化</span><br><span class="line">&lt;__main__.MusicPlayers <span class="built_in">object</span> at <span class="number">0x000002343B945248</span>&gt;</span><br><span class="line">&lt;__main__.MusicPlayers <span class="built_in">object</span> at <span class="number">0x000002343B945248</span>&gt;</span><br></pre></td></tr></table></figure><p>（3）存在的问题</p><p><strong>问题所在</strong></p><ul><li><p>在每次使用<code>类名()</code>创建对象时，<code>Python</code>的解释器都会自动调用两个方法。</p><ul><li><p><code>__new__</code>分配空间</p></li><li><p><code>__init__</code>对象初始化</p></li></ul></li><li><p>在上一小节对<code>__new__</code>方法改造之后，每次都会得到第一次被创建对象的引用。</p></li><li><p>但是：<strong>初始化方法还会被再次调用</strong>。</p></li></ul><p><strong>需求</strong>：让初始化动作只被执行一次。</p><p><strong>解决办法</strong></p><ul><li>定义一个类属性<code>init_flag</code>标记<strong>是否执行过初始化动作</strong>，初始值为<code>False</code>；</li><li>在<code>__init__</code>方法中，判断<code>init_flag</code>，如果为<code>False</code>就执行初始化动作；</li><li>然后将<code>init_flag</code>设置为<code>True</code>；</li><li>这样，再次自动调用<code>__init__</code>方法时，初始化动作就不会被再次执行了。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MPlayers</span>():</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 记录第一个被创建对象的引用</span></span><br><span class="line">    instance = <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 记录是否执行过初始化的动作</span></span><br><span class="line">    init_flag = <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">cls</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;分配空间&quot;</span>)</span><br><span class="line">        <span class="comment"># 判断类属性是否为空对象</span></span><br><span class="line">        <span class="keyword">if</span> cls.instance <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="comment"># 调用父类的方法，为第一个对象分配空间</span></span><br><span class="line">            cls.instance = <span class="built_in">super</span>().__new__(cls)</span><br><span class="line">        <span class="keyword">return</span> cls.instance</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> MPlayers.init_flag:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;初始化了，一次&quot;</span>)</span><br><span class="line">        MPlayers.init_flag = <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line"><span class="comment"># 创建多个实例,无论调用多少次创建对象类的方法，得到的对象内存地址都是相同的</span></span><br><span class="line">player3 = MPlayers()</span><br><span class="line">player4 = MPlayers()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(player3)</span><br><span class="line"><span class="built_in">print</span>(player4)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">分配空间</span><br><span class="line">初始化了，一次</span><br><span class="line">分配空间</span><br><span class="line">&lt;__main__.MPlayers <span class="built_in">object</span> at <span class="number">0x000001E149BB2F08</span>&gt;</span><br><span class="line">&lt;__main__.MPlayers <span class="built_in">object</span> at <span class="number">0x000001E149BB2F08</span>&gt;</span><br></pre></td></tr></table></figure><h2 id="⛄继承"><a href="#⛄继承" class="headerlink" title="⛄继承"></a>⛄继承</h2><h3 id="👀继承概述"><a href="#👀继承概述" class="headerlink" title="👀继承概述"></a>👀继承概述</h3><p>（1）继承的概念：<strong>子类</strong>拥有<strong>父类</strong>的所有<strong>方法</strong>和<strong>属性</strong>。</p><p>（2）继承的语法</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">类名</span>(<span class="title class_ inherited__">父类名</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p><strong>子类</strong>继承自<strong>父类</strong>，可以直接享受父类中已经封装好的方法，不需要再次开发；</p><p><strong>子类</strong>中应该根据职责，封装<strong>子类特有的属性和方法</strong>。</p><blockquote><p>子类        父类<br>派生类    基类</p></blockquote><p>（3）继承的传递性</p><ul><li>C类是B类继承，B类又从A类继承；</li><li>那么C类就具有B类和A类的所有属性和方法；</li><li>子类拥有父类以及父类的父类中封装的所有属性和方法。</li></ul><h3 id="👀方法重写"><a href="#👀方法重写" class="headerlink" title="👀方法重写"></a>👀方法重写</h3><p>（1）方法的重写</p><p><strong>子类</strong>拥有<strong>父类</strong>的所有<strong>方法</strong>和<strong>属性</strong>。</p><p><strong>子类</strong>继承自<strong>父类</strong>，可以直接享受父类中已经封装好的方法，不需要再次开发</p><p>（2）应用场景</p><p>当<strong>父类</strong>的方法实现不能满足子类需求时，可以对方法进行重写（<code>override</code>）</p><p>重写父类方法有两种情况：①覆盖父类的方法；②对父类方法进行扩展。</p><p>①覆盖父类的方法</p><ul><li>如果在开发中，<strong>父类的方法实现</strong>和<strong>子类的方法实现</strong>，<strong>完全不同</strong>；</li><li>就可以使用<strong>覆盖</strong>的方式，在子类中<strong>重新编写</strong>父类的方法实现；</li></ul><blockquote><p>【具体的实现方式】，就相当于在子类中定义了一个和父类同名的方法并且实现。</p><p>重写之后，在运行时，只会调用子类中重写的方法，而不再会调用父类封装的方法</p></blockquote><p>②对父类方法进行扩展</p><p>如果在开发中，子类的方法实现中包含父类的方法实现，父类原本封装的方法实现是子类方法的一部分。</p><p>使用扩展的方式：</p><ul><li>在子类中重写父类的方法；</li><li>在需要的位置使用<code>super().父类方法</code>来调用父类方法的执行；</li><li>代码其他的位置针对子类的需求，编写<strong>子类特有的代码</strong>实现。</li></ul><p>（3）<code>super</code></p><ul><li>在<code>Python</code>中<code>super</code>是一个特殊的类；</li><li><code>super()</code>就是使用<code>super</code>类创建出来的对象；</li><li>最常使用的场景就是在重写父类方法时，调用在父类中封装的方法实现。</li></ul><p>（4）调用父类方法的另外一种方式（知道）</p><p>在<code>Python 2.x</code>时，如果需要调用父类的方法,还可以使用以下方式：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">父类名.方法(self)</span><br></pre></td></tr></table></figure><ul><li>这种方式,目前在Python 3.x还支持这种方式</li><li>这种方法不推荐使用，因为一旦父类发生变化，方法调用位置的类名同样需要修改</li></ul><blockquote><p>提示：</p><p>在开发时，父类名和<code>super()</code>两种方式不要混用；</p><p>如果使用当前子类名调用方法，会形成递归调用，出现死循环。</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">People</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">language</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;地球语言:汉语、俄语、西班牙语、英语、德语...&quot;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(<span class="title class_ inherited__">People</span>):</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">language</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>().language()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%s是中国人，说汉语&quot;</span>%self.name)</span><br><span class="line">    </span><br><span class="line">xiaotang = Person(<span class="string">&quot;小汤&quot;</span>) </span><br><span class="line"><span class="built_in">print</span>(xiaotang.name)</span><br><span class="line">xiaotang.language()  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">小汤</span><br><span class="line">地球语言:汉语、俄语、西班牙语、英语、德语...</span><br><span class="line">小汤是中国人，说汉语</span><br></pre></td></tr></table></figure><h3 id="👀父类的私有属性和私有方法"><a href="#👀父类的私有属性和私有方法" class="headerlink" title="👀父类的私有属性和私有方法"></a>👀父类的私有属性和私有方法</h3><p>父类的私有属性和私有方法</p><ul><li>子类对象<strong>不能</strong>在自己的方法内部，直接访问父类的私有属性或私有方法；</li><li>子类对象可以通过父类的公有方法<strong>间接访问</strong>私有属性或私有方法。</li></ul><blockquote><p><strong>私有属性、方法</strong>是对象的隐私，不对外公开，<strong>外界</strong>以及<strong>子类</strong>都不能直接访问；</p><p><strong>私有属性、方法</strong>通常用于做一些内部的事情。</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">People</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        <span class="comment"># 私有属性</span></span><br><span class="line">        self.__num = <span class="number">8000000000</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">language</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;地球语言:汉语、俄语、西班牙语、英语、德语...&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 私有方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__protect</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;人数：%d，这是一个秘密&quot;</span>% self.__num)</span><br><span class="line">   </span><br><span class="line"><span class="comment"># 通过公有方法间接调用私有属性和私有方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">people_num</span>(<span class="params">self</span>):</span><br><span class="line">        self.__protect()</span><br><span class="line">    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(<span class="title class_ inherited__">People</span>):</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">language</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>().language()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%s是中国人，说汉语&quot;</span>%self.name)</span><br><span class="line">        <span class="comment"># 访问父类中私有方法,是访问不到的</span></span><br><span class="line">        <span class="comment"># self.__protect()</span></span><br><span class="line">        self.people_num()</span><br><span class="line">        </span><br><span class="line">xiaotang = Person(<span class="string">&quot;小汤&quot;</span>) </span><br><span class="line"><span class="built_in">print</span>(xiaotang.name)</span><br><span class="line"><span class="comment"># 访问父类中私有属性,是访问不到的</span></span><br><span class="line"><span class="comment"># print(xiaotang.__num)</span></span><br><span class="line">xiaotang.language()  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">小汤</span><br><span class="line">地球语言:汉语、俄语、西班牙语、英语、德语...</span><br><span class="line">小汤是中国人，说汉语</span><br><span class="line">人数：<span class="number">8000000000</span>，这是一个秘密</span><br></pre></td></tr></table></figure><h3 id="👀多继承"><a href="#👀多继承" class="headerlink" title="👀多继承"></a>👀多继承</h3><p>子类可以拥有多个父类，并且具有所有父类的属性和方法。</p><p>例如：孩子会继承父亲和母亲的特性</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 语法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">子类名</span>(父类名<span class="number">1</span>,父类名<span class="number">2.</span>..):</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p><strong>多继承的使用注意事项</strong></p><p>​    如果<strong>不同的父类</strong>中存在<strong>同名的方法</strong>，<strong>子类</strong>对象在调用方法时，会调用<strong>哪一个父类</strong>中的方法。开发时，应该尽量避免这种容易产生混淆的情况！如果父类之间存在同名的属性或方法，应该尽量避免使用多继承。</p><p><code>python</code>中的<code>MRO</code>—-方法搜索顺序（了解）</p><ul><li><code>python</code>中针对类提供了一个内置属性<code>__mro__</code>可以查看方法的搜索顺序。</li><li><code>MRO</code>是<code>method resolution order</code>，主要用于在<strong>多继承时判断方法、属性的调用路径</strong>。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(*.__mro__)</span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">(&lt;<span class="keyword">class</span> <span class="string">&#x27;__main__.*&#x27;</span>&gt;,&lt;<span class="keyword">class</span> <span class="string">&#x27;__main__.*&#x27;</span>&gt;,&lt;<span class="keyword">class</span> <span class="string">&#x27;object&#x27;</span>&gt;)</span><br></pre></td></tr></table></figure><ul><li>在搜索方法时，是按照<code>__mro__</code>的输出结果从左至右的顺序查找的；</li><li>如果在当前类中找到方法，就直接执行，不再搜索；</li><li>如果没有找到，就查找下一个类中是否有对应的方法，如果找到，就直接执行，不再搜索；</li><li>如果找到最后一个类，还没有找到方法，程序报错。</li></ul><h3 id="👀新式类与旧式-经典-类"><a href="#👀新式类与旧式-经典-类" class="headerlink" title="👀新式类与旧式(经典)类"></a>👀新式类与旧式(经典)类</h3><p><code>object</code> 是<code>Python</code>为所有对象提供的基类，提供有一些内置的属性和方法，可以使用<code>dir</code>函数查看。</p><ul><li>新式类：以<code>object</code>为基类的类，推荐使用；</li><li>经典类：不以<code>object</code>为基类的类，不推荐使用；</li><li>在<code>Python 3.x</code>中定义类时，如果没有指定父类，会默认使用<code>object</code>作为该类的基类–<code>Python 3.x</code>中定义的类都是新式类；</li><li>在<code>Python 2.x</code>中定义类时，如果没有指定父类，则不会以<code>object</code>作为基类。</li></ul><blockquote><p>​    新式类和经典类在多继承时–会影响到方法的搜索顺序</p></blockquote><p>为了保证编写的代码能够同时在<code>Python 2.x</code>和<code>Python 3.x</code>运行！今后在定义类时，如果没有父类，建议统一继承自<code>object</code>。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 语法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">类名</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><h2 id="⛄多态"><a href="#⛄多态" class="headerlink" title="⛄多态"></a>⛄多态</h2><p><strong>多态</strong>，不同的子类对象调用相同的父类方法，产生不同的执行结果。</p><ul><li><p>多态可以增加代码的灵活度</p></li><li><p>以继承和重写父类方法为前提</p></li><li><p>是调用方法的技巧，不会影响到类的内部设计</p></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">game</span>(<span class="params">self</span>):</span><br><span class="line">         <span class="built_in">print</span>(<span class="string">&quot;%s简单的玩耍&quot;</span>%self.name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">T_Dog</span>(<span class="title class_ inherited__">Dog</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">game</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%s在天上玩耍&quot;</span>%self.name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">game_with_dog</span>(<span class="params">self, dog</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%s和%s一起快乐的玩耍&quot;</span>%(self.name, dog.name))</span><br><span class="line">        dog.game()</span><br><span class="line"><span class="comment"># 定义一个狗对象</span></span><br><span class="line"><span class="comment"># wangcai = Dog(&quot;旺财&quot;)</span></span><br><span class="line">wangcai = T_Dog(<span class="string">&quot;飞天旺财&quot;</span>)</span><br><span class="line"><span class="comment"># 定义一个小明对象</span></span><br><span class="line">X_Ming = Person(<span class="string">&quot;小明&quot;</span>)</span><br><span class="line"><span class="comment"># 调用一起玩耍的方法</span></span><br><span class="line">X_Ming.game_with_dog(wangcai)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">小明和飞天旺财一起快乐的玩耍</span><br><span class="line">飞天旺财在天上玩耍</span><br></pre></td></tr></table></figure><h2 id="⛄类属性和类方法"><a href="#⛄类属性和类方法" class="headerlink" title="⛄类属性和类方法"></a>⛄类属性和类方法</h2><h3 id="👀类的结构"><a href="#👀类的结构" class="headerlink" title="👀类的结构"></a>👀类的结构</h3><p>（1）实例</p><p>使用<code>类名()</code>创建对象（分配空间、对象初始化）后，内存中就有了一个对象的实实在在的存在–实例。</p><ul><li>创建出来的<strong>对象</strong>叫做类的<strong>实例</strong>；</li><li>创建对象的<strong>动作</strong>叫做<strong>实例化</strong>；</li><li><strong>对象的属性</strong>叫做<strong>实例属性</strong>；</li><li><strong>对象调用的方法</strong>叫做<strong>实例方法</strong>。</li></ul><p>在程序执行时：</p><ul><li><p>对象各自拥有自己的<strong>实例属性</strong>；</p></li><li><p>调用对象方法，可以通过<code>self.</code></p><ul><li><p>访问自己的属性</p></li><li><p>调用自己的方法</p></li></ul></li></ul><p>结论</p><ul><li>每一个对象都有自己独立的内存空间，保存各自不同的属性；</li><li>多个对象的方法，在内存中只有一份，在调用方法时，需要把对象的引用传递到方法内部。</li></ul><p>（2）类是一个特殊的对象</p><blockquote><p><code>Python</code> 中一切皆对象：</p><ul><li><code>class AAA</code>：定义的类属于<strong>类对象</strong></li><li><code>obj1=AAA()</code> 属于<strong>实例对象</strong></li></ul></blockquote><ul><li><p>在程序运行时，<strong>类</strong>同样会被加载到内存；</p></li><li><p>在<code>Python</code>中，<strong>类</strong>是一个特殊的对象–类对象；</p></li><li><p>在程序运行时，<strong>类对象</strong>在内存中<strong>只有一份</strong>，使用一个类可以<strong>创建出很多个对象实例</strong>；</p></li><li><p>除了封装<strong>实例</strong>的<strong>属性</strong>和<strong>方法</strong>外，<strong>类对象</strong>还可以拥有自己的<strong>属性</strong>和<strong>方法</strong>：</p><ul><li><p>类属性</p></li><li><p>类方法</p></li></ul></li><li><p>通过<code>类名.</code>的方式可以<strong>访问类的属性</strong>或者<strong>调用类的方法</strong>。</p><ul><li><p><code>类名.类属性</code></p></li><li><p><code>类名.方法名()</code></p></li></ul></li></ul><h3 id="👀类属性和实例属性"><a href="#👀类属性和实例属性" class="headerlink" title="👀类属性和实例属性"></a>👀类属性和实例属性</h3><p>（1）概念和使用</p><ul><li><strong>类属性</strong>就是在类对象中定义的属性；</li><li>通常用来记录与这个类相关的<strong>特征</strong>；</li><li><strong>类属性</strong>不会用于记录具体对象的特征。</li></ul><p>（2）属性的获取机制</p><p>在<code>Python</code>中属性的获取存在一个向上查找机制。因此，要访问类属性有两种方式：</p><ul><li><code>类名.类属性</code></li><li><code>对象.类属性</code>(不推荐)，遵循向上查找机制（先在对象内部查找，没有就会向上查找类属性）</li></ul><blockquote><p>注意：如果使用【对象.类属性&#x3D;值赋值语句】，只会给对象添加一个属性，而不会影响到类属性的值。</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Tool</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="comment"># 使用赋值语句,定义类属性,记录创建工具对象的总数</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        <span class="comment"># 计数</span></span><br><span class="line">        Tool.count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建工具对象</span></span><br><span class="line">tool1 = Tool(<span class="string">&quot;钳子&quot;</span>)</span><br><span class="line">tool2 = Tool(<span class="string">&quot;斧头&quot;</span>)</span><br><span class="line">tool3 = Tool(<span class="string">&quot;锤子&quot;</span>)</span><br><span class="line"><span class="comment"># 使用Tool类创建了多少个对象</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;现在创建了%d个工具&quot;</span>% Tool.count)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">现在创建了<span class="number">3</span>个工具</span><br></pre></td></tr></table></figure><h3 id="👀类方法和静态方法"><a href="#👀类方法和静态方法" class="headerlink" title="👀类方法和静态方法"></a>👀类方法和静态方法</h3><p>（1）类方法</p><p><strong>类属性</strong>就是针对<strong>类对象</strong>定义的<strong>属性</strong></p><ul><li>使用赋值语句在<code>class</code>关键字下方可以定义类属性；</li><li>类属性用于记录与这个类相关的特征。</li></ul><p><strong>类方法</strong>就是针对<strong>类对象</strong>定义的<strong>方法</strong></p><ul><li>在<strong>类方法</strong>内部可以直接访问<strong>类属性</strong>或者<strong>调用其他的类方法</strong>。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 语法</span></span><br><span class="line"><span class="meta">@classmethod </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">类方法名</span>(<span class="params">cls</span>):</span><br><span class="line"><span class="keyword">pass</span></span><br></pre></td></tr></table></figure><ul><li><p>类方法需要用<strong>修饰器</strong><code>@classmethod</code>来标识,告诉解释器这是一个类方法。</p></li><li><p>类方法的<strong>第一个参数</strong>应该是<code>cls</code></p><ul><li><p>由<strong>哪一个类</strong>调用的方法，方法内的<code>cls</code>就是<strong>哪一个类的引用</strong>；</p></li><li><p>这个<strong>参数</strong>和<strong>实例方法</strong>的第一个参数是<code>self</code>类似；</p></li><li><p>提示：使用其他名称也可以，不过习惯使用<code>cls</code>。</p></li></ul></li><li><p>通过<code>类名.</code>调用<strong>类方法</strong>，调用方法时，不需要传递<code>cls</code>参数。</p></li><li><p>在方法内部</p><ul><li><p>可以通过<code>c1s.</code><strong>访问类的属性</strong></p></li><li><p>也可以通过<code>c1s.</code><strong>调用其他的类方法</strong></p></li></ul></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Tool</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="comment"># 使用赋值语句,定义类属性,记录创建工具对象的总数</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        <span class="comment"># 计数</span></span><br><span class="line">        Tool.count += <span class="number">1</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">show_tool_count</span>(<span class="params">cls</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;工具对象的总数:%d&quot;</span> % cls.count)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建工具对象</span></span><br><span class="line">tool1 = Tool(<span class="string">&quot;钳子&quot;</span>)</span><br><span class="line">tool2 = Tool(<span class="string">&quot;斧头&quot;</span>)</span><br><span class="line">tool3 = Tool(<span class="string">&quot;锤子&quot;</span>)</span><br><span class="line"><span class="comment"># 使用Tool类创建了多少个对象</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;现在创建了%d个工具&quot;</span>% Tool.count)</span><br><span class="line">Tool.show_tool_count()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">现在创建了<span class="number">3</span>个工具</span><br><span class="line">工具对象的总数:<span class="number">3</span></span><br></pre></td></tr></table></figure><blockquote><p>在类方法内部，可以直接使用<code>cls</code>访问类属性或者调用类方法。</p></blockquote><p>（2）静态方法</p><ul><li><p>在开发时，如果需要在类中封装一个方法，这个方法：</p><ul><li><p>既<strong>不需要</strong>访问<strong>实例属性</strong>或者调用<strong>实例方法</strong></p></li><li><p>也<strong>不需要</strong>访问<strong>类属性</strong>或者调用<strong>类方法</strong></p></li></ul></li><li><p>这个时候，可以把这个方法封装成一个<strong>静态方法</strong>语法如下。</p></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 语法</span></span><br><span class="line"><span class="meta">@staticmethod </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">静态方法名</span>():</span><br><span class="line"><span class="keyword">pass</span></span><br></pre></td></tr></table></figure><ul><li><p>静态方法需要用修饰器<code>@staticmethod</code> 来标识，告诉解释器这是一个静态方法。</p></li><li><p>通过<code>类名.</code>调用静态方法，不需要创建对象。</p></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Game</span>:</span><br><span class="line">    <span class="comment"># 类属性</span></span><br><span class="line">    top_score = <span class="number">100</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 实例属性,在初始化方法内部定义</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,player_name</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.name = player_name</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 静态方法</span></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">show_help</span>():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;帮助信息&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 类方法</span></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">show_top_score</span>(<span class="params">cls</span>):</span><br><span class="line">        <span class="comment"># print(&quot;历史最高分：%d&quot;%Game.top_score)</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;历史最高分：%d&quot;</span>%cls.top_score)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 实例方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">start_game</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%s开始的游戏&quot;</span>%self.name)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 【类名.】</span></span><br><span class="line">Game.show_help()</span><br><span class="line">Game.show_top_score()</span><br><span class="line"><span class="comment"># 创建对象，【对象.】</span></span><br><span class="line">Tom = Game(<span class="string">&quot;小汤&quot;</span>)</span><br><span class="line">Tom.start_game()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">帮助信息</span><br><span class="line">历史最高分：<span class="number">100</span></span><br><span class="line">小汤开始的游戏</span><br></pre></td></tr></table></figure><blockquote><p>小结</p><ol><li>实例方法–方法内部需要访问<strong>实例属性</strong></li><li>实例方法–方法内部可以使用<code>类名.</code>访问<strong>类属性</strong></li><li>类方法–方法内部<strong>只需要</strong>访问<strong>类属性</strong>，或<strong>类方法</strong></li><li>静态方法–方法内部，<strong>不需要访问</strong>实例属性和类属性</li></ol><p>如果方法内部即需要访问实例属性，又需要访问类属性，应该定义成什么方法？(实例方法)</p></blockquote><p>笔者不才，请多交流！！！</p><p>参考文献：黑马程序员《<code>Python</code>入门教程完整版》</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Python基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python小知识点</title>
      <link href="/2022/09/17/Python-Add05/"/>
      <url>/2022/09/17/Python-Add05/</url>
      
        <content type="html"><![CDATA[<h2 id="⛄变量的应用"><a href="#⛄变量的应用" class="headerlink" title="⛄变量的应用"></a>⛄变量的应用</h2><p>变量和数据都是保存在内存中的，在<code>Python</code>中函数的参数传递以及返回值都是通过引用传递的。</p><h3 id="👀引用的概念"><a href="#👀引用的概念" class="headerlink" title="👀引用的概念"></a>👀引用的概念</h3><p>在<code>Python</code>中：</p><ul><li>变量和数据是分开存储的；</li><li>数据保存在内存中的一个位置；</li><li>变量中保存着数据在内存中的地址；</li><li>变量中记录数据的地址，就叫作<strong>引用</strong>；</li><li>使用<strong>id()<strong>函数可以查看变量中保存数据所在的</strong>内存地址</strong>。</li></ul><blockquote><p>注意：如果变量已经被定义，当给一个变量赋值的时候，本质上是修改了数据的引用。</p><ul><li>变量不再对之前的数据引用；</li><li>变量改为对新赋值的数据引用。</li></ul></blockquote><h3 id="👀函数的参数和返回值的传递"><a href="#👀函数的参数和返回值的传递" class="headerlink" title="👀函数的参数和返回值的传递"></a>👀函数的参数和返回值的传递</h3><p>在<code>Python</code>中，函数的实参&#x2F;返回值都是通过引用来传递的。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">mytest</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">50</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;%d 在函数内的内存地址是%x&quot;</span> % (n,<span class="built_in">id</span>(n)))</span><br><span class="line">    </span><br><span class="line">    result = <span class="number">10000</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;返回值%d在函数内的内存地址是%x&quot;</span> % (result,<span class="built_in">id</span>(result)))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">50</span>)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">a = <span class="number">100</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;调用函数前，内存地址是%x&quot;</span> % <span class="built_in">id</span>(a))</span><br><span class="line">r = mytest(a)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;调用函数后，实参内存地址是%x&quot;</span> % <span class="built_in">id</span>(a))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;调用函数前，返回值内存地址是%x&quot;</span> % <span class="built_in">id</span>(r))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">调用函数前，内存地址是7ffd3378adf0</span><br><span class="line">**************************************************</span><br><span class="line"><span class="number">100</span> 在函数内的内存地址是7ffd3378adf0</span><br><span class="line">返回值<span class="number">10000</span>在函数内的内存地址是1cd96276b70</span><br><span class="line">**************************************************</span><br><span class="line">调用函数后，实参内存地址是7ffd3378adf0</span><br><span class="line">调用函数前，返回值内存地址是1cd96276b70</span><br></pre></td></tr></table></figure><h2 id="⛄可变和不可变类型"><a href="#⛄可变和不可变类型" class="headerlink" title="⛄可变和不可变类型"></a>⛄可变和不可变类型</h2><ol><li><p>不可变类型，内存中的数据不允许被修改：</p><ul><li><p>数字类型：<code>int</code>、<code>bool</code>、<code>float</code>、<code>complex</code>、<code>long</code></p></li><li><p>字符串：<code>str</code></p></li><li><p>元组：<code>tuple</code></p></li></ul></li><li><p>可变类型，内存中的数据可以被修改：</p><ul><li><p>列表：<code>list</code></p></li><li><p>字典：<code>dict</code>，字典中的<code>key</code>只能使用不可变类型的数据</p></li></ul></li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">emo_list = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;定义列表后内存地址是%d&quot;</span> % <span class="built_in">id</span>(demo_list))</span><br><span class="line"></span><br><span class="line">demo_list.append(<span class="number">10</span>)</span><br><span class="line">demo_list.remove(<span class="number">1</span>)</span><br><span class="line">demo_list[<span class="number">0</span>] = <span class="number">30</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;修改数据后内存地址是%d&quot;</span> % <span class="built_in">id</span>(demo_list))</span><br><span class="line"></span><br><span class="line">demo_dict = &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;小李子&quot;</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;定义字典后内存地址是%d&quot;</span> % <span class="built_in">id</span>(demo_dict))</span><br><span class="line"></span><br><span class="line">demo_dict[<span class="string">&quot;age&quot;</span>] = <span class="number">20</span></span><br><span class="line">demo_dict[<span class="string">&quot;name&quot;</span>] = <span class="string">&quot;小喜子&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;修改数据后内存地址是%d&quot;</span> % <span class="built_in">id</span>(demo_dict))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">定义列表后内存地址是<span class="number">1982499211272</span></span><br><span class="line">修改数据后内存地址是<span class="number">1982499211272</span></span><br><span class="line">定义字典后内存地址是<span class="number">1982498720808</span></span><br><span class="line">修改数据后内存地址是<span class="number">1982498720808</span></span><br></pre></td></tr></table></figure><p>可变类型的数据变化，是通过方法来实现的；如果给一个可变类型的变量，赋值一个新的数据，引用会修改：</p><ul><li>变量不再对之前的数据引用；</li><li>变量改为对新赋值的数据引用</li></ul><h2 id="⛄局部变量和全局变量"><a href="#⛄局部变量和全局变量" class="headerlink" title="⛄局部变量和全局变量"></a>⛄局部变量和全局变量</h2><p><strong>局部变量</strong>是在<strong>函数内部</strong>定义的变量，只能在函数内部使用；函数执行结束后，函数内部的局部变量，会被系统回收；不同的函数，可以定义相同名字的局部变量，但是彼此之间不会产生影响；</p><p>局部变量的生命周期：</p><ul><li>所谓<strong>生命周期</strong>就是变量从<strong>被创建</strong>到<strong>被系统回收</strong>的过程；</li><li>局部变量在函数执行时才会被创建；</li><li>函数执行结束后，局部变量被系统回收；</li><li>局部变量在生命周期内，可以用来存储函数内部临时使用到的数据。</li></ul><p><strong>全局变量</strong>是在<strong>函数外部</strong>定义的变量，所有函数内部都可以使用这个变量。（不推荐使用，不易维护）</p><blockquote><p>注意：函数执行时，需要处理变量时，会首先查找函数内部是否存在指定名称的局部变量，如果有，直接使用；如果没有，查找函数外部是否存在指定名称的全局变量，如果有，直接使用；如果还没有，程序报错！！！</p><p>注意：如果在函数内部定义了一个与全局变量同名的局部变量，只是变量名相同，不能直接修改全局变量的值。</p></blockquote><p>如果在函数中需要修改全局变量，需要使用<code>global</code>进行声明。</p><h2 id="⛄函数进阶"><a href="#⛄函数进阶" class="headerlink" title="⛄函数进阶"></a>⛄函数进阶</h2><h3 id="👀函数参数和返回值的作用"><a href="#👀函数参数和返回值的作用" class="headerlink" title="👀函数参数和返回值的作用"></a>👀函数参数和返回值的作用</h3><p>定义函数时，是否接收参数，或者是否返回结果，是根据实际的功能需求来确定的。</p><ul><li>如果函数内部处理的数据不确定，就可以将外界的数据以参数传递到函数内部；</li><li>如果希望一个函数执行完成后，向外界汇报执行结果，就可以增加函数的返回值。</li></ul><blockquote><p>如果全局变量的数据类型是一个可变类型，在函数内部可以使用方法修改全局变量的内容，变量的引用不会改变；在函数内部，通过赋值语句才会修改变量的引用。</p></blockquote><h3 id="👀函数的返回值进阶"><a href="#👀函数的返回值进阶" class="headerlink" title="👀函数的返回值进阶"></a>👀函数的返回值进阶</h3><ul><li>程序开发中，希望一个函数执行结束后，告诉调用者一个结果，以便调用者针对具体的结果做后续的处理；</li><li>返回值是函数完成工作后，最后给调用者的一个结果；</li><li>在函数中使用<code>return</code>关键字可以返回结果；</li><li>调用函数一方，可以使用变量来接收函数的返回结果。</li></ul><blockquote><ul><li>注意：如果一个函数执行后返回多个结果，可以利用元组，元祖括号可以省略；</li><li>返回结果也是一个元组，可以将元组返回值赋值给<strong>一个变量</strong>或者<strong>相同个数的多个变量</strong>。</li></ul></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">my_description</span>():</span><br><span class="line">    stu = <span class="string">&quot;00000001&quot;</span></span><br><span class="line">    name = <span class="string">&quot;xiaotang&quot;</span></span><br><span class="line">    age = <span class="number">20</span></span><br><span class="line">    height = <span class="number">180</span></span><br><span class="line">    <span class="comment"># return (stu, name, age, height) 括号可以省略</span></span><br><span class="line">    <span class="keyword">return</span> stu, name, age, height</span><br><span class="line">stu, name, age, height = my_description()</span><br><span class="line"><span class="built_in">print</span>(stu, name, age, height)</span><br><span class="line">my_des = my_description()</span><br><span class="line"><span class="built_in">print</span>(my_des)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">00000001 xiaotang <span class="number">20</span> <span class="number">180</span></span><br><span class="line">(<span class="string">&#x27;00000001&#x27;</span>, <span class="string">&#x27;xiaotang&#x27;</span>, <span class="number">20</span>, <span class="number">180</span>)</span><br></pre></td></tr></table></figure><p>例如：利用元组交换两个数字</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">10</span></span><br><span class="line">b = <span class="number">5</span></span><br><span class="line"><span class="comment"># (1)使用中间变量</span></span><br><span class="line">c = b</span><br><span class="line">b = a</span><br><span class="line">a = c</span><br><span class="line"><span class="built_in">print</span>(a, b)</span><br><span class="line"><span class="comment"># (2)不使用中间变量</span></span><br><span class="line">a = <span class="number">10</span></span><br><span class="line">b = <span class="number">5</span></span><br><span class="line">a = a + b</span><br><span class="line">b = a - b</span><br><span class="line">a = a - b</span><br><span class="line"><span class="built_in">print</span>(a, b)</span><br><span class="line">a = <span class="number">10</span></span><br><span class="line">b = <span class="number">5</span></span><br><span class="line"><span class="comment"># 利用元祖</span></span><br><span class="line">a, b = b, a</span><br><span class="line"><span class="built_in">print</span>(a, b)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="number">5</span> <span class="number">10</span></span><br><span class="line"><span class="number">5</span> <span class="number">10</span></span><br><span class="line"><span class="number">5</span> <span class="number">10</span></span><br></pre></td></tr></table></figure><h3 id="👀函数的参数进阶"><a href="#👀函数的参数进阶" class="headerlink" title="👀函数的参数进阶"></a>👀函数的参数进阶</h3><h4 id="（1）不可变和可变的参数"><a href="#（1）不可变和可变的参数" class="headerlink" title="（1）不可变和可变的参数"></a><strong>（1）不可变和可变的参数</strong></h4><p>在函数内部，针对参数使用赋值语句，不会影响调用函数时传递的实参变量。</p><ul><li>无论传递的参数是可变还是不可变，只要针对参数使用<strong>赋值语句</strong>，会在函数内部<strong>修改</strong>局部变量的引用，<strong>不会影响</strong>到外部变量的引用。</li><li>如果传递的参数是<strong>可变类型</strong>，在函数内部，使用<strong>方法</strong>修改了数据的内容，同样<strong>会影响</strong>到外部的数据。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">demo1</span>(<span class="params">num, num_list</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;函数内部&quot;</span>)</span><br><span class="line">    <span class="comment"># 赋值语句</span></span><br><span class="line">    num = <span class="number">200</span></span><br><span class="line">    num_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">    <span class="built_in">print</span>(num)</span><br><span class="line">    <span class="built_in">print</span>(num_list)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;函数执行完成&quot;</span>)</span><br><span class="line"></span><br><span class="line">gl_num = <span class="number">99</span></span><br><span class="line">gl_list = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">demo1(gl_num, gl_list)</span><br><span class="line"><span class="built_in">print</span>(gl_num)</span><br><span class="line"><span class="built_in">print</span>(gl_list)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">50</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">demo2</span>(<span class="params">num_list</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;函数内部&quot;</span>)</span><br><span class="line">    <span class="comment"># 赋值语句</span></span><br><span class="line">    num_list.extend([<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>])</span><br><span class="line">    <span class="built_in">print</span>(num_list)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;函数执行完成&quot;</span>)</span><br><span class="line"></span><br><span class="line">gl_list = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">demo2(gl_list)</span><br><span class="line"><span class="built_in">print</span>(gl_list)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">函数内部</span><br><span class="line"><span class="number">200</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">函数执行完成</span><br><span class="line"><span class="number">99</span></span><br><span class="line">[<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">**************************************************</span><br><span class="line">函数内部</span><br><span class="line">[<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br><span class="line">函数执行完成</span><br><span class="line">[<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br></pre></td></tr></table></figure><p>在<code>Python</code>中，列表变量调用<code>+=</code>本质上是在执行列表变量的<code>extend()</code>方法，不会修改变量的引用。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">demo3</span>(<span class="params">num, num_list</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;函数内部&quot;</span>)</span><br><span class="line">    <span class="comment"># 赋值语句</span></span><br><span class="line">    num = <span class="number">200</span></span><br><span class="line">    num_list += [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">    <span class="built_in">print</span>(num)</span><br><span class="line">    <span class="built_in">print</span>(num_list)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;函数执行完成&quot;</span>)</span><br><span class="line"></span><br><span class="line">gl_num = <span class="number">99</span></span><br><span class="line">gl_list = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">demo3(gl_num, gl_list)</span><br><span class="line"><span class="built_in">print</span>(gl_num)</span><br><span class="line"><span class="built_in">print</span>(gl_list)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">函数内部</span><br><span class="line"><span class="number">200</span></span><br><span class="line">[<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">函数执行完成</span><br><span class="line"><span class="number">99</span></span><br><span class="line">[<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure><h4 id="（2）缺省参数"><a href="#（2）缺省参数" class="headerlink" title="（2）缺省参数"></a><strong>（2）缺省参数</strong></h4><ul><li>定义函数时，可以给某个参数指定一个默认值，具有默认值的参数就叫做<strong>缺省参数</strong>；</li><li>调用函数时，如果没有传入<strong>缺省参数</strong>的值，则在函数内部使用定义函数时指定的<strong>参数默认值</strong>；</li><li>函数的缺省参数，将<strong>常见的值</strong>设置为参数的缺省值，从而简化函数的调用。</li></ul><p>例如：对列表排序的方法</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">num_list = [<span class="number">6</span>, <span class="number">4</span>, <span class="number">8</span>]</span><br><span class="line"><span class="comment"># 默认就是升序排序,因为这种应用需求更多</span></span><br><span class="line">num_list.sort()</span><br><span class="line"><span class="built_in">print</span>(num_list)</span><br><span class="line"><span class="comment"># 当需要降序排序时, 才需要传递&quot;reverse&quot;参数</span></span><br><span class="line">num_list.sort(reverse=<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(num_list)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[<span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>]</span><br><span class="line">[<span class="number">8</span>, <span class="number">6</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure><p>缺省参数的注意事项：</p><ul><li>缺省参数的定义位置，必须保证带有默认值的缺省参数在参数列表<strong>末尾</strong>；</li><li>调用带有多个缺省参数的函数，需要<strong>指定参数名</strong>，这样解释器才能知道对应关系。</li></ul><h4 id="（3）多值参数"><a href="#（3）多值参数" class="headerlink" title="（3）多值参数"></a><strong>（3）多值参数</strong></h4><ul><li><p>有时可能需要一个函数能够处理的<strong>参数个数是不确定的</strong>，这个时候，就可以使用<strong>多值参数</strong>。</p></li><li><p><code>python</code> 中有<strong>两种</strong>多值参数：</p><ul><li><p>参数名前增加<strong>一个</strong><code>*</code>，可以接收<strong>元组</strong></p></li><li><p>参数名前增加<strong>两个</strong><code>*</code>，可以接收<strong>字典</strong></p></li></ul></li><li><p>一般在给多值参数命名时，习惯使用以下两个名字</p><ul><li><p><code>*args</code>——存放<strong>元组</strong>参数，前面有<strong>一个</strong><code>*</code></p></li><li><p><code>**Kwargs</code>——存放<strong>字典</strong>参数，前面有<strong>两个</strong><code>*</code></p></li></ul></li><li><p><code>args</code>是<code>arguments</code>的缩写，有变量的含义</p></li><li><p><code>kw</code>是<code>keyword</code>的缩写，<code>kwargs</code> 可以记忆键值对参数</p></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">demo4</span>(<span class="params">num, *args, **kwargs</span>):</span><br><span class="line">    <span class="built_in">print</span>(num)</span><br><span class="line">    <span class="built_in">print</span>(args)</span><br><span class="line">    <span class="built_in">print</span>(kwargs)</span><br><span class="line">demo4(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, name=<span class="string">&quot;小明&quot;</span>, age=<span class="number">18</span>, gender=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line">(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;小明&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">18</span>, <span class="string">&#x27;gender&#x27;</span>: <span class="literal">True</span>&#125;</span><br></pre></td></tr></table></figure><h4 id="（4）元组和字典的拆包（了解）"><a href="#（4）元组和字典的拆包（了解）" class="headerlink" title="（4）元组和字典的拆包（了解）"></a><strong>（4）元组和字典的拆包（了解）</strong></h4><ul><li><p>在调用带有多值参数的函数时，如果希望：</p><ul><li><p>将一个<strong>元组</strong>变量，直接传递给<code>args</code></p></li><li><p>将一个<strong>字典</strong>变量，直接传递给<code>kwargs</code></p></li></ul></li><li><p>可以使用拆包，简化参数的传递，<strong>拆包</strong>的方式是：</p><ul><li><p>在<strong>元组</strong>变量前，增加<strong>一个</strong><code>*</code></p></li><li><p>在<strong>字典</strong>变量前，增加<strong>两个</strong><code>*</code></p></li></ul></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">demo5</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">    <span class="built_in">print</span>(args)</span><br><span class="line">    <span class="built_in">print</span>(kwargs)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 需要将一个元组变量/字典变量传递给函数对应的参数</span></span><br><span class="line">num = (<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line">dict_name = &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;小汤&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">20</span>&#125;</span><br><span class="line"><span class="comment"># 会把num, dict_name作为元组传递给args</span></span><br><span class="line">demo5(num, dict_name)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">50</span>)</span><br><span class="line"><span class="comment"># 元组和字典的拆包</span></span><br><span class="line">demo5(*num, **dict_name)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">((<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>), &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;小汤&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">20</span>&#125;)</span><br><span class="line">&#123;&#125;</span><br><span class="line">**************************************************</span><br><span class="line">(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line">&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;小汤&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">20</span>&#125;</span><br></pre></td></tr></table></figure><h3 id="👀递归函数"><a href="#👀递归函数" class="headerlink" title="👀递归函数"></a>👀递归函数</h3><p><strong>函数内部调用自己</strong>。函数内部可以调用其他函数，当然在函数内部也可以调用自己。</p><p>代码特点：</p><ul><li>函数内部的代码是相同的，只是针对参数不同，处理的结果不同</li><li>当参数满足一个条件时，函数不再执行。这个非常重要，通常被称为递归的出口，否则会出现死循环！</li></ul><p>例如：计算数字累加</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sum_number</span>(<span class="params">num</span>):</span><br><span class="line">    <span class="keyword">if</span> num == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    temp = sum_number(num - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> num + temp</span><br><span class="line"><span class="built_in">print</span>(sum_number(<span class="number">10</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="number">55</span></span><br></pre></td></tr></table></figure><p>笔者不才，请多交流！！！</p><p>参考文献：黑马程序员《Python入门教程完整版》</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Python基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python中的正则表达式详解</title>
      <link href="/2022/09/11/re/"/>
      <url>/2022/09/11/re/</url>
      
        <content type="html"><![CDATA[<h2 id="⛄正则表达式概述"><a href="#⛄正则表达式概述" class="headerlink" title="⛄正则表达式概述"></a>⛄正则表达式概述</h2><p>正则表达式（<code>Regular Expression</code>）是强大、便捷、高效的文本处理工具。正则表达式本身，加上如同一门袖珍编程语言的通用模式表示法（<code>general pattern notation</code>），赋予使用者描述和分析文本的能力。配合上特定工具提供的额外支持，正则表达式能够添加、删除、分离、叠加、插入和修整各种类型的文本和数据。</p><p>正则表达式使用单个字符串来描述、匹配一系列匹配某个句法规则的字符串。正则表达式是繁琐的，但它是强大的，学会之后的应用会让你除了提高效率外，会给你带来绝对的成就感。正则表达式的使用难度只相当于文本编辑器的搜索命令，但功能却与完整的文本处理语言一样强大。正则表达式的特点是：</p><ul><li>灵活性、逻辑性和功能性非常强；</li><li>可以迅速地用极简单的方式达到字符串的复杂控制；</li><li>对于刚接触的人来说，比较晦涩难懂。</li></ul><h2 id="⛄RE语法中特殊元素"><a href="#⛄RE语法中特殊元素" class="headerlink" title="⛄RE语法中特殊元素"></a>⛄<code>RE</code>语法中特殊元素</h2><h3 id="👀-匹配所有字符"><a href="#👀-匹配所有字符" class="headerlink" title="👀.匹配所有字符"></a>👀<code>.</code>匹配所有字符</h3><p><code>.</code>表示要匹配除了换行符之外的<strong>任何单个字符</strong>。其中点代表了任意的一个字符，注意是一个字符。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="built_in">str</span> = re.<span class="built_in">compile</span>(<span class="string">r&quot;.&quot;</span>).findall(<span class="string">&quot;xiaotangsmile&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[<span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;t&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;n&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;s&#x27;</span>, <span class="string">&#x27;m&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;e&#x27;</span>]</span><br></pre></td></tr></table></figure><h3 id="👀-重复匹配任意次"><a href="#👀-重复匹配任意次" class="headerlink" title="👀*重复匹配任意次"></a>👀<code>*</code>重复匹配任意次</h3><p><code>*</code> 表示匹配前面的子表达式<strong>任意次</strong>，包括<strong>0</strong>次。</p><blockquote><p>注意， .* 在正则表达式中非常常见，表示匹配任意字符任意次数。当然这个 * 前面不是非得是点，也可以是其它字符。</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">str1 = re.<span class="built_in">compile</span>(<span class="string">r&quot;ia*&quot;</span>).findall(<span class="string">&quot;xiaaaaaaaotangsmile&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(str1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[<span class="string">&#x27;iaaaaaaa&#x27;</span>, <span class="string">&#x27;i&#x27;</span>]</span><br></pre></td></tr></table></figure><h3 id="👀-重复匹配多次"><a href="#👀-重复匹配多次" class="headerlink" title="👀+重复匹配多次"></a>👀<code>+</code>重复匹配多次</h3><p><code>+</code>表示匹配前面的子表达式一次或多次，不包括0次。即：表示至少匹配1次</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">str2 = re.<span class="built_in">compile</span>(<span class="string">r&quot;ia+&quot;</span>).findall(<span class="string">&quot;xiaaaaaaaotangsmile&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(str2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[<span class="string">&#x27;iaaaaaaa&#x27;</span>]</span><br></pre></td></tr></table></figure><h3 id="👀-匹配0-1次"><a href="#👀-匹配0-1次" class="headerlink" title="👀?匹配0-1次"></a>👀<code>?</code>匹配0-1次</h3><p><code>?</code> 表示匹配前面的子表达式0次或1次。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">str3 = re.<span class="built_in">compile</span>(<span class="string">r&quot;ia?&quot;</span>).findall(<span class="string">&quot;xiaaaaaaaotangsmile&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(str3)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[<span class="string">&#x27;ia&#x27;</span>, <span class="string">&#x27;i&#x27;</span>]</span><br></pre></td></tr></table></figure><h3 id="👀-匹配指定次数"><a href="#👀-匹配指定次数" class="headerlink" title="👀{}匹配指定次数"></a>👀<code>&#123;&#125;</code>匹配指定次数</h3><p><code>&#123;&#125;</code>花括号表示前面的字符匹配 指定的次数。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">str4 = re.<span class="built_in">compile</span>(<span class="string">r&quot;ia&#123;2,5&#125;&quot;</span>).findall(<span class="string">&quot;xiaaaaaaaotangsmile&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(str4)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[<span class="string">&#x27;iaaaaa&#x27;</span>]</span><br></pre></td></tr></table></figure><h3 id="👀-匹配几个字符之一"><a href="#👀-匹配几个字符之一" class="headerlink" title="👀[]匹配几个字符之一"></a>👀<code>[]</code>匹配几个字符之一</h3><p><code>[]</code>方括号表示要匹配指定的几个字符之一。比如：</p><ul><li>[abc] 可以匹配 a, b, 或者c里面的任意一个字符，等价于 [a-c]；</li><li>[a-c] 中间的 -表示一个范围从a到c；</li><li>如果你想匹配所有的小写字母，可以使用[a-z]；</li></ul><ol><li>一些元字符在方括号内失去了本意，变得和普通字符一样了。例如：[evol.] 匹配 <code>evol.</code> 里面任意一个字符，这里 <code>.</code> 在括号里面不在表示匹配任意字符了，而就是表示匹配 <code>.</code> 这个字符。</li><li>如果在方括号中使用<code>^</code>，表示非方括号里面的字符集合。例如：<code>[^\d]</code>表示，选择非数字的字符。</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">str5 = re.<span class="built_in">compile</span>(<span class="string">r&quot;i[a-z]&quot;</span>).findall(<span class="string">&quot;xiaaaaaaaotangsmile&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(str5)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[<span class="string">&#x27;ia&#x27;</span>, <span class="string">&#x27;il&#x27;</span>]</span><br></pre></td></tr></table></figure><h3 id="👀贪婪模式和贪婪模式"><a href="#👀贪婪模式和贪婪模式" class="headerlink" title="👀贪婪模式和贪婪模式"></a>👀贪婪模式和贪婪模式</h3><p>在正则表达式中， ‘<code>*</code>‘, ‘<code>+</code>‘, ‘<code>?</code>‘ 都是贪婪地，使用他们时，会尽可能多的匹配内容。</p><p>解决这个问题，就需要使用非贪婪模式，也就是在星号后面加上<code>?</code> ，变成这样<code>&lt;.*?&gt;</code></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">str6 = re.<span class="built_in">compile</span>(<span class="string">r&quot;&lt;.*&gt;&quot;</span>).findall(<span class="string">&quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;Title&lt;/title&gt;&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(str6)</span><br><span class="line">str7 = re.<span class="built_in">compile</span>(<span class="string">r&quot;&lt;.*?&gt;&quot;</span>).findall(<span class="string">&quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;Title&lt;/title&gt;&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(str7)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[<span class="string">&#x27;&lt;html&gt;&lt;head&gt;&lt;title&gt;Title&lt;/title&gt;&#x27;</span>]</span><br><span class="line">[<span class="string">&#x27;&lt;html&gt;&#x27;</span>, <span class="string">&#x27;&lt;head&gt;&#x27;</span>, <span class="string">&#x27;&lt;title&gt;&#x27;</span>, <span class="string">&#x27;&lt;/title&gt;&#x27;</span>]</span><br></pre></td></tr></table></figure><h3 id="👀元字符转义"><a href="#👀元字符转义" class="headerlink" title="👀元字符转义"></a>👀元字符转义</h3><p>反斜杠 <code>\</code> 在正则表达式中有多种用途。</p><p>如果，我们这样写正则表达式 <code>.*.</code> ，聪明的你肯定发现不对劲。因为点是一个元字符，直接出现在正则表达式中，表示匹配任意的单个字符，不能表示<code>.</code>这个字符本身的意思了。</p><blockquote><p>怎么办呢？如果我们要搜索的内容本身就包含元字符，就可以使用<strong>反斜杠</strong>进行转义。这里我们就应用使用这样的表达式： <code>.*\.</code></p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">str8 = re.<span class="built_in">compile</span>(<span class="string">r&quot;[a-zA-Z0-9]*@[1-9]&#123;3&#125;\.com&quot;</span>).findall(<span class="string">&quot;xiao@163.cn,tangsmile@126.com&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(str8)</span><br><span class="line">str9 = re.<span class="built_in">compile</span>(<span class="string">r&quot;[\w]*@[1-9]&#123;3&#125;\.com&quot;</span>).findall(<span class="string">&quot;xiaoxiao@163.cn,tangsmile@126.com&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(str9)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[<span class="string">&#x27;tangsmile@126.com&#x27;</span>]</span><br><span class="line">[<span class="string">&#x27;tangsmile@126.com&#x27;</span>]</span><br></pre></td></tr></table></figure><h3 id="👀特殊字符类"><a href="#👀特殊字符类" class="headerlink" title="👀特殊字符类"></a>👀特殊字符类</h3><p>反斜杠后面接一些字符，表示匹配某种类型的一个字符。</p><table><thead><tr><th><strong>实例</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><code>\d</code></td><td>匹配任意一个数字字符。等价于[<code>0-9]</code>。</td></tr><tr><td><code>\D</code></td><td>匹配任意一个非数字字符。等价于[<code>^0-9</code>]。</td></tr><tr><td><code>\s</code></td><td>匹配任意一个空白字符，包括空格、制表符、换页符等等。等价于[<code>\f\n\r\t\v</code>]。</td></tr><tr><td><code>\S</code></td><td>匹配任意一个非空白字符。等价于[<code>^\f\n\r\t\v</code>]。</td></tr><tr><td><code>\w</code></td><td>匹配任意一个文字字符，包括大小写字母、数字、下划线。等价于[<code>A-Za-z0-9_</code>]。</td></tr><tr><td><code>\W</code></td><td>匹配任意一个非文字字符。等价于[<code>^A-Za-z0-9_</code>]。</td></tr></tbody></table><p>反斜杠也可以用在方括号里面，例如： [<code>\s,.</code>] 表示匹配 任何空白字符，或者逗号，或者点。</p><h3 id="👀起始、结尾位置和单-x2F-行模式"><a href="#👀起始、结尾位置和单-x2F-行模式" class="headerlink" title="👀起始、结尾位置和单&#x2F;行模式"></a>👀起始、结尾位置和单&#x2F;行模式</h3><p><code>^</code> 在方括号里面表示非；除此之外，<code>^</code>表示匹配文本的开头位置。</p><p>正则表达式可以设定单行模式和多行模式</p><ul><li>如果是单行模式，表示匹配整个文本的开头位置。</li><li>如果是多行模式，表示匹配文本每行的开头位置。</li></ul><p><code>$</code> 表示匹配文本的 结尾 位置。</p><ul><li>如果是单行模式，表示匹配整个文本的结尾位置。</li><li>如果是多行模式，表示匹配文本每行的结尾位置。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">content = <span class="string">&#x27;&#x27;&#x27;001-小汤-99</span></span><br><span class="line"><span class="string">002-小明-98</span></span><br><span class="line"><span class="string">003-小红-97&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># 注意，compile 的第二个参数 re.M ，指明了使用多行模式，</span></span><br><span class="line">str10 = re.<span class="built_in">compile</span>(<span class="string">r&#x27;^\d+&#x27;</span>, re.M).findall(content)</span><br><span class="line"><span class="built_in">print</span>(str10)</span><br><span class="line">str11 = re.<span class="built_in">compile</span>(<span class="string">r&#x27;^\d+&#x27;</span>).findall(content)</span><br><span class="line"><span class="built_in">print</span>(str11)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[<span class="string">&#x27;001&#x27;</span>, <span class="string">&#x27;002&#x27;</span>, <span class="string">&#x27;003&#x27;</span>]</span><br><span class="line">[<span class="string">&#x27;001&#x27;</span>]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">content = <span class="string">&#x27;&#x27;&#x27;001-小汤-99</span></span><br><span class="line"><span class="string">002-小明-98</span></span><br><span class="line"><span class="string">003-小红-97&#x27;&#x27;&#x27;</span></span><br><span class="line">str12 = re.<span class="built_in">compile</span>(<span class="string">r&#x27;\d+$&#x27;</span>, re.M).findall(content)</span><br><span class="line"><span class="built_in">print</span>(str12)</span><br><span class="line">str13 = re.<span class="built_in">compile</span>(<span class="string">r&#x27;\d+$&#x27;</span>).findall(content)</span><br><span class="line"><span class="built_in">print</span>(str13)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[<span class="string">&#x27;99&#x27;</span>, <span class="string">&#x27;98&#x27;</span>, <span class="string">&#x27;97&#x27;</span>]</span><br><span class="line">[<span class="string">&#x27;97&#x27;</span>]</span><br></pre></td></tr></table></figure><h3 id="👀-竖线"><a href="#👀-竖线" class="headerlink" title="👀|竖线"></a>👀<code>|</code>竖线</h3><p>竖线表示<strong>匹配其中之一</strong> 。特别要注意的是，竖线在正则表达式的优先级是最低的，这就意味着，竖线隔开的部分是一个整体。</p><p>比如，小明|王 表示要匹配：<strong>小明</strong>或者<strong>王</strong> ，而不是 <strong>小明</strong> 或者 <strong>小王</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">str14 = re.<span class="built_in">compile</span>(<span class="string">r&#x27;小汤|明|红|王&#x27;</span>).findall(<span class="string">&quot;小汤小明小红小王&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(str14)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[<span class="string">&#x27;小汤&#x27;</span>, <span class="string">&#x27;明&#x27;</span>, <span class="string">&#x27;红&#x27;</span>, <span class="string">&#x27;王&#x27;</span>]</span><br></pre></td></tr></table></figure><h3 id="👀-括号"><a href="#👀-括号" class="headerlink" title="👀()括号"></a>👀<code>()</code>括号</h3><p>括号称之为正则表达式的组选择。组就是把正则表达式匹配的内容里面 中的某些部分标记为某个组。我们可以在 正则表达式中标记多个组。</p><blockquote><p>为什么要有组的概念呢？因为我们往往需要提取已经匹配的内容里面的某些部分。</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">content = <span class="string">&#x27;&#x27;&#x27;001小汤,你最棒</span></span><br><span class="line"><span class="string">002小明,你更棒</span></span><br><span class="line"><span class="string">003小红,你较棒&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># 输出包含逗号</span></span><br><span class="line">str15 = re.<span class="built_in">compile</span>(<span class="string">r&#x27;^.*,&#x27;</span>).findall(content)</span><br><span class="line"><span class="built_in">print</span>(str15)</span><br><span class="line"><span class="comment"># 输出不包含逗号</span></span><br><span class="line">str16 = re.<span class="built_in">compile</span>(<span class="string">r&#x27;^(.*),&#x27;</span>).findall(content)</span><br><span class="line"><span class="built_in">print</span>(str16)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[<span class="string">&#x27;001小汤,&#x27;</span>]</span><br><span class="line">[<span class="string">&#x27;001小汤&#x27;</span>]</span><br></pre></td></tr></table></figure><h3 id="👀点匹配换行符"><a href="#👀点匹配换行符" class="headerlink" title="👀点匹配换行符"></a>👀点匹配换行符</h3><p>点是不匹配换行符的，可是有时候，特征字符串就是跨行的，比如要找出下面文字中所有的职位名称。</p><p>设置点也匹配换行符：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用re.S和re.DOTALL匹配出来的内容都是一样的,都表示包括换行符内容的匹配</span></span><br><span class="line"><span class="comment"># re.DOTALL</span></span><br><span class="line"><span class="comment"># re.S</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line">content = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">&lt;div class=&quot;el&quot;&gt;</span></span><br><span class="line"><span class="string">        &lt;p class=&quot;t1&quot;&gt;           </span></span><br><span class="line"><span class="string">            &lt;span&gt;</span></span><br><span class="line"><span class="string">                &lt;a&gt;Python开发工程师&lt;/a&gt;</span></span><br><span class="line"><span class="string">            &lt;/span&gt;</span></span><br><span class="line"><span class="string">        &lt;/p&gt;</span></span><br><span class="line"><span class="string">        &lt;span class=&quot;t2&quot;&gt;南京&lt;/span&gt;</span></span><br><span class="line"><span class="string">        &lt;span class=&quot;t3&quot;&gt;1.5-2万/月&lt;/span&gt;</span></span><br><span class="line"><span class="string">&lt;/div&gt;</span></span><br><span class="line"><span class="string">&lt;div class=&quot;el&quot;&gt;</span></span><br><span class="line"><span class="string">        &lt;p class=&quot;t1&quot;&gt;</span></span><br><span class="line"><span class="string">            &lt;span&gt;</span></span><br><span class="line"><span class="string">                &lt;a&gt;java开发工程师&lt;/a&gt;</span></span><br><span class="line"><span class="string">            &lt;/span&gt;</span></span><br><span class="line"><span class="string">&lt;/p&gt;</span></span><br><span class="line"><span class="string">        &lt;span class=&quot;t2&quot;&gt;苏州&lt;/span&gt;</span></span><br><span class="line"><span class="string">        &lt;span class=&quot;t3&quot;&gt;1.5-2/月&lt;/span&gt;</span></span><br><span class="line"><span class="string">&lt;/div&gt;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">str16 = re.<span class="built_in">compile</span>(<span class="string">r&#x27;class=\&quot;t1\&quot;&gt;.*?&lt;a&gt;(.*?)&lt;/a&gt;&#x27;</span>, re.S).findall(content)</span><br><span class="line"><span class="built_in">print</span>(str16)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[<span class="string">&#x27;Python开发工程师&#x27;</span>, <span class="string">&#x27;java开发工程师&#x27;</span>]</span><br></pre></td></tr></table></figure><h2 id="⛄常用的函数"><a href="#⛄常用的函数" class="headerlink" title="⛄常用的函数"></a>⛄常用的函数</h2><p><code>re</code>模块使<code>Python</code>语言拥有全部的正则表达式功能。</p><ul><li><code>compile()</code>函数根据一个模式字符串和可选的标志参数生成一个正则表达式对象,该对象拥有一系列方法用于正则表达式匹配和替换。</li><li><code>re</code> 模块也提供了与这些方法功能完全一致的函数，这些函数使用一个模式字符串做为它们的第一个参数。</li></ul><h3 id="👀re-match"><a href="#👀re-match" class="headerlink" title="👀re.match()"></a>👀re.match()</h3><p><code>re.match()</code>尝试从字符串的<strong>起始位置匹配一个模式</strong>，如果不是起始位置匹配成功的话，就返回<code>none</code>。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 函数语法</span></span><br><span class="line">re.match(pattern, string, flags=<span class="number">0</span>)</span><br><span class="line"><span class="comment"># 参数</span></span><br><span class="line">pattern 匹配的正则表达式</span><br><span class="line">string  要匹配的字符串。</span><br><span class="line">flags 标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等。</span><br></pre></td></tr></table></figure><p>匹配成功&#96;&#96;re.match()<code>方法**返回一个匹配的</code>Match<code>对象**，而不是匹配的正则表达式，否则返回</code>None<code>。通过</code>span()<code>可以获取匹配的位置，使用</code>group(num)<code>或</code>groups()&#96; 匹配对象函数来获取匹配表达式。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="comment"># 在起始位置匹配</span></span><br><span class="line"><span class="built_in">print</span>(re.match(<span class="string">&#x27;www&#x27;</span>, <span class="string">&#x27;www.runoob.com&#x27;</span>).span())</span><br><span class="line"><span class="comment"># 不在起始位置匹配</span></span><br><span class="line"><span class="built_in">print</span>(re.match(<span class="string">&#x27;com&#x27;</span>, <span class="string">&#x27;www.runoob.com&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">(<span class="number">0</span>, <span class="number">3</span>)</span><br><span class="line"><span class="literal">None</span></span><br></pre></td></tr></table></figure><h3 id="👀re-search"><a href="#👀re-search" class="headerlink" title="👀re,search()"></a>👀re,search()</h3><p><code>re.search()</code>扫描<strong>整个字符串并返回第一个成功的匹配</strong>。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 函数语法</span></span><br><span class="line">re.search(pattern, string, flags=<span class="number">0</span>)</span><br><span class="line"><span class="comment"># 参数</span></span><br><span class="line">pattern 匹配的正则表达式</span><br><span class="line">string  要匹配的字符串。</span><br><span class="line">flags 标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等。</span><br></pre></td></tr></table></figure><p>匹配成功<code>re.search()</code>方法<strong>返回一个匹配的<code>Match</code>对象</strong>，而不是匹配的正则表达式，否则返回<code>None</code>。通过<code>span()</code>可以获取匹配的位置，使用<code>group(num)</code> 或<code>groups()</code> 匹配对象函数来获取匹配表达式。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="comment"># 在起始位置匹配</span></span><br><span class="line"><span class="built_in">print</span>(re.search(<span class="string">&#x27;www&#x27;</span>, <span class="string">&#x27;www.runoob.com&#x27;</span>).span())</span><br><span class="line"><span class="comment"># 不在起始位置匹配</span></span><br><span class="line"><span class="built_in">print</span>(re.search(<span class="string">&#x27;com&#x27;</span>, <span class="string">&#x27;www.runoob.com&#x27;</span>).span())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">(<span class="number">0</span>, <span class="number">3</span>)</span><br><span class="line">(<span class="number">11</span>, <span class="number">14</span>)</span><br></pre></td></tr></table></figure><blockquote><p><code>re.match()</code>只匹配字符串的开始，如果字符串开始不符合正则表达式，则匹配失败，函数返回 <code>None</code>，而<code>re.search()</code>匹配整个字符串，直到找到一个匹配。</p></blockquote><h3 id="👀re-sub-检索和替换"><a href="#👀re-sub-检索和替换" class="headerlink" title="👀re.sub()检索和替换"></a>👀re.sub()检索和替换</h3><p><code>Python</code>的<code>re</code>模块提供了<code>re.sub()</code>用于替换字符串中的匹配项。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 函数语法：</span></span><br><span class="line">re.sub(pattern, repl, string, count=<span class="number">0</span>, flags=<span class="number">0</span>)</span><br><span class="line"><span class="comment"># 参数</span></span><br><span class="line">pattern: 正则中的模式字符串。</span><br><span class="line">repl: 替换的字符串，也可为一个函数。</span><br><span class="line">string: 要被查找替换的原始字符串。</span><br><span class="line">count: 模式匹配后替换的最大次数，默认<span class="number">0</span>表示替换所有的匹配。</span><br><span class="line">flags: 编译时用的匹配模式，数字形式。</span><br><span class="line"></span><br><span class="line"><span class="comment"># 前三个为必选参数，后两个为可选参数；返回替换后的字符串。</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re </span><br><span class="line">phone = <span class="string">&quot;2004-959-559 # 这是一个电话号码&quot;</span> </span><br><span class="line"><span class="comment"># 删除注释 </span></span><br><span class="line">num = re.sub(<span class="string">r&#x27;#.*$&#x27;</span>, <span class="string">&quot;&quot;</span>, phone) </span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;电话号码 : &quot;</span>, num) </span><br><span class="line"><span class="comment"># 移除非数字的内容 </span></span><br><span class="line">num = re.sub(<span class="string">r&#x27;\D&#x27;</span>, <span class="string">&quot;&quot;</span>, phone) </span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;电话号码 : &quot;</span>, num)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">电话号码 :  <span class="number">2004</span>-<span class="number">959</span>-<span class="number">559</span> </span><br><span class="line">电话号码 :  <span class="number">2004959559</span></span><br></pre></td></tr></table></figure><h3 id="👀compile"><a href="#👀compile" class="headerlink" title="👀compile()"></a>👀compile()</h3><p><code>compile()</code>函数用于编译正则表达式，生成一个正则表达式（<code>Pattern</code>）对象，供<code>match()</code>和 <code>search()</code>这两个函数使用。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 语法格式</span></span><br><span class="line">re.<span class="built_in">compile</span>(pattern[, flags])</span><br><span class="line"><span class="comment"># 参数</span></span><br><span class="line">pattern: 一个字符串形式的正则表达式</span><br><span class="line">flags: 可选，表示匹配模式，比如忽略大小写，多行模式等，具体参数为：</span><br><span class="line">re.I 忽略大小写</span><br><span class="line">re.L 表示特殊字符集\w,\W,\b,\B,\s,\S依赖于当前环境</span><br><span class="line">re.M 多行模式</span><br><span class="line">re.S 即为<span class="string">&#x27;.&#x27;</span>匹配包括换行符在内的任意字符（<span class="string">&#x27;.&#x27;</span>不包括换行符）</span><br><span class="line">re.U 表示特殊字符集\w,\W,\b,\B,\d,\D,\s,\S依赖于Unicode字符属性数据库</span><br><span class="line">re.X 为了增加可读性，忽略空格和<span class="string">&#x27; # &#x27;</span>后面的注释</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pattern = re.<span class="built_in">compile</span>(<span class="string">r&#x27;([a-z]+) ([a-z]+)&#x27;</span>, re.I) <span class="comment"># re.I表示忽略大小写 </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m = pattern.match(<span class="string">&#x27;Hello World Wide Web&#x27;</span>) </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>( m ) <span class="comment"># 匹配成功，返回一个 Match 对象 </span></span><br><span class="line">&lt;_sre.SRE_Match <span class="built_in">object</span> at <span class="number">0x10bea83e8</span>&gt; </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m.group(<span class="number">0</span>) <span class="comment"># 返回匹配成功的整个子串 </span></span><br><span class="line"><span class="string">&#x27;Hello World&#x27;</span> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m.span(<span class="number">0</span>)  <span class="comment"># 返回匹配成功的整个子串的索引 </span></span><br><span class="line">(<span class="number">0</span>, <span class="number">11</span>) </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m.group(<span class="number">1</span>) <span class="comment"># 返回第一个分组匹配成功的子串 </span></span><br><span class="line"><span class="string">&#x27;Hello&#x27;</span></span><br><span class="line"> &gt;&gt;&gt; m.span(<span class="number">1</span>) <span class="comment"># 返回第一个分组匹配成功的子串的索引</span></span><br><span class="line"> (<span class="number">0</span>, <span class="number">5</span>) </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m.group(<span class="number">2</span>) <span class="comment"># 返回第二个分组匹配成功的子串 </span></span><br><span class="line"><span class="string">&#x27;World&#x27;</span> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m.span(<span class="number">2</span>)  <span class="comment"># 返回第二个分组匹配成功的子串索引</span></span><br><span class="line"> (<span class="number">6</span>, <span class="number">11</span>) </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m.groups() <span class="comment"># 等价于 (m.group(1), m.group(2), ...) </span></span><br><span class="line">(<span class="string">&#x27;Hello&#x27;</span>, <span class="string">&#x27;World&#x27;</span>) </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m.group(<span class="number">3</span>) <span class="comment"># 不存在第三个分组</span></span><br><span class="line"> Traceback (most recent call last): File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt; IndexError: no such group</span><br></pre></td></tr></table></figure><h3 id="👀findall"><a href="#👀findall" class="headerlink" title="👀findall()"></a>👀findall()</h3><p>在字符串中找到正则表达式所匹配的所有子串，并<strong>返回一个列表</strong>，如果有多个匹配模式，则返回元组列表，如果没有找到匹配的，则返回空列表。</p><blockquote><p>注意： match()和search()是匹配一次，findall()匹配所有。</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 语法格式</span></span><br><span class="line">re.findall(pattern, string, flags=<span class="number">0</span>)</span><br><span class="line">或</span><br><span class="line">pattern.findall(string[, pos[, endpos]])</span><br><span class="line"><span class="comment"># 参数</span></span><br><span class="line">pattern 匹配模式。</span><br><span class="line">string  待匹配的字符串。</span><br><span class="line">pos 可选参数，指定字符串的起始位置，默认为 <span class="number">0</span>。</span><br><span class="line">endpos 可选参数，指定字符串的结束位置，默认为字符串的长度。</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># (1)查找字符串中的所有数字</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line">result1 = re.findall(<span class="string">r&#x27;\d+&#x27;</span>,<span class="string">&#x27;runoob 123 google 456&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(result1)</span><br><span class="line">pattern = re.<span class="built_in">compile</span>(<span class="string">r&#x27;\d+&#x27;</span>) <span class="comment"># 查找数字</span></span><br><span class="line">result2 = pattern.findall(<span class="string">&#x27;runoob 123 google 456&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(result2)</span><br><span class="line">result3 = pattern.findall(<span class="string">&#x27;run88oob123google456&#x27;</span>, <span class="number">0</span>, <span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(result3)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[<span class="string">&#x27;123&#x27;</span>, <span class="string">&#x27;456&#x27;</span>]</span><br><span class="line">[<span class="string">&#x27;123&#x27;</span>, <span class="string">&#x27;456&#x27;</span>]</span><br><span class="line">[<span class="string">&#x27;88&#x27;</span>, <span class="string">&#x27;12&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 多个匹配模式，返回元组列表</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line">result = re.findall(<span class="string">r&#x27;(\w+)=(\d+)&#x27;</span>, <span class="string">&#x27;set width=20 and height=10&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[(<span class="string">&#x27;width&#x27;</span>, <span class="string">&#x27;20&#x27;</span>), (<span class="string">&#x27;height&#x27;</span>, <span class="string">&#x27;10&#x27;</span>)]</span><br></pre></td></tr></table></figure><h3 id="👀re-finditer"><a href="#👀re-finditer" class="headerlink" title="👀re.finditer()"></a>👀re.finditer()</h3><p>和 <code>findall(</code>)类似，在字符串中找到正则表达式所匹配的所有子串，并把它们作为一个<strong>迭代器</strong>返回。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 语法格式</span></span><br><span class="line">re.finditer(pattern, string, flags=<span class="number">0</span>)</span><br><span class="line"><span class="comment"># 参数</span></span><br><span class="line">pattern 匹配的正则表达式</span><br><span class="line">string 要匹配的字符串。</span><br><span class="line">flags 标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等。</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">it = re.finditer(<span class="string">r&quot;\d+&quot;</span>,<span class="string">&quot;12a32bc43jf3&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(it)</span><br><span class="line"><span class="keyword">for</span> match <span class="keyword">in</span> it:</span><br><span class="line"><span class="built_in">print</span> (match.group())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">&lt;callable_iterator <span class="built_in">object</span> at <span class="number">0x000001FA199BA0C8</span>&gt;</span><br><span class="line"><span class="number">12</span> </span><br><span class="line"><span class="number">32</span> </span><br><span class="line"><span class="number">43</span> </span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><h3 id="👀re-split"><a href="#👀re-split" class="headerlink" title="👀re.split()"></a>👀re.split()</h3><p><code>split()</code>方法按照能够匹配的子串将字符串分割后，<strong>返回列表</strong>。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 语法格式</span></span><br><span class="line">re.split(pattern, string[, maxsplit=<span class="number">0</span>, flags=<span class="number">0</span>])</span><br><span class="line"><span class="comment"># 参数</span></span><br><span class="line">pattern 匹配的正则表达式</span><br><span class="line">string 要匹配的字符串。</span><br><span class="line">maxsplit 分割次数，maxsplit=<span class="number">1</span> 分割一次，默认为 <span class="number">0</span>，不限制次数。</span><br><span class="line">flags 标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等。</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="keyword">import</span> re </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.split(<span class="string">&#x27;\W+&#x27;</span>, <span class="string">&#x27;runoob, runoob, runoob.&#x27;</span>) </span><br><span class="line">[<span class="string">&#x27;runoob&#x27;</span>, <span class="string">&#x27;runoob&#x27;</span>, <span class="string">&#x27;runoob&#x27;</span>, <span class="string">&#x27;&#x27;</span>] </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.split(<span class="string">&#x27;(\W+)&#x27;</span>, <span class="string">&#x27; runoob, runoob, runoob.&#x27;</span>) </span><br><span class="line">[<span class="string">&#x27;&#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;runoob&#x27;</span>, <span class="string">&#x27;, &#x27;</span>, <span class="string">&#x27;runoob&#x27;</span>, <span class="string">&#x27;, &#x27;</span>, <span class="string">&#x27;runoob&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;&#x27;</span>] </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.split(<span class="string">&#x27;\W+&#x27;</span>, <span class="string">&#x27; runoob, runoob, runoob.&#x27;</span>, <span class="number">1</span>) </span><br><span class="line">[<span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;runoob, runoob, runoob.&#x27;</span>] </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.split(<span class="string">&#x27;ab*&#x27;</span>, <span class="string">&#x27;hello world&#x27;</span>) <span class="comment"># 对于一个找不到匹配的字符串而言，split 不会对其作出分割</span></span><br><span class="line">[<span class="string">&#x27;hello world&#x27;</span>]</span><br></pre></td></tr></table></figure><h3 id="👀正则表达式对象"><a href="#👀正则表达式对象" class="headerlink" title="👀正则表达式对象"></a>👀正则表达式对象</h3><p><strong>re.RegexObject</strong></p><ul><li><code>re.compile()</code> 返回 <code>RegexObject</code> 对象。</li></ul><p><strong>re.MatchObject</strong></p><ul><li><p><code>group()</code> 返回被 <code>RE</code> 匹配的字符串。</p><ul><li><p><code>start()</code> 返回匹配开始的位置</p></li><li><p><code>end()</code> 返回匹配结束的位置</p></li><li><p><code>span()</code> 返回一个元组包含匹配 (开始,结束) 的位置</p></li></ul></li></ul><h3 id="👀正则表达式修饰符-可选标志"><a href="#👀正则表达式修饰符-可选标志" class="headerlink" title="👀正则表达式修饰符-可选标志"></a>👀正则表达式修饰符-可选标志</h3><p>正则表达式可以包含一些可选标志修饰符来控制匹配的模式。修饰符被指定为一个可选的标志。多个标志可以通过按位 <code>OR(|)</code> 它们来指定。如<code>re.I</code> | <code>re.M</code> 被设置成 I 和 M 标志：</p><table><thead><tr><th align="center">修饰符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="center"><code>re.I</code></td><td align="left">使匹配对大小写不敏感</td></tr><tr><td align="center"><code>re.L</code></td><td align="left">做本地化识别（local-aware）匹配</td></tr><tr><td align="center"><code>re.M</code></td><td align="left">多行匹配，影响^和$</td></tr><tr><td align="center"><code>re.S</code></td><td align="left">使<code>.</code>匹配包括换行在内的所有字符</td></tr><tr><td align="center"><code>re.U</code></td><td align="left">根据<code>Unicode</code>字符集解析字符。这个标志影响<code>\w</code>，<code>\W</code>，<code>\b</code>，<code>\B</code></td></tr><tr><td align="center"><code>re.X</code></td><td align="left">该标志通过给予你更灵活的格式以便你将正则表达式写得更易于理解。</td></tr></tbody></table><h3 id="👀正则表达式实例"><a href="#👀正则表达式实例" class="headerlink" title="👀正则表达式实例"></a>👀正则表达式实例</h3><p>（1）字符匹配</p><table><thead><tr><th><strong>实例</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><code>python</code></td><td>匹配 “<code>python</code>“.</td></tr></tbody></table><p>（2）字符类</p><table><thead><tr><th><strong>实例</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><code>[Pp]ython</code></td><td>匹配 “<code>Python</code>“ 或 “<code>python</code>“</td></tr><tr><td><code>rub[ye]</code></td><td>匹配 “<code>ruby</code>“ 或 “<code>rube</code>“</td></tr><tr><td><code>[aeiou]</code></td><td>匹配中括号内的任意一个字母</td></tr><tr><td><code>[0-9]</code></td><td>匹配任何数字。类似于 [<code>0123456789</code>]</td></tr><tr><td><code>[a-z]</code></td><td>匹配任何小写字母</td></tr><tr><td><code>[A-Z]</code></td><td>匹配任何大写字母</td></tr><tr><td><code>[a-zA-Z0-9]</code></td><td>匹配任何字母及数字</td></tr><tr><td><code>[^aeiou]</code></td><td>除了<code>aeiou</code>字母以外的所有字符</td></tr><tr><td><code>[^0-9]</code></td><td>匹配除了数字外的字符</td></tr></tbody></table><p>（3）特殊字符类</p><table><thead><tr><th><strong>实例</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><code>.</code></td><td>匹配除 “<code>\n</code>“ 之外的任何单个字符。要匹配包括 ‘<code>\n</code>‘ 在内的任何字符，请使用象 ‘<code>[.\n]</code>‘ 的模式。</td></tr><tr><td><code>\d</code></td><td>匹配一个数字字符。等价于[<code>0-9</code>]。</td></tr><tr><td><code>\D</code></td><td>匹配一个非数字字符。等价于[<code>^0-9</code>]。</td></tr><tr><td><code>\s</code></td><td>匹配任何空白字符，包括空格、制表符、换页符等等。等价于[<code>\f\n\r\t\v</code>]。</td></tr><tr><td><code>\S</code></td><td>匹配任何非空白字符。等价于[<code>^\f\n\r\t\v</code>]。</td></tr><tr><td><code>\w</code></td><td>匹配包括下划线的任何单词字符。等价于[<code>A-Za-z0-9_</code>]。</td></tr><tr><td><code>\W</code></td><td>匹配任何非单词字符。等价于[<code>^A-Za-z0-9_</code>]。</td></tr></tbody></table><p>笔者不才，请多交流！！！</p><p>参考文献：正则表达式 - 教程|菜鸟教程</p>]]></content>
      
      
      <categories>
          
          <category> 正则表达式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 正则表达式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ERA5数据下载和批处理教程</title>
      <link href="/2022/09/08/ERA5-data/"/>
      <url>/2022/09/08/ERA5-data/</url>
      
        <content type="html"><![CDATA[<p><code>ERA5</code> 再分析数据是最新一代的再分析数据，由欧盟资助的哥白尼气候变化服务（<code>C3S</code>）创建，由 <code>ECMWF</code> 运营。同化了包括全球范围内不同区域和来源的遥感资料、地表与上层大气常规气象资料。它覆盖了 1950 年至今的历史时期，实现了实时更新，延迟约 3 个月。<code>ERA5</code> 在其前身 <code>ERA-Interim</code> 的基础上进行了大幅升级，在时间分辨率和空间分辨率上都有显著提高。</p><p><code>ERA5</code> 再分析资料提供了许多种类的要素，包括 2m 温度、2m 相对湿度、海平面气压、10m 风等地面要素以及温度、相对湿度、位势高度、风场等高空要素。</p><h2 id="⛄ERA5数据下载"><a href="#⛄ERA5数据下载" class="headerlink" title="⛄ERA5数据下载"></a>⛄ERA5数据下载</h2><p>本例子以<code>ERA5 monthly averaged data on single levels from 1959 to present</code>数据为基础，下载2017、2018、2019、2020、2021年ERA5再分析数据，并进行批处理。数据变量主要包括：</p><ul><li>2m_temperature</li><li>skin_temperature</li><li>total_precipitation</li></ul><h3 id="👀前期准备"><a href="#👀前期准备" class="headerlink" title="👀前期准备"></a>👀前期准备</h3><p>进入 <strong>Climate Data Store</strong>（CDS），<a href="https://cds.climate.copernicus.eu/cdsapp#!/home">官方网站</a>，<a href="https://cds.climate.copernicus.eu/user/register?destination=/%23!/home">注册新用户</a>（已有请忽略）</p><ul><li>选择需要的数据，以<a href="https://cds.climate.copernicus.eu/cdsapp#!/dataset/reanalysis-era5-single-levels-monthly-means">ERA5 monthly averaged data on single levels from 1959 to present</a>数据为例，</li><li>在<code>Download data</code>选项卡里面产品类型<code>Product type</code>和变量<code>Variable</code></li><li>选择对应的<code>Year</code>、<code>Month</code>、<code>Time</code>；地理区域<code>Geographical area</code>；格式<code>Format</code>为<code>NetCDF</code>；</li><li><code>Terms of use</code> 勾上对号<code>Licence to use Copernicus Products</code>；</li><li>最下面有三种下载方式①<code>Show API request</code>；②<code>Show Toolbox request</code>；③<code>Submit Form</code>。</li></ul><h3 id="👀Python方式下载"><a href="#👀Python方式下载" class="headerlink" title="👀Python方式下载"></a>👀Python方式下载</h3><p>点击<code>Show API request</code>，出现Python代码，是根据你选择的数据自动生成的API请求。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cdsapi</span><br><span class="line"></span><br><span class="line">c = cdsapi.Client()</span><br><span class="line"></span><br><span class="line">c.retrieve(</span><br><span class="line">    <span class="string">&#x27;reanalysis-era5-single-levels-monthly-means&#x27;</span>,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&#x27;product_type&#x27;</span>: <span class="string">&#x27;monthly_averaged_reanalysis&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;variable&#x27;</span>: [</span><br><span class="line">            <span class="string">&#x27;2m_temperature&#x27;</span>, <span class="string">&#x27;skin_temperature&#x27;</span>, <span class="string">&#x27;total_precipitation&#x27;</span>,</span><br><span class="line">        ],</span><br><span class="line">        <span class="string">&#x27;year&#x27;</span>: [</span><br><span class="line">            <span class="string">&#x27;2017&#x27;</span>, <span class="string">&#x27;2018&#x27;</span>, <span class="string">&#x27;2019&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;2020&#x27;</span>, <span class="string">&#x27;2021&#x27;</span>,</span><br><span class="line">        ],</span><br><span class="line">        <span class="string">&#x27;month&#x27;</span>: [</span><br><span class="line">            <span class="string">&#x27;01&#x27;</span>, <span class="string">&#x27;02&#x27;</span>, <span class="string">&#x27;03&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;04&#x27;</span>, <span class="string">&#x27;05&#x27;</span>, <span class="string">&#x27;06&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;07&#x27;</span>, <span class="string">&#x27;08&#x27;</span>, <span class="string">&#x27;09&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;10&#x27;</span>, <span class="string">&#x27;11&#x27;</span>, <span class="string">&#x27;12&#x27;</span>,</span><br><span class="line">        ],</span><br><span class="line">        <span class="string">&#x27;time&#x27;</span>: <span class="string">&#x27;00:00&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;area&#x27;</span>: [</span><br><span class="line">            <span class="number">60</span>, <span class="number">70</span>, <span class="number">0</span>,</span><br><span class="line">            <span class="number">140</span>,</span><br><span class="line">        ],</span><br><span class="line">        <span class="string">&#x27;format&#x27;</span>: <span class="string">&#x27;netcdf&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&#x27;download.nc&#x27;</span>)</span><br></pre></td></tr></table></figure><p>运行成功此代码，需要以下准备：</p><p>（1）安装cdsapi模块</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip install cdsapi</span><br></pre></td></tr></table></figure><p>（2）此时可能运行出错</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Exception: Missing/incomplete configuration file:C:\Users\Administrator/.cdsapirc</span><br></pre></td></tr></table></figure><p><strong>初步分析</strong>：在目标路径下缺少<code>.cdsapirc</code>文件，该文件里含有下载数据的<code>url</code>和<code>key</code></p><p><strong>解决方案</strong>：针对已注册的用户，进入<a href="https://cds.climate.copernicus.eu/api-how-to">How to use the CDS API</a>网站，获得<code>url</code>和<code>key</code></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">url: https://cds.climate.copernicus.eu/api/v2</span><br><span class="line">key: *****************************************(已隐藏)</span><br></pre></td></tr></table></figure><ul><li>新建<code>txt</code>文件，将自己的<code>url</code>和<code>key</code>复制进去，然后保存；</li><li>把<code>txt</code>文件名改为<code>.cdsapirc</code>(注意有<code>.</code>)，同时修改文件后缀名，即把<code>.txt</code>后缀删除；</li><li>将文件复制或剪切到之前报错的目标路径下；</li><li>运行Python程序，即可成功下载。</li></ul><h3 id="👀IDM下载器方式下载"><a href="#👀IDM下载器方式下载" class="headerlink" title="👀IDM下载器方式下载"></a>👀IDM下载器方式下载</h3><p>点击<code>Submit Form</code>，跳转界面到<code>Your requests</code>，会显示当前下载数据的请求状态，需要你耐心等待一会儿。</p><p>通过请求之后，即可通过<code>Internet Download Manager</code>（<code>IDM</code>）下载器下载（前提已安装）。</p><h2 id="⛄ERA5数据批处理"><a href="#⛄ERA5数据批处理" class="headerlink" title="⛄ERA5数据批处理"></a>⛄ERA5数据批处理</h2><p>ERA5数据批处理目标要求：</p><ul><li>读取nc文件；</li><li>查看并获取nc文件中对应变量的信息；</li><li>根据数据的经纬度，计算分辨率；</li><li>定义投影；</li><li>保存数据为tif格式。</li></ul><h3 id="👀流程步骤"><a href="#👀流程步骤" class="headerlink" title="👀流程步骤"></a>👀流程步骤</h3><p>（1）读取nc文件</p><p>安装对应的netCDF4模块</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip install netCDF4</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> netCDF4 <span class="keyword">as</span> nc</span><br><span class="line"><span class="comment"># 读取nc文件</span></span><br><span class="line">tep_data = nc.Dataset(input_path)</span><br></pre></td></tr></table></figure><p>（2）查看并获取nc文件中对应变量的信息</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看nc文件中的变量信息</span></span><br><span class="line"><span class="built_in">print</span>(tep_data.variables.keys())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取nc文件中对应变量的信息</span></span><br><span class="line">lon_data = tep_data.variables[<span class="string">&quot;longitude&quot;</span>][:]</span><br><span class="line">lat_data = tep_data.variables[<span class="string">&quot;latitude&quot;</span>][:]</span><br></pre></td></tr></table></figure><p>（3）根据数据的经纬度，计算分辨率</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"> <span class="comment"># 影像的左上角&amp;右下角坐标</span></span><br><span class="line">lonmin, latmax, lonmax, latmin = [lon_data.<span class="built_in">min</span>(), lat_data.<span class="built_in">max</span>(), lon_data.<span class="built_in">max</span>(), lat_data.<span class="built_in">min</span>()]</span><br><span class="line"><span class="comment"># print(lonmin, latmax, lonmax, latmin)</span></span><br><span class="line">    </span><br><span class="line"><span class="comment"># 分辨率计算</span></span><br><span class="line">num_lon = <span class="built_in">len</span>(lon_data)  </span><br><span class="line">num_lat = <span class="built_in">len</span>(lat_data)  </span><br><span class="line">lon_res = (lonmax - lonmin) / (<span class="built_in">float</span>(num_lon) - <span class="number">1</span>)</span><br><span class="line">lat_res = (latmax - latmin) / (<span class="built_in">float</span>(num_lat) - <span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(num_lon, num_lat)</span><br><span class="line"><span class="built_in">print</span>(lon_res, lat_res)</span><br></pre></td></tr></table></figure><p>（4）定义投影</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义投影</span></span><br><span class="line">proj = osr.SpatialReference()</span><br><span class="line">proj.ImportFromEPSG(<span class="number">4326</span>)  <span class="comment"># WGS84</span></span><br><span class="line">proj = proj.ExportToWkt()  <span class="comment"># 重点，转成wkt格式</span></span><br><span class="line"><span class="comment"># print(prj)     字符串</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义六参数，设置影像的显示范围和分辨率</span></span><br><span class="line"><span class="comment"># 影像左上角横坐标：geoTransform[0]</span></span><br><span class="line"><span class="comment"># 影像左上角纵坐标：geoTransform[3]</span></span><br><span class="line"><span class="comment"># 遥感图像的水平空间分辨率为geoTransform[1]</span></span><br><span class="line"><span class="comment"># 遥感图像的垂直空间分辨率为geoTransform[5]</span></span><br><span class="line"><span class="comment"># 通常geoTransform[5] 与 geoTransform[1]相等</span></span><br><span class="line"><span class="comment"># 如果遥感影像方向没有发生旋转，即上北、下南，则geoTransform[2] 与 row *geoTransform[4] 为零。</span></span><br><span class="line">geotransform = (lonmin, lon_res, <span class="number">0.0</span>, latmax, <span class="number">0.0</span>, -lat_res)</span><br></pre></td></tr></table></figure><p>（5）保存数据为tif格式，以2m_temperature（t2m）温度为例</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">t2m = tep_data.variables[<span class="string">&quot;t2m&quot;</span>][:]  </span><br><span class="line"><span class="comment"># 用np.array把数据转化成数组（矩阵）类型</span></span><br><span class="line">t2m_arr = np.asarray(t2m)</span><br><span class="line"><span class="comment">#年份</span></span><br><span class="line">yearlist = [<span class="number">2017</span>,<span class="number">2018</span>,<span class="number">2019</span>,<span class="number">2020</span>,<span class="number">2021</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(yearlist)):</span><br><span class="line">    year = yearlist[i]</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">12</span>*i, <span class="number">12</span>*(i+<span class="number">1</span>)):</span><br><span class="line">        month = (j % <span class="number">12</span>) + <span class="number">1</span></span><br><span class="line">        outputpath = output_path + <span class="built_in">str</span>(year) + <span class="string">&quot;_&quot;</span> + <span class="built_in">str</span>(month) + <span class="string">&quot;_t2m.tif&quot;</span></span><br><span class="line">        write_img(outputpath, proj, geotransform, t2m_arr[j])</span><br></pre></td></tr></table></figure><h3 id="👀结果文件展示"><a href="#👀结果文件展示" class="headerlink" title="👀结果文件展示"></a>👀结果文件展示</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">2017_1_t2m.tif</span><br><span class="line">2017_2_t2m.tif</span><br><span class="line">2017_3_t2m.tif</span><br><span class="line">2017_4_t2m.tif</span><br><span class="line">2017_5_t2m.tif</span><br><span class="line">2017_6_t2m.tif</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">2021_7_t2m.tif</span><br><span class="line">2021_8_t2m.tif</span><br><span class="line">2021_9_t2m.tif</span><br><span class="line">2021_10_t2m.tif</span><br><span class="line">2021_11_t2m.tif</span><br><span class="line">2021_12_t2m.tif</span><br></pre></td></tr></table></figure><p>以2017_1_t2m.tif结果为例，如下图：</p><p><img src="https://s2.loli.net/2022/12/10/UNrouOseVYvwRhL.jpg"></p><h3 id="👀完整参考代码"><a href="#👀完整参考代码" class="headerlink" title="👀完整参考代码"></a>👀完整参考代码</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> netCDF4 <span class="keyword">as</span> nc</span><br><span class="line"><span class="keyword">from</span> osgeo <span class="keyword">import</span> gdal, osr</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment">#1.2定义写图像文件的函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">write_img</span>(<span class="params">filename, im_proj, im_geotrans, im_data</span>):</span><br><span class="line">    <span class="comment"># 判断栅格数据的数据类型</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;int8&#x27;</span> <span class="keyword">in</span> im_data.dtype.name:</span><br><span class="line">        datatype = gdal.GDT_Byte</span><br><span class="line">    <span class="keyword">elif</span> <span class="string">&#x27;int16&#x27;</span> <span class="keyword">in</span> im_data.dtype.name:</span><br><span class="line">        datatype = gdal.GDT_UInt16</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        datatype = gdal.GDT_Float32</span><br><span class="line">    <span class="comment"># 判读数组维数</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(im_data.shape) == <span class="number">3</span>:</span><br><span class="line">        im_bands, im_height, im_width = im_data.shape</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        im_bands, (im_height, im_width) = <span class="number">1</span>, im_data.shape</span><br><span class="line">    <span class="comment"># 创建文件</span></span><br><span class="line">    driver = gdal.GetDriverByName(<span class="string">&quot;GTiff&quot;</span>)</span><br><span class="line">    dataset = driver.Create(filename, im_width, im_height, im_bands, datatype)</span><br><span class="line">    dataset.SetGeoTransform(im_geotrans)  <span class="comment"># 写入仿射变换参数</span></span><br><span class="line">    dataset.SetProjection(im_proj)  <span class="comment"># 写入投影</span></span><br><span class="line">    <span class="keyword">if</span> im_bands == <span class="number">1</span>:</span><br><span class="line">        dataset.GetRasterBand(<span class="number">1</span>).WriteArray(im_data)  <span class="comment"># 写入数组数据</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(im_bands):</span><br><span class="line">            dataset.GetRasterBand(i + <span class="number">1</span>).WriteArray(im_data[i])</span><br><span class="line">    <span class="keyword">del</span> dataset</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">nc_totif</span>(<span class="params">input_path, output_path</span>):</span><br><span class="line">    <span class="comment"># 读取nc文件</span></span><br><span class="line">    tep_data = nc.Dataset(input_path)</span><br><span class="line">    <span class="comment"># 获取nc文件中对应变量的信息</span></span><br><span class="line">    lon_data = tep_data.variables[<span class="string">&quot;longitude&quot;</span>][:]</span><br><span class="line">    lat_data = tep_data.variables[<span class="string">&quot;latitude&quot;</span>][:]</span><br><span class="line">    <span class="comment"># 影像的左上角&amp;右下角坐标</span></span><br><span class="line">    lonmin, latmax, lonmax, latmin = [lon_data.<span class="built_in">min</span>(), lat_data.<span class="built_in">max</span>(), lon_data.<span class="built_in">max</span>(), lat_data.<span class="built_in">min</span>()]</span><br><span class="line">    <span class="comment"># 分辨率计算</span></span><br><span class="line">    num_lon = <span class="built_in">len</span>(lon_data)  <span class="comment"># 281</span></span><br><span class="line">    num_lat = <span class="built_in">len</span>(lat_data)  <span class="comment"># 241</span></span><br><span class="line">    lon_res = (lonmax - lonmin) / (<span class="built_in">float</span>(num_lon) - <span class="number">1</span>)</span><br><span class="line">    lat_res = (latmax - latmin) / (<span class="built_in">float</span>(num_lat) - <span class="number">1</span>)</span><br><span class="line">    <span class="comment"># 定义投影</span></span><br><span class="line">    proj = osr.SpatialReference()</span><br><span class="line">    proj.ImportFromEPSG(<span class="number">4326</span>)  <span class="comment"># WGS84</span></span><br><span class="line">    proj = proj.ExportToWkt()  <span class="comment"># 重点，转成wkt格式</span></span><br><span class="line">    <span class="comment"># print(prj)     字符串</span></span><br><span class="line">    geotransform = (lonmin, lon_res, <span class="number">0.0</span>, latmax, <span class="number">0.0</span>, -lat_res)</span><br><span class="line">    <span class="comment"># 获取2m温度</span></span><br><span class="line">    t2m = tep_data.variables[<span class="string">&quot;t2m&quot;</span>][:]  <span class="comment"># (60, 241, 281)</span></span><br><span class="line">    t2m_arr = np.asarray(t2m)</span><br><span class="line">    <span class="comment">#年份</span></span><br><span class="line">    yearlist = [<span class="number">2017</span>,<span class="number">2018</span>,<span class="number">2019</span>,<span class="number">2020</span>,<span class="number">2021</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(yearlist)):</span><br><span class="line">        year = yearlist[i]</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">12</span>*i, <span class="number">12</span>*(i+<span class="number">1</span>)):</span><br><span class="line">            month = (j % <span class="number">12</span>) + <span class="number">1</span></span><br><span class="line">            outputpath = output_path + <span class="built_in">str</span>(year) + <span class="string">&quot;_&quot;</span> + <span class="built_in">str</span>(month) + <span class="string">&quot;_t2m.tif&quot;</span></span><br><span class="line">            write_img(outputpath, proj, geotransform, t2m_arr[j])</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># nc文件输入输出路径</span></span><br><span class="line">    input_path = <span class="string">&quot;D:/Study/Data_Process/ERA5/Code/Monthly_averaged_2017_2021.nc&quot;</span></span><br><span class="line">    output_path = <span class="string">&quot;D:/Study/Data_Process/ERA5/Code/数据转换/&quot;</span></span><br><span class="line">    <span class="comment"># 读取nc文件，转换为tif文件</span></span><br><span class="line">    nc_totif(input_path, output_path)</span><br></pre></td></tr></table></figure><p>笔者不才，多多交流！！！</p>]]></content>
      
      
      <categories>
          
          <category> ERA5 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ERA5 </tag>
            
            <tag> 数据处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python基础知识（04）</title>
      <link href="/2022/09/03/Python-Basic04/"/>
      <url>/2022/09/03/Python-Basic04/</url>
      
        <content type="html"><![CDATA[<h2 id="⛄字符串的定义"><a href="#⛄字符串的定义" class="headerlink" title="⛄字符串的定义"></a>⛄字符串的定义</h2><p>字符串就是一串字符，用途众多，是编程语言中表示文本的数据类型，如”Hello World”。在Python中可以使用一对双引号<code>&quot; &quot;</code>或者一对单引号<code>&#39;&#39;</code>定义一个字符串。虽然可以使用<code>\&quot;</code>或者<code>\&#39;</code>做字符串的转义，但是在实际开发中：</p><ul><li>如果字符串内部需要使用<code>&quot;</code>，可以使用<code>&#39;</code>定义字符串</li><li>如果字符串内部需要使用<code>&#39;</code>，可以使用<code>&quot;</code>定义字符串</li></ul><p>可以使用索引获取一个字符串中指定位置的字符，索引计数从0开始；也可以使用<code>for</code>循环遍历字符串中每一个字符。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">str1 = <span class="string">&quot;My name is &#x27;xiaotang&#x27;&quot;</span></span><br><span class="line">str2 = <span class="string">&#x27;My name is &quot;HeartLoveLife&quot;&#x27;</span></span><br><span class="line"><span class="comment"># len(字符串)获取字符串的长度</span></span><br><span class="line">str1_len = <span class="built_in">len</span>(str1)</span><br><span class="line">str2_len = <span class="built_in">len</span>(str2)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(str1, <span class="string">&quot;;&quot;</span>, str2)</span><br><span class="line"><span class="built_in">print</span>(str1_len, <span class="string">&quot;;&quot;</span>, str2_len)</span><br><span class="line"><span class="comment"># 字符串.count(字符串)统计小字符串在大字符串中出现的次数</span></span><br><span class="line"><span class="built_in">print</span>(str1.count(<span class="string">&quot;n&quot;</span>))</span><br><span class="line"><span class="comment"># 字符串[索引]从字符串中取出单个字符</span></span><br><span class="line"><span class="built_in">print</span>(str1[<span class="number">0</span>])</span><br><span class="line"><span class="comment"># 字符串.index(字符串)获得小字符串第一次出现的索引</span></span><br><span class="line"><span class="built_in">print</span>(str1.index(<span class="string">&quot;n&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">My name <span class="keyword">is</span> <span class="string">&#x27;xiaotang&#x27;</span> ; My name <span class="keyword">is</span> <span class="string">&quot;HeartLoveLife&quot;</span></span><br><span class="line"><span class="number">21</span> ; <span class="number">26</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line">M</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><h2 id="⛄字符串常用操作"><a href="#⛄字符串常用操作" class="headerlink" title="⛄字符串常用操作"></a>⛄字符串常用操作</h2><p>Python内置提供的方法有很多，使得在开发时，能够针对字符串进行更加灵活的操作，应对更多的开发需求。使用Python内置函数dir()返回字符串的属性、方法列表。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">str_list = <span class="built_in">dir</span>(<span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(str_list)</span><br><span class="line"></span><br><span class="line">[<span class="string">&#x27;__add__&#x27;</span>, <span class="string">&#x27;__class__&#x27;</span>, <span class="string">&#x27;__contains__&#x27;</span>, <span class="string">&#x27;__delattr__&#x27;</span>, <span class="string">&#x27;__dir__&#x27;</span>, <span class="string">&#x27;__doc__&#x27;</span>, <span class="string">&#x27;__eq__&#x27;</span>, <span class="string">&#x27;__format__&#x27;</span>, <span class="string">&#x27;__ge__&#x27;</span>, <span class="string">&#x27;__getattribute__&#x27;</span>, <span class="string">&#x27;__getitem__&#x27;</span>, <span class="string">&#x27;__getnewargs__&#x27;</span>, <span class="string">&#x27;__gt__&#x27;</span>, <span class="string">&#x27;__hash__&#x27;</span>, <span class="string">&#x27;__init__&#x27;</span>, <span class="string">&#x27;__init_subclass__&#x27;</span>, <span class="string">&#x27;__iter__&#x27;</span>, <span class="string">&#x27;__le__&#x27;</span>, <span class="string">&#x27;__len__&#x27;</span>, <span class="string">&#x27;__lt__&#x27;</span>, <span class="string">&#x27;__mod__&#x27;</span>, <span class="string">&#x27;__mul__&#x27;</span>, <span class="string">&#x27;__ne__&#x27;</span>, <span class="string">&#x27;__new__&#x27;</span>, <span class="string">&#x27;__reduce__&#x27;</span>, <span class="string">&#x27;__reduce_ex__&#x27;</span>, <span class="string">&#x27;__repr__&#x27;</span>, <span class="string">&#x27;__rmod__&#x27;</span>, <span class="string">&#x27;__rmul__&#x27;</span>, <span class="string">&#x27;__setattr__&#x27;</span>, <span class="string">&#x27;__sizeof__&#x27;</span>, <span class="string">&#x27;__str__&#x27;</span>, <span class="string">&#x27;__subclasshook__&#x27;</span>, <span class="string">&#x27;capitalize&#x27;</span>, <span class="string">&#x27;casefold&#x27;</span>, <span class="string">&#x27;center&#x27;</span>, <span class="string">&#x27;count&#x27;</span>, <span class="string">&#x27;encode&#x27;</span>, <span class="string">&#x27;endswith&#x27;</span>, <span class="string">&#x27;expandtabs&#x27;</span>, <span class="string">&#x27;find&#x27;</span>, <span class="string">&#x27;format&#x27;</span>, <span class="string">&#x27;format_map&#x27;</span>, <span class="string">&#x27;index&#x27;</span>, <span class="string">&#x27;isalnum&#x27;</span>, <span class="string">&#x27;isalpha&#x27;</span>, <span class="string">&#x27;isascii&#x27;</span>, <span class="string">&#x27;isdecimal&#x27;</span>, <span class="string">&#x27;isdigit&#x27;</span>, <span class="string">&#x27;isidentifier&#x27;</span>, <span class="string">&#x27;islower&#x27;</span>, <span class="string">&#x27;isnumeric&#x27;</span>, <span class="string">&#x27;isprintable&#x27;</span>, <span class="string">&#x27;isspace&#x27;</span>, <span class="string">&#x27;istitle&#x27;</span>, <span class="string">&#x27;isupper&#x27;</span>, <span class="string">&#x27;join&#x27;</span>, <span class="string">&#x27;ljust&#x27;</span>, <span class="string">&#x27;lower&#x27;</span>, <span class="string">&#x27;lstrip&#x27;</span>, <span class="string">&#x27;maketrans&#x27;</span>, <span class="string">&#x27;partition&#x27;</span>, <span class="string">&#x27;replace&#x27;</span>, <span class="string">&#x27;rfind&#x27;</span>, <span class="string">&#x27;rindex&#x27;</span>, <span class="string">&#x27;rjust&#x27;</span>, <span class="string">&#x27;rpartition&#x27;</span>, <span class="string">&#x27;rsplit&#x27;</span>, <span class="string">&#x27;rstrip&#x27;</span>, <span class="string">&#x27;split&#x27;</span>, <span class="string">&#x27;splitlines&#x27;</span>, <span class="string">&#x27;startswith&#x27;</span>, <span class="string">&#x27;strip&#x27;</span>, <span class="string">&#x27;swapcase&#x27;</span>, <span class="string">&#x27;title&#x27;</span>, <span class="string">&#x27;translate&#x27;</span>, <span class="string">&#x27;upper&#x27;</span>, <span class="string">&#x27;zfill&#x27;</span>]</span><br></pre></td></tr></table></figure><h3 id="👀-判断类型"><a href="#👀-判断类型" class="headerlink" title="👀 判断类型"></a>👀 判断类型</h3><table><thead><tr><th align="left">方法</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">string.isspace()</td><td align="left">如果string中只包含空格，则返回True</td></tr><tr><td align="left">string.isalnum()</td><td align="left">如果string至少有一个字符并且所有字符都是字母或数字则返回True</td></tr><tr><td align="left">string.isalpha()</td><td align="left">如果string至少有一个字符并且所有字符都是字母则返回True</td></tr><tr><td align="left">string.isdecimal()</td><td align="left">如果 string只包含数字则返回True，<code>全角数字</code></td></tr><tr><td align="left">string.isdigit()</td><td align="left">如果 string只包含数字则返回True，<code>全角数字</code></td></tr><tr><td align="left">string.isnumeric()</td><td align="left">如果 string只包含数字则返回True，<code>全角数字</code>，<code>汉字数字</code></td></tr><tr><td align="left">string.istitle()</td><td align="left">如果 string是标题化的（每个单词的首字母大写）则返回True</td></tr><tr><td align="left">string.islower()</td><td align="left">如果string中包含至少一个区分大小写的字符，并且所有这些（区分大小写的）字符都是小写，则返回True</td></tr><tr><td align="left">string.isupper()</td><td align="left">如果 string中包含至少一个区分大小写的字符，并且所有这些（区分大小写的）字符都是大写，则返回True</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">str_space = <span class="string">&quot;   &quot;</span> </span><br><span class="line"><span class="built_in">print</span>(str_space.isspace())</span><br><span class="line"></span><br><span class="line">str1 = <span class="string">&quot;a_&quot;</span></span><br><span class="line">str2 = <span class="string">&quot;a9527&quot;</span></span><br><span class="line"><span class="built_in">print</span>(str1.isalnum(), str2.isalnum())</span><br><span class="line"></span><br><span class="line">str3 = <span class="string">&quot;a9527&quot;</span></span><br><span class="line">str4 = <span class="string">&quot;abc&quot;</span></span><br><span class="line"><span class="built_in">print</span>(str3.isalpha(), str4.isalpha())</span><br><span class="line"></span><br><span class="line">str5 = <span class="string">&quot;9527&quot;</span></span><br><span class="line">str6 = <span class="string">&quot;1&quot;</span></span><br><span class="line">str7 = <span class="string">&quot;一&quot;</span></span><br><span class="line"><span class="built_in">print</span>(str5.isdecimal(), str6.isdigit(), str7.isnumeric())</span><br><span class="line"></span><br><span class="line">str8 = <span class="string">&quot;Xiaotang&quot;</span></span><br><span class="line"><span class="built_in">print</span>(str8.istitle())</span><br><span class="line"></span><br><span class="line">str9 = <span class="string">&quot;xiaotang&quot;</span></span><br><span class="line">str10 = <span class="string">&quot;XIAOTANG&quot;</span></span><br><span class="line"><span class="built_in">print</span>(str9.islower(), str10.isupper())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="literal">False</span> <span class="literal">True</span></span><br><span class="line"><span class="literal">False</span> <span class="literal">True</span></span><br><span class="line"><span class="literal">True</span> <span class="literal">True</span> <span class="literal">True</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="literal">True</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><h3 id="👀-查找和替换"><a href="#👀-查找和替换" class="headerlink" title="👀 查找和替换"></a>👀 查找和替换</h3><table><thead><tr><th align="left">方法</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">string.startswith(str)</td><td align="left">检查字符串是否是以str开头，是则返回True</td></tr><tr><td align="left">string.endswith(str)</td><td align="left">检查字符串是否是以str结束，是则返回True</td></tr><tr><td align="left">string.find(str,start&#x3D;0,end&#x3D;len(string))</td><td align="left">检测str是否包含在string中，如果start和end指定范围，则检查是否包含在指定范围内，如果是返回开始的索引值，否则返回-1</td></tr><tr><td align="left">string.rfind(str,start&#x3D;0,end&#x3D;len(string))</td><td align="left">类似于find()，不过是从右边开始查找</td></tr><tr><td align="left">string.index(str,start&#x3D;0,end&#x3D;len(string))</td><td align="left">跟find()方法类似，不过如果str不在string会报错</td></tr><tr><td align="left">string.rindex(str,start&#x3D;0,end&#x3D;len(string))</td><td align="left">类似于index()，不过是从右边开始</td></tr><tr><td align="left">string.replace(old_str,new_str,num&#x3D;string.count(old))</td><td align="left">把string中的old_str替换成new_str，如果num指定，则替换不超过num次</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">str1 = <span class="string">&quot;his name is xiaotang, see you&quot;</span></span><br><span class="line"><span class="built_in">print</span>(str1.startswith(<span class="string">&quot;his&quot;</span>), str1.endswith(<span class="string">&quot;you&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(str1.find(<span class="string">&quot;is&quot;</span>, <span class="number">0</span>, <span class="number">5</span>), str1.rfind(<span class="string">&quot;is&quot;</span>), str1.find(<span class="string">&quot;iss&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(str1.index(<span class="string">&quot;is&quot;</span>), str1.rindex(<span class="string">&quot;is&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(str1.replace(<span class="string">&quot;xiaotang&quot;</span>, <span class="string">&quot;heartlovelife&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="literal">True</span> <span class="literal">True</span></span><br><span class="line"><span class="number">1</span> <span class="number">9</span> -<span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">9</span></span><br><span class="line">his name <span class="keyword">is</span> heartlovelife, see you</span><br></pre></td></tr></table></figure><h3 id="👀-大小写转换"><a href="#👀-大小写转换" class="headerlink" title="👀 大小写转换"></a>👀 大小写转换</h3><table><thead><tr><th align="left">方法</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">string.capitalize()</td><td align="left">把字符串的第一个字符大写</td></tr><tr><td align="left">string.title()</td><td align="left">把字符串的每个单词首字母大写</td></tr><tr><td align="left">string.lower()</td><td align="left">转换string中所有大写字符为小写</td></tr><tr><td align="left">string.upper()</td><td align="left">转换string中的小写字母为大写</td></tr><tr><td align="left">string.swapcase()</td><td align="left">翻转string中的大小写</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">str1 = <span class="string">&quot;xiao tang heLLo heLLo&quot;</span></span><br><span class="line"><span class="built_in">print</span>(str1.capitalize())</span><br><span class="line"><span class="built_in">print</span>(str1.title())</span><br><span class="line"><span class="built_in">print</span>(str1.lower())</span><br><span class="line"><span class="built_in">print</span>(str1.upper())</span><br><span class="line"><span class="built_in">print</span>(str1.swapcase())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">Xiao tang hello hello</span><br><span class="line">Xiao Tang Hello Hello</span><br><span class="line">xiao tang hello hello</span><br><span class="line">XIAO TANG HELLO HELLO</span><br><span class="line">XIAO TANG HEllO HEllO</span><br></pre></td></tr></table></figure><h3 id="👀-文本对齐"><a href="#👀-文本对齐" class="headerlink" title="👀 文本对齐"></a>👀 文本对齐</h3><table><thead><tr><th align="left">方法</th><th>说明</th></tr></thead><tbody><tr><td align="left">string.ljust(width，[填充字符])</td><td>返回一个原字符串左对齐，并使用填充字符（默认空格）填充至长度width的新字符串</td></tr><tr><td align="left">string.rjust(width，[填充字符])</td><td>返回一个原字符串右对齐，并使用填充字符（默认空格）填充至长度width的新字符串</td></tr><tr><td align="left">string.center(width，[填充字符])</td><td>返回一个原字符串居中，并使用填充字符（默认空格）填充至长度width的新字符串</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">str1 = <span class="string">&quot;-xiaotang hello hello-&quot;</span></span><br><span class="line"><span class="built_in">print</span>(str1.ljust(<span class="number">50</span>,<span class="string">&quot;a&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(str1.rjust(<span class="number">50</span>,<span class="string">&quot;b&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(str1.center(<span class="number">50</span>,<span class="string">&quot;a&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">-xiaotang hello hello-aaaaaaaaaaaaaaaaaaaaaaaaaaaa</span><br><span class="line">bbbbbbbbbbbbbbbbbbbbbbbbbbbb-xiaotang hello hello-</span><br><span class="line">aaaaaaaaaaaaaa-xiaotang hello hello-aaaaaaaaaaaaaa</span><br></pre></td></tr></table></figure><h3 id="👀去除空白字符"><a href="#👀去除空白字符" class="headerlink" title="👀去除空白字符"></a>👀去除空白字符</h3><table><thead><tr><th align="left">方法</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">string.lstrip()</td><td align="left">截掉string左边（开始）的空白字符</td></tr><tr><td align="left">string.rstrip()</td><td align="left">截掉string右边（末尾）的空白字符</td></tr><tr><td align="left">string.strip()</td><td align="left">截掉 string左右两边的空白字符</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">str1 = <span class="string">&quot;   xiaotangxiaotang   &quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;=&quot;</span>*<span class="number">5</span>, str1.lstrip(), <span class="string">&quot;=&quot;</span>*<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;=&quot;</span>*<span class="number">5</span>, str1.rstrip(), <span class="string">&quot;=&quot;</span>*<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;=&quot;</span>*<span class="number">5</span>, str1.strip(), <span class="string">&quot;=&quot;</span>*<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">===== xiaotangxiaotang    =====</span><br><span class="line">=====    xiaotangxiaotang =====</span><br><span class="line">===== xiaotangxiaotang =====</span><br></pre></td></tr></table></figure><h3 id="👀拆分和连接"><a href="#👀拆分和连接" class="headerlink" title="👀拆分和连接"></a>👀拆分和连接</h3><table><thead><tr><th align="left">方法</th><th>说明</th></tr></thead><tbody><tr><td align="left">string.partition(str)</td><td>把字符串string分成一个3元素的元组（str前面，str，str 后面）</td></tr><tr><td align="left">string.rpartition(str)</td><td>类似于partition()方法，不过是从右边开始查找</td></tr><tr><td align="left">string.split(str&#x3D;””,num)</td><td>以str为分隔符拆分string，返回列表；如果num有指定值，则仅分隔num+1个子字符串，str默认包含’r’，’t’，’n’和空格</td></tr><tr><td align="left">string.splitlines()</td><td>按照行（’r’，’n’，’rn’）分隔，返回一个包含各行作为元素的列表</td></tr><tr><td align="left">string.join(seq)</td><td>以string作为分隔符，将seq（要连接的元素序列）中所有的元素合并为一个新的字符串</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">str1 = <span class="string">&quot;xiaotang=or=xiaoming=or=xiaolizi&quot;</span></span><br><span class="line">str2 = <span class="string">&quot;xiaotang=or=xiaoming=or=xiaolizi\nxiaotang&quot;</span></span><br><span class="line">str3 = (<span class="string">&quot;I&quot;</span>,<span class="string">&quot;love&quot;</span>,<span class="string">&quot;you&quot;</span>)</span><br><span class="line">str4 = [<span class="string">&quot;I&quot;</span>,<span class="string">&quot;love&quot;</span>,<span class="string">&quot;you&quot;</span>]</span><br><span class="line"><span class="built_in">print</span>(str1.partition(<span class="string">&quot;or&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(str1.rpartition(<span class="string">&quot;or&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(str1.split(<span class="string">&quot;=&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(str2.splitlines())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;@&quot;</span>.join(str3))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;#&quot;</span>.join(str4))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">(<span class="string">&#x27;xiaotang=&#x27;</span>, <span class="string">&#x27;or&#x27;</span>, <span class="string">&#x27;=xiaoming=or=xiaolizi&#x27;</span>)</span><br><span class="line">(<span class="string">&#x27;xiaotang=or=xiaoming=&#x27;</span>, <span class="string">&#x27;or&#x27;</span>, <span class="string">&#x27;=xiaolizi&#x27;</span>)</span><br><span class="line">[<span class="string">&#x27;xiaotang&#x27;</span>, <span class="string">&#x27;or&#x27;</span>, <span class="string">&#x27;xiaoming&#x27;</span>, <span class="string">&#x27;or&#x27;</span>, <span class="string">&#x27;xiaolizi&#x27;</span>]</span><br><span class="line">[<span class="string">&#x27;xiaotang=or=xiaoming=or=xiaolizi&#x27;</span>, <span class="string">&#x27;xiaotang&#x27;</span>]</span><br><span class="line">I@love@you</span><br><span class="line">I<span class="comment">#love#you</span></span><br></pre></td></tr></table></figure><h3 id="👀字符串的切片"><a href="#👀字符串的切片" class="headerlink" title="👀字符串的切片"></a>👀字符串的切片</h3><p><strong>切片</strong>方法适用于<strong>字符串</strong>、<strong>列表</strong>、<strong>元组</strong></p><ul><li><strong>切片</strong>使用<strong>索引值</strong>来限定范围，从一个大的字符串中切出小的字符串</li><li><strong>列表</strong>和<strong>元组</strong>都是有序的集合，都能够<strong>通过索引值</strong>获取对应的数据</li><li><strong>字典</strong>是一个无序的集合，是使用<strong>键值对</strong>保存数据</li></ul><p>注意事项：</p><ul><li>指定的区间属于左闭右开型<code>[开始索引，结束索引]</code>相当于从起始位开始，到结束位的前一位结束（<strong>不包含结束位本身</strong>）</li><li>从头开始，<strong>开始索引</strong>数字可以省略，冒号不能省略</li><li>到末尾结束，<strong>结束索引</strong>数字可以省略，冒号不能省略</li><li>步长默认为1，如果连续切片，数字和冒号都可以省略</li><li>不仅支持<strong>顺序索引</strong>，还支持<strong>倒序索引</strong>；所谓倒序索引就是从右向左计算索引，最右边的索引值是**-1**，依次递减。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">str</span> = <span class="string">&quot;xiaotang9527helloworld&quot;</span></span><br><span class="line"><span class="comment"># 截取3~6位置的字符串,相当于索引为[2:5],因为不包含末尾,所以为[2,6]</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[<span class="number">2</span>:<span class="number">6</span>])</span><br><span class="line"><span class="comment"># 截取3~末尾的字符串</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[<span class="number">2</span>:])</span><br><span class="line"><span class="comment"># 截取从开始~6位置的字符串,6位置相当于索引为5,因为不包含末尾,所以为[:6]</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[:<span class="number">6</span>])</span><br><span class="line"><span class="comment"># 取完整的字符串</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[:])</span><br><span class="line"><span class="comment"># 从开始位置,每隔一个字符截取字符串</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[::<span class="number">2</span>])</span><br><span class="line"><span class="comment"># 倒序切片</span></span><br><span class="line"><span class="comment"># -1表示倒数第一个字符</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[-<span class="number">1</span>])</span><br><span class="line"><span class="comment"># 截取3-末尾的字符串(不包含最后一个字符)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[<span class="number">2</span>:-<span class="number">1</span>])</span><br><span class="line"><span class="comment"># 截取字符串末尾两个字符</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[-<span class="number">2</span>:])</span><br><span class="line"><span class="comment"># 字符串的逆序</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[::-<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">aota</span><br><span class="line">aotang9527helloworld</span><br><span class="line">xiaota</span><br><span class="line">xiaotang9527helloworld</span><br><span class="line">xatn92hlool</span><br><span class="line">d</span><br><span class="line">aotang9527helloworl</span><br><span class="line">ld</span><br><span class="line">dlrowolleh7259gnatoaix</span><br></pre></td></tr></table></figure><h2 id="⛄公共方法及特殊用法"><a href="#⛄公共方法及特殊用法" class="headerlink" title="⛄公共方法及特殊用法"></a>⛄公共方法及特殊用法</h2><h3 id="👀内置函数"><a href="#👀内置函数" class="headerlink" title="👀内置函数"></a>👀内置函数</h3><table><thead><tr><th>函数</th><th>描述</th><th>备注</th></tr></thead><tbody><tr><td>len(item)</td><td>计算容器中元素个数</td><td></td></tr><tr><td>del(item)</td><td>删除变量</td><td>del有两种方式</td></tr><tr><td>max(item)</td><td>返回容器中元素最大值</td><td>如果是字典，只针对key比较</td></tr><tr><td>min(item)</td><td>返回容器中元素最小值</td><td>如果是字典，只针对key比较</td></tr><tr><td>cmp(item1,item2)</td><td>比较两个值，-1小于&#x2F;0相等&#x2F;1大于</td><td>Python3.x取消了cmp函数</td></tr></tbody></table><h3 id="👀运算符特殊用法"><a href="#👀运算符特殊用法" class="headerlink" title="👀运算符特殊用法"></a>👀运算符特殊用法</h3><table><thead><tr><th>运算符</th><th>表达式</th><th>结果</th><th>描述</th><th>支持数据类型</th></tr></thead><tbody><tr><td>+</td><td>[1,2] + [3,4]</td><td>[1,2,3,4]</td><td>合并</td><td>字符串、列表、元组</td></tr><tr><td>*</td><td>[“a”] * 2</td><td>[“a”,”a”]</td><td>重复</td><td>字符串、列表、元组</td></tr><tr><td>in</td><td>2 in (1,2,3)</td><td>True</td><td>元素是否存在</td><td>字符串、列表、元组、字典</td></tr><tr><td>not in</td><td>5 not in(1,2,3)</td><td>True</td><td>元素是否不存在</td><td>字符串、列表、元组、字典</td></tr></tbody></table><blockquote><p><code>in</code> 在对字典操作时，判断的是字典的键；<code>in</code>和<code>not in</code>被称为成员运算符，用于测试序列中是否包含指定的成员。</p></blockquote><h3 id="👀完成的for循环语法·"><a href="#👀完成的for循环语法·" class="headerlink" title="👀完成的for循环语法·"></a>👀完成的for循环语法·</h3><p>在Python中完整的<code>for</code>循环语法如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> 变量 <span class="keyword">in</span> 集合:</span><br><span class="line">循环体代码</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">没有通过<span class="keyword">break</span>退出循环，循环结束后，会执行的代码</span><br></pre></td></tr></table></figure><p>应用场景</p><ol><li>在迭代遍历嵌套的数据类型时，例如一个列表包含了多个字典</li><li>需求：判断某一个字典中，是否存在指定的值</li></ol><ul><li>如果存在，提示并且退出循环</li><li>如果不存在，在循环整体结束后，希望得到一个统一的提示</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 第一种</span></span><br><span class="line">stu = [</span><br><span class="line">       &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;xiaotang&quot;</span>,</span><br><span class="line">        <span class="string">&quot;age&quot;</span>: <span class="string">&quot;25&quot;</span>,</span><br><span class="line">        <span class="string">&quot;gender&quot;</span>: <span class="literal">True</span>,</span><br><span class="line">        <span class="string">&quot;height&quot;</span>: <span class="number">180</span>,</span><br><span class="line">        <span class="string">&quot;weight&quot;</span>: <span class="number">66</span>&#125;,</span><br><span class="line">       &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;xiaoming&quot;</span>,</span><br><span class="line">        <span class="string">&quot;age&quot;</span>: <span class="string">&quot;26&quot;</span>,</span><br><span class="line">        <span class="string">&quot;gender&quot;</span>: <span class="literal">True</span>,</span><br><span class="line">        <span class="string">&quot;height&quot;</span>: <span class="number">179</span>,</span><br><span class="line">        <span class="string">&quot;weight&quot;</span>: <span class="number">65</span>&#125;</span><br><span class="line">       ]</span><br><span class="line">find_name = <span class="string">&quot;xiaotang&quot;</span></span><br><span class="line"><span class="keyword">for</span> stu_dict <span class="keyword">in</span> stu:</span><br><span class="line">    <span class="built_in">print</span>(stu_dict)</span><br><span class="line">    <span class="comment"># 判断当前遍历的字典中姓名是否为find_name</span></span><br><span class="line">    <span class="keyword">if</span> stu_dict[<span class="string">&quot;name&quot;</span>] == find_name:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;找到阿汤了&quot;</span>)</span><br><span class="line">        <span class="comment"># 如果找到,直接退出循环,不需对后续的数据进行比较</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;怎么搞的，没有找到！！&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;循环结束&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;xiaotang&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="string">&#x27;25&#x27;</span>, <span class="string">&#x27;gender&#x27;</span>: <span class="literal">True</span>, <span class="string">&#x27;height&#x27;</span>: <span class="number">180</span>, <span class="string">&#x27;weight&#x27;</span>: <span class="number">66</span>&#125;</span><br><span class="line">找到阿汤了</span><br><span class="line">循环结束</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二种</span></span><br><span class="line">stu = [</span><br><span class="line">       &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;xiaotang&quot;</span>,</span><br><span class="line">        <span class="string">&quot;age&quot;</span>: <span class="string">&quot;25&quot;</span>,</span><br><span class="line">        <span class="string">&quot;gender&quot;</span>: <span class="literal">True</span>,</span><br><span class="line">        <span class="string">&quot;height&quot;</span>: <span class="number">180</span>,</span><br><span class="line">        <span class="string">&quot;weight&quot;</span>: <span class="number">66</span>&#125;,</span><br><span class="line">       &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;xiaoming&quot;</span>,</span><br><span class="line">        <span class="string">&quot;age&quot;</span>: <span class="string">&quot;26&quot;</span>,</span><br><span class="line">        <span class="string">&quot;gender&quot;</span>: <span class="literal">True</span>,</span><br><span class="line">        <span class="string">&quot;height&quot;</span>: <span class="number">179</span>,</span><br><span class="line">        <span class="string">&quot;weight&quot;</span>: <span class="number">65</span>&#125;</span><br><span class="line">       ]</span><br><span class="line">find_name = <span class="string">&quot;xiaotang1&quot;</span></span><br><span class="line"><span class="keyword">for</span> stu_dict <span class="keyword">in</span> stu:</span><br><span class="line">    <span class="built_in">print</span>(stu_dict)</span><br><span class="line">    <span class="comment"># 判断当前遍历的字典中姓名是否为find_name</span></span><br><span class="line">    <span class="keyword">if</span> stu_dict[<span class="string">&quot;name&quot;</span>] == find_name:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;找到阿汤了&quot;</span>)</span><br><span class="line">        <span class="comment"># 如果找到,直接退出循环,不需对后续的数据进行比较</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;怎么搞的，没有找到！！&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;循环结束&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;xiaotang&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="string">&#x27;25&#x27;</span>, <span class="string">&#x27;gender&#x27;</span>: <span class="literal">True</span>, <span class="string">&#x27;height&#x27;</span>: <span class="number">180</span>, <span class="string">&#x27;weight&#x27;</span>: <span class="number">66</span>&#125;</span><br><span class="line">&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;xiaoming&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="string">&#x27;26&#x27;</span>, <span class="string">&#x27;gender&#x27;</span>: <span class="literal">True</span>, <span class="string">&#x27;height&#x27;</span>: <span class="number">179</span>, <span class="string">&#x27;weight&#x27;</span>: <span class="number">65</span>&#125;</span><br><span class="line">怎么搞的，没有找到！！</span><br><span class="line">循环结束</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Python基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python基础知识（03）</title>
      <link href="/2022/08/07/Python-Basic03/"/>
      <url>/2022/08/07/Python-Basic03/</url>
      
        <content type="html"><![CDATA[<p>作为一个实用主义的学习者，最关心的问题一定是【我为什么要选择学<code>Python</code>，学会之后我可以用来做什么？】首先，对于初学者来说，比起其它编程语言，<code>Python</code>更容易上手。<code>Python</code>的设计哲学是优雅、明确、简单。</p><blockquote><p>在官方的The Zen of Python《Python之禅》中：There should be one – and preferably only one – obvious way to do it.</p></blockquote><p><code>Python</code>追求的是找到最好的解决方案。</p><h2 id="⛄函数"><a href="#⛄函数" class="headerlink" title="⛄函数"></a>⛄函数</h2><p>所谓函数，就是把具有独立功能的代码块组织为一个小模块，在需要的时候调用。</p><p>函数的使用包含两个步骤：</p><p>（1）定义函数——封装独立的功能；</p><p>（2）调用函数——享受封装的成果；</p><p>函数的作用，在开发程序时，使用函数可以提高编写的效率以及代码的重用。其实我们早已掌握了函数的用法，例如：</p><blockquote><p><code>print</code>() ：是一个放入对象就能将结果打印的函数；</p><p><code>input</code>()：是一个可以让用户输入信息的函数；</p><p><code>len</code>()：是一个可以测量对象长度的函数；</p><p><code>int</code>()：是一个可以将字符串类型的数字转换成是整数类型的函数。</p></blockquote><p>通过观察其实不难发现，<code>Python</code>中所谓的函数就是把你要处理的对象放到一个名字后面的括号里就可以了。</p><h3 id="👀函数的定义"><a href="#👀函数的定义" class="headerlink" title="👀函数的定义"></a>👀函数的定义</h3><p>定义函数的格式如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">函数名</span>（参数<span class="number">1</span>，参数<span class="number">2</span>）:</span><br><span class="line">函数封装的代码</span><br><span class="line"><span class="keyword">return</span> </span><br></pre></td></tr></table></figure><p>（1）<code>def</code>：是英文<code>define</code>的缩写。</p><p>（2）函数名称：应该能够表达函数封装代码的功能，方便后续的调用。</p><p>（3）函数名称的命名应该符合标识符的命名规则。</p><p>​①可以由字母、下划线和数字组成</p><p>​②不能以数字开头</p><p>​③不能与关键字重名</p><blockquote><p>函数调用：调用函数很简单的，通过<code>函数名（）</code>即可完成对函数的调用；函数调用应该放在函数定义的下方。</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">say_hello</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;hello world_1&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;hello world_2&quot;</span>)</span><br><span class="line"><span class="comment"># 只有在调用函数时，之前定义的函数才会执行</span></span><br><span class="line"><span class="comment"># 函数执行完成之后，会重新回到之前的程序中，继续执行后续的代码</span></span><br><span class="line">say_hello()</span><br></pre></td></tr></table></figure><h3 id="👀函数的参数"><a href="#👀函数的参数" class="headerlink" title="👀函数的参数"></a>👀函数的参数</h3><p><strong>函数</strong>，把<strong>具有独立功能的代码块</strong>组织为一个小模块，在需要的时候调用。</p><p><strong>函数的参数</strong>，增加函数的通用性，针对相同数据处理逻辑，能够适应更多的数据。</p><p>（1）在函数内部，把参数当做变量使用，进行需要的数据处理；</p><p>（2）函数调用时，按照函数定义的参数顺序，把希望在函数内部处理的数据，通过参数传递。</p><blockquote><p>形参：定义函数时，小括号中的参数，是用来接收参数用的，在函数内部作为变量使用；</p><p>实参：调用函数时，小括号中的参数，是用来把数据传递到函数内部用的。</p></blockquote><p>函数返回值。在程序开发中，有时候，会希望一个函数执行结束后，告诉调用者一个结果，以便调用者针对具体的结果做后续的处理。</p><p>返回值是函数完成工作后，最后给调用者的一个结果；在函数中使用<code>return</code>关键字可以返回结果；调用函数一方，可以使用变量来接收函数的返回结果。</p><blockquote><p>注意：return表示返回，后续的代码都不会被执行。</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sum</span>(<span class="params">num1, num2</span>):</span><br><span class="line">    <span class="keyword">return</span> num1 + num2</span><br><span class="line"><span class="comment"># 调用函数，并使用result变量接收计算结果</span></span><br><span class="line">result = <span class="built_in">sum</span>(<span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;计算结果是%d&quot;</span>%result)</span><br></pre></td></tr></table></figure><h2 id="⛄数据结构"><a href="#⛄数据结构" class="headerlink" title="⛄数据结构"></a>⛄数据结构</h2><p>   <code>Python</code> 有四种数据结构，分别是：列表、字典、元组，集合。每种数据结构都有自己的特点，并且都有着独到的用处。为了避免过早地陷入细枝末节，我们先从整体上来认识一下这四种数据结构：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">list</span> = [vall,val2,val3,val4]</span><br><span class="line"><span class="built_in">dict</span> = &#123;key1:vall,key2:val2&#125;</span><br><span class="line"><span class="built_in">tuple</span> = (vall,val2,val3,val4)</span><br><span class="line"><span class="built_in">set</span> = &#123;vall,val2,val3,val4&#125;</span><br></pre></td></tr></table></figure><p>从最容易识别的特征上来说，列表中的元素使用方括号扩起来，字典和集合是花括号，而元组则是圆括号。其中字典中的元素是均带有”:”的<code>key</code>与<code>value</code>的对应关系组。</p><p><code>Python</code>中数据类型可以分为<strong>数字型</strong>和<strong>非数字型</strong></p><p>（1）数字型</p><ul><li><p>整型（<code>int</code>）</p></li><li><p>浮点型（<code>float</code>）</p></li><li><p>布尔型（<code>bool</code>）</p><ul><li>真<code>True</code>非<code>0</code>数——<strong>非零即真</strong></li><li>假<code>False</code>  0</li></ul></li><li><p>复数型（<code>complex</code>）主要用于科学计算，例如：平面场问题、波动问题、电感电容等问题</p></li></ul><p>（2）非数字型</p><ul><li>字符串</li><li>列表</li><li>元组</li><li>字典</li></ul><p>（3）在<code>Python</code>中，所有非数字型变量都支持以下特点</p><ul><li>都是一个序列<code>sequence</code>，也可以理解为容器</li><li>取值<code>[]</code></li><li>遍历<code>for in</code></li><li>计算长度、最大&#x2F;最小值、比较、删除</li><li>链接<code>+</code>和重复<code>*</code></li><li>切片</li></ul><h3 id="👀列表"><a href="#👀列表" class="headerlink" title="👀列表"></a>👀列表</h3><p>列表具有的最显著的特征：</p><ul><li>列表中的每一个元素都是<strong>可变</strong>的；</li><li>列表中的元素是<strong>有序</strong>的，也就是说每一个元素都有一个位置；</li><li>列表可以容纳<code>Python</code>中的任何对象。</li></ul><p>列表中的元素是可变的，这意味着我们可以在列表中添加、删除和修改元素。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Weekday = [<span class="string">&quot;Monday&quot;</span>, <span class="string">&quot;Tuesday&quot;</span>, <span class="string">&quot;Wednesday&quot;</span>, <span class="string">&quot;Thursday&quot;</span>, <span class="string">&quot;Friday&quot;</span>, <span class="string">&quot;Sunday&quot;</span>]</span><br><span class="line"><span class="built_in">print</span>(Weekday[<span class="number">0</span>])</span><br></pre></td></tr></table></figure><p><code>List</code>（列表）是<code>Python</code>中使用最频繁的数据类型，在其他语言中通常叫做数组。专门用于存储一串信息；列表用<code>[]</code>定义，数据之间使用<code>,</code>分隔；列表的索引从0开始。</p><blockquote><p>索引就是数据在列表中的位置编号，索引又可以被称为下标。从列表中取值时，如果超出索引范围，程序会报错</p></blockquote><table><thead><tr><th align="center">序号</th><th align="center">分类</th><th align="center">关键字&#x2F;函数&#x2F;方法</th><th align="center">说明描述</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">增加</td><td align="center">列表.<code>insert</code>(索引，数据)</td><td align="center">在指定位置插入数据</td></tr><tr><td align="center"></td><td align="center"></td><td align="center">列表.<code>append</code>(数据)</td><td align="center">在末尾追加数据</td></tr><tr><td align="center"></td><td align="center"></td><td align="center">列表.<code>extend</code>(列表2)</td><td align="center">将列表2的数据追加到列表</td></tr><tr><td align="center">2</td><td align="center">修改</td><td align="center">列表[索引] &#x3D; 数据</td><td align="center">修改指定索引的数据</td></tr><tr><td align="center">3</td><td align="center">删除</td><td align="center"><code>del</code> 列表[索引]</td><td align="center">删除指定索引的数据</td></tr><tr><td align="center"></td><td align="center"></td><td align="center">列表.<code>remove</code>[数据]</td><td align="center">删除第一个出现的指定数据</td></tr><tr><td align="center"></td><td align="center"></td><td align="center">列表.<code>pop</code></td><td align="center">删除末尾数据</td></tr><tr><td align="center"></td><td align="center"></td><td align="center">列表.<code>pop</code>(索引)</td><td align="center">删除指定索引数据</td></tr><tr><td align="center"></td><td align="center"></td><td align="center">列表.<code>clear</code></td><td align="center">清空列表</td></tr><tr><td align="center">4</td><td align="center">统计</td><td align="center"><code>len</code>(列表)</td><td align="center">列表长度</td></tr><tr><td align="center"></td><td align="center"></td><td align="center">列表.<code>count</code>(数据)</td><td align="center">数据在列表中出现的次数</td></tr><tr><td align="center">5</td><td align="center">排序</td><td align="center">列表.<code>sort</code>()</td><td align="center">升序排序</td></tr><tr><td align="center"></td><td align="center"></td><td align="center">列表.<code>sort</code>(<code>reverse</code> &#x3D; <code>True</code>)</td><td align="center">降序排序</td></tr><tr><td align="center"></td><td align="center"></td><td align="center">列表.<code>reverse</code>()</td><td align="center">逆序、反转</td></tr></tbody></table><p><strong><code>del</code>关键字</strong></p><ul><li>使用<code>del</code>关键字（<code>delete</code>）同样可以删除列表中元素；</li><li><code>del</code>关键字本质上是用来将一个变量从内存中删除的；</li><li>如果使用<code>del</code>关键字将变量从内存中删除，后续的代码就不能再使用这个变量了。</li></ul><p>在日常开发中，要从列表删除数据，建议使用列表提供的方法。</p><p><strong>循环遍历</strong></p><p>遍历就是从头到尾依次从列表中获取数据；在循环体内部针对每一个元素，执行相同的操作。在<code>Python</code>中为了提高列表的遍历效率，专门提供的迭代<code>iteration</code>遍历。使用<code>for</code>就能实现迭代遍历。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> name_list:</span><br><span class="line">    <span class="built_in">print</span>(name)</span><br></pre></td></tr></table></figure><p><strong>应用场景</strong></p><p>尽管Python的列表中可以存储不同类型的数据。但是在开发中，更多的应用场景是</p><ul><li>列表存储相同类型的数据</li><li>通过迭代遍历，在循环体内部，针对列表中的每一项元素，执行相同的操作</li></ul><h3 id="👀元组（Tuple）"><a href="#👀元组（Tuple）" class="headerlink" title="👀元组（Tuple）"></a>👀元组（Tuple）</h3><p>元组其实可以理解成一个稳固版的列表，因为元组是<strong>不可修改</strong>的，因此在列表中的存在的方法均不可以使用在元组上，但是元组是可以被查看索引的，方式就和列表一样：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">letters = (<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>, <span class="string">&quot;e&quot;</span>, <span class="string">&quot;f&quot;</span>, <span class="string">&quot;g&quot;</span>, <span class="string">&quot;h&quot;</span>)</span><br><span class="line">letter[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>（1）<code>Tuple</code>（元组）与列表类似，不同之处在于元组的元素不能修改</p><ul><li><p>元组表示多个元素组成的序列</p></li><li><p>元组在<code>Python</code>开发中，有特定的应用场景</p></li></ul><p>（2）用于存储一串信息，数据之间使用<code>,</code>分隔</p><p>（3）元组用<code>（）</code>定义</p><p>（4）元组的索引从<code>0</code>开始，索引就是数据在元组中的位置编号</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">info_tuple = (<span class="string">&quot;zhangsan&quot;</span>,<span class="number">18</span>,<span class="number">1.75</span>)</span><br><span class="line"><span class="comment"># 创建空元组</span></span><br><span class="line">first_tuple = ()</span><br><span class="line"><span class="comment"># 元组中只包含一个元素时，需要在元素后面添加逗号</span></span><br><span class="line">second_tuple = (<span class="number">50</span>,)</span><br></pre></td></tr></table></figure><blockquote><p>元组的索引值是从0开始的，<code>len</code>(元组)获取元组的长度n+1，元组.<code>count</code>(数据)数据在元组中出现的次数。</p></blockquote><ul><li>元组[索引]表示从列表中取值</li><li>元组.<code>index</code>[数据]表示获得数据第一次出现的索引。</li></ul><p><strong>循环遍历</strong></p><p>取值就是从元组中获取存储在指定位置的数据。</p><p>遍历就是从头到尾依次从元组中获取数据。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> name_tuple:</span><br><span class="line">    <span class="built_in">print</span>(item)</span><br></pre></td></tr></table></figure><blockquote><p>在<code>Python</code>中，可以使用<code>for</code> 循环遍历所有非数字型类型的变量：列表、元组、字典以及字符串提示：在实际开发中，除非能够确认元组中的数据类型，否则针对元组的循环遍历需求并不是很多</p></blockquote><p><strong>应用场景</strong></p><p>尽管可以使用<code>for in</code> 遍历元组。但是在开发中，更多的应用场景是：</p><ul><li>函数的参数和返回值，一个函数可以接收任意多个参数，或者一次返回多个数据（可以利用元组保存数据，即返回值默认是以元组形式保存的）；</li><li>格式化字符串，格式化字符串后面的（）本质上就是一个元组；</li><li>让列表不可以被修改，以保护数据安全。</li></ul><p><strong>元组和列表之间的转换</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用list函数可以把元组转换成列表</span></span><br><span class="line"><span class="built_in">list</span>(元组)</span><br><span class="line"><span class="comment"># 使用tuple函数可以把列表转换成元组</span></span><br><span class="line"><span class="built_in">tuple</span>(列表)</span><br></pre></td></tr></table></figure><h3 id="👀字典-Dictionary"><a href="#👀字典-Dictionary" class="headerlink" title="👀字典(Dictionary)"></a>👀字典(Dictionary)</h3><p>编程世界中其实有很多概念都基于现实生活的原型，字典这种数据结构的特征也正如现实世界中的字典一样，使用名称一内容进行数据的构建，在<code>Python</code>中分别对应着键（<code>key</code>）-值（<code>value</code>），习惯上称之为键值对。</p><p>字典的特征总结如下：</p><ul><li>字典中数据必须是以键值对的形式出现的；</li><li>逻辑上讲，键是不能重复的，而值可以重复；</li><li>字典中的键（<code>key</code>）是不可变的，也就是无法修改的；而值（<code>value</code>）是可变的，可修改的，可以是任何对象。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">xiaotang = &#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;xiaotang&quot;</span>,</span><br><span class="line">    <span class="string">&quot;age&quot;</span>: <span class="number">18</span>,</span><br><span class="line">    <span class="string">&quot;gender&quot;</span>: <span class="literal">True</span>,</span><br><span class="line">    <span class="string">&quot;height&quot;</span>: <span class="number">1.80</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（1）<code>dictionary</code>（字典）是除列表以外<code>Python</code>之中最灵活的数据类型</p><p>（2）字典同样可以用来存储多个数据</p><ul><li>通常用于存储描述一个物体的相关信息</li></ul><p>（3）字典和列表的区别</p><ul><li><strong>列表</strong>是<strong>有序</strong>的对象集合</li><li><strong>字典</strong>是<strong>无序</strong>的对象集合</li></ul><p>（4）字典用<code>&#123;&#125;</code>定义</p><p>（5）字典使用键值对存储数据，键值对之间使用<code>,</code>分隔</p><ul><li><p>键<code>key</code>是索引</p></li><li><p>值<code>value</code>是数据</p></li><li><p>键和值之间使用<code>:</code>分隔</p></li><li><p>键必须是唯一的</p></li><li><p>值可以取任何数据类型，但键只能使用字符串、数字或元组</p></li></ul><p><strong>字典的常用操作</strong></p><table><thead><tr><th align="center">关键字&#x2F;函数&#x2F;方法</th><th align="center">描述说明</th></tr></thead><tbody><tr><td align="center"><code>len</code>(字典)</td><td align="center">获取字典的键值对数量</td></tr><tr><td align="center">字典.<code>keys</code>()</td><td align="center">所有<code>key</code>列表</td></tr><tr><td align="center">字典.<code>values</code>()</td><td align="center">所有<code>value</code>列表</td></tr><tr><td align="center">字典.<code>items</code>()</td><td align="center">所有（<code>key</code>，<code>value</code>）元组列表</td></tr><tr><td align="center">字典[<code>key</code>]</td><td align="center">可以从字典中取值，<code>key</code>不存在会报错</td></tr><tr><td align="center">字典.<code>get(key)</code></td><td align="center">可以从字典中取值，<code>key</code>不存在不会报错</td></tr><tr><td align="center"><code>del</code> 字典<code>[key]</code></td><td align="center">删除指定键值对，<code>key</code>不存在会报错</td></tr><tr><td align="center">字典.<code>pop(key)</code></td><td align="center">删除指定键值对，<code>key</code>不存在会报错</td></tr><tr><td align="center">字典.<code>popitem()</code></td><td align="center">随机删除一个键值对</td></tr><tr><td align="center">字典.<code>clear()</code></td><td align="center">清空字典</td></tr><tr><td align="center">字典<code>[key]</code> &#x3D; <code>value</code></td><td align="center">如果<code>key</code>存在，修改数据<br />如果<code>key</code>不存在，新建键值对</td></tr><tr><td align="center">字典.<code>setdefault</code>(<code>key</code>, <code>value</code>)</td><td align="center">如果<code>key</code>存在，不会修改数据<br />如果<code>key</code>不存在，新建键值对</td></tr><tr><td align="center">字典1.<code>update</code>(字典2)</td><td align="center">将字典2的数据合并到字典1</td></tr></tbody></table><p><strong>循环遍历</strong></p><p>遍历就是依次从字典中获取所有键值对。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> item_key <span class="keyword">in</span> name_dic:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;%s: %s&quot;</span> % (item_key, name_dic[item_key]))</span><br></pre></td></tr></table></figure><blockquote><p>在实际开发中，由于字典中每一个键值对保存数据的类型是不同的，所以针对字典的循环遍历需求并不是很多。</p></blockquote><p><strong>应用场景</strong></p><p>尽管可以使用<code>for in</code>遍历字典。但是在开发中，更多的应用场景是：</p><ul><li>使用多个键值对，存储描述一个物体的相关信息——描述更复杂的数据信息</li><li>将多个字典放在一个列表中，再进行遍历，在循环体内部针对每一个字典进行相同的处理</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">card_list=[</span><br><span class="line">    &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;张三”，</span></span><br><span class="line"><span class="string">&quot;</span>qq<span class="string">&quot;: &quot;</span><span class="number">12345</span><span class="string">&quot;，</span></span><br><span class="line"><span class="string">&quot;</span>phone<span class="string">&quot;: &quot;</span><span class="number">110</span><span class="string">&quot;&#125;，</span></span><br><span class="line"><span class="string">&#123;&quot;</span>name<span class="string">&quot;: &quot;</span>李四<span class="string">&quot;，</span></span><br><span class="line"><span class="string">            &quot;</span>qq<span class="string">&quot;: &quot;</span><span class="number">54321</span><span class="string">&quot;，</span></span><br><span class="line"><span class="string">&quot;</span>phone<span class="string">&quot;: &quot;</span><span class="number">10086</span><span class="string">&quot;&#125;</span></span><br><span class="line"><span class="string">          ]</span></span><br></pre></td></tr></table></figure><h3 id="👀集合-Set"><a href="#👀集合-Set" class="headerlink" title="👀集合(Set)"></a>👀集合(Set)</h3><p>集合则更接近数学上集合的概念。每一个集合中的元素是<strong>无序的</strong>、<strong>不重复</strong>的任意对象，我们可以通过集合去判断数据的从属关系，有时还可以通过集合把数据结构中重复的元素减掉。</p><p>集合不能被切片也不能被索引，除了做集合运算之外，集合元素可以被添加还有删除。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">item_set = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;</span><br><span class="line">item_add(<span class="number">5</span>)</span><br><span class="line">item_discard(<span class="number">5</span>)</span><br></pre></td></tr></table></figure><p>参考文献：</p><p>《编程小白的第1本Python入门书》侯爵</p><p>《Python入门教程完整版》黑马程序员</p><p>《Python基础教程（第3版）》 Magnus Lie Hetland（著）袁国忠（译）</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Python基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python基础知识（02）</title>
      <link href="/2022/07/12/Python-Basic02/"/>
      <url>/2022/07/12/Python-Basic02/</url>
      
        <content type="html"><![CDATA[<p>编程语言是最有意思的，如果要实现一个复杂的功能或程序，条件语句和循环语句必不可少。除了常见的顺序结构，<code>if-elif-else</code>是常见的条件语句，当你写出这样的语句的时候，就意味着你告诉了计算机什么时候该怎么做，或者什么是不用做的。<code>for</code>循环和<code>while</code>循环是常见的循环语句，循环作为编程语言中最强力的特性之一，能够帮助我们做很多重复性的事情，比如批量命名、批量操作等。</p><h2 id="⛄顺序结构"><a href="#⛄顺序结构" class="headerlink" title="⛄顺序结构"></a>⛄顺序结构</h2><p>在我们最开始编写的基础程序中，语句都是逐条执行的。即从上而下，顺序执行代码。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = <span class="string">&quot;xiaotang&quot;</span></span><br><span class="line">name_describe =<span class="string">&quot;this is My name&quot;</span></span><br><span class="line">age = <span class="number">20</span></span><br><span class="line">age_describe = <span class="string">&quot;this is My age&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;=&quot;</span>*<span class="number">50</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;this is a line&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;this is another block&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hello World&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;My friends&quot;</span>)</span><br><span class="line">......</span><br></pre></td></tr></table></figure><h2 id="⛄分支结构"><a href="#⛄分支结构" class="headerlink" title="⛄分支结构"></a>⛄分支结构</h2><h3 id="👀布尔值"><a href="#👀布尔值" class="headerlink" title="👀布尔值"></a>👀布尔值</h3><p>现在，如果想更进一步，让程序选择是否执行特定的语句块，该怎么办呢？在介绍分支语句之前，我们先了解一下布尔值的用武之地，布尔值（<code>True</code>和<code>False</code>）作为一种变量的类型，实际上，<code>True</code>和<code>False</code>不过是0和1的别名，虽然看起来不同，但作用是相同的。换而言之，标准值<code>False</code>和<code>None</code>、各种类型（包括浮点数、复数等）的数值0、空序列（如空字符串、空元组和空列表）以及空映射（如空字典）都被视为假，而其他各种值都被视为真，包括特殊值<code>True</code>。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="literal">True</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="literal">False</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="literal">True</span> == <span class="number">1</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="literal">False</span> == <span class="number">0</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="literal">True</span> + <span class="literal">False</span> + <span class="number">20</span></span><br><span class="line"><span class="number">21</span></span><br></pre></td></tr></table></figure><blockquote><p>因此，如果你看到一个返回1或0的表达式（可能是使用较旧的<code>Python</code>版本编写的），就知道这实际上意味着<code>True</code>或<code>False</code>。</p></blockquote><p>布尔值<code>True</code>和<code>False</code>属于类型<code>bool</code>，而<code>bool</code>与<code>list</code>、<code>str</code>和<code>tuple</code>一样，可用来转换其他的值。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">bool</span>(<span class="string">&quot;I think, there I am&quot;</span>)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">bool</span>(<span class="number">20</span>)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">bool</span>(<span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">bool</span>(<span class="number">0</span>)</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure><blockquote><p>鉴于任何值都可用作布尔值，因此你几乎不需要显式地进行转换（<code>Python</code>会自动转换）。</p></blockquote><h3 id="👀if语句"><a href="#👀if语句" class="headerlink" title="👀if语句"></a>👀if语句</h3><p>真值可合并，至于如何合并稍后再讲，先来看看真值可用来做什么。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = <span class="built_in">input</span>(<span class="string">&quot;请输入你的语句：&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> name.endswith(<span class="string">&quot;wow!!&quot;</span>)：</span><br><span class="line"><span class="built_in">print</span>（<span class="string">&quot;hello xiaotang wow!!&quot;</span>）</span><br></pre></td></tr></table></figure><blockquote><p><code>endswith()</code>方法用于判断字符串是否以指定后缀结尾，如果以指定后缀结尾返回<code>True</code>，否则返回<code>False</code>。可选参数”<code>start</code>“和”<code>end</code>“为检索字符串的开始与结束位置。</p></blockquote><p>这就是if语句，让你能够有条件地执行代码。这意味着如果条件（<code>if</code>和冒号之间的表达式）为前面定义的真，就执行后续代码块（这里是一条<code>print</code>语句）；如果条件为假，就不执行（你应该猜到了）。</p><h3 id="👀else子句"><a href="#👀else子句" class="headerlink" title="👀else子句"></a>👀else子句</h3><p>在前一节的示例中，如果你输入以Gumby结尾的名字，方法<code>name.endswith</code>将返回<code>True</code>，导致后续代码块执行——打印问候语。如果你愿意，可使用else子句增加一种选择（之所以叫子句是因为<code>else</code>不是独立的语句，而是if语句的一部分）。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = <span class="built_in">input</span>(<span class="string">&quot;请输入你的语句：&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> name.endswith(<span class="string">&quot;wow!!&quot;</span>)：</span><br><span class="line"><span class="built_in">print</span>（<span class="string">&quot;hello xiaotang wow!!&quot;</span>）</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello people&quot;</span>)</span><br></pre></td></tr></table></figure><p>在这里，如果没有执行第一个代码块（因为条件为假），将进入第二个代码块。这个示例表明，<code>Python</code>代码很容易理解，不是吗？如果从if开始将代码大声朗读出来，听起来将像普通句子一样（也可能不那么普通）。</p><p>还有一个与<code>if</code>语句很像的“亲戚”，它就是条件表达式——C语言中三目运算符的<code>Python</code>版本。下面的表达式使用<code>if</code>和<code>else</code>确定其值：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">status = <span class="string">&quot;friend&quot;</span> <span class="keyword">if</span> name.endswith(<span class="string">&quot;wow!!&quot;</span>) <span class="keyword">else</span> <span class="string">&quot;people&quot;</span></span><br></pre></td></tr></table></figure><p>如果条件（紧跟在if后面）为真，表达式的结果为提供的第一个值（这里为”<code>friend</code>“），否则为第二个值（这里为”<code>people</code>“）。</p><h3 id="👀elif子句"><a href="#👀elif子句" class="headerlink" title="👀elif子句"></a>👀elif子句</h3><p>要检查多个条件，可使用<code>elif</code>。<code>elif</code>是<code>else if</code>的缩写，由一个<code>if</code>子句和一个<code>else</code>子句组合而成，也就是包含条件的<code>else</code>子句。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">num = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;Enter a number: &#x27;</span>)) </span><br><span class="line"><span class="keyword">if</span> num &gt; <span class="number">0</span>: </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;The number is positive&#x27;</span>) </span><br><span class="line"><span class="keyword">elif</span> num &lt; <span class="number">0</span>: </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;The number is negative&#x27;</span>) </span><br><span class="line"><span class="keyword">else</span>: </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;The number is zero&#x27;</span>) </span><br></pre></td></tr></table></figure><h3 id="👀代码块嵌套"><a href="#👀代码块嵌套" class="headerlink" title="👀代码块嵌套"></a>👀代码块嵌套</h3><p>下面穿插点额外的内容。你可将if语句放在其他if语句块中，如下所示：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> 条件 <span class="number">1</span>：</span><br><span class="line"><span class="comment"># 条件1满足执行的代码</span></span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> 条件<span class="number">1</span>基础上的条件<span class="number">2</span>：</span><br><span class="line">    <span class="comment"># 条件2满足时，执行的代码</span></span><br><span class="line">        ......</span><br><span class="line"><span class="comment"># 条件2不满足的处理</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 条件2不满足时，执行的代码</span></span><br><span class="line"><span class="comment"># 条件1不满足的处理</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="comment"># 条件1不满足时，执行的代码</span></span><br><span class="line">    ......</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = <span class="built_in">input</span>(<span class="string">&#x27;What is your name? &#x27;</span>) </span><br><span class="line"><span class="keyword">if</span> name.endswith(<span class="string">&#x27;Gumby&#x27;</span>): </span><br><span class="line"><span class="keyword">if</span> name.startswith(<span class="string">&#x27;Mr.&#x27;</span>): </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Hello, Mr. Gumby&#x27;</span>) </span><br><span class="line"><span class="keyword">elif</span> name.startswith(<span class="string">&#x27;Mrs.&#x27;</span>): </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Hello, Mrs. Gumby&#x27;</span>) </span><br><span class="line"><span class="keyword">else</span>: </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Hello, Gumby&#x27;</span>) </span><br><span class="line"><span class="keyword">else</span>: </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Hello, stranger&#x27;</span>) </span><br></pre></td></tr></table></figure><p>在这里，如果名字以Gumby结尾，就同时检查名字开头，这是在第一个代码块中使用一条独立的if语句完成的。请注意，这里还使用了<code>elif</code>。最后一个分支（<code>else</code>子句）没有指定条件——如果没有选择其他分支，就选择最后一个分支。如果需要，这里的两个<code>else</code>子句都可省略。如果省略里面的<code>else</code>子句，将忽略并非以Mr.或Mrs.打头的名字（假设名字为Gumby）。如果省略外面的<code>else</code>子句，将忽略陌生人。</p><h2 id="⛄循环结构"><a href="#⛄循环结构" class="headerlink" title="⛄循环结构"></a>⛄循环结构</h2><p>至此，你知道了如何在条件为真（或假）时执行操作，但如何重复操作多次呢？例如，你可能想创建一个程序，要打印1~100的所有数。当然，你可能会想到：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="number">5</span>)</span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line"><span class="built_in">print</span>(<span class="number">98</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="number">99</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="number">100</span>)</span><br></pre></td></tr></table></figure><p>但如果你愿意使用笨办法，就不会求助于<code>Python</code>了，不是吗？</p><p>循环的作用就是让<strong>指定的代码</strong>重复的执行。</p><h3 id="👀while循环"><a href="#👀while循环" class="headerlink" title="👀while循环"></a>👀while循环</h3><p>为避免前述示例所示的繁琐代码，可以使用<code>while</code>循环快速地打印出1~100的所有数。<code>while</code>循环最常用的应用场景就是让<strong>执行的代码</strong>按照<strong>指定的次数重复</strong>执行。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = <span class="number">1</span> </span><br><span class="line"><span class="keyword">while</span> x &lt;= <span class="number">100</span>: </span><br><span class="line"><span class="built_in">print</span>(x) </span><br><span class="line">x += <span class="number">1</span></span><br></pre></td></tr></table></figure><p>就像上面那样做，不太复杂，不是吗？你还可以使用循环来确保用户输入名字，如下所示：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = <span class="string">&#x27;&#x27;</span> </span><br><span class="line"><span class="keyword">while</span> <span class="keyword">not</span> name: </span><br><span class="line">name = <span class="built_in">input</span>(<span class="string">&#x27;Please enter your name: &#x27;</span>) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Hello, &#123;&#125;!&#x27;</span>.<span class="built_in">format</span>(name)) </span><br></pre></td></tr></table></figure><p>请尝试运行这些代码，并在要求你输入名字时直接按回车键。你会看到提示信息再次出现，因为name还是为空字符串，这相当于假。</p><blockquote><p>如果你只是输入一个空格字符（将其作为你的名字），结果将如何呢？程序将接受这个名字，因为包含一个空格字符的字符串不是空的，因此不会将name视为假。这无疑是这个小程序的一个瑕疵，但很容易修复：只需将<code>while not name</code>改为<code>while not name or name.isspace()</code>或<code>while not name.strip()</code>即可。</p><p><code>isspace()</code>方法：如果字符串中的所有字符均为空格字符，则返回”<code>True</code>“，否则，返回”<code>False</code>“;</p><p><code>strip()</code>方法：用于移除字符串头尾指定的字符（默认为空格或换行符）或字符序列。该方法只能删除开头或结尾的字符，不能删除中间部分的字符。</p></blockquote><p><strong>while循环语句基本语法</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">初始条件设置--通常是重复执行的计数器</span><br><span class="line"><span class="keyword">while</span> 条件（判断计数器是否达到目标次数）：</span><br><span class="line">条件满足时，做的事情<span class="number">1</span></span><br><span class="line">    条件满足时，做的事情<span class="number">2</span></span><br><span class="line">    条件满足时，做的事情<span class="number">3</span></span><br><span class="line">    ......</span><br><span class="line">    处理条件（例如：计数器 + <span class="number">1</span>）</span><br></pre></td></tr></table></figure><p><code>while</code>语句以及缩进部分是一个<strong>完整的代码块</strong>。例子：打印100遍<code>Hello Python</code></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1 初始条件设置--通常是重复执行的计数器</span></span><br><span class="line">i = <span class="number">1</span></span><br><span class="line"><span class="comment"># 2 使用while判断条件</span></span><br><span class="line"><span class="keyword">while</span> i &lt;= <span class="number">5</span>：</span><br><span class="line"><span class="comment"># 要重复执行的代码</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello Python&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 处理计数器 i</span></span><br><span class="line">    i = i + <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;循环结束后 i = %d&quot;</span> % i)</span><br></pre></td></tr></table></figure><p>注意：循环结束后，之前定义的计数器条件的数值时依旧存在的。</p><blockquote><p>死循环，由于程序员的问题，忘记在循环内部<strong>修改循环的判断条件</strong>，导致<strong>循环持续执行</strong>，程序无法终止。</p></blockquote><h3 id="👀for循环"><a href="#👀for循环" class="headerlink" title="👀for循环"></a>👀for循环</h3><p><code>while</code>语句非常灵活，可用于在条件为真时反复执行代码块。这在通常情况下很好，但有时候你可能想根据需要进行定制。一种这样的需求是为序列（或其他可迭代对象）中每个元素执行代码块。</p><blockquote><p>基本上，可迭代对象是可使用for循环进行遍历的对象。就目前而言，只需将可迭代对象视为序列即可。</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">words = [<span class="string">&#x27;this&#x27;</span>, <span class="string">&#x27;is&#x27;</span>, <span class="string">&#x27;an&#x27;</span>, <span class="string">&#x27;ex&#x27;</span>, <span class="string">&#x27;parrot&#x27;</span>] </span><br><span class="line"><span class="keyword">for</span> word <span class="keyword">in</span> words: </span><br><span class="line"><span class="built_in">print</span>(word) </span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">numbers = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>] </span><br><span class="line"><span class="keyword">for</span> number <span class="keyword">in</span> numbers: </span><br><span class="line"><span class="built_in">print</span>(number)</span><br></pre></td></tr></table></figure><p>鉴于迭代（也就是遍历）特定范围内的数是一种常见的任务，<code>Python</code>提供了一个创建范围的内置函数。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">range</span>(<span class="number">0</span>, <span class="number">10</span>) </span><br><span class="line"><span class="built_in">range</span>(<span class="number">0</span>, <span class="number">10</span>) </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">0</span>, <span class="number">10</span>)) </span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>] </span><br></pre></td></tr></table></figure><p>范围类似于切片。它们包含起始位置（这里为0），但不包含结束位置（这里为10）。在很多情况下，你都希望范围的起始位置为0。实际上，如果只提供了一个位置，将把这个位置视为结束位置，并假定起始位置为0。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">range</span>(<span class="number">10</span>) </span><br><span class="line"><span class="built_in">range</span>(<span class="number">0</span>, <span class="number">10</span>) </span><br></pre></td></tr></table></figure><p>下面的程序打印数1～100：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> number <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">101</span>): </span><br><span class="line"><span class="built_in">print</span>(number) </span><br></pre></td></tr></table></figure><p>（1）迭代字典</p><p>要遍历字典的所有关键字，可像遍历序列那样使用普通的for语句。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d = &#123;<span class="string">&#x27;x&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;y&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;z&#x27;</span>: <span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> d:</span><br><span class="line"><span class="built_in">print</span>(key, <span class="string">&#x27;corresponds to&#x27;</span>, d[key])</span><br></pre></td></tr></table></figure><p>也可使用<code>keys</code>等字典方法来获取所有的键。如果只对值感兴趣，可使用<code>d.values</code>。你可能还记得，<code>d.items</code>以元组的方式返回键值对。<code>for</code>循环的优点之一是，可在其中使用序列解包。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> key, value <span class="keyword">in</span> d.items(): </span><br><span class="line"><span class="built_in">print</span>(key, <span class="string">&#x27;corresponds to&#x27;</span>, value)</span><br></pre></td></tr></table></figure><p>（2）遍历列表</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">names = [<span class="string">&#x27;anne&#x27;</span>, <span class="string">&#x27;beth&#x27;</span>, <span class="string">&#x27;george&#x27;</span>, <span class="string">&#x27;damon&#x27;</span>]</span><br><span class="line">ages = [<span class="number">12</span>, <span class="number">45</span>, <span class="number">32</span>, <span class="number">102</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(names)):</span><br><span class="line"><span class="built_in">print</span>(names[i], <span class="string">&#x27;is&#x27;</span>, ages[i], <span class="string">&#x27;years old&#x27;</span>) </span><br></pre></td></tr></table></figure><h3 id="👀break和continue"><a href="#👀break和continue" class="headerlink" title="👀break和continue"></a>👀break和continue</h3><p><code>break</code>和<code>continue</code>是专门在循环中使用的关键字。</p><blockquote><p><code>break</code>：在循环过程中，如果某一条件满足后，不希望执行循环，可以使用<code>break</code>退出循环；</p><p><code>continue</code>：在循环过程中，如果某一条件满足后，不希望执行循环，但又不退出循环，可以使用<code>continue</code>跳过当次循环。即：在整个循环中，只有某些条件，不需要执行循环代码，而其它条件都需要执行。</p></blockquote><h3 id="👀练习"><a href="#👀练习" class="headerlink" title="👀练习"></a>👀练习</h3><p>（1）打印小星星</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 打印小星星</span></span><br><span class="line">i = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> i &lt;= <span class="number">5</span>:</span><br><span class="line">    j = <span class="number">1</span></span><br><span class="line">    <span class="comment"># 在循环内部，再增加一个循环，实现每一行的星星打印</span></span><br><span class="line">    <span class="keyword">while</span> j &lt;= i:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>,end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">        j += <span class="number">1</span></span><br><span class="line">    <span class="comment"># 每一行星号输出完成后，再增加一个换行</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&quot;</span>)</span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">*</span><br><span class="line">**</span><br><span class="line">***</span><br><span class="line">****</span><br><span class="line">*****</span><br></pre></td></tr></table></figure><blockquote><p>默认情况下，<code>print()</code>函数输出内容之后，会自动在内容末尾增加换行；如果不希望末尾增加换行，可以在<code>print()</code>函数输出内容的后面增加，<code>end=&quot;&quot;</code>；其中””中间可以指定<code>print()</code>函数输出内容之后，继续希望显示的内容。</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 向控制台输出内容结束之后，不会换行</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>,end=<span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="comment"># 单纯的换行</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&quot;</span>)</span><br></pre></td></tr></table></figure><p>（2）打印九九乘法表</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 打印九九乘法表</span></span><br><span class="line">i = <span class="number">1</span></span><br><span class="line"><span class="comment"># 最大打印9行</span></span><br><span class="line"><span class="keyword">while</span> i &lt;= <span class="number">9</span>:</span><br><span class="line">    <span class="comment"># 定义起始列</span></span><br><span class="line">    j = <span class="number">1</span></span><br><span class="line">    <span class="comment"># 最大打印i列</span></span><br><span class="line">    <span class="keyword">while</span> j &lt;= i:</span><br><span class="line">        <span class="comment"># 转义字符，\t在控制台输出一个制表符，协助在输出文件时，垂直方向保持对齐</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%d*%d=%d&quot;</span>%(j,i,i*j),end=<span class="string">&quot;\t&quot;</span>)</span><br><span class="line">        j += <span class="number">1</span></span><br><span class="line">    <span class="comment"># 一行打印完成后，换行</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&quot;</span>)</span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="number">1</span>*<span class="number">1</span>=<span class="number">1</span></span><br><span class="line"><span class="number">1</span>*<span class="number">2</span>=<span class="number">2</span>   <span class="number">2</span>*<span class="number">2</span>=<span class="number">4</span></span><br><span class="line"><span class="number">1</span>*<span class="number">3</span>=<span class="number">3</span>   <span class="number">2</span>*<span class="number">3</span>=<span class="number">6</span>   <span class="number">3</span>*<span class="number">3</span>=<span class="number">9</span></span><br><span class="line"><span class="number">1</span>*<span class="number">4</span>=<span class="number">4</span>   <span class="number">2</span>*<span class="number">4</span>=<span class="number">8</span>   <span class="number">3</span>*<span class="number">4</span>=<span class="number">12</span>  <span class="number">4</span>*<span class="number">4</span>=<span class="number">16</span></span><br><span class="line"><span class="number">1</span>*<span class="number">6</span>=<span class="number">6</span>   <span class="number">2</span>*<span class="number">6</span>=<span class="number">12</span>  <span class="number">3</span>*<span class="number">6</span>=<span class="number">18</span>  <span class="number">4</span>*<span class="number">6</span>=<span class="number">24</span>  <span class="number">5</span>*<span class="number">6</span>=<span class="number">30</span>  <span class="number">6</span>*<span class="number">6</span>=<span class="number">36</span></span><br><span class="line"><span class="number">1</span>*<span class="number">7</span>=<span class="number">7</span>   <span class="number">2</span>*<span class="number">7</span>=<span class="number">14</span>  <span class="number">3</span>*<span class="number">7</span>=<span class="number">21</span>  <span class="number">4</span>*<span class="number">7</span>=<span class="number">28</span>  <span class="number">5</span>*<span class="number">7</span>=<span class="number">35</span>  <span class="number">6</span>*<span class="number">7</span>=<span class="number">42</span>  <span class="number">7</span>*<span class="number">7</span>=<span class="number">49</span></span><br><span class="line"><span class="number">1</span>*<span class="number">8</span>=<span class="number">8</span>   <span class="number">2</span>*<span class="number">8</span>=<span class="number">16</span>  <span class="number">3</span>*<span class="number">8</span>=<span class="number">24</span>  <span class="number">4</span>*<span class="number">8</span>=<span class="number">32</span>  <span class="number">5</span>*<span class="number">8</span>=<span class="number">40</span>  <span class="number">6</span>*<span class="number">8</span>=<span class="number">48</span>  <span class="number">7</span>*<span class="number">8</span>=<span class="number">56</span>  <span class="number">8</span>*<span class="number">8</span>=<span class="number">64</span></span><br><span class="line"><span class="number">1</span>*<span class="number">9</span>=<span class="number">9</span>   <span class="number">2</span>*<span class="number">9</span>=<span class="number">18</span>  <span class="number">3</span>*<span class="number">9</span>=<span class="number">27</span>  <span class="number">4</span>*<span class="number">9</span>=<span class="number">36</span>  <span class="number">5</span>*<span class="number">9</span>=<span class="number">45</span>  <span class="number">6</span>*<span class="number">9</span>=<span class="number">54</span>  <span class="number">7</span>*<span class="number">9</span>=<span class="number">63</span>  <span class="number">8</span>*<span class="number">9</span>=<span class="number">72</span>  <span class="number">9</span>*<span class="number">9</span>=<span class="number">81</span></span><br></pre></td></tr></table></figure><blockquote><p><code>\t</code> 在控制台输出一个制表符，协助在输出文本时垂直方向保持对齐</p><p><code>\n</code> 在控制台输出一个换行符</p><p>制表符的功能是在不使用表格的情况下在垂直方向按列对齐文本。</p></blockquote><h2 id="⛄转义字符"><a href="#⛄转义字符" class="headerlink" title="⛄转义字符"></a>⛄转义字符</h2><p>转义字符是很多程序语言、数据格式和通信协议的形式文法的一部分。对于一个给定的字母表，一个转义字符的目的是开始一个字符序列，使得转义字符开头的该字符序列具有不同于该字符序列单独出现时的语义。因此转义字符开头的字符序列被叫做转义序列。</p><p>转义序列通常有两种功能。第一个是编码一个句法上的实体，如设备命令或者无法被字母表直接表示的特殊数据。第二种功能，也叫字符引用，用于表示无法在当前上下文中被键盘录入的字符（如字符串中的回车符），或者在当前上下文中会有不期望的含义的字符（如C语言字符串中的双引号字符”，不能直接出现，必须用转义序列表示）。在后面那种情况，转义序列是一种由转义字符自身和一个被引用的字符组成的一个二合字母（<code>digraph</code>）情形。</p><table><thead><tr><th align="center">转义字符</th><th align="center">描述说明</th></tr></thead><tbody><tr><td align="center">\\</td><td align="center">反斜杠符号</td></tr><tr><td align="center">&#39;</td><td align="center">单引号</td></tr><tr><td align="center">&quot;</td><td align="center">双引号</td></tr><tr><td align="center">\n</td><td align="center">换行</td></tr><tr><td align="center">\t</td><td align="center">横向制表符</td></tr><tr><td align="center">\r</td><td align="center">回车</td></tr></tbody></table><p>参考文献：</p><p>《编程小白的第1本Python入门书》侯爵</p><p>《Python基础教程（第3版）》 Magnus Lie Hetland（著）袁国忠（译）</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Python基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python基础知识（01）</title>
      <link href="/2022/07/09/Python-Basic01/"/>
      <url>/2022/07/09/Python-Basic01/</url>
      
        <content type="html"><![CDATA[<p>1999年，吉多·范罗苏姆向<code>DARPA</code>提交了一条名为”<code>Computer Programming for Everybody</code>“的资金申请，并在后来说明了他对<code>Python</code>的目标：</p><ul><li>一门简单直观的语言并与主要竞争者一样强大</li><li>开源，以便任何人都可以为它做贡献</li><li>代码像纯英语那样容易理解</li><li>适用于短期开发的日常任务</li></ul><p>计算机不能直接理解任何除<strong>机器语言</strong>以外的语言，所以必须要把程序员所写的程序语言翻译成机器语言，计算机才能执行程序。将其他语言翻译成机器语言的工具，被称为<strong>编译器</strong>。</p><p>编译器翻译的方式有两种：一个是<strong>编译</strong>，另外一个是<strong>解释</strong>。两种方式之间的区别在于翻译时间点的不同。当编译器以解释方式运行的时候，也称之为<strong>解释器</strong>。</p><ul><li><strong>编译型语言</strong>：程序在执行之前需要一个专门的编译过程，把程序编译成为机器语言的文件，运行时不需要重新翻译，直接使用编译的结果就行了。程序执行效率高，依赖编译器，跨平台性差些。如<code>C</code>、<code>C++</code>。</li><li><strong>解释型语言</strong>：解释型语言编写的程序不进行预先编译，以文本方式存储程序代码，会将代码一句一句直接运行。在发布程序时，看起来省了道编译工序，但是在运行程序的时候，必须先解释再运行</li></ul><blockquote><p>编译型语言和解释型语言对比</p><ul><li>速度——编译型语言比解释型语言执行速度快</li><li>跨平台性——解释型语言比编译型语言跨平台性好</li></ul></blockquote><h2 id="⛄Python-概述"><a href="#⛄Python-概述" class="headerlink" title="⛄Python 概述"></a>⛄Python 概述</h2><h3 id="👀Python特点"><a href="#👀Python特点" class="headerlink" title="👀Python特点"></a>👀Python特点</h3><ul><li><code>Python</code> 是完全面向对象的语言</li></ul><ol><li><p>函数、模块、数字、字符串都是对象，在<code>Python</code>中一切皆对象</p></li><li><p>完全支持继承、重载、多重继承</p></li><li><p>支持重载运算符，也支持泛型设计</p></li></ol><ul><li><code>Python</code> 拥有一个强大的标准库，</li></ul><ol><li><code>Python</code>语言的核心只包含数字、字符串、列表、字典、文件等常见类型和函数，而由<code>Python</code>标准库提供了系统管理、网络通信、文本处理、数据库接口、图形系统、<code>XML</code>处理等额外的功能。</li><li><code>Python</code> 社区提供了大量的第三方模块，使用方式与标准库类似。它们的功能覆盖科学计算、人工智能、机器学习、<code>Web</code>开发、数据库接口、图形系统多个领域。</li></ol><h3 id="👀Python程序执行方式"><a href="#👀Python程序执行方式" class="headerlink" title="👀Python程序执行方式"></a>👀Python程序执行方式</h3><ul><li><code>Python</code>解释器</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用Python2.x解释器</span></span><br><span class="line">python xxx.py</span><br><span class="line"><span class="comment"># 使用Python3.x解释器</span></span><br><span class="line">python3 xxx.py</span><br><span class="line"></span><br><span class="line"><span class="comment"># 其他语言Python解释器</span></span><br><span class="line">CPython       <span class="comment"># 官方版本的C语言实现</span></span><br><span class="line">Jython        <span class="comment"># 可以运行在Java平台</span></span><br><span class="line">IronPython    <span class="comment"># 可以运行在.NET和Mono平台</span></span><br><span class="line">PyPy          <span class="comment"># Python实现的，支持JIT即时编译</span></span><br></pre></td></tr></table></figure><ul><li>交互式运行<code>Python</code>程序</li></ul><p>直接在终端中运行解释器，而不输入要执行的文件名；在<code>Python</code>的<code>Shell</code>中直接输入<code>Python</code>的代码，会立即看到程序执行结果。优缺点：适合于学习&#x2F;验证<code>Python</code>语法或者局部代码；代码不能保存，不适合运行太大的程序。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">退出官方的解释器</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">(1) 直接输入<span class="built_in">exit</span>()</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; <span class="built_in">exit</span>()</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">(2)使用热键退出</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在python解释器中，使用热键ctrl+d可以退出解释器</span></span><br></pre></td></tr></table></figure><ul><li><code>IPython</code></li></ul><p><code>Ipython</code>中的“<code>I</code>”代表交互<code>interactive</code></p><p>特点：<code>IPython</code>是一个<code>python</code>的交互式<code>shell</code>，比默认的<code>python shell</code>好用得多。<code>IPython</code>是基于<code>BSD</code>开源的。</p><ol><li>支持自动补全；</li><li>自动缩进；</li><li>支持<code>bash shell</code>命令；</li><li>内置了许多很有用的功能和函数。</li></ol><blockquote><p>单行注释，行注释，以#开头</p><p>多行注释，块注释，一对连续的三个引号</p></blockquote><h2 id="⛄Python基础知识（快速入门）"><a href="#⛄Python基础知识（快速入门）" class="headerlink" title="⛄Python基础知识（快速入门）"></a>⛄Python基础知识（快速入门）</h2><h3 id="👀标识符和关键字"><a href="#👀标识符和关键字" class="headerlink" title="👀标识符和关键字"></a>👀标识符和关键字</h3><p><strong>标识符</strong>就是程序员定义变量名、函数名。</p><blockquote><p>命名规则：在<code>Python</code>中，<strong>标识符</strong>（名称）只能由字母、数字和下划线（<code>_</code>）构成；不能以数字开头；不能与<strong>关键字</strong>重名；区分大小写。</p></blockquote><p><strong>关键字</strong>就是在<code>Python</code>内部已经使用的标识符；<strong>关键字</strong>具有特殊的功能和含义；开发者不允许定义和关键字相同名字的标识符。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 通过以下命令查看可以查看Python中的关键字</span></span><br><span class="line"><span class="keyword">import</span> keyword             <span class="comment"># import关键字可以导入一个“工具包”</span></span><br><span class="line"><span class="built_in">print</span>(keyword.kwlist)</span><br></pre></td></tr></table></figure><h3 id="👀变量"><a href="#👀变量" class="headerlink" title="👀变量"></a>👀变量</h3><p>变量是表示（或指向）特定值的名称。例如，可以使用名称<code>X</code>来表示<code>6</code>。不同于其它一些语言，使用Python变量前必须给它赋值，因为Python变量没有默认值。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Python中的标识符是区分大小写的</span></span><br><span class="line">x = <span class="number">6</span>    <span class="comment"># 赋值，表示将6赋给了变量x，等号（=）用来给变量赋值；</span></span><br><span class="line"><span class="comment"># 变量赋值之后，就可在表达式中使用它</span></span><br></pre></td></tr></table></figure><p>在定义变量时，为了保证代码格式，<code>=</code>的左右应该各保留一个空格；在<code>Python</code>中，如果变量名需要<strong>两个</strong>或<strong>多个单词</strong>组成时，可以按照以下方式命名：</p><ul><li>每个单词都使用小写字母；</li><li>单词与单词之间使用<code>_</code>下划线连接，例如：<code>first_name</code>&#x2F;<code>last_name</code>。</li></ul><p><strong>驼峰命名法</strong>，当变量名是由两个或多个单词组成时，还可以利用驼峰命名法来命名。</p><p>小驼峰式命名法：第一个单词以小写字母开始，后续单词的首字母大写。例如：<code>firstName</code>&#x2F;<code>lastName</code>。</p><p>大驼峰式命名法：每一个单词的首字母都采用大写字母。例如：<code>FirstName</code>&#x2F;<code>LastName</code>。</p><h3 id="👀变量的类型"><a href="#👀变量的类型" class="headerlink" title="👀变量的类型"></a>👀变量的类型</h3><p>首先，在内存中创建一个变量，会包括：</p><ul><li>变量的名称</li><li>变量保存的数据</li><li>变量存储数据的类型</li><li>变量的地址</li></ul><p>在Python中定义变量是<strong>不需要指定类型</strong>，数据类型可以分为数字型和非数字型；</p><table><thead><tr><th align="center">数字型</th><th align="center">非数字型</th></tr></thead><tbody><tr><td align="center">整型（<code>int</code>)</td><td align="center">字符串（<code>string</code>）</td></tr><tr><td align="center">浮点型（<code>float</code>)</td><td align="center">列表（<code>list</code>）</td></tr><tr><td align="center">布尔型（<code>bool</code>：<code>True</code>非0、<code>False</code>）</td><td align="center">元组（<code>tuple</code>不能修改）</td></tr><tr><td align="center">复数型（主要用于科学计算）</td><td align="center">字典（<code>dict</code>:键和值）</td></tr></tbody></table><h3 id="👀不同类型变量之间的计算"><a href="#👀不同类型变量之间的计算" class="headerlink" title="👀不同类型变量之间的计算"></a>👀不同类型变量之间的计算</h3><ol><li><p>数字型变量之间可以直接计算</p><p>在<code>Python</code>中，两个数字型变量是可以直接进行算术运算的，如果变量是<code>bool</code>型，在计算时：</p><ul><li><p><code>True</code>对应的数字是1</p></li><li><p><code>False</code>对应的数字是0</p></li></ul></li><li><p>字符串变量之间使用<code>+</code>拼接字符串</p><p>在Python中，字符串之间可以使用<code>+</code>拼接生成新的字符串。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">first_name = <span class="string">&quot;张&quot;</span></span><br><span class="line">last_name = <span class="string">&quot;三&quot;</span></span><br><span class="line">Name = first_name + last_name</span><br><span class="line"><span class="comment"># 输出“张三”</span></span><br></pre></td></tr></table></figure></li><li><p>字符串变量可以和整数使用<code>*</code>重复拼接相同的字符串</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;%&quot;</span> * <span class="number">10</span></span><br><span class="line"><span class="comment"># 输出“%%%%%%%%%%”</span></span><br></pre></td></tr></table></figure></li><li><p>数字型变量和字符串之间不能进行其它计算</p></li></ol><h3 id="👀变量的输入"><a href="#👀变量的输入" class="headerlink" title="👀变量的输入"></a>👀变量的输入</h3><p>所谓<strong>输入</strong>，就是用<strong>代码</strong>获取用户通过<strong>键盘输入的信息</strong>。例如：输入密码</p><p>在<code>Python</code>中，如果要获取用户在<strong>键盘</strong>上的输入信息，需要使用到<code>input</code>函数。</p><p>（1）关于函数</p><table><thead><tr><th align="center">函数</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center"><code>print(x)</code></td><td align="center">将<code>x</code>输出到控制台</td></tr><tr><td align="center"><code>type(x)</code></td><td align="center">查看<code>x</code>的变量类型</td></tr></tbody></table><p>（2）<code>input</code>函数实现键盘输入</p><p>在<code>Python</code>中可以使用<code>input</code>函数从键盘中等待用户的输入；</p><p>用户输入的任何内容，<code>Python</code>都认为是一个字符串；</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">字符串变量 = <span class="built_in">input</span>(<span class="string">&quot;提示信息：&quot;</span>)</span><br><span class="line">浮点数变量 = <span class="built_in">float</span>(<span class="built_in">input</span>(<span class="string">&quot;提示信息：&quot;</span>))</span><br><span class="line">整数型变量 = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;提示信息：&quot;</span>))</span><br></pre></td></tr></table></figure><p>（3）类型转换函数</p><table><thead><tr><th align="center">函数</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center"><code>int(x)</code></td><td align="center">将<code>x</code>转换为一个整数</td></tr><tr><td align="center"><code>float(x)</code></td><td align="center">将<code>x</code>转换为一个浮点数</td></tr></tbody></table><h3 id="👀变量的格式化输出"><a href="#👀变量的格式化输出" class="headerlink" title="👀变量的格式化输出"></a>👀变量的格式化输出</h3><p>在<code>Python</code>中可以使用<code>print</code>函数将信息输出到控制台；如果希望输出文字信息的同时，一起输出数据，就需要使用到<strong>格式化操作符</strong>。</p><p><code>%</code>被称为格式化操作符，专门用于处理字符串中的格式。</p><ul><li><p>包含<code>%</code>的字符串，被称为<strong>格式化字符串</strong>；</p></li><li><p><code>%</code>和不同的<strong>字符</strong>连用，<strong>不同类型的数据</strong>需要使用<strong>不同的格式化字符</strong>。</p></li></ul><table><thead><tr><th align="center">格式化字符</th><th align="center">含义说明</th></tr></thead><tbody><tr><td align="center"><code>%s</code></td><td align="center">字符串</td></tr><tr><td align="center"><code>%d</code></td><td align="center">有符号十进制整数，<code>%06d</code>表示输出的整数显示位数，不足的地方使用<code>0</code>补全</td></tr><tr><td align="center"><code>%f</code></td><td align="center">浮点数，<code>%.2f</code>表示小数点后只显示两位</td></tr><tr><td align="center"><code>%%</code></td><td align="center">输出<code>%</code></td></tr></tbody></table><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 语法格式</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;格式化字符串&quot;</span> % 变量<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;格式化字符串&quot;</span> % （变量<span class="number">1</span>，变量<span class="number">2.</span>..）)</span><br><span class="line"></span><br><span class="line">name = <span class="string">&quot;小明&quot;</span></span><br><span class="line">student = 000001</span><br><span class="line">scale = <span class="number">10.00</span>%</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;我的名字叫%s&quot;</span> % name)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;我的学号是%06d&quot;</span> % student)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;数据比例是%.2f%%&quot;</span> % (scale * <span class="number">100</span>)</span><br></pre></td></tr></table></figure><h2 id="⛄运算符"><a href="#⛄运算符" class="headerlink" title="⛄运算符"></a>⛄运算符</h2><p>运算符主要包括：</p><ul><li>算术运算符</li><li>比较（关系）运算符</li><li>逻辑运算符</li><li>赋值运算符</li><li>运算符的优先级</li></ul><h3 id="👀算术运算符"><a href="#👀算术运算符" class="headerlink" title="👀算术运算符"></a>👀算术运算符</h3><p>算术运算符是完成基本的算术运算使用的符号，用来处理四则运算。</p><table><thead><tr><th align="center">运算符</th><th align="center">描述</th><th align="center">实例</th></tr></thead><tbody><tr><td align="center"><code>+</code></td><td align="center">加</td><td align="center"><code>30 + 20 = 50</code></td></tr><tr><td align="center"><code>-</code></td><td align="center">减</td><td align="center"><code>30 - 20 = 10</code></td></tr><tr><td align="center"><code>*</code></td><td align="center">乘（也可计算字符串重复次数）</td><td align="center"><code>30 * 20 = 600</code></td></tr><tr><td align="center"><code>/</code></td><td align="center">除</td><td align="center"><code>30 / 20 = 1.5</code></td></tr><tr><td align="center"><code>//</code></td><td align="center">取整除</td><td align="center"><code>9 // 2 = 4</code></td></tr><tr><td align="center"><code>%</code></td><td align="center">取余数</td><td align="center"><code>9 % 2 = 1</code></td></tr><tr><td align="center"><code>**</code></td><td align="center">幂</td><td align="center"><code>2 ** 3 = 8</code></td></tr></tbody></table><h3 id="👀比较（关系）运算符"><a href="#👀比较（关系）运算符" class="headerlink" title="👀比较（关系）运算符"></a>👀比较（关系）运算符</h3><table><thead><tr><th align="center">运算符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="center"><code>==</code></td><td align="left">检查两个操作数的值是否<strong>相等</strong>，如果是，则条件成立，返回<code>True</code></td></tr><tr><td align="center"><code>!=</code></td><td align="left">检查两个操作数的值是否<strong>不相等</strong>，如果是，则条件成立，返回<code>True</code></td></tr><tr><td align="center"><code>&gt;</code></td><td align="left">检查左操作数的值是否<strong>大于</strong>右操作数的值，如果是，则条件成立，返回<code>True</code></td></tr><tr><td align="center"><code>&lt;</code></td><td align="left">检查左操作数的值是否<strong>小于</strong>右操作数的值，如果是，则条件成立，返回<code>True</code></td></tr><tr><td align="center"><code>&gt;=</code></td><td align="left">检查左操作数的值是否<strong>大于或等于</strong>右操作数的值，如果是，则条件成立，返回<code>True</code></td></tr><tr><td align="center"><code>&lt;=</code></td><td align="left">检查左操作数的值是否<strong>小于或等于</strong>右操作数的值，如果是，则条件成立，返回<code>True</code></td></tr></tbody></table><h3 id="👀逻辑运算符"><a href="#👀逻辑运算符" class="headerlink" title="👀逻辑运算符"></a>👀逻辑运算符</h3><table><thead><tr><th align="center">运算符</th><th align="center">逻辑表达式</th><th>描述</th></tr></thead><tbody><tr><td align="center"><code>and</code></td><td align="center"><code>x and y</code></td><td>只有<code>x</code>和<code>y</code>的值都为<code>True</code>，才会返回<code>True</code><br />否则只要<code>x</code>或者<code>y</code>有一个值为<code>False</code>，就返回<code>False</code></td></tr><tr><td align="center"><code>or</code></td><td align="center"><code>a or y</code></td><td>只要<code>x</code>或者<code>y</code>有一个值为<code>True</code>，就返回True<br />只有<code>x</code>和<code>y</code>的值都为<code>False</code>，才会返回<code>False</code></td></tr><tr><td align="center"><code>not</code></td><td align="center"><code>not x</code></td><td>如果<code>x</code>为<code>True</code>，返回<code>False</code><br />如果<code>x</code>为<code>False</code>，返回<code>True</code></td></tr></tbody></table><h3 id="👀-赋值运算符"><a href="#👀-赋值运算符" class="headerlink" title="👀 赋值运算符"></a>👀 赋值运算符</h3><p>在<code>Python</code>中，使用&#x3D;可以给变量赋值；在算术运算时，为了简化代码的编写，<code>python</code>还提供了一系列与算术运算符对应的赋值运算符。注意：赋值运算符中间不能使用空格。</p><table><thead><tr><th align="center">运算符</th><th align="center">描述</th><th>实例</th></tr></thead><tbody><tr><td align="center"><code>=</code></td><td align="center">简单的赋值运算符</td><td>c &#x3D; a + b将a + b的运算结果赋值为c</td></tr><tr><td align="center"><code>+=</code></td><td align="center">加法赋值运算符</td><td>c +&#x3D; a等效于c &#x3D; c + a</td></tr><tr><td align="center"><code>-=</code></td><td align="center">减法赋值运算符</td><td>c -&#x3D; a等效于c &#x3D; c - a</td></tr><tr><td align="center"><code>*=</code></td><td align="center">乘法赋值运算符</td><td>c *&#x3D; a等效于c &#x3D;c * a</td></tr><tr><td align="center"><code>/=</code></td><td align="center">除法赋值运算符</td><td>c &#x2F;&#x3D; a等效于c &#x3D; c  &#x2F;a</td></tr><tr><td align="center"><code>//=</code></td><td align="center">取整除赋值运算符</td><td>c &#x2F;&#x2F;&#x3D; a等效于c &#x3D; c &#x2F;&#x2F; a</td></tr><tr><td align="center"><code>%=</code></td><td align="center">取模（余数）赋值运算符</td><td>c %&#x3D; a等效于c &#x3D; c % a</td></tr><tr><td align="center"><code>**=</code></td><td align="center">幂赋值运算符</td><td>c **&#x3D; a等效于c &#x3D; c ** a</td></tr></tbody></table><h3 id="👀-运算符的优先级"><a href="#👀-运算符的优先级" class="headerlink" title="👀 运算符的优先级"></a>👀 运算符的优先级</h3><p>优先级由高到低顺序排列：</p><table><thead><tr><th align="center">运算符</th><th>描述</th></tr></thead><tbody><tr><td align="center"><code>**</code></td><td>幂（最高优先级）</td></tr><tr><td align="center"><code>*</code>  <code>/</code>  <code>%</code>  <code>//</code></td><td>乘、除、取余数、取整数</td></tr><tr><td align="center"><code>+</code>  <code>-</code></td><td>加法、减法</td></tr><tr><td align="center"><code>&lt;=</code>  <code>&lt;</code>  <code>&gt;</code>  <code>&gt;=</code></td><td>比较运算符</td></tr><tr><td align="center"><code>==</code>  <code>!=</code></td><td>等于运算符</td></tr><tr><td align="center"><code>=</code>  <code>%=</code>  <code>/=</code>  <code>//=</code>  <code>-=</code>  <code>+=</code>  <code>*=</code></td><td>赋值运算符</td></tr><tr><td align="center"><code>not</code> <code>or</code> <code>and</code></td><td>逻辑运算符</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Python基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（一）Google Earth Engine概述</title>
      <link href="/2022/05/16/GEE01/"/>
      <url>/2022/05/16/GEE01/</url>
      
        <content type="html"><![CDATA[<p><code>Google Earth Engine (GEE)</code> 是由谷歌公司开发的众多应用之一。借助谷歌公司超强的服务器运算能力以及与 <code>NASA</code> 的合作关系，<code>GEE</code> 平台将<code>Landsat</code>、<code>MODIS</code>、 <code>Sentinel</code> 等可以公开获取的遥感图像数据存储在谷歌的磁盘阵列中，使得 <code>GEE</code> 用户可以方便的提取、调用和分析海量的遥感大数据资源。</p><p><code>GEE</code>它是一个集科学分析以及地理信息数据可视化的综合性平台。简单的说，<code>GEE</code>是一个“遥感大数据”分析和呈现的平台。作为<strong>地理云计算服务平台</strong>，<code>GEE</code> 将地理数据分析算法封装成函数接口的形式提供给用户，通过互联网可以使用户快速地访问海量的影像数据以及其他空间数据，而不需要下载到本地，在云端实现当前地理空间数据分析的全部流程。通过云计算还可以使共享的计算机软硬件资源和地理大数据，按需求提供给用户使用，使任何用户都可以使用服务商提供的多平台软硬件资源和地理大数据，开展常规个人计算机无法实现的地理计算和数据分析。</p><blockquote><p><code>GEE</code> 在设计之初就是为了服务科研人员而构建的，因此在概念上可以将 <code>GEE</code> 视为一种工具，类似于菜刀之于厨师或者猎枪之于猎手，而不应该将其当作一种复杂的计算机编程平台。</p></blockquote><p><code>GEE</code>包含图形用户界面和应用程序编程接口。<code>GEE</code> 是一个主要依靠编码命令进行空间分析和操作的平台，但 <code>GEE</code> 也有适合界面操作的平台：<code>GEE</code> 的图形用户界面(<code>Graphical User Interface, GUI</code>)。<code>GEE</code> 的 <code>GUI</code> 的优点在于符合人的操作直觉，并且对新用户友好，缺点是功能较少，可以实现的空间分析有限。<code>GEE</code> 的应用程序编程接口(<code>Application Programming Interface, API</code>)是 <code>GEE</code> 的核心功能所在，也是 <code>GEE</code> 用户最为关注的平台，与 <code>GUI</code> 相比，<code>API</code> 可以调用 <code>GEE</code> 平台中的所有数据和功能。可以说，学习 <code>GEE</code> 就是学习 <code>GEE</code> 的 <code>API</code>。</p><p><code>GEE</code> 中存储着海量的遥感数据，熟悉这些数据能够让用户更加便捷的实现空间和地理分析目标。总体上，<code>GEE</code> 的数据可以分为 4 个种类：栅格数据，栅格集数据，矢量数据，矢量集数据。</p><h2 id="⛄栅格数据"><a href="#⛄栅格数据" class="headerlink" title="⛄栅格数据"></a>⛄栅格数据</h2><p><code>GEE</code> 中的栅格数据主要包括来源自遥感卫星的数据和空间插值数据产品。</p><table><thead><tr><th align="center">数据集</th><th align="center">空间分辨率</th><th align="center">时间分辨率</th><th align="center">时间覆盖</th><th align="center">空间覆盖</th></tr></thead><tbody><tr><td align="center"><strong>Landsat</strong></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">Landsat 8 OLI&#x2F;TIRS</td><td align="center">30m</td><td align="center">16day</td><td align="center">2013-Now</td><td align="center">Global</td></tr><tr><td align="center">Landsat 7 ETM+</td><td align="center">30m</td><td align="center">16day</td><td align="center">2000-Now</td><td align="center">Global</td></tr><tr><td align="center">Landsat 5 TM</td><td align="center">30m</td><td align="center">16day</td><td align="center">1984-2012</td><td align="center">Global</td></tr><tr><td align="center">Landsat 4–8 surface reflectance</td><td align="center">30m</td><td align="center">16day</td><td align="center">1984-Now</td><td align="center">Global</td></tr><tr><td align="center"><strong>Sentinel</strong></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">Sentinel 1 A&#x2F;B ground range detected</td><td align="center">10m</td><td align="center">6day</td><td align="center">2014-Now</td><td align="center">Global</td></tr><tr><td align="center">Sentinel 2A MSI</td><td align="center">20m</td><td align="center">10day</td><td align="center">2015-Now</td><td align="center">Global</td></tr><tr><td align="center"><strong>MODIS</strong></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">MOD08 atmosphere</td><td align="center">1°</td><td align="center">daily</td><td align="center">2000-Now</td><td align="center">Global</td></tr><tr><td align="center">MOD09 surface reflectance</td><td align="center">500m</td><td align="center">1&#x2F;8day</td><td align="center">2000-Now</td><td align="center">Global</td></tr><tr><td align="center">MOD10 snow cover</td><td align="center">500m</td><td align="center">1day</td><td align="center">2000-Now</td><td align="center">Global</td></tr><tr><td align="center">MOD11 temperature and emissivity</td><td align="center">1000m</td><td align="center">1&#x2F;8day</td><td align="center">2000-Now</td><td align="center">Global</td></tr><tr><td align="center">MCD12 Land cover</td><td align="center">500m</td><td align="center">Annual</td><td align="center">2000-Now</td><td align="center">Global</td></tr><tr><td align="center">MOD13 Vegetation indices</td><td align="center">500&#x2F;250m</td><td align="center">16day</td><td align="center">2000-Now</td><td align="center">Global</td></tr><tr><td align="center">MOD14 Thermal anomalies &amp; fire</td><td align="center">1000m</td><td align="center">8day</td><td align="center">2000-Now</td><td align="center">Global</td></tr><tr><td align="center">MCD15 Leaf area index&#x2F;FPAR</td><td align="center">500m</td><td align="center">4day</td><td align="center">2000-Now</td><td align="center">Global</td></tr><tr><td align="center">MOD17 Gross primary productivity</td><td align="center">500m</td><td align="center">8day</td><td align="center">2000-Now</td><td align="center">Global</td></tr><tr><td align="center">MCD43 BRDF-adjusted reflectance</td><td align="center">1000&#x2F;500m</td><td align="center">8&#x2F;16day</td><td align="center">2000-Now</td><td align="center">Global</td></tr><tr><td align="center">MOD44 veg. cover conversion</td><td align="center">250m</td><td align="center">Annual</td><td align="center">2000-Now</td><td align="center">Global</td></tr><tr><td align="center">MCD45 thermal anomalies and fire</td><td align="center">500m</td><td align="center">30day</td><td align="center">2000-Now</td><td align="center">Global</td></tr><tr><td align="center"><strong>ASTER</strong></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">L1 T radiance</td><td align="center">15&#x2F;30&#x2F;90m</td><td align="center">1day</td><td align="center">2000-Now</td><td align="center">Global</td></tr><tr><td align="center">Global emissivity</td><td align="center">100m</td><td align="center">Once</td><td align="center">2000-2010</td><td align="center">Global</td></tr><tr><td align="center">Other imagery</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">PROBA-V top of canopy reflectance</td><td align="center">100&#x2F;300m</td><td align="center">2day</td><td align="center">2013-Now</td><td align="center">Global</td></tr><tr><td align="center">EO-1 hyperion hyperspectral radiance</td><td align="center">30m</td><td align="center">Targeted</td><td align="center">2001-Now</td><td align="center">Global</td></tr><tr><td align="center">DMSP-OLS nighttime lights</td><td align="center">1km</td><td align="center">Annual</td><td align="center">1992-2013</td><td align="center">Global</td></tr><tr><td align="center">USDA NAIP aerial imagery</td><td align="center">1m</td><td align="center">Sub-annual</td><td align="center">2003-2015</td><td align="center">CONUS</td></tr><tr><td align="center"><strong>地形</strong></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">Shuttle Radar Topography Mission</td><td align="center">30m</td><td align="center">single</td><td align="center">2000</td><td align="center">60°N–54°S</td></tr><tr><td align="center">USGS GMTED2010</td><td align="center">10m</td><td align="center">single</td><td align="center">Multiple</td><td align="center">US</td></tr><tr><td align="center">USGS National Elevation Dataset</td><td align="center">7.5″</td><td align="center">single</td><td align="center">Multiple</td><td align="center">83°N–57°S</td></tr><tr><td align="center">GTOPO30</td><td align="center">30″</td><td align="center">single</td><td align="center">Multiple</td><td align="center">Global</td></tr><tr><td align="center">ETOPO1</td><td align="center">1′</td><td align="center">single</td><td align="center">Multiple</td><td align="center">Global</td></tr></tbody></table><p>注：来源 <code>Google Earth Engine: Planetary-scale geospatial analysis for everyone [J]. Remote Sensing of Environment</code> </p><p><code>GEE</code> 中其他的主要栅格产品包括土地利用数据，气象数据和人口数据等。这些数据与遥感影像数据相比，主要用来反映某些社会因子的空间分布，或者反映地表以上空间的自然特征。</p><table><thead><tr><th align="center">数据集</th><th align="center">空间分辨率</th><th align="center">时间分辨率</th><th align="center">时间覆盖</th><th align="center">空间覆盖</th></tr></thead><tbody><tr><td align="center"><strong>土地利用</strong></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">GlobCover</td><td align="center">300m</td><td align="center">Non-periodic</td><td align="center">2009</td><td align="center">90°N–65°S</td></tr><tr><td align="center">USGS National Landcover Database</td><td align="center">30m</td><td align="center">Non-periodic</td><td align="center">1992-2011</td><td align="center">CONUS</td></tr><tr><td align="center">UMD global forest change</td><td align="center">30m</td><td align="center">Annual</td><td align="center">2000-2014</td><td align="center">80°N–57°S</td></tr><tr><td align="center">JRC global surface water</td><td align="center">300m</td><td align="center">Monthly</td><td align="center">1984-2015</td><td align="center">78°N–60°S</td></tr><tr><td align="center">GLCF tree cover</td><td align="center">30m</td><td align="center">5year</td><td align="center">2000-2010</td><td align="center">Global</td></tr><tr><td align="center">USDA NASS cropland data layer</td><td align="center">30m</td><td align="center">Annual</td><td align="center">1997-2015</td><td align="center">CONUS</td></tr><tr><td align="center"><strong>气象</strong></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">Global precipitation measurement</td><td align="center">6′</td><td align="center">3h</td><td align="center">2014-Now</td><td align="center">Global</td></tr><tr><td align="center">TRMM 3B42 precipitation</td><td align="center">15′</td><td align="center">3h</td><td align="center">1985-2015</td><td align="center">50°N–50°S</td></tr><tr><td align="center">CHIRPS precipitation</td><td align="center">3′</td><td align="center">5day</td><td align="center">1981-Now</td><td align="center">50°N–50°S</td></tr><tr><td align="center">NLDAS-2</td><td align="center">7.5′</td><td align="center">1h</td><td align="center">1979-Now</td><td align="center">North America</td></tr><tr><td align="center">GLDAS-2</td><td align="center">15′</td><td align="center">3h</td><td align="center">1948-2010</td><td align="center">Global</td></tr><tr><td align="center">NCEP reanalysis</td><td align="center">2.5°</td><td align="center">6h</td><td align="center">1948-Now</td><td align="center">Global</td></tr><tr><td align="center">ORNL DAYMET weather</td><td align="center">1km</td><td align="center">12 Images</td><td align="center">1980-Now</td><td align="center">North America</td></tr><tr><td align="center">GRIDMET</td><td align="center">4km</td><td align="center">1day</td><td align="center">1979-Now</td><td align="center">CONUS</td></tr><tr><td align="center">NCEP global forecast system</td><td align="center">15′</td><td align="center">6h</td><td align="center">2015-Now</td><td align="center">Global</td></tr><tr><td align="center">NCEP climate forecast system</td><td align="center">12′</td><td align="center">6h</td><td align="center">1979-Now</td><td align="center">Global</td></tr><tr><td align="center">WorldClim</td><td align="center">30″</td><td align="center">12 Images</td><td align="center">1960-1990</td><td align="center">Global</td></tr><tr><td align="center">NEX downscaled climate projections</td><td align="center">1km</td><td align="center">1day</td><td align="center">1950-2099</td><td align="center">North America</td></tr><tr><td align="center"><strong>人口</strong></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">WorldPop</td><td align="center">100m</td><td align="center">5year</td><td align="center">Multiple</td><td align="center">2010–2015</td></tr><tr><td align="center">GPWv4</td><td align="center">30″</td><td align="center">5year</td><td align="center">2000-2020</td><td align="center">85°N–60°S</td></tr></tbody></table><p>注：来源 <code>Google Earth Engine: Planetary-scale geospatial analysis for everyone [J]. Remote Sensing of Environment</code></p><h2 id="⛄矢量数据"><a href="#⛄矢量数据" class="headerlink" title="⛄矢量数据"></a>⛄矢量数据</h2><p>简单来说，矢量数据可以理解为点、线和面类型的数据。在处理空间问题时，常常需要确定某个地理要素的位置(例如某区域商店的位置)，或者某些线状地物的位置(河流、道路等)，以及某些面状物的分布(行政边界等)。在确定矢量空间要素空间特征的基础上，再给这些空间要素贴上标签(名称，面积，权属等)，那么就得到了包含一定信息的矢量数据。我们通常将这种矢量数据成为“特征矢量”(<code>Feature</code>)，将其空间形状称为“地理特征”(<code>Geometry</code>)，将贴上去的标签信息称为“属性”(<code>Property</code>)。我们分别从<code>ArcGIS</code>和<code>GEE</code> 中添加并查看<code>Feature</code>的信息，以此加深对矢量数据的理解。</p><h2 id="⛄数据类型和参数类型"><a href="#⛄数据类型和参数类型" class="headerlink" title="⛄数据类型和参数类型"></a>⛄数据类型和参数类型</h2><h3 id="👀GEE-的数据类型-String-Number"><a href="#👀GEE-的数据类型-String-Number" class="headerlink" title="👀GEE 的数据类型 (String, Number)"></a>👀GEE 的数据类型 (<code>String</code>, <code>Number</code>)</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">显示：<span class="title function_">print</span>(string)</span><br><span class="line">创建：ee.<span class="title class_">String</span>()</span><br><span class="line">修改：string.<span class="title function_">cat</span>()string.<span class="title function_">replace</span>()</span><br><span class="line">段落：string.<span class="title function_">split</span>() string.<span class="property">match</span></span><br><span class="line">查询：string.<span class="title function_">slice</span>() string.<span class="title function_">length</span>()</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">创建：ee.<span class="title class_">Number</span>()</span><br><span class="line">修改：number.<span class="title function_">uint8</span>() number.<span class="title class_">Uint8</span>() number.<span class="title function_">int8</span>() number.<span class="title function_">toInt8</span>()……</span><br><span class="line">比较：number.<span class="title function_">eq</span>() number.<span class="title function_">neq</span>()……</span><br><span class="line">    number.<span class="title function_">and</span>() number.<span class="title function_">or</span>() ee.<span class="property">Algorithms</span>.<span class="title class_">IsEqua</span>()……</span><br><span class="line">运算：number.<span class="title function_">abs</span>() number.<span class="title function_">round</span>() number.<span class="title function_">pow</span>()……</span><br><span class="line">字位：number.<span class="title function_">bitwiseAnd</span>() number.<span class="title function_">bitwiseOr</span>() number.<span class="title function_">bitwise_and</span>()</span><br><span class="line">    number.<span class="title function_">bitwise_or</span>() number.<span class="title function_">leftShift</span>() number.<span class="title function_">right_shift</span>()……</span><br></pre></td></tr></table></figure><h3 id="👀GEE-的数据类型-Dictionary，List，Array"><a href="#👀GEE-的数据类型-Dictionary，List，Array" class="headerlink" title="👀GEE 的数据类型(Dictionary，List，Array)"></a>👀GEE 的数据类型(<code>Dictionary</code>，<code>List</code>，<code>Array</code>)</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">创建：ee.<span class="title class_">Dicionary</span>()</span><br><span class="line">修改：dictionary.<span class="title function_">combine</span>() dinctionary.<span class="title function_">set</span>()</span><br><span class="line">查询：dictionary.<span class="title function_">keys</span>() dictionary.<span class="title function_">get</span>() dictionary.<span class="title function_">values</span>()</span><br><span class="line">对比：dictionary.<span class="title function_">contains</span>()</span><br><span class="line">尺寸：dictionary.<span class="title function_">size</span>()</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">创建：ee.<span class="title class_">List</span>() list.<span class="title function_">repeat</span>() list.<span class="title function_">sequence</span>()</span><br><span class="line">修改：list.<span class="title function_">set</span>() list.<span class="title function_">replaceAll</span>() list.<span class="title function_">add</span>() list.<span class="title function_">insert</span>() list.<span class="title function_">zip</span>()</span><br><span class="line">list.<span class="title function_">reverse</span>() list.<span class="title function_">rotate</span>() list.<span class="title function_">sort</span>() list.<span class="title function_">swap</span>() list.<span class="title function_">flatten</span>()</span><br><span class="line">查询：list.<span class="title function_">get</span>() list.<span class="title function_">remove</span>() list.<span class="title function_">removeAll</span>()</span><br><span class="line">比较：list.<span class="title function_">equals</span>() list.<span class="title function_">contains</span>() list.<span class="title function_">containsALL</span>() list. <span class="title function_">indexOf</span>()          </span><br><span class="line">list.<span class="title function_">indexOfSubList</span>() list.<span class="title function_">lastIndexOfSubList</span>() list.<span class="title function_">frequency</span>()</span><br><span class="line">其他：list.<span class="title function_">map</span>() list.<span class="title function_">iterate</span>() list.<span class="title function_">length</span>() list.<span class="title function_">size</span>()</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">创建：ee.<span class="title class_">Array</span>() ee.<span class="property">Array</span>.<span class="title function_">identity</span>() ee.<span class="property">Array</span>.<span class="title function_">repeat</span>()</span><br><span class="line">修改：array.<span class="title function_">mask</span>()array.<span class="title function_">transpose</span>() array.<span class="title function_">uint8</span>()array.<span class="title class_">Uint8</span>()</span><br><span class="line">数学：array.<span class="title function_">eq</span>() array.<span class="title function_">and</span>() array.<span class="title function_">or</span>() array.<span class="title function_">round</span>()</span><br><span class="line">array.<span class="title function_">bitwiseAnd</span>() array.<span class="title function_">leftShift</span>() </span><br></pre></td></tr></table></figure><h3 id="👀GEE-的数据类型-Geometry，Feature，FeatureCollection"><a href="#👀GEE-的数据类型-Geometry，Feature，FeatureCollection" class="headerlink" title="👀GEE 的数据类型(Geometry，Feature，FeatureCollection)"></a>👀GEE 的数据类型(<code>Geometry</code>，<code>Feature</code>，<code>FeatureCollection</code>)</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">创建：ee.<span class="property">Geometry</span>.<span class="title class_">Point</span>() ee.<span class="property">Geometry</span>.<span class="title class_">Multipoint</span>() 绘图工具 ……</span><br><span class="line">几何：<span class="title class_">Geometry</span>.<span class="title function_">transform</span>() geometry.<span class="title function_">centroid</span>() geometry.<span class="title function_">simplify</span>()            </span><br><span class="line">geometry.<span class="title function_">bounds</span>() geometry.<span class="title function_">buffer</span>() geometry.<span class="title function_">union</span>() ……</span><br><span class="line">查询：geometry.<span class="title function_">geometries</span>() geometry.<span class="title function_">coordinates</span>() geometry.<span class="title function_">length</span>() </span><br><span class="line">geometry.<span class="title function_">area</span>() geometry.<span class="title function_">perimeter</span>() geometry.<span class="title function_">distance</span>() </span><br><span class="line">转换：geometry.<span class="title function_">toGeoJSON</span>()</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">创建：ee.<span class="title class_">Feature</span>()绘图工具</span><br><span class="line">编辑：<span class="title class_">Feature</span>.<span class="title function_">select</span>() <span class="title class_">Feature</span>.<span class="title function_">transform</span>() <span class="title class_">Feature</span>.<span class="property">set</span>/<span class="title function_">setMulti</span>()</span><br><span class="line">几何：<span class="title class_">Feature</span>.<span class="property">centroid</span>/simplify/bounds/convexHull/<span class="title function_">buffer</span>()</span><br><span class="line"><span class="title class_">Feature</span>.<span class="property">union</span>/intersection/difference/<span class="title function_">symmetricDifference</span>()</span><br><span class="line">提取：<span class="title class_">Feature</span>.<span class="title function_">geometry</span>() <span class="title class_">Feature</span>.<span class="title function_">get</span>() <span class="title class_">Feature</span>.<span class="property">Length</span>/<span class="title class_">Area</span>/<span class="title class_">Perimeter</span>()</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">创建：<span class="variable constant_">GEE</span>自带 上传 <span class="title class_">FushionTable</span> ee.<span class="title class_">FeatureCollection</span>() .<span class="title function_">randomPoints</span>() 手绘…</span><br><span class="line">编辑：.<span class="title function_">filterMetadata</span>() .<span class="title function_">limit</span>() .<span class="title function_">filterDate</span>() .<span class="title function_">filterBounds</span>() .<span class="title function_">filter</span>() </span><br><span class="line">    .<span class="title function_">select</span>() .<span class="title function_">distinct</span>() .<span class="title function_">union</span>() .<span class="title function_">merge</span>() .<span class="title function_">set</span>() .<span class="title function_">remap</span>() .<span class="title function_">sort</span>()</span><br><span class="line">    .<span class="title function_">makeArray</span>()</span><br><span class="line">转换：.<span class="title function_">geometry</span>() .<span class="title function_">reduceToImage</span>()</span><br><span class="line">查询：.<span class="title function_">first</span>() .<span class="title function_">toList</span>() .<span class="title function_">aggregate_first</span>() .<span class="title function_">aggregate_array</span>()</span><br><span class="line">统计：.<span class="property">aggregate_stats</span>/_histogram/_count/_count_distinct       </span><br><span class="line">    .<span class="property">aggregate_max</span>/_min/_sum/_mean/_product          </span><br><span class="line">    .<span class="property">aggregate_sample_var</span>/_total_var/_sample_sd/_total_sd/</span><br><span class="line">其他: .<span class="title function_">map</span>()</span><br></pre></td></tr></table></figure><h3 id="👀GEE-的数据类型-Image，ImageCollection"><a href="#👀GEE-的数据类型-Image，ImageCollection" class="headerlink" title="👀GEE 的数据类型 (Image，ImageCollection)"></a>👀GEE 的数据类型 (<code>Image</code>，<code>ImageCollection</code>)</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">创建: <span class="variable constant_">GEE</span>自带 用户上传 ee.<span class="title function_">image</span>()/<span class="title function_">constant</span>() ee.<span class="property">Image</span>.<span class="title function_">pixelLonLat</span>() </span><br><span class="line">编辑: .<span class="title function_">mask</span>() .<span class="title function_">clip</span>() .<span class="title function_">select</span>() .<span class="title function_">slice</span>() .<span class="title function_">addBands</span>() .<span class="title function_">reproject</span>() .<span class="title function_">rbgtohsv</span>()         </span><br><span class="line">    .<span class="title function_">hsvtorbg</span>() .<span class="title function_">unit8</span>() .<span class="title function_">cast</span>() .<span class="title function_">set</span>() .<span class="title function_">setMulti</span>() .<span class="title function_">remap</span>() .<span class="title function_">where</span>()   </span><br><span class="line">    .<span class="title function_">metadata</span>() .<span class="title function_">clamp</span>() .<span class="title function_">unitScale</span>() .<span class="title function_">interpolate</span>() .<span class="title function_">eq</span>()…… .<span class="title function_">abs</span>()…… .<span class="title function_">sin</span>() …… </span><br><span class="line">    .<span class="title function_">bitWiseAnd</span>()…… .<span class="title function_">reduce</span>()</span><br><span class="line">地形: image.<span class="title function_">derivative</span>() ee.<span class="property">Terrain</span>.<span class="title function_">products</span>() ee.<span class="property">Algorithm</span>.<span class="title class_">Terrain</span>()</span><br><span class="line">     ee.<span class="property">Terrain</span>.<span class="title function_">slope</span>() ee.<span class="property">Terrain</span>.<span class="title function_">aspect</span>() ee.<span class="property">Terrain</span>.<span class="title function_">fillMinima</span>()  </span><br><span class="line"> ee.<span class="property">Terrain</span>.<span class="title function_">hillshade</span>() ee.<span class="property">Terrain</span>.<span class="title function_">hillshadow</span>() ee.<span class="property">Algorithm</span>.<span class="title class_">Hillshadow</span>()</span><br><span class="line">纹理: .<span class="title function_">entropy</span>() .<span class="title class_">Texture</span>() .<span class="title function_">zeroCrossing</span>() .<span class="property">ee</span>.<span class="property">Algorithms</span>.<span class="title class_">CannyEdgeDetector</span>()   </span><br><span class="line">    ee.<span class="property">Algorithms</span>.<span class="title class_">HoughTransform</span>()</span><br><span class="line">邻域: .<span class="title function_">focal_max</span>() .<span class="title function_">focal_min</span>() .<span class="title function_">focal_median</span>() .<span class="title function_">focal_mode</span>() .<span class="title function_">convolve</span>()                </span><br><span class="line">    .<span class="title function_">reduceNeighborhood</span>()</span><br><span class="line">转换: .<span class="property">Image</span>.<span class="title class_">ToVector</span>() <span class="title class_">Image</span>.<span class="title class_">ToArray</span>() <span class="title class_">Image</span>.<span class="title function_">arrayFlatten</span>()</span><br><span class="line">其他: .<span class="title class_">CrossCorrelation</span>() .<span class="title function_">distance</span>() <span class="title class_">Export</span>.<span class="title function_">image</span>()</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">创建: ee.<span class="title class_">ImageCollection</span>() ee.<span class="property">ImageCollection</span>.<span class="title function_">load</span>()</span><br><span class="line">筛选: .<span class="title function_">limit</span>() .<span class="title function_">filterMetadata</span>() .<span class="title function_">filterDate</span>() .<span class="title function_">filterBounds</span>() .<span class="title function_">filter</span>() .<span class="title function_">select</span>()     </span><br><span class="line">.<span class="title function_">distinct</span>() .<span class="title function_">comnibe</span>() .<span class="title function_">unit8</span>()…… .<span class="title function_">set</span>() .<span class="title function_">setMulti</span>()</span><br><span class="line">求值: .<span class="title function_">mosaic</span>() .<span class="property">and</span>/<span class="title function_">or</span>() .<span class="property">sum</span>/product/max/min/mean/mode/median/<span class="title function_">count</span>()</span><br><span class="line">转换: .<span class="title function_">first</span>() .<span class="title function_">toList</span>() .<span class="title function_">toArray</span>()     </span><br></pre></td></tr></table></figure><h3 id="👀GEE-的数据类型-Landsat-Images-ConfusionMarix"><a href="#👀GEE-的数据类型-Landsat-Images-ConfusionMarix" class="headerlink" title="👀GEE 的数据类型 (Landsat Images, ConfusionMarix)"></a>👀GEE 的数据类型 (<code>Landsat Images</code>, <code>ConfusionMarix</code>)</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">LansatCollection</span>.<span class="title function_">qualityMosaic</span>()</span><br><span class="line"><span class="title class_">LansatCollection</span>.<span class="title function_">unmixing</span>()</span><br><span class="line"><span class="title class_">LansatCollection</span>.<span class="title function_">normalizedDifference</span>()</span><br><span class="line">ee.<span class="property">Algorithms</span>.<span class="property">Landsat</span>.<span class="title function_">simpleCloudScore</span>()</span><br><span class="line">ee.<span class="property">Algorithms</span>.<span class="property">Landsat</span>.<span class="title function_">simpleComposite</span>()</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">创建: ee.<span class="title class_">ConfusionMatrix</span>() </span><br><span class="line">转换: <span class="title class_">ConfusionMatrix</span>.<span class="title function_">array</span>()</span><br><span class="line">精度: .<span class="title function_">kappa</span>() .<span class="title function_">accuracy</span>() .<span class="title function_">producersAccuracy</span>() .<span class="title function_">consumersAccuracy</span>() .<span class="title function_">order</span>()</span><br></pre></td></tr></table></figure><h3 id="👀GEE-的参数类型-Date-DateRange"><a href="#👀GEE-的参数类型-Date-DateRange" class="headerlink" title="👀GEE 的参数类型 (Date, DateRange)"></a>👀GEE 的参数类型 (<code>Date</code>, <code>DateRange</code>)</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">创建：ee.<span class="title class_">Date</span>() ee.<span class="property">Algorithms</span>.<span class="title class_">Date</span>() ee.<span class="property">Date</span>.<span class="title function_">fromYMD</span>() ee.<span class="property">Date</span>.<span class="title function_">parse</span>()</span><br><span class="line">编辑：<span class="title class_">Date</span>.<span class="title function_">advance</span>() <span class="title class_">Date</span>.<span class="title function_">update</span>()</span><br><span class="line">调整：<span class="title class_">Date</span>.<span class="title function_">format</span>() <span class="title class_">Date</span>.<span class="title function_">milis</span>() <span class="title class_">Date</span>.<span class="title function_">getRange</span>()</span><br><span class="line">提取：<span class="title class_">Date</span>.<span class="title function_">get</span>() <span class="title class_">Date</span>.<span class="title function_">gerFraction</span>() <span class="title class_">Date</span>.<span class="title function_">unitRation</span>() <span class="title class_">Date</span>.<span class="title function_">difference</span>()</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">创建: ee.<span class="title class_">DateRange</span>() ee.<span class="property">DateRange</span>.<span class="title function_">unbounded</span>()</span><br><span class="line">联并: <span class="title class_">DateRange</span>.<span class="title class_">Union</span>() <span class="title class_">DateRange</span>.<span class="title function_">intersection</span>()</span><br><span class="line">查询: <span class="title class_">DateRange</span>.<span class="title function_">start</span>() <span class="title class_">DateRange</span>.<span class="title function_">end</span>()</span><br><span class="line">判断: .<span class="title function_">intersencts</span>() .<span class="title function_">contains</span>() .<span class="title function_">inEmpty</span>() .<span class="title function_">isUnbounded</span>()</span><br></pre></td></tr></table></figure><h3 id="👀GEE-的参数类型-Filter，Join"><a href="#👀GEE-的参数类型-Filter，Join" class="headerlink" title="👀GEE 的参数类型 (Filter，Join)"></a>👀GEE 的参数类型 (<code>Filter</code>，<code>Join</code>)</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">创建：ee.<span class="property">Filter</span>.<span class="title function_">eq</span>() ee.<span class="property">Filter</span>.<span class="title function_">neq</span>() ee.<span class="property">Filter</span>.<span class="title function_">ge</span>() ee.<span class="property">Filter</span>.<span class="title function_">gte</span>() ee.<span class="property">Filter</span>.<span class="title function_">le</span>() </span><br><span class="line">ee.<span class="property">Filter</span>.<span class="title function_">lte</span>() ee.<span class="property">Filter</span>.<span class="title function_">maxDifference</span>()</span><br><span class="line">字段：ee.<span class="property">Filter</span>.<span class="title function_">stringContains</span>() ee.<span class="property">Filter</span>.<span class="title class_">StarsWith</span>() ee.<span class="property">Filter</span>.<span class="title class_">EndWith</span>() </span><br><span class="line">ee.<span class="property">Filter</span>.<span class="title class_">Rangecontains</span>() ee.<span class="property">Filter</span>.<span class="title function_">listContains</span>() ee.<span class="property">Filter</span>.<span class="title function_">inList</span>()</span><br><span class="line">时间：ee.<span class="property">Filter</span>.<span class="title function_">calendarRange</span>() ee.<span class="title class_">FilterDateRangeContains</span>() </span><br><span class="line">ee.<span class="property">Filter</span>.<span class="title function_">dayOfYear</span>()</span><br><span class="line">转换：ee.<span class="property">Filter</span>.<span class="title function_">and</span>() ee.<span class="property">Filter</span>.<span class="title function_">or</span>() ee.<span class="property">Filter</span>.<span class="title function_">not</span>() ee.<span class="title class_">Filter</span>()</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ee.<span class="property">Join</span>.<span class="title function_">simple</span>() ee.<span class="property">Join</span>.<span class="title function_">inverted</span>() ee.<span class="property">Join</span>.<span class="title function_">inner</span>()</span><br><span class="line">ee.<span class="property">Join</span>.<span class="title function_">saveAll</span>() ee.<span class="property">Join</span>.<span class="title function_">saveBest</span>() ee.<span class="property">Join</span>.<span class="title function_">saveFirst</span>()</span><br><span class="line"><span class="title class_">Spatial</span> <span class="title class_">Joins</span> (ee.<span class="property">Filter</span>.<span class="property">withinDistance</span>/ee.<span class="property">Filter</span>.<span class="property">intersects</span>)</span><br></pre></td></tr></table></figure><h3 id="👀GEE-的参数类型-Reducer，Kernel，Algorithm"><a href="#👀GEE-的参数类型-Reducer，Kernel，Algorithm" class="headerlink" title="👀GEE 的参数类型 (Reducer，Kernel，Algorithm)"></a>👀GEE 的参数类型 (<code>Reducer</code>，<code>Kernel</code>，<code>Algorithm</code>)</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">创建: ee.<span class="property">Reducer</span>.<span class="title function_">count</span>() .<span class="title function_">countEvery</span>() .<span class="title function_">first</span>() .<span class="title function_">histogram</span>() .<span class="title function_">allNonZero</span>() </span><br><span class="line">    .<span class="title function_">anyNonZero</span>() .<span class="title function_">frequencyHistrogram</span>() .<span class="title function_">toList</span>() .<span class="title function_">toCollection</span>()</span><br><span class="line">数学: <span class="title function_">sum</span>() .<span class="title function_">product</span>() .<span class="title function_">mean</span>() .<span class="title function_">variance</span>() .<span class="title function_">std_dev</span>() .<span class="title function_">sampleVariance</span>()       </span><br><span class="line">    .<span class="title function_">sampleStdDev</span>() .<span class="title function_">max</span>() .<span class="title function_">min</span>() .<span class="title function_">minMax</span>() .<span class="title function_">median</span>() .<span class="title function_">mode</span>()         </span><br><span class="line">    .<span class="title function_">intervalMean</span>() .<span class="title function_">percentile</span>() .<span class="title function_">linearFit</span>()</span><br><span class="line">转换: .<span class="title function_">setOutputs</span>() .<span class="title function_">getOutputs</span>() .<span class="title function_">combine</span>() .<span class="title function_">repeat</span>() .<span class="title function_">repeat</span>()      </span><br><span class="line">     .<span class="title function_">group</span>() .<span class="title function_">unweighted</span>() .<span class="title function_">splitWeights</span>()</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">创建: ee.<span class="property">Kernel</span>.<span class="title function_">roberts</span>() ee.<span class="property">Kernel</span>.<span class="title function_">prewitt</span>() ee.<span class="property">Kernel</span>.<span class="title function_">sobel</span>()    </span><br><span class="line">ee.<span class="property">Kernel</span>.<span class="title function_">compass</span>() ee.<span class="property">Kernel</span>.<span class="title function_">kirsch</span>() ee.<span class="property">Kernel</span>.<span class="title function_">laplacian4</span>()</span><br><span class="line">ee.<span class="property">Kernel</span>.<span class="title function_">laplacian8</span>() ee.<span class="property">Kernel</span>.<span class="title function_">euclidean</span>() ee.<span class="property">Kernel</span>.<span class="title function_">gaussian</span>()</span><br><span class="line">ee.<span class="property">Kernel</span>.<span class="title function_">manhattan</span>() ee.<span class="property">Kernel</span>.<span class="title function_">chebyshev</span>() ee.<span class="property">Kernel</span>.<span class="title function_">circle</span>()      </span><br><span class="line">ee.<span class="property">Kernel</span>.<span class="title function_">octagon</span>() ee.<span class="property">Kernel</span>.<span class="title function_">square</span>() ee.<span class="property">Kernel</span>.<span class="title function_">diamond</span>() ee.<span class="property">Kernel</span>.<span class="title function_">cross</span>()</span><br><span class="line">ee.<span class="property">Kernel</span>.<span class="title function_">plus</span>() ee.<span class="property">Kernel</span>.<span class="title function_">fixed</span>()</span><br><span class="line">编辑: <span class="title class_">Kernel</span>.<span class="title function_">rotate</span>() kernel.<span class="title function_">add</span>() <span class="title function_">print</span>(<span class="title class_">Kernel</span>)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Algorithm</span>,算法的目的是减少重复运算，我们可将其理解为一个“小程序”，借助这个小程序可以对数据集内的每一个数据都进行同样的操作。下边是算法的语法格式：</span><br><span class="line"><span class="keyword">function</span> 函数名(变量)</span><br><span class="line">   &#123; 操作 &#125;</span><br><span class="line">算法的核心在于操作的编写。编写操作时要注意两点，第一，应该按照目标数据集确定变量名，比如针对栅格数据集的操作变量可以写作 <span class="title class_">Image</span> 或者 img，这样能够提高操作的可读性。第二，操作必须包含 <span class="keyword">return</span> 命令以告诉 <span class="variable constant_">GEE</span> 算法的目的是什么。</span><br></pre></td></tr></table></figure><h2 id="⛄GEE平台优势与应用"><a href="#⛄GEE平台优势与应用" class="headerlink" title="⛄GEE平台优势与应用"></a>⛄GEE平台优势与应用</h2><p>随着云计算技术的不断发展，<code>GEE</code> 从2008 年提出构想不断发展至今天，已经成为提供覆盖全球的地理空间数据的集成、处理、可视化和综合分析一站式解决方案的云端共享平台，总结GEE的平台具有如下优势：</p><ul><li><strong>免费向非商业用户提供使用</strong>。<code>GEE</code>面向全球科研人员、学生、教育工作者等提供非商业性质用户提供免费服务。</li><li><strong>算法高集成度以及可定制性</strong>。在算法集成方面，提供了持续更新的智能算法以及可供研究者定制的功能接口，这将激励研究者不断尝试新的算法来实现科学构想，而不只是停留在理论层面，这将进一步促进平台的智能化发展，很多以往难以解决的问题都将开启新的思路。</li><li><strong>后台处理运算能力强</strong>。使用<code>GEE</code>平台，用户可以比较方便地处理全球影像数据，解决了用户受限自己本地机器运算能力不强，以及存储空间不足的问题，能够高校、快速地处理大范围的影像。</li><li><strong>完整的生态开发环境</strong>。目前<code>GEE</code> 已经拥有一个完整而良好的开发生态环境，开发者和平台核心团队人员可以通过论坛，会议等多种形式进行深入甲流，探讨各种问题，除了现有的工具资源，用户还可以利用GEE提供的开发包做二次开发，满足更多的需求，实现更加强大的功能。</li></ul><p><code>GEE</code>被广泛应用于各个领域，涵盖全球森林变化，全球地表水变化、作物产量估算、稻田制图、城市测绘、洪水测绘、火灾恢复和疟疾风险绘图等等不同主题。它还被整合到许多第三方应用中，例如分析物种栖息地范围（<code>Map of Life</code>）、监测气候（<code>Climate Engine</code>）和评估土地利用变化（<code>Collect Earth</code>）等等。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://www.aisoutu.com/a/776592">遥感云计算平台:Google Earth Engine</a></li><li>遥感大数据工具（<code>Google Earth Engine</code>）基础教程，作者：王金柱</li></ol>]]></content>
      
      
      <categories>
          
          <category> GEE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GEE </tag>
            
            <tag> API </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo之常见的问题及小技巧Tips</title>
      <link href="/2022/05/13/Hexo-Tips/"/>
      <url>/2022/05/13/Hexo-Tips/</url>
      
        <content type="html"><![CDATA[<h2 id="⛄提高GitHub-访问速度"><a href="#⛄提高GitHub-访问速度" class="headerlink" title="⛄提高GitHub 访问速度"></a>⛄提高GitHub 访问速度</h2><p>将<code>Hexo</code>项目托管在<code>GitHub</code>数据仓库中，面临的问题通常就是<code>GitHub</code>访问速度比较慢。本人通过搜索资料、不断尝试，发现通过修改 <code>hosts</code> 文件可以进行加速，访问速度得到了有效的提高，亲测有效。手动把<code>cdn</code>和<code>ip</code>地址绑定，具体的步骤为：</p><p>第一步：获取 <code>GitHub</code> 的 global.ssl.fastly 地址</p><p>访问入口：<a href="https://ipaddress.com/website/github.global.ssl.fastly.net#ipinfo">点击进入</a></p><p>获得<code>IP Address</code>：<code>199.232.69.194</code></p><p>第二步：获取 <code>github.com</code> 的地址</p><p>访问入口：<a href="https://ipaddress.com/website/github.com#ipinfo">点击进入</a></p><p>获得<code>IP Address</code>：<code>140.82.113.4</code></p><p>第三步：修改 <code>hosts</code> 文件映射上面查找到的 <code>IP</code></p><p>①首先，针对<code>windows</code>系统，修改<code>C:\Windows\System32\drivers\etc\hosts</code>文件的权限，指定可写入：右击-&gt;<code>hosts</code>-&gt;属性-&gt;安全-&gt;编辑-&gt;点击Users-&gt;在Users的权限”写入“后面打勾，点击确定。</p><p>②然后，右击-&gt;<code>hosts</code>-&gt;打开方式-&gt;选定记事本（或者Notepad++、EmEditor工具）-&gt;在末尾处添加以下内容：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">199.232.69.194 github.global.ssl.fastly.net</span><br><span class="line">140.82.113.4 github.com</span><br></pre></td></tr></table></figure><h2 id="⛄Hexo常见问题"><a href="#⛄Hexo常见问题" class="headerlink" title="⛄Hexo常见问题"></a>⛄Hexo常见问题</h2><h3 id="👀问题一，hexo命令运行出错"><a href="#👀问题一，hexo命令运行出错" class="headerlink" title="👀问题一，hexo命令运行出错"></a>👀问题一，hexo命令运行出错</h3><p><strong>①问题描述</strong>：运行Hexo报错hexo : 无法加载文件hexo.ps1，因为在此系统上禁止运行脚本</p><p>使用如下命令安装 <code>Hexo</code>成功：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure><p>运行<code>hexo -v、hexo clean、hexo g、hexo s、hexo d</code>会出现错误：</p><figure class="highlight plaintext"><figcaption><span>bash</span></figcaption><table><tr><td class="code"><pre><span class="line">PS C:\Users\Desktop\heartlovelife&gt; hexo s</span><br><span class="line">hexo : 无法加载文件 C:\Users\AppData\Roaming\npm\hexo.ps1，因为在此系统上禁止运行脚本。有关详细信息，请参阅 https:/go.microsoft.com/fwlink/?LinkID</span><br><span class="line">=135170 中的 about_Execution_Policies。</span><br><span class="line">所在位置 行:1 字符: 1</span><br><span class="line">+ hexo s</span><br><span class="line">+ ~~~~</span><br><span class="line">    + CategoryInfo          : SecurityError: (:) []，PSSecurityException</span><br><span class="line">    + FullyQualifiedErrorId : UnauthorizedAccess</span><br></pre></td></tr></table></figure><p><strong>②解决方案</strong>：针对<code>windows</code>系统，设置-&gt;隐私和安全性-&gt;开发者选项-&gt;允许本地<code>PowerShell</code>脚本在为签名的情况下运行。</p><h3 id="👀问题二，-hexo-init初始化失败"><a href="#👀问题二，-hexo-init初始化失败" class="headerlink" title="👀问题二， hexo init初始化失败"></a>👀问题二， <code>hexo init</code>初始化失败</h3><p><strong>①问题描述</strong>：<code>WARN Failed to install dependencies. Please run ‘npm install’ manually!</code></p><p><strong>②解决方案</strong>：如果我们输入命令<code>npm install</code>还是会出现错误，这时我们需要修改<code>npm</code>的镜像：</p><figure class="highlight plaintext"><figcaption><span>bash</span></figcaption><table><tr><td class="code"><pre><span class="line">npm -v</span><br><span class="line"># 修改镜像</span><br><span class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br><span class="line"># 初始化</span><br><span class="line">hexo init</span><br><span class="line"># 利用cnpm执行cnpm install</span><br><span class="line">cnpm install </span><br></pre></td></tr></table></figure><h3 id="👀问题三，hexo-d部署失败"><a href="#👀问题三，hexo-d部署失败" class="headerlink" title="👀问题三，hexo d部署失败"></a>👀问题三，<code>hexo d</code>部署失败</h3><p><strong>①问题描述</strong>：<code>fatal: unable to auto-detect email address....</code></p><figure class="highlight plaintext"><figcaption><span>bash</span></figcaption><table><tr><td class="code"><pre><span class="line">fatal: unable to auto-detect email address</span><br><span class="line">error:src refspec HEAD does not match any</span><br><span class="line">error:failed to push some refs to &quot;*******&quot;</span><br><span class="line">FATAL &#123;</span><br><span class="line">err:Error:Spawn failed</span><br><span class="line">.......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>②解决方案</strong>：在文件浏览器中勾选显示隐藏的项目，进入我们的博客目录</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">D:\Blog_Hexo\Blog\.deploy_git\.git</span><br></pre></td></tr></table></figure><p>找到config文件，添加</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[user]</span><br><span class="line">email = 3086786161@qq.com</span><br><span class="line">name = HeartLoveLife</span><br><span class="line">[core]</span><br><span class="line">repositoryformatversion = 0</span><br><span class="line">filemode = false</span><br><span class="line">bare = false</span><br><span class="line">logallrefupdates = true</span><br><span class="line">symlinks = false</span><br><span class="line">ignorecase = true</span><br><span class="line">[branch &quot;main&quot;]</span><br><span class="line">remote = https://github.com/HeartLoveLife/HeartLoveLife.github.io.git</span><br><span class="line">merge = refs/heads/main</span><br></pre></td></tr></table></figure><h3 id="👀问题四，hexo-s出现警告"><a href="#👀问题四，hexo-s出现警告" class="headerlink" title="👀问题四，hexo s出现警告"></a>👀问题四，<code>hexo s</code>出现警告</h3><p><strong>①问题描述</strong>：<code>Accessing non-existent property &#39;*&#39; of module exports inside circular dependency</code></p><figure class="highlight plaintext"><figcaption><span>bash</span></figcaption><table><tr><td class="code"><pre><span class="line">INFO  Start processing</span><br><span class="line">INFO  Hexo is running at http://localhost:4000/ . Press Ctrl+C to stop.</span><br><span class="line">(node:60224) Warning: Accessing non-existent property &#x27;lineno&#x27; of module exports inside circular dependency</span><br><span class="line">(Use `node --trace-warnings ...` to show where the warning was created)</span><br><span class="line">(node:60224) Warning: Accessing non-existent property &#x27;column&#x27; of module exports inside circular dependency</span><br><span class="line">(node:60224) Warning: Accessing non-existent property &#x27;filename&#x27; of module exports inside circular dependency</span><br><span class="line">(node:60224) Warning: Accessing non-existent property &#x27;lineno&#x27; of module exports inside circular dependency</span><br><span class="line">(node:60224) Warning: Accessing non-existent property &#x27;column&#x27; of module exports inside circular dependency</span><br><span class="line">(node:60224) Warning: Accessing non-existent property &#x27;filename&#x27; of module exports inside circular dependency</span><br></pre></td></tr></table></figure><p><strong>②解决方案</strong>：出现警告，是因为<code>node</code>版本太高，切换成低版本的<code>node</code>来安装<code>Hexo</code>就可以了</p><h2 id="⛄Hexo更换主题"><a href="#⛄Hexo更换主题" class="headerlink" title="⛄Hexo更换主题"></a>⛄Hexo更换主题</h2><p>在博客的项目文件夹下打开<code>git bash</code>执行命令，以<code>hexo-theme-butterfly</code>主题为例</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone -b master https://github.com/jerryc127/hexo-theme-butterfly.git themes/butterfly</span><br></pre></td></tr></table></figure><p>运行成功之后，在项目文件夹<code>source</code>中可以查看到新的主题<code>themes</code>文件夹：<code>butterfly</code></p><p>在博客的项目文件夹下，修改<code>_config.yml</code>配置文件如下:</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># theme: landscape  默认主题</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">butterfly</span></span><br></pre></td></tr></table></figure><p>此时主题还不能正常配置使用，需要安装<code>pug</code> 以及<code>stylus</code> 的渲染器:</p><figure class="highlight plaintext"><figcaption><span>bash</span></figcaption><table><tr><td class="code"><pre><span class="line"># npm install hexo-renderer-pug hexo-renderer-stylus --save</span><br><span class="line">cnpm install hexo-renderer-pug hexo-renderer-stylus --save</span><br></pre></td></tr></table></figure><p>执行<code>hexo s</code>部署到本地运行</p><figure class="highlight plaintext"><figcaption><span>bash</span></figcaption><table><tr><td class="code"><pre><span class="line"># 清除缓存b.json 和已生成的静态文件 public</span><br><span class="line">hexo clean</span><br><span class="line"># 生成静态页面到默认设置的 public 文件夹</span><br><span class="line">hexo g</span><br><span class="line"># 启动本地服务器，用于预览</span><br><span class="line">hexo s</span><br><span class="line"># 自动生成网站静态文件，并部署到设定的仓库或上传部署至服务端</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>默认地址：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://localhost:4000/</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客Blog框架简介</title>
      <link href="/2022/05/12/Blog/"/>
      <url>/2022/05/12/Blog/</url>
      
        <content type="html"><![CDATA[<p>简言之，<a href="https://baike.baidu.com/item/%E5%8D%9A%E5%AE%A2/124?fromtitle=blog&fromid=70149&fr=aladdin">Blog</a>就是以网络作为载体，简易迅速便捷地发布自己的心得，及时有效轻松地与他人进行交流，再集丰富多彩的个性化展示于一体的综合性平台。</p><h2 id="⛄博客搭建的方式"><a href="#⛄博客搭建的方式" class="headerlink" title="⛄博客搭建的方式"></a>⛄博客搭建的方式</h2><p>总体来说，Blog搭建的方式可以分为静态博客和动态博客。顾名思义，静态博客：博文内容是通过文档（如：.md文件等）记录的（一个独立的文件），通过生成工具编译成最终的<code>hml</code>、<code>css</code>、<code>js</code>等静态文件，然后部署在静态Server服务器上或<code>Web托管</code>至数据<code>仓库</code>（如：<code>Github</code>），即可在互联网中被访问，不需要数据库的支撑。动态博客：是以数据库技术为基础，其博文内容是通过数据库记录存储的，主要特点体现在<code>交互性</code>；<code>动</code>不是指网页中的页面元素或特效在动，而是与后台数据库进行交互和数据传递（如：注册登录、评论、用户管理等）。</p><p>常见的博客框架：</p><h3 id="👀静态框架"><a href="#👀静态框架" class="headerlink" title="👀静态框架"></a>👀静态框架</h3><ul><li><p>Hexo (<a href="https://hexo.io/zh-cn/">https://hexo.io/zh-cn/</a>)</p></li><li><p>Hugo (<a href="https://www.gohugo.cn/">https://www.gohugo.cn/</a>)</p></li><li><p>VuePress (<a href="https://www.vuepress.cn/">https://www.vuepress.cn/</a>)</p></li><li><p>Jekyll (<a href="https://www.jekyll.com.cn/">https://www.jekyll.com.cn/</a>)</p></li></ul><h3 id="👀动态框架"><a href="#👀动态框架" class="headerlink" title="👀动态框架"></a>👀动态框架</h3><ul><li><p>WordPress  (<a href="https://wordpress.org/">https://wordpress.org/</a>)</p></li><li><p>Typecho (<a href="https://typecho.org/">https://typecho.org/</a>)</p></li><li><p>Halo (<a href="https://halo.run/">https://halo.run/</a>)</p></li><li><p>Solo (<a href="https://b3log.org/solo/">https://b3log.org/solo/</a>)</p></li></ul><h2 id="⛄框架简介"><a href="#⛄框架简介" class="headerlink" title="⛄框架简介"></a>⛄框架简介</h2><h3 id="👀Hexo"><a href="#👀Hexo" class="headerlink" title="👀Hexo"></a>👀Hexo</h3><p><code>Hexo</code> 是一个基于<code>Node.js</code>的快速、简洁且高效的静态博客框架。Hexo 使用 <a href="http://daringfireball.net/projects/markdown/">Markdown</a>（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。Hexo具有丰富的主题、插件系统。</p><p><strong>优点：</strong></p><ul><li>纯静态博客，部署简单、成本低廉、运行优化非常高效。</li><li>Hexo 静态博客框架可以在云端，也可以在本地电脑上甚至手机上。</li><li>Hexo 框架的博客网站没有网站后台，不存在后台安全漏洞的问题。</li><li>因为是纯静态的，几乎所有的 CDN 服务都可以完美的加速提升浏览速度。</li><li>搜索引擎对纯静态网站有天然的青睐度，收录、权重优先权明显。</li><li>纯静态网站会让网络攻击成本大大的增加也就是说纯静态网站被攻击的可能性更低了。</li></ul><h3 id="👀Hugo"><a href="#👀Hugo" class="headerlink" title="👀Hugo"></a>👀Hugo</h3><p><code>Hugo</code> 被称为是世界上最快的构建网站的框架。Hugo 是一个快速且现代的静态网站生成器，采用 Go 编程语言开发，Hugo 的设计目标是让创建网站重新变得有趣。Hugo 是一个通用的网站框架。从技术上讲，Hugo 是一个<a href="https://www.gohugo.cn/about/benefits/">静态站点生成器</a>。与动态构建页面的系统不同，Hugo 在创建或更新内容时构建页面。由于网站的浏览频率远高于编辑频率，因此 Hugo 旨在为您的网站最终用户提供最佳的浏览体验，并为网站作者提供理想的写作体验。使用 Hugo 构建的网站非常快速和安全。Hugo 构建的网站可以托管在任何地方，包括 <a href="https://netlify.com/">Netlify</a>、<a href="https://www.heroku.com/">Heroku</a>、<a href="https://www.godaddy.com/">GoDaddy</a>、<a href="https://www.dreamhost.com/">DreamHost</a>、<a href="https://pages.github.com/">GitHub Pages</a>、<a href="https://about.gitlab.com/features/pages/">GitLab Pages</a>、<a href="https://surge.sh/">Surge</a>、<a href="https://www.aerobatic.com/">Aerobatic</a>、<a href="https://firebase.google.com/docs/hosting/">Firebase</a>、<a href="https://cloud.google.com/storage/">Google Cloud Storage</a>、<a href="https://aws.amazon.com/s3/">Amazon S3</a>、<a href="https://www.rackspace.com/cloud/files">Rackspace</a>、<a href="https://docs.microsoft.com/en-us/azure/storage/blobs/storage-blob-static-website">Azure</a>, 和 <a href="https://aws.amazon.com/cloudfront/">CloudFront</a>，并且与 CDN 更配。Hugo 网站在运行时不需要数据库或依赖于诸如 Ruby、Python 或 PHP 等昂贵的运行时环境。我们认为 Hugo 是一个理想的网站创建工具，具有几乎即时的构建时间，能够在网站修改时即刻重建。</p><p><strong>优点：</strong></p><ul><li>飞快的构建速度。在等待网站构建时有多无聊？Hugo 是同类中最快的工具。每个页面的构建时间小于一毫秒时，网站的平均构建时间不到一秒钟。</li><li>健壮的内容管理。灵活性为王。Hugo 是内容战略家的梦想。Hugo 支持无限的内容类型、分类、菜单、动态 API 驱动的内容等，所有这些都无需插件。</li><li>短代码(shortcodes)。Hugo 短代增强了 Markdown 的能力。我们喜欢 Markdown 语法的漂亮、简洁，但有时我们需要更多的灵活性。Hugo 短代码满足了美观和灵活的需求。</li><li>内置模板。Hugo 提供的通用模式让您的工作迅速完成。Hugo 提供了预制的模板，可以快速完成 SEO、评论、统计和其他功能。一行代码，完成所有工作。</li><li>支持多语言和 i18n。原生支持多语言。Hugo 为多语言站点提供了完整的 i18n 支持，并且与 Hugo 用户喜欢的单语言站点的开发体验完全相同。</li><li>定制输出。HTML 够吗？Hugo 允许以多种格式输出您的内容，包括 JSON 或 AMP，并使您可以轻松创建自己的内容。</li></ul><h3 id="👀VuePress"><a href="#👀VuePress" class="headerlink" title="👀VuePress"></a>👀VuePress</h3><p><code>VuePress</code> 由两部分组成：第一部分是一个<a href="https://github.com/vuejs/vuepress/tree/master/packages/%40vuepress/core">极简静态网站生成器 (opens new window)</a>，它包含由 Vue 驱动的<a href="https://www.vuepress.cn/theme/">主题系统</a>和<a href="https://www.vuepress.cn/plugin/">插件 API</a>，另一个部分是为书写技术文档而优化的<a href="https://www.vuepress.cn/theme/default-theme-config.html">默认主题</a>，它的诞生初衷是为了支持 Vue 及其子项目的文档需求。每一个由 VuePress 生成的页面都带有预渲染好的 HTML，也因此具有非常好的加载性能和搜索引擎优化（SEO）。同时，一旦页面被加载，Vue 将接管这些静态内容，并将其转换成一个完整的单页应用（SPA），其他的页面则会只在用户浏览到的时候才按需加载。</p><p>事实上，一个 VuePress 网站是一个由 <a href="http://vuejs.org/">Vue (opens new window)</a>、<a href="https://github.com/vuejs/vue-router">Vue Router (opens new window)</a>和 <a href="http://webpack.js.org/">webpack (opens new window)</a>驱动的单页应用。如果你以前使用过 Vue 的话，当你在开发一个自定义主题的时候，你会感受到非常熟悉的开发体验，你甚至可以使用 Vue DevTools 去调试你的自定义主题。在构建时，我们会为应用创建一个服务端渲染（SSR）的版本，然后通过虚拟访问每一条路径来渲染对应的HTML。这种做法的灵感来源于 <a href="https://nuxtjs.org/">Nuxt (opens new window)</a>的 <code>nuxt generate</code> 命令，以及其他的一些项目，比如 <a href="https://www.gatsbyjs.org/">Gatsby (opens new window)</a>。</p><p><strong>优点：</strong></p><ul><li>简洁至上。以 Markdown 为中心的项目结构，以最少的配置帮助你专注于写作。</li><li>Vue 驱动。享受 Vue + webpack 的开发体验，可以在 Markdown 中使用 Vue 组件，又可以使用 Vue 来开发自定义主题。</li><li>高性能。VuePress 会为每个页面预渲染生成静态的 HTML，同时，每个页面被加载的时候，将作为 SPA 运行。</li></ul><h3 id="👀Jekyll"><a href="#👀Jekyll" class="headerlink" title="👀Jekyll"></a>👀Jekyll</h3><p><code>Jekyll</code> 是一个静态网站生成器。用你喜欢的标记语言书写内容并交给 Jekyll 处理，它将利用模板为你创建一个静态网站。你可以调整你想要的网址样式、在网站上显示哪些数据等等。jekyll是一个简单的免费的Blog生成工具，类似WordPress。但是和WordPress又有很大的不同，原因是jekyll只是一个生成静态网页的工具，不需要<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%BA%93/103728">数据库</a>支持。但是可以配合第三方服务,例如Disqus。最关键的是jekyll可以免费部署在Github上，而且可以绑定自己的域名。</p><p><strong>优点：</strong></p><ul><li>简单。无需数据库、评论功能或频繁的版本更新—只需关注<em>你的内容</em>。</li><li>静态。只用 <a href="https://daringfireball.net/projects/markdown/">Markdown</a>、<a href="https://github.com/Shopify/liquid/wiki">Liquid</a>、HTML &amp; CSS g就可以构建可部署的静态网站。</li><li>博客。原生支持自定义链接、分类、静态页、文章以及自定义布局。</li></ul><h3 id="👀WordPress"><a href="#👀WordPress" class="headerlink" title="👀WordPress"></a>👀WordPress</h3><p><code>WordPress</code>是一款能让您建立出色网站、博客或应用程序的开源软件。WordPress是使用<a href="https://baike.baidu.com/item/PHP/9337">PHP</a>语言开发的博客平台，用户可以在支持PHP和MySQL数据库的<a href="https://baike.baidu.com/item/%E6%9C%8D%E5%8A%A1%E5%99%A8/100571">服务器</a>上架设属于自己的网站。也可以把 WordPress当作一个<a href="https://baike.baidu.com/item/%E5%86%85%E5%AE%B9%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/2683135">内容管理系统</a>（CMS）来使用。WordPress是一款<a href="https://baike.baidu.com/item/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/5466014">个人博客</a>系统，并逐步演化成一款内容管理系统软件，它是使用PHP语言和<a href="https://baike.baidu.com/item/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93/10991669">MySQL数据库</a>开发的，用户可以在支持 PHP 和 MySQL数据库的服务器上使用自己的博客。WordPress有许多第三方开发的免费模板，安装方式简单易用。不过要做一个自己的模板，则需要你有一定的专业知识。比如你至少要懂的<a href="https://baike.baidu.com/item/%E6%A0%87%E5%87%86%E9%80%9A%E7%94%A8%E6%A0%87%E8%AE%B0%E8%AF%AD%E8%A8%80/6805073">标准通用标记语言</a>下的一个应用<a href="https://baike.baidu.com/item/HTML">HTML</a>、<a href="https://baike.baidu.com/item/CSS/5457">CSS</a>、PHP等相关知识。</p><p><strong>优点：</strong></p><ul><li>WordPress 功能强大、扩展性强、生态丰富，这主要得益于其插件众多，易于扩充功能，基本上一个完整网站该有的功能，通过其第三方插件都能实现所有功能。</li><li>wordpress搭建的博客对seo搜索引擎友好，收录也快，排名靠前。</li><li>适合DIY，如果你是喜欢丰富内容的网站，那么wordpress可以很好地符合你的胃口。</li><li>主题很多，网站上一大片都是wordpress的主题，各色各样，应有尽有！</li><li>wordpress备份和网站转移比较方便，原站点使用站内工具导出后，使用WordPress Importer插件就能方便地将内容导入新网站。</li><li>wordpress有强大的社区支持，有上千万的开发者贡献和审查wordpress，所以wordpress是安全并且活跃的。</li></ul><h3 id="👀Typecho"><a href="#👀Typecho" class="headerlink" title="👀Typecho"></a>👀Typecho</h3><p><code>Typecho</code>是由type和echo两个词合成的，来自于开发团队的头脑风暴。Typecho基于PHP5开发，支持多种数据库，是一款内核强健﹑扩展方便﹑体验友好﹑运行流畅的轻量级开源博客程序。选用Typecho，搭建独一无二个人<a href="https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E6%97%A5%E5%BF%97/87941">网络日志</a>发布平台，享受创作的快乐。</p><p><strong>优点：</strong></p><ul><li>轻量高效。仅仅 7 张数据表，加上不足 400KB 的代码，就实现了完整的插件与模板机制。超低的 CPU 和内存使用率，足以发挥主机的最高性能。</li><li>先进稳定。原生支持 Markdown 排版语法，易读更易写。支持 BAE&#x2F;GAE&#x2F;SAE 等各类云主机，即使面对突如其来的高访问量，也能轻松应对。</li><li>简洁友好。精心打磨过的操作界面，依然是你熟悉的面孔，更多了一份成熟与贴心。每一个像素的剪裁，都只为离完美更进一步。</li></ul><h3 id="👀Halo"><a href="#👀Halo" class="headerlink" title="👀Halo"></a>👀Halo</h3><p><code>Halo</code>是一款基于<code>Java</code>语言，使用<a href="https://baike.baidu.com/item/Spring%20Boot/20249767?fr=aladdin">Spring Boot</a>框架开发的博客系统，致力于打造最好的 Java 博客系统，且只想安安静静的做一个博客系统。</p><p><strong>优点：</strong></p><ul><li>代码开源。我们的所有代码开源在 <a href="https://github.com/halo-dev">GitHub</a> 上且处于积极维护状态，截止目前已经发布了 <a href="https://github.com/halo-dev/halo/releases">81</a> 个版本。您也可以在上面提交您的问题或者参与代码贡献。</li><li>易于部署。采用了程序与用户配置分离的方式，迁移和备份成本大大降低。您只需要一条命令即可运行成功，同时也支持 Docker 部署。</li><li>REST API。提供了完善的 <a href="https://api.halo.run/content-api.html">Content API</a> 和 <a href="https://api.halo.run/admin-api.html">Admin API</a>，你可以用于开发单页面模板，微信小程序，各种系统的插件等。</li><li>模板系统完善的模板系统，支持自定义配置，支持在线安装和更新。开发主题也十分方便，欢迎大家参与主题的开发。</li><li>附件系统。支持本地上传，阿里云 OSS&#x2F;又拍云 OSS&#x2F;七牛云 OSS&#x2F;SM.MS 等云存储，你可以更方便的管理你文章中的附件。</li><li>评论系统拥有独立的评论插件，使用 Vue 开发，只需在页面引入构建好的 JS 文件即可，完美地和主题相结合。目前已有多款评论组件，你可以非常方便的切换。</li></ul><h3 id="👀Solo"><a href="#👀Solo" class="headerlink" title="👀Solo"></a>👀Solo</h3><p><code>Solo</code> 是一款基于Java语言有后台管理的，小而美的博客系统，专为程序员设计</p><p><strong>优点：</strong></p><ul><li>Markdown 编辑器支持三种编辑模式：所见即所得 &#x2F; 即时渲染 &#x2F; 分屏预览。</li><li><a href="https://ld246.com/article/1498490209748">Hexo &#x2F; Jekyll &#x2F; Markdown 导入</a>。</li><li>SQL &#x2F; JSON &#x2F; Markdown 导出。</li><li>拉取 GitHub 仓库和自动备份。</li><li>内置 HTTPS+CDN 文件存储。</li><li>支持生成导出静态站点，用于发布 GitHub Pages。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Blog </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
