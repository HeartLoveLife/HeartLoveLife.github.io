<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Python/Matlab/IDL之文件读写操作【CSV/Excel/JSON/XML/TXT】</title>
      <link href="/2023/11/28/Files-ReadWrite/"/>
      <url>/2023/11/28/Files-ReadWrite/</url>
      
        <content type="html"><![CDATA[<h2 id="⛄前言"><a href="#⛄前言" class="headerlink" title="⛄前言"></a>⛄前言</h2><p><code>CSV</code>（<code>Comma-Separated Values</code>，逗号分隔值，有时也称为<strong>字符分隔值</strong>，因为分隔字符也可以不是逗号），其文件以纯文本形式存储表格数据（数字和文本）。纯文本意味着该文件是一个字符序列，不含必须像二进制数字那样被解读的数据。<code>CSV</code>文件由任意数目的记录组成，记录间以某种换行符分隔；每条记录由字段组成，字段间的分隔符是其它字符或字符串，最常见的是逗号或制表符。<code>CSV</code>文件通常以 <code>.csv</code> 作为文件扩展名。</p><p><code>XLS</code>就是<code>Microsoft Excel</code>工作表，是一种非常常用的电子表格格式。<code>xls</code>文件可以使用<code>Microsoft Excel</code>打开，另外微软为那些没有安装<code>Excel</code>的用户开发了专门的查看器<code>Excel Viewer</code>。使用<code>Microsoft Excel</code>可以将<code>XLS</code>格式的表格转换为多种格式：<code>XML</code>表格、<code>XML</code>数据、网页、使用制表符分割的文本文件（<code>.txt</code>）、使用逗号分隔的文本文件(<code>.csv</code>)等。</p><p><code>XLSX</code>是<code>Microsoft Office EXCEL 2007/.../2019</code>文档及以上的扩展名。其基于<code>Office Open XML</code>标准的压缩文件格式取代以前专有的默认文件格式，在传统文件名扩展名后面添加字母”<code>x</code>“（即<code>.docx</code>取代<code>.doc</code>、<code>.xlsx</code>取代<code>.xls</code>、<code>.pptx</code>取代<code>.ppt</code>）。任何能够打开<code>.xlsx</code>文件的文字处理软件都可以将该文档转换为<code>.xls</code>文件，<code>.xlsx</code>文件比<code>.xls</code>文件所占用空间更小。</p><blockquote><p><code>xlsx</code>格式文档文件无法被<code>EXCEL2003</code>及以下版本<code>EXCEL</code>软件直接打开编辑，安装<code>OFFICE2007</code>兼容包后可以打开查看。手动将<code>XLSX</code>文件后缀修改为<code>XLS</code>无法改变文档文件的本质属性，是不能被<code>EXCEL2003</code>等低版本<code>EXCEL</code>直接打开编辑的。用户可在<code>EXCEL</code>软件成功打开<code>EXCEL2007</code>专有<code>XLSX</code>格式文档的前提下，采用另存为方式将其转换为<code>EXCEL97—2003</code>格式文档的<code>XLS</code>文件这样可与旧的版本兼容，但一些<code>EXCEL2007</code>文档专有的特性格式可能丢失。<code>Excel xls</code>和<code>xlsx</code>的详细区别如下：</p><ul><li><strong>文件格式不同</strong>：<code>xls</code>是一个特有的<a href="https://www.zhihu.com/search?q=%E4%BA%8C%E8%BF%9B%E5%88%B6&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2685933475%7D">二进制</a>格式，其核心结构是复合文档类型的结构，而<code>xlsx</code>的核心结构是<code>XML</code>类型的结构，采用的是基于<code>XML</code>的压缩方式，使其占用的空间更小。<code>xlsx</code>中最后一个<code>x</code>的意义就在于此。</li><li><strong>版本不同</strong>：<code>xls</code>是<code>excel2003</code>及以前版本生成的文件格式，不管有没有宏程序的话都是<code>xls</code>文件，而<code>xlsx</code>是<code>excel2007</code>及以后版本生成的文件格式，从<code>2007</code>开始做了区分，<code>XLSM</code>文件和<code>XLSX</code>文件都是<code>excel2007</code>及其以后的文件，但前者是含有宏启用，<code>Excel</code>中默认情况下不自动启用宏，默认是<code>XLSX</code>。<code>VBA</code>中，如果不想保存代码，可以保存为<code>xlsx</code>，即可自动删除其中<code>VBA</code>代码，反之则保存为<code>XLSM</code>文件。</li><li><strong>兼容性不同</strong>：<code>xlsx</code>格式是向下兼容的，可兼容<code>xls</code>格式。07版的<code>Office Excel</code>，能打开编辑07版（后缀<code>.xlsx</code>）的<code>Excel</code>文件，也能打开编辑03版（后缀<code>.xls</code>）的<code>Excel</code>文件，都不会出现乱码或者卡死的情况。03版的<code>Office Excel</code>，就只能打开编辑03版（后缀<code>.xls</code>）的<code>Excel</code>文件；如果打开编辑07版（后缀<code>.xlsx</code>）的<code>Excel</code>文件，则可能出现乱码或者开始能操作到最后就卡死，以后一打开就卡死。</li><li><strong>默认保存方式上</strong>：<code>xls</code>是03版<code>Microsoft Office Excel</code> 工作表的格式，用03版Office，新建<code>Excel</code>默认保存的<code>Excel</code>文件格式的后缀是<code>.xls</code>；<code>xlsx</code>是07版<code>Microsoft Office Excel</code> 工作表的格式，用07版Office，新建<code>Excel</code>默认保存的的<code>Excel</code>文件格式后缀是<code>.xlsx</code>。</li><li><strong>容量不同</strong>：<code>xls</code>只有65536行、256列；<code>xlsx</code>可以有1048576行、16384列</li></ul></blockquote><p><code>JSON</code>（<code>JavaScript Object Notation</code>, <code>JS</code>对象简谱）是一种轻量级的数据交换格式。它基于 <a href="https://baike.baidu.com/item/ECMAScript?fromModule=lemma_inlink">ECMAScript</a>（欧洲计算机协会制定的<code>js</code>规范）的一个子集，采用完全独立于编程语言的文本格式来存储和表示数据。简洁和清晰的层次结构使得<code>JSON</code>成为理想的数据交换语言。 易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。</p><p><code>XML</code> (<code>Extensible Markup Language</code>, 可扩展标记语言) ，<a href="https://baike.baidu.com/item/%E6%A0%87%E5%87%86%E9%80%9A%E7%94%A8%E6%A0%87%E8%AE%B0%E8%AF%AD%E8%A8%80/6805073?fromModule=lemma_inlink">标准通用标记语言</a>的子集，可以用来标记数据、定义数据类型，是一种允许用户对自己的标记语言进行定义的源语言。 <code>XML</code>是标准通用标记语言可扩展性良好，内容与形式分离，遵循严格的语法要求，保值性良好等优点。</p><p><code>TXT</code>文件是微软在操作系统上附带的一种文本格式，是最常见的一种文件格式，早在<a href="https://baike.baidu.com/item/DOS/32025?fromModule=lemma_inlink">DOS</a>时代应用就很多，主要存储文本信息，即为文字信息，现在的操作系统大多使用记事本等程序保存，大多数软件可以查看，如记事本，浏览器等等。</p><h2 id="⛄Python之读写文件"><a href="#⛄Python之读写文件" class="headerlink" title="⛄Python之读写文件"></a>⛄Python之读写文件</h2><h3 id="👀CSV"><a href="#👀CSV" class="headerlink" title="👀CSV"></a>👀CSV</h3><h4 id="（1）CSV库读取"><a href="#（1）CSV库读取" class="headerlink" title="（1）CSV库读取"></a><strong>（1）CSV库读取</strong></h4><p><code>csv.reader</code>：以列表的形式返回读取的数据；<br><code>csv.writer</code>：以列表的形式写入数据；<br><code>csv.DictReader</code>：以字典的形式返回读取的数据；<br><code>csv.DictWriter</code>：以字典的形式写入数据。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">r&quot;D:\Desktop\data.csv&quot;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    reader = csv.reader(file)</span><br><span class="line">    <span class="built_in">print</span>(reader)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">20</span>)</span><br><span class="line">    <span class="comment"># 用next()函数读取文件时：如果只执行一次默认读取第一行。</span></span><br><span class="line">    headers = <span class="built_in">next</span>(reader)</span><br><span class="line">    <span class="built_in">print</span>(headers)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">20</span>)</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> reader:</span><br><span class="line">        <span class="built_in">print</span>(row)</span><br><span class="line">        <span class="built_in">print</span>(row[<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">&lt;_csv.reader <span class="built_in">object</span> at <span class="number">0x000001D6B95F1668</span>&gt;</span><br><span class="line">********************</span><br><span class="line">[<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;gender&#x27;</span>, <span class="string">&#x27;age&#x27;</span>, <span class="string">&#x27;hobby&#x27;</span>]</span><br><span class="line">********************</span><br><span class="line">[<span class="string">&#x27;小红&#x27;</span>, <span class="string">&#x27;女&#x27;</span>, <span class="string">&#x27;20&#x27;</span>, <span class="string">&#x27;跑步&#x27;</span>]</span><br><span class="line"><span class="number">20</span></span><br><span class="line">[<span class="string">&#x27;小汤&#x27;</span>, <span class="string">&#x27;男&#x27;</span>, <span class="string">&#x27;22&#x27;</span>, <span class="string">&#x27;篮球&#x27;</span>]</span><br><span class="line"><span class="number">22</span></span><br><span class="line">[<span class="string">&#x27;小李&#x27;</span>, <span class="string">&#x27;男&#x27;</span>, <span class="string">&#x27;24&#x27;</span>, <span class="string">&#x27;足球&#x27;</span>]</span><br><span class="line"><span class="number">24</span></span><br></pre></td></tr></table></figure><p><strong><code>namedtuple</code></strong>(具名元组)，因为元组的局限性：不能为元组内部的数据进行命名，所以往往我们并不知道一个元组所要表达的意义，在这里引入了<code>collections.namedtuple</code> 这个工厂函数，来构造一个带字段名的元组。具名元组的实例和普通元组消耗的内存一样多，因为字段名都被存在对应的类里面。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 获取一行数据中的某一列数据</span></span><br><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">r&quot;D:\Desktop\data.csv&quot;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    reader = csv.reader(file)</span><br><span class="line">    <span class="built_in">print</span>(reader)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">20</span>)</span><br><span class="line">    headers = <span class="built_in">next</span>(reader)</span><br><span class="line">    <span class="comment"># namedtuple(具名元组)返回一个具名元组子类 typename</span></span><br><span class="line">    Row = namedtuple(<span class="string">&#x27;Row&#x27;</span>, headers)</span><br><span class="line">    <span class="built_in">print</span>(headers)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">20</span>)</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> reader:</span><br><span class="line">        <span class="comment"># 列表或元组前面加星号作用是将列表解开成两个独立的参数;</span></span><br><span class="line">        <span class="comment"># 字典前面加两个星号,是将字典的值解开成独立的元素作为形参。</span></span><br><span class="line">        row = Row(*row)</span><br><span class="line">        <span class="comment"># 获取一行数据中的某一列数据。</span></span><br><span class="line">        <span class="built_in">print</span>(row.name,row.age)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">&lt;_csv.reader <span class="built_in">object</span> at <span class="number">0x000001D6B95F1128</span>&gt;</span><br><span class="line">********************</span><br><span class="line">[<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;gender&#x27;</span>, <span class="string">&#x27;age&#x27;</span>, <span class="string">&#x27;hobby&#x27;</span>]</span><br><span class="line">********************</span><br><span class="line">小红 <span class="number">20</span></span><br><span class="line">小汤 <span class="number">22</span></span><br><span class="line">小李 <span class="number">24</span></span><br></pre></td></tr></table></figure><p>简单使用<code>csv.DictReader</code></p><blockquote><p>可以深入了解该函数的参数：</p><ul><li><code>csv.DictReader()</code>之<code>fieldnames</code>参数</li><li><code>csv.DictReader()</code>之<code>restkey</code>参数</li><li><code>csv.DictReader()</code>之<code>restval</code>参数</li></ul></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">r&quot;D:\Desktop\data.csv&quot;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    # 如果没有字段名，参数fieldnames</span></span><br><span class="line"><span class="string">    reader = csv.DictReader(file,fieldnames = [&#x27;name&#x27;,&#x27;gender&#x27;,&#x27;age&#x27;,&#x27;hobby&#x27;])</span></span><br><span class="line"><span class="string">    # next()方法用于移动指针</span></span><br><span class="line"><span class="string">    head_row = next(reader)</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    reader = csv.DictReader(file)</span><br><span class="line">    <span class="built_in">print</span>(reader)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">20</span>)</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> reader:</span><br><span class="line">        <span class="comment"># OrderedDict是一种长相类似于列表的数据类型，该列表中嵌套着元组；</span></span><br><span class="line">        <span class="comment"># 每个元组中的第一个元素为键，第二个元素为值（类似于字典）</span></span><br><span class="line">        <span class="built_in">print</span>(row)</span><br><span class="line">        <span class="built_in">print</span>(row[<span class="string">&quot;name&quot;</span>],row[<span class="string">&quot;hobby&quot;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">&lt;csv.DictReader <span class="built_in">object</span> at <span class="number">0x000001D6B95F0388</span>&gt;</span><br><span class="line">********************</span><br><span class="line">OrderedDict([(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;小红&#x27;</span>), (<span class="string">&#x27;gender&#x27;</span>, <span class="string">&#x27;女&#x27;</span>), (<span class="string">&#x27;age&#x27;</span>, <span class="string">&#x27;20&#x27;</span>), (<span class="string">&#x27;hobby&#x27;</span>, <span class="string">&#x27;跑步&#x27;</span>)])</span><br><span class="line">小红 跑步</span><br><span class="line">OrderedDict([(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;小汤&#x27;</span>), (<span class="string">&#x27;gender&#x27;</span>, <span class="string">&#x27;男&#x27;</span>), (<span class="string">&#x27;age&#x27;</span>, <span class="string">&#x27;22&#x27;</span>), (<span class="string">&#x27;hobby&#x27;</span>, <span class="string">&#x27;篮球&#x27;</span>)])</span><br><span class="line">小汤 篮球</span><br><span class="line">OrderedDict([(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;小李&#x27;</span>), (<span class="string">&#x27;gender&#x27;</span>, <span class="string">&#x27;男&#x27;</span>), (<span class="string">&#x27;age&#x27;</span>, <span class="string">&#x27;24&#x27;</span>), (<span class="string">&#x27;hobby&#x27;</span>, <span class="string">&#x27;足球&#x27;</span>)])</span><br><span class="line">小李 足球</span><br></pre></td></tr></table></figure><h4 id="（2）CSV库写入"><a href="#（2）CSV库写入" class="headerlink" title="（2）CSV库写入"></a><strong>（2）CSV库写入</strong></h4><p><code>csv.reader</code>：以列表的形式返回读取的数据；<br><code>csv.writer</code>：以列表的形式写入数据；<br><code>csv.DictReader</code>：以字典的形式返回读取的数据；<br><code>csv.DictWriter</code>：以字典的形式写入数据。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="comment"># 1. 创建文件对象（指定文件名，模式，编码方式）,指定下次写入在这次的下一行</span></span><br><span class="line"><span class="comment"># 注意引入newline=&quot;&quot;，不然加入的数据会空一行</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">r&quot;D:\Desktop\data.csv&quot;</span>, <span class="string">&quot;a+&quot;</span>, encoding=<span class="string">&quot;gbk&quot;</span>, newline=<span class="string">&quot;&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="comment"># 2. 基于文件对象构建 csv写入对象</span></span><br><span class="line">    csv_writer = csv.writer(f)</span><br><span class="line">    <span class="comment"># 3. 构建列表头</span></span><br><span class="line">    <span class="comment"># name = [&#x27;name&#x27;,&#x27;gender&#x27;,&#x27;age&#x27;,&#x27;hobby&#x27;]</span></span><br><span class="line">    <span class="comment"># csv_writer.writerow(name)</span></span><br><span class="line">    <span class="comment"># 4. 写入csv文件内容</span></span><br><span class="line">    z = [[<span class="string">&quot;小ai&quot;</span>, <span class="string">&quot;男&quot;</span>, <span class="number">21</span>, <span class="string">&quot;篮球&quot;</span>],[<span class="string">&quot;小张&quot;</span>, <span class="string">&quot;男&quot;</span>, <span class="number">25</span>, <span class="string">&quot;篮球&quot;</span>]]</span><br><span class="line">    csv_writer.writerows(z)</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">r&quot;D:\Desktop\data.csv&quot;</span>, <span class="string">&quot;r+&quot;</span>, encoding=<span class="string">&quot;gbk&quot;</span>, newline=<span class="string">&quot;&quot;</span>) <span class="keyword">as</span> f:   </span><br><span class="line">    reader = csv.reader(f)</span><br><span class="line">    headers = <span class="built_in">next</span>(reader)</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> reader:</span><br><span class="line">        <span class="built_in">print</span>(row)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[<span class="string">&#x27;小红&#x27;</span>, <span class="string">&#x27;女&#x27;</span>, <span class="string">&#x27;20&#x27;</span>, <span class="string">&#x27;跑步&#x27;</span>]</span><br><span class="line">[<span class="string">&#x27;小汤&#x27;</span>, <span class="string">&#x27;男&#x27;</span>, <span class="string">&#x27;22&#x27;</span>, <span class="string">&#x27;篮球&#x27;</span>]</span><br><span class="line">[<span class="string">&#x27;小李&#x27;</span>, <span class="string">&#x27;男&#x27;</span>, <span class="string">&#x27;24&#x27;</span>, <span class="string">&#x27;足球&#x27;</span>]</span><br><span class="line">[<span class="string">&#x27;小ai&#x27;</span>, <span class="string">&#x27;男&#x27;</span>, <span class="string">&#x27;21&#x27;</span>, <span class="string">&#x27;篮球&#x27;</span>]</span><br><span class="line">[<span class="string">&#x27;小张&#x27;</span>, <span class="string">&#x27;男&#x27;</span>, <span class="string">&#x27;25&#x27;</span>, <span class="string">&#x27;篮球&#x27;</span>]</span><br></pre></td></tr></table></figure><blockquote><p>如果<code>csvfile</code>是文件对象，则打开它时应使用<code>newline=&quot;&quot;</code>。如果没有指定<code>newline=&quot;&quot;</code>，则嵌入引号中的换行符将无法正确解析，并且在写入时，使用<code>\r\n</code>换行的平台会有多余的<code>\r</code>写入。由于<code>csv</code>模块会执行自己的（通用）换行符处理，因此指定<code>newline=&quot;&quot;</code>应该总是安全的。</p><p><code>open()</code>完成后必须调用<code>close()</code>方法关闭文件，因为文件对象会占用操作系统资源，并且操作系统同一时间能打开的文件数量也是有限的。由于文件读写时有可能产生<code>IOError</code>，一旦出错，后面的<code>f.close()</code>就不会调用。<code>with open()</code>则可以避免这样的情况。</p></blockquote><table><thead><tr><th align="center">模式</th><th>描述</th></tr></thead><tbody><tr><td align="center"><code>t</code></td><td>以<strong>文本格式</strong>打开文件（默认）。一般用于文本文件，如：<code>txt</code>。</td></tr><tr><td align="center"><code>b</code></td><td>以<strong>二进制格式</strong>打开文件。一般用于非文本文件，如：图片。</td></tr><tr><td align="center"><code>r</code></td><td>以<strong>只读</strong>方式打开文件（默认模式）。文件的指针将会放在文件的开头，如果文件不存在会<strong>报错</strong>。</td></tr><tr><td align="center"><code>w</code></td><td>以<strong>只写</strong>方式打开文件。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，则创建新文件。</td></tr><tr><td align="center"><code>a</code></td><td>以<strong>追加</strong>方式打开文件，同样是只写，不允许进行读操作。如果文件已存在，文件指针将会放在文件的结尾，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。</td></tr><tr><td align="center"><code>r+</code></td><td>打开一个文件用于读写。如果文件存在，则打开文件，将文件指针定位在文件头，新写入的内容在原有内容的前面；如果文件不存在会报错。</td></tr><tr><td align="center"><code>w+</code></td><td>打开一个文件用于读写。如果文件存在，则打开文件，清空原有内容，进入编辑模式；如果文件不存在，则创建一个新文件进行读写操作。</td></tr><tr><td align="center"><code>a+</code></td><td>以追加模式打开一个文件用于读写。如果文件存在，则打开文件，将文件指针定位在文件尾，新写入的内容在原有内容的后面；如果文件不存在，则创建一个新文件用于读写。</td></tr><tr><td align="center"><code>rb</code></td><td>以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。这是默认模式。一般用于非文本文件如图片等。</td></tr><tr><td align="center"><code>wb</code></td><td>以二进制格式打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。</td></tr><tr><td align="center"><code>ab</code></td><td>以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。</td></tr><tr><td align="center"><code>rb+</code></td><td>以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。一般用于非文本文件如图片等。</td></tr><tr><td align="center"><code>wb+</code></td><td>以二进制格式打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。</td></tr><tr><td align="center"><code>ab+</code></td><td>以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。</td></tr></tbody></table><blockquote><p><code>csv</code>库常见的问题</p><ul><li><code>csv.DictWriter()</code>：该函数返回的结果遍历一次之后，再次遍历返回的结果是空列表。</li><li><code>csv.reader()</code>：返回的结果是结构体，需要<code>for</code>循环才能调用，不能像<code>list</code>那样直接选取特定单元格。</li><li>通过列名来查找指定列的操作麻烦。</li></ul></blockquote><h4 id="（3）pandas库读取"><a href="#（3）pandas库读取" class="headerlink" title="（3）pandas库读取"></a><strong>（3）pandas库读取</strong></h4><blockquote><p>使用<code>pandas</code>读取<code>csv</code>文件的优势：</p><ul><li>方便，有专门支持读取<code>csv</code>文件的<code>pd.read_csv()</code>函数；</li><li>将<code>csv</code>转换成二维列表形式；</li><li>支持通过列名查找特定列；</li><li>相比<code>csv</code>库，事半功倍。</li></ul></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pandas.read_csv(filepath_or_buffer, sep=, delimiter=<span class="literal">None</span>, header=‘infer’, names=<span class="literal">None</span>, index_col=<span class="literal">None</span>, usecols=<span class="literal">None</span>, squeeze=<span class="literal">False</span>, prefix=<span class="literal">None</span>, mangle_dupe_cols=<span class="literal">True</span>, dtype=<span class="literal">None</span>, engine=<span class="literal">None</span>, converters=<span class="literal">None</span>, true_values=<span class="literal">None</span>, false_values=<span class="literal">None</span>, skipinitialspace=<span class="literal">False</span>, skiprows=<span class="literal">None</span>, skipfooter=<span class="number">0</span>, nrows=<span class="literal">None</span>, na_values=<span class="literal">None</span>, keep_default_na=<span class="literal">True</span>, na_filter=<span class="literal">True</span>, verbose=<span class="literal">False</span>, skip_blank_lines=<span class="literal">True</span>, parse_dates=<span class="literal">False</span>, infer_datetime_format=<span class="literal">False</span>, keep_date_col=<span class="literal">False</span>, date_parser=<span class="literal">None</span>, dayfirst=<span class="literal">False</span>, cache_dates=<span class="literal">True</span>, iterator=<span class="literal">False</span>, chunksize=<span class="literal">None</span>, compression=‘infer’, thousands=<span class="literal">None</span>, decimal=’.’, lineterminator=<span class="literal">None</span>, quotechar=<span class="string">&#x27;&quot;&#x27;</span>, quoting=<span class="number">0</span>, doublequote=<span class="literal">True</span>, escapechar=<span class="literal">None</span>, comment=<span class="literal">None</span>, encoding=<span class="literal">None</span>, dialect=<span class="literal">None</span>, error_bad_lines=<span class="literal">True</span>, warn_bad_lines=<span class="literal">True</span>, delim_whitespace=<span class="literal">False</span>, low_memory=<span class="literal">True</span>, memory_map=<span class="literal">False</span>, float_precision=<span class="literal">None</span>, storage_options=<span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 常用参数详解</span></span><br><span class="line">（<span class="number">1</span>）filepath_or_buffer：必须有的参数，其它都是按需求选用的。文件所在处的路径。</span><br><span class="line">（<span class="number">2</span>）sep：指定分隔符，默认为逗号<span class="string">&#x27;,&#x27;</span>。</span><br><span class="line">（<span class="number">3</span>）delimiter：<span class="built_in">str</span>/default/<span class="literal">None</span>，定界符，备选分隔符（如果指定该参数，则sep参数失效）</span><br><span class="line">（<span class="number">4</span>）header：<span class="built_in">int</span> <span class="keyword">or</span> <span class="built_in">list</span> of ints, default ‘infer’，指定哪一行作为表头。默认设置为<span class="number">0</span>（即第一行作为表头），如果没有表头的话，要修改参数，设置header=<span class="literal">None</span>。</span><br><span class="line">（<span class="number">5</span>）names：指定列的名称，用列表表示。一般我们没有表头，即header=<span class="literal">None</span>时，这个用来添加列名就很有用啦。</span><br><span class="line">（<span class="number">6</span>）index_col：指定哪一列数据作为行索引，可以是一列，也可以多列。多列的话，会看到一个分层索引。</span><br><span class="line">（<span class="number">7</span>）squeeze：布尔值，默认为<span class="literal">False</span>。如果解析的数据仅包含一列，则返回一个Series。</span><br><span class="line">（<span class="number">8</span>）prefix：给列名添加前缀。如prefix=<span class="string">&quot;x&quot;</span>,会出来<span class="string">&quot;x1&quot;</span>、<span class="string">&quot;x2&quot;</span>、<span class="string">&quot;x3&quot;</span>。</span><br><span class="line">（<span class="number">9</span>）nrows：<span class="built_in">int</span>, default <span class="literal">None</span>。需要读取的行数（从文件头开始算起）。</span><br><span class="line">（<span class="number">10</span>）encoding：编码方式。</span><br><span class="line">（<span class="number">11</span>）skiprows：<span class="built_in">list</span>-like <span class="keyword">or</span> integer, default <span class="literal">None</span>。在文件开始处要跳过的行号（索引为<span class="number">0</span>）或要跳过的行数（整数）。</span><br><span class="line">......</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">df = pd.read_csv(<span class="string">r&quot;D:\Desktop\data.csv&quot;</span>,encoding=<span class="string">&quot;gbk&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(df) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="built_in">print</span>(df.index.values)</span><br><span class="line"><span class="built_in">print</span>(df.columns.values)</span><br><span class="line"><span class="built_in">print</span>(df.values)</span><br><span class="line"><span class="comment"># 通过位置选取</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;=&quot;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="built_in">print</span>(df.iloc[:,<span class="number">0</span>:<span class="number">3</span>].values)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(df.iloc[:,<span class="number">0</span>:<span class="number">3</span>].values))</span><br><span class="line"><span class="built_in">print</span>(df.iloc[:,<span class="number">0</span>:<span class="number">3</span>].values.tolist())</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(df.iloc[:,<span class="number">0</span>:<span class="number">3</span>].values.tolist()))</span><br><span class="line"><span class="comment"># 通过标签选取</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;-&quot;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="built_in">print</span>(df.loc[[<span class="number">0</span>,<span class="number">3</span>],[<span class="string">&quot;name&quot;</span>,<span class="string">&quot;hobby&quot;</span>]].values)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">  name gender  age hobby</span><br><span class="line"><span class="number">0</span>   小红      女   <span class="number">20</span>    跑步</span><br><span class="line"><span class="number">1</span>   小汤      男   <span class="number">22</span>    篮球</span><br><span class="line"><span class="number">2</span>   小李      男   <span class="number">24</span>    足球</span><br><span class="line"><span class="number">3</span>  小ai      男   <span class="number">21</span>    篮球</span><br><span class="line"><span class="number">4</span>   小张      男   <span class="number">25</span>    篮球</span><br><span class="line">********************</span><br><span class="line">[<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>]</span><br><span class="line">[<span class="string">&#x27;name&#x27;</span> <span class="string">&#x27;gender&#x27;</span> <span class="string">&#x27;age&#x27;</span> <span class="string">&#x27;hobby&#x27;</span>]</span><br><span class="line">[[<span class="string">&#x27;小红&#x27;</span> <span class="string">&#x27;女&#x27;</span> <span class="number">20</span> <span class="string">&#x27;跑步&#x27;</span>]</span><br><span class="line"> [<span class="string">&#x27;小汤&#x27;</span> <span class="string">&#x27;男&#x27;</span> <span class="number">22</span> <span class="string">&#x27;篮球&#x27;</span>]</span><br><span class="line"> [<span class="string">&#x27;小李&#x27;</span> <span class="string">&#x27;男&#x27;</span> <span class="number">24</span> <span class="string">&#x27;足球&#x27;</span>]</span><br><span class="line"> [<span class="string">&#x27;小ai&#x27;</span> <span class="string">&#x27;男&#x27;</span> <span class="number">21</span> <span class="string">&#x27;篮球&#x27;</span>]</span><br><span class="line"> [<span class="string">&#x27;小张&#x27;</span> <span class="string">&#x27;男&#x27;</span> <span class="number">25</span> <span class="string">&#x27;篮球&#x27;</span>]]</span><br><span class="line">====================</span><br><span class="line">[[<span class="string">&#x27;小红&#x27;</span> <span class="string">&#x27;女&#x27;</span> <span class="number">20</span>]</span><br><span class="line"> [<span class="string">&#x27;小汤&#x27;</span> <span class="string">&#x27;男&#x27;</span> <span class="number">22</span>]</span><br><span class="line"> [<span class="string">&#x27;小李&#x27;</span> <span class="string">&#x27;男&#x27;</span> <span class="number">24</span>]</span><br><span class="line"> [<span class="string">&#x27;小ai&#x27;</span> <span class="string">&#x27;男&#x27;</span> <span class="number">21</span>]</span><br><span class="line"> [<span class="string">&#x27;小张&#x27;</span> <span class="string">&#x27;男&#x27;</span> <span class="number">25</span>]]</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;numpy.ndarray&#x27;</span>&gt;</span><br><span class="line">[[<span class="string">&#x27;小红&#x27;</span>, <span class="string">&#x27;女&#x27;</span>, <span class="number">20</span>], [<span class="string">&#x27;小汤&#x27;</span>, <span class="string">&#x27;男&#x27;</span>, <span class="number">22</span>], [<span class="string">&#x27;小李&#x27;</span>, <span class="string">&#x27;男&#x27;</span>, <span class="number">24</span>], [<span class="string">&#x27;小ai&#x27;</span>, <span class="string">&#x27;男&#x27;</span>, <span class="number">21</span>], [<span class="string">&#x27;小张&#x27;</span>, <span class="string">&#x27;男&#x27;</span>, <span class="number">25</span>]]</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;list&#x27;</span>&gt;</span><br><span class="line">--------------------</span><br><span class="line">[[<span class="string">&#x27;小红&#x27;</span> <span class="string">&#x27;跑步&#x27;</span>]</span><br><span class="line"> [<span class="string">&#x27;小ai&#x27;</span> <span class="string">&#x27;篮球&#x27;</span>]]</span><br></pre></td></tr></table></figure><h4 id="（4）pandas库写入"><a href="#（4）pandas库写入" class="headerlink" title="（4）pandas库写入"></a><strong>（4）pandas库写入</strong></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">DataFrame.to_csv(path_or_buf=<span class="literal">None</span>, sep=<span class="string">&#x27;,&#x27;</span>, na_rep=<span class="string">&#x27;&#x27;</span>, float_format=<span class="literal">None</span>, columns=<span class="literal">None</span>, header=<span class="literal">True</span>, index=<span class="literal">True</span>, index_label=<span class="literal">None</span>, mode=<span class="string">&#x27;w&#x27;</span>, encoding=<span class="literal">None</span>, compression=<span class="string">&#x27;infer&#x27;</span>, quoting=<span class="literal">None</span>, quotechar=<span class="string">&#x27;&quot;&#x27;</span>, lineterminator=<span class="literal">None</span>, chunksize=<span class="literal">None</span>, date_format=<span class="literal">None</span>, doublequote=<span class="literal">True</span>, escapechar=<span class="literal">None</span>, decimal=<span class="string">&#x27;.&#x27;</span>, errors=<span class="string">&#x27;strict&#x27;</span>, storage_options=<span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 常用参数详解</span></span><br><span class="line">（<span class="number">1</span>）path_or_buf：字符串，放文件名、相对路径、文件流等。</span><br><span class="line">（<span class="number">2</span>）sep：字符串，分隔符，跟read_csv()的一个意思。</span><br><span class="line">（<span class="number">3</span>）na_rep：字符串，将NaN转换为特定值。</span><br><span class="line">（<span class="number">4</span>）columns：列表，指定哪些列写进去。</span><br><span class="line">（<span class="number">5</span>）header：默认header=<span class="number">0</span>，如果没有表头，设置header=<span class="literal">None</span>，表示我没有表头呀！</span><br><span class="line">（<span class="number">6</span>）index：关于索引的，默认<span class="literal">True</span>,写入索引</span><br><span class="line">（<span class="number">7</span>）mode：&#123;‘w’, ‘x’, ‘a’&#125;, default ‘w’，写入方式。</span><br><span class="line">（<span class="number">8</span>）encoding：编码方式。</span><br><span class="line">......</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">name = [<span class="string">&quot;小小&quot;</span>,<span class="string">&quot;小耿&quot;</span>]</span><br><span class="line">gender = [<span class="string">&quot;男&quot;</span>,<span class="string">&quot;男&quot;</span>]</span><br><span class="line">age = [<span class="number">20</span>,<span class="number">25</span>]</span><br><span class="line">hobby = [<span class="string">&quot;跳绳&quot;</span>,<span class="string">&quot;羽毛球&quot;</span>]</span><br><span class="line"></span><br><span class="line">dict_data = &#123;<span class="string">&quot;name&quot;</span>:name,<span class="string">&quot;gender&quot;</span>:gender,<span class="string">&quot;age&quot;</span>:age,<span class="string">&quot;hobby&quot;</span>:hobby&#125;</span><br><span class="line">df1 = pd.DataFrame(dict_data)</span><br><span class="line"><span class="comment"># mode = &quot;a&quot;为追加数据,index为每行的索引序号,header为标题</span></span><br><span class="line">df1.to_csv(<span class="string">&quot;D:\Desktop\data.csv&quot;</span>,mode=<span class="string">&quot;a&quot;</span>,index=<span class="literal">False</span>,header=<span class="literal">False</span>,encoding=<span class="string">&quot;gbk&quot;</span>)</span><br><span class="line">df2 = pd.read_csv(<span class="string">r&quot;D:\Desktop\data.csv&quot;</span>,encoding=<span class="string">&quot;gbk&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(df2) </span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">  name gender  age hobby</span><br><span class="line"><span class="number">0</span>   小红      女   <span class="number">20</span>    跑步</span><br><span class="line"><span class="number">1</span>   小汤      男   <span class="number">22</span>    篮球</span><br><span class="line"><span class="number">2</span>   小李      男   <span class="number">24</span>    足球</span><br><span class="line"><span class="number">3</span>  小ai      男   <span class="number">21</span>    篮球</span><br><span class="line"><span class="number">4</span>   小张      男   <span class="number">25</span>    篮球</span><br><span class="line"><span class="number">5</span>   小小      男   <span class="number">20</span>    跳绳</span><br><span class="line"><span class="number">6</span>   小耿      男   <span class="number">25</span>   羽毛球</span><br></pre></td></tr></table></figure><h3 id="👀Excel"><a href="#👀Excel" class="headerlink" title="👀Excel"></a>👀Excel</h3><p><code>python</code>用于读写<code>excel</code>文件的库有很多，除了前面提到的<code>pandas</code>，还有<code>xlrd</code>、<code>xlwt</code>、<code>openpyxl</code>、<code>xlwings</code>等等。<strong>这里以<code>pandas</code>库为例对<code>Excel</code>进行操作</strong>。</p><ul><li><code>xlrd</code>库：从<code>excel</code>中读取数据，支持<code>xls</code>、<code>xlsx</code>；</li><li><code>xlwt</code>库：对<code>excel</code>进行修改操作，不支持对<code>xlsx</code>格式的修改；</li><li><code>xlutils</code>库：在<code>xlw</code>和<code>xlrd</code>中，对一个已存在的文件进行修改；</li><li><code>openpyxl</code>库：主要针对<code>xlsx</code>格式的<code>excel</code>进行读取和编辑；</li><li><code>xlwings</code>库：对<code>xlsx</code>、<code>xls</code>、<code>xlsm</code>格式文件进行读写、格式修改等操作；</li><li><code>xlsxwriter</code>库：用来生成<code>excel</code>表格，插入数据、插入图标等表格操作，不支持读取；</li><li><code>Microsoft Excel API</code>：需安装<code>pywin32</code>，直接与<code>Excel</code>进程通信，可以做任何在<code>Excel</code>里可以做的事情，但比较慢。</li></ul><h4 id="（1）读取Excel文件"><a href="#（1）读取Excel文件" class="headerlink" title="（1）读取Excel文件"></a><strong>（1）读取Excel文件</strong></h4><p><code>read_excel()</code>读取<code>xlsx</code>文件：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pd.read_excel(io, sheet_name=<span class="number">0</span>, header=<span class="number">0</span>, names=<span class="literal">None</span>, index_col=<span class="literal">None</span>, usecols=<span class="literal">None</span>, squeeze=<span class="literal">False</span>,dtype=<span class="literal">None</span>, engine=<span class="literal">None</span>, converters=<span class="literal">None</span>, true_values=<span class="literal">None</span>, false_values=<span class="literal">None</span>, skiprows=<span class="literal">None</span>, nrows=<span class="literal">None</span>, na_values=<span class="literal">None</span>, parse_dates=<span class="literal">False</span>, date_parser=<span class="literal">None</span>, thousands=<span class="literal">None</span>, comment=<span class="literal">None</span>, skipfooter=<span class="number">0</span>, convert_float=<span class="literal">True</span>, **kwds)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 常见参数详解</span></span><br><span class="line">（<span class="number">1</span>）io:文件的路径。</span><br><span class="line">（<span class="number">2</span>）sheet_name:读取的工作表的名称；可以是整型数字、列表名，如果读取多个sheet，也可以是它们组成的列表；以<span class="number">0</span>为起始点。</span><br><span class="line">（<span class="number">3</span>）header:指定哪几行做列名；默认header为<span class="number">0</span>，如果设置为[<span class="number">0</span>,<span class="number">1</span>]，则表示将前两行作为多重索引。</span><br><span class="line">（<span class="number">4</span>）names:自定义列名；长度必须和excel的列大小相同；如果缺少列名，使用names指定列名字，会替代原来的列表头。</span><br><span class="line">（<span class="number">5</span>）index_col:用作索引的列；可以是某列的名字，也可以是整型数字或列表。</span><br><span class="line">（<span class="number">6</span>）usecols:指定读取的列；列从<span class="number">0</span>开始，可以是列表，也可以使用Excel的列名，如<span class="string">&#x27;A&#x27;</span>，<span class="string">&#x27;B&#x27;</span>等字母。</span><br><span class="line">（<span class="number">7</span>）squeeze:一列数据时，返回Series还是DataFrame。仅当Excel只有一列的时候起作用，squeeze为<span class="literal">True</span>时，返回Series，反之返回DataFrame。</span><br><span class="line">（<span class="number">8</span>）skiprows:跳过指定行；skiprows=n，跳过前n行；skiprows=[a,b,c]，跳过第a+<span class="number">1</span>,b+<span class="number">1</span>,c+<span class="number">1</span>行（索引从<span class="number">0</span>开始）；使用skiprows后，可能会跳过行首，也就是列名。</span><br><span class="line">（<span class="number">9</span>）nrows:需要读取的行数，表示只读取excel的前nrows行，包括表头。</span><br><span class="line">（<span class="number">10</span>）skipfooter:跳过末尾n行。</span><br><span class="line">......</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取xlsx,设置sheet位置,详细参数解释可以检索该函数</span></span><br><span class="line">data = pd.read_excel(<span class="string">r&quot;D:\Desktop\data.xlsx&quot;</span>,sheet_name=<span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(data)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(data))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="built_in">print</span>(data.iloc[:,[<span class="number">0</span>,<span class="number">1</span>,<span class="number">3</span>]].values)</span><br><span class="line"><span class="built_in">print</span>(data.iloc[:,[<span class="number">0</span>,<span class="number">1</span>,<span class="number">3</span>]].values.tolist())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">  name gender  age hobby</span><br><span class="line"><span class="number">0</span>   小红      女   <span class="number">20</span>    跑步</span><br><span class="line"><span class="number">1</span>   小汤      男   <span class="number">22</span>    篮球</span><br><span class="line"><span class="number">2</span>   小李      男   <span class="number">24</span>    足球</span><br><span class="line"><span class="number">3</span>  小ai      男   <span class="number">21</span>    篮球</span><br><span class="line"><span class="number">4</span>   小张      男   <span class="number">25</span>    篮球</span><br><span class="line"><span class="number">5</span>   小小      男   <span class="number">20</span>    跳绳</span><br><span class="line"><span class="number">6</span>   小耿      男   <span class="number">25</span>   羽毛球</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;pandas.core.frame.DataFrame&#x27;</span>&gt;</span><br><span class="line">********************</span><br><span class="line">[[<span class="string">&#x27;小红&#x27;</span> <span class="string">&#x27;女&#x27;</span> <span class="string">&#x27;跑步&#x27;</span>]</span><br><span class="line"> [<span class="string">&#x27;小汤&#x27;</span> <span class="string">&#x27;男&#x27;</span> <span class="string">&#x27;篮球&#x27;</span>]</span><br><span class="line"> [<span class="string">&#x27;小李&#x27;</span> <span class="string">&#x27;男&#x27;</span> <span class="string">&#x27;足球&#x27;</span>]</span><br><span class="line"> [<span class="string">&#x27;小ai&#x27;</span> <span class="string">&#x27;男&#x27;</span> <span class="string">&#x27;篮球&#x27;</span>]</span><br><span class="line"> [<span class="string">&#x27;小张&#x27;</span> <span class="string">&#x27;男&#x27;</span> <span class="string">&#x27;篮球&#x27;</span>]</span><br><span class="line"> [<span class="string">&#x27;小小&#x27;</span> <span class="string">&#x27;男&#x27;</span> <span class="string">&#x27;跳绳&#x27;</span>]</span><br><span class="line"> [<span class="string">&#x27;小耿&#x27;</span> <span class="string">&#x27;男&#x27;</span> <span class="string">&#x27;羽毛球&#x27;</span>]]</span><br><span class="line">[[<span class="string">&#x27;小红&#x27;</span>, <span class="string">&#x27;女&#x27;</span>, <span class="string">&#x27;跑步&#x27;</span>], [<span class="string">&#x27;小汤&#x27;</span>, <span class="string">&#x27;男&#x27;</span>, <span class="string">&#x27;篮球&#x27;</span>], [<span class="string">&#x27;小李&#x27;</span>, <span class="string">&#x27;男&#x27;</span>, <span class="string">&#x27;足球&#x27;</span>], [<span class="string">&#x27;小ai&#x27;</span>, <span class="string">&#x27;男&#x27;</span>, <span class="string">&#x27;篮球&#x27;</span>], [<span class="string">&#x27;小张&#x27;</span>, <span class="string">&#x27;男&#x27;</span>, <span class="string">&#x27;篮球&#x27;</span>], [<span class="string">&#x27;小小&#x27;</span>, <span class="string">&#x27;男&#x27;</span>, <span class="string">&#x27;跳绳&#x27;</span>], [<span class="string">&#x27;小耿&#x27;</span>, <span class="string">&#x27;男&#x27;</span>, <span class="string">&#x27;羽毛球&#x27;</span>]]</span><br></pre></td></tr></table></figure><h4 id="（2）写入Excel文件"><a href="#（2）写入Excel文件" class="headerlink" title="（2）写入Excel文件"></a><strong>（2）写入Excel文件</strong></h4><p><code>to.excel()</code>保存<code>xlsx</code>文件：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">DataFrame.to_excel(excel_writer, sheet_name=<span class="string">&#x27;Sheet1&#x27;</span>, na_rep=<span class="string">&#x27;&#x27;</span>, float_format=<span class="literal">None</span>, columns=<span class="literal">None</span>, header=<span class="literal">True</span>, index=<span class="literal">True</span>, index_label=<span class="literal">None</span>, startrow=<span class="number">0</span>, startcol=<span class="number">0</span>, engine=<span class="literal">None</span>, merge_cells=<span class="literal">True</span>, encoding=<span class="literal">None</span>, inf_rep=<span class="string">&#x27;inf&#x27;</span>, verbose=<span class="literal">True</span>, freeze_panes=<span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 参数详解</span></span><br><span class="line">（<span class="number">1</span>）excel_writer:字符串或ExcelWriter对象；文件路径或现有的ExcelWriter。</span><br><span class="line">（<span class="number">2</span>）sheet_name:字符串，默认<span class="string">&quot;Sheet1&quot;</span>将包含DataFrame的表的名称。</span><br><span class="line">（<span class="number">3</span>）na_rep:字符串，默认<span class="string">&#x27;&#x27;</span>缺失数据表示方式。</span><br><span class="line">（<span class="number">4</span>）float_format:字符串，默认<span class="literal">None</span>格式化浮点数的字符串。</span><br><span class="line">（<span class="number">5</span>）columns:序列，可选要编写的列。</span><br><span class="line">（<span class="number">6</span>）header:布尔或字符串列表，默认为Ture。写出列名。如果给定字符串列表，则假定它是列名称的别名。</span><br><span class="line">（<span class="number">7</span>）index:布尔，默认的Ture写行名（索引）。</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p><code>ExcelWriter()</code>可以向同一个<code>excel</code>的不同<code>sheet</code>中写入对应的表格数据，首先需要实例化一个<code>writer</code>对象，传入的主要参数为已存在容器表格的路径及文件名称。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 用于将DataFrame对象写入Excel工作表的类。默认值是对xls使用xlwt，对xlsx使用openpyxl。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">pandas</span>.ExcelWriter(path, engine=<span class="literal">None</span>, date_format=<span class="literal">None</span>, datetime_format=<span class="literal">None</span>, mode=<span class="string">&#x27;w&#x27;</span>, **engine_kwargs)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 参数详解</span></span><br><span class="line">（<span class="number">1</span>）path：<span class="built_in">str</span>，xls或xlsx文件的路径。</span><br><span class="line">（<span class="number">2</span>）engine：<span class="built_in">str</span> (可选参数)，用于编写的引擎，常见的引擎有<span class="string">&quot;openpyxl&quot;</span>和<span class="string">&quot;xlsxwriter&quot;</span>。如果为无，则默认为xlsxwriter，但是<span class="string">&quot;xlsxwriter&quot;</span>模块不支持追加操作，需要追加新的sheet操作选择<span class="string">&quot;openpyxl&quot;</span>参数，否则会报错。注意：只能作为关键字参数传递。</span><br><span class="line">（<span class="number">3</span>）date_format：<span class="built_in">str</span>，默认为<span class="literal">None</span>，格式字符串，用于写入Excel文件的日期(例如<span class="string">&quot;YYYY-MM-DD&quot;</span>)。</span><br><span class="line">（<span class="number">4</span>）datetime_format：<span class="built_in">str</span>，默认为<span class="literal">None</span>，写入Excel文件的日期时间对象的格式字符串。(例如<span class="string">&quot;YYYY-MM-DD HH:MM:SS&quot;</span>)。</span><br><span class="line">（<span class="number">5</span>）mode：&#123;<span class="string">&quot;w&quot;</span>,<span class="string">&quot;a&quot;</span>&#125;，默认为<span class="string">&quot;w&quot;</span>，要使用的文件模式(写或追加)。</span><br><span class="line">（<span class="number">6</span>）if_sheet_exists：&#123;<span class="string">&#x27;error&#x27;</span>,<span class="string">&#x27;new&#x27;</span>,<span class="string">&#x27;replace&#x27;</span>,<span class="string">&#x27;overlay&#x27;</span>&#125;，默认<span class="string">&#x27;error&#x27;</span>，写入的sheet name已存在时代码操作。默认<span class="string">&#x27;error&#x27;</span>表示报错；<span class="string">&#x27;new&#x27;</span>表示engine自动创建新的其他sheet name；<span class="string">&#x27;replace&#x27;</span>表示覆盖原sheet数据，在写入之前删除工作表的内容；<span class="string">&#x27;overlay&#x27;</span>表示将内容写入现有工作表而不删除旧内容。</span><br><span class="line"></span><br><span class="line">为了与CSV编写器兼容，ExcelWriter在写入之前将列表和字典序列化为字符串。</span><br></pre></td></tr></table></figure><blockquote><p>在使用<code>pd.ExcelWriter()</code>的时候可能会出现问题：<strong>if_sheet_exists&#x3D;’overlay’ 不起作用</strong></p><p>查阅资料：<code>if_sheet_exists&#123;&#39;error&#39;, &#39;new&#39;, &#39;replace&#39;, &#39;overlay&#39;&#125;</code>，如果<code>pandas</code>的版本过低，是没有<code>overlay</code>参数的，需要升级<code>pandas</code>版本。我的版本：<code>pandas-2.0.1</code></p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 追加数据</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">name = [<span class="string">&quot;小伟&quot;</span>,<span class="string">&quot;小猪&quot;</span>]</span><br><span class="line">gender = [<span class="string">&quot;男&quot;</span>,<span class="string">&quot;男&quot;</span>]</span><br><span class="line">age = [<span class="number">20</span>,<span class="number">18</span>]</span><br><span class="line">hobby = [<span class="string">&quot;跳绳&quot;</span>,<span class="string">&quot;台球&quot;</span>]</span><br><span class="line">dict_data = &#123;<span class="string">&quot;name&quot;</span>:name,<span class="string">&quot;gender&quot;</span>:gender,<span class="string">&quot;age&quot;</span>:age,<span class="string">&quot;hobby&quot;</span>:hobby&#125;</span><br><span class="line">df = pd.DataFrame(dict_data)</span><br><span class="line"><span class="keyword">with</span> pd.ExcelWriter(<span class="string">r&quot;D:\Desktop\data.xlsx&quot;</span>, engine=<span class="string">&#x27;openpyxl&#x27;</span>, mode=<span class="string">&#x27;a&#x27;</span>,if_sheet_exists=<span class="string">&#x27;overlay&#x27;</span>) <span class="keyword">as</span> writer:</span><br><span class="line">df1 = pd.DataFrame(pd.read_excel(<span class="string">r&quot;D:\Desktop\data.xlsx&quot;</span>, sheet_name=<span class="string">&#x27;data&#x27;</span>)) </span><br><span class="line">df_rows = df1.shape[<span class="number">0</span>] <span class="comment">#获取原数据的行数</span></span><br><span class="line"><span class="comment"># 将数据df写入excel中的sheet1表,从第一个空行开始写</span></span><br><span class="line"><span class="comment"># 为了避免覆盖现有内容，要告诉to_excel方法从新的一行开始写，参数startrow设为&quot;原行数+1&quot;</span></span><br><span class="line">df.to_excel(writer, sheet_name=<span class="string">&#x27;data&#x27;</span>,startrow=df_rows+<span class="number">1</span>, index=<span class="literal">False</span>, header=<span class="literal">False</span>)</span><br><span class="line">df2 = pd.read_excel(<span class="string">r&quot;D:\Desktop\data.xlsx&quot;</span>,sheet_name=<span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(df2) </span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">  name gender  age hobby</span><br><span class="line"><span class="number">0</span>   小红      女   <span class="number">20</span>    跑步</span><br><span class="line"><span class="number">1</span>   小汤      男   <span class="number">22</span>    篮球</span><br><span class="line"><span class="number">2</span>   小李      男   <span class="number">24</span>    足球</span><br><span class="line"><span class="number">3</span>  小ai      男   <span class="number">21</span>    篮球</span><br><span class="line"><span class="number">4</span>   小张      男   <span class="number">25</span>    篮球</span><br><span class="line"><span class="number">5</span>   小小      男   <span class="number">20</span>    跳绳</span><br><span class="line"><span class="number">6</span>   小耿      男   <span class="number">25</span>   羽毛球</span><br><span class="line"><span class="number">7</span>   小伟      男   <span class="number">20</span>    跳绳</span><br><span class="line"><span class="number">8</span>   小猪      男   <span class="number">18</span>    台球</span><br></pre></td></tr></table></figure><p>写入<code>Excel</code>的几种情形与方式（覆盖、新增、追加、对齐），具体细节见：<a href="https://blog.csdn.net/m0_46419189/article/details/123111493">参考博客①</a>、<a href="https://blog.csdn.net/HJ_xing/article/details/112390297">参考博客②</a></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">s1 = pd.DataFrame(np.array([[<span class="string">&#x27;s1&#x27;</span>, <span class="string">&#x27;s1&#x27;</span>, <span class="string">&#x27;s1&#x27;</span>, <span class="string">&#x27;s1&#x27;</span>]]), columns=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>])</span><br><span class="line">s2 = pd.DataFrame(np.array([[<span class="string">&#x27;s2&#x27;</span>, <span class="string">&#x27;s2&#x27;</span>, <span class="string">&#x27;s2&#x27;</span>, <span class="string">&#x27;s2&#x27;</span>]]), columns=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># （1）删除文件原有数据,只保留s2一份数据(最后一份)</span></span><br><span class="line"><span class="comment"># s1.to_excel(r&quot;D:\Desktop\test.xlsx&quot;, sheet_name=&quot;111&quot;, index=False)</span></span><br><span class="line"><span class="comment"># s2.to_excel(r&quot;D:\Desktop\test.xlsx&quot;, sheet_name=&quot;222&quot;, index=False)</span></span><br><span class="line"><span class="keyword">with</span> pd.ExcelWriter(<span class="string">r&quot;D:\Desktop\test2.xlsx&quot;</span>) <span class="keyword">as</span> writer:</span><br><span class="line">    <span class="comment"># (2) 删除文件原有数据,同时保留s1和s2两份数据</span></span><br><span class="line">    s1.to_excel(writer, sheet_name=<span class="string">&quot;111&quot;</span>, index=<span class="literal">False</span>)</span><br><span class="line">    s2.to_excel(writer, sheet_name=<span class="string">&quot;222&quot;</span>, index=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><h3 id="👀JSON"><a href="#👀JSON" class="headerlink" title="👀JSON"></a>👀JSON</h3><p>常见的处理<code>JSON</code>文件的第三方库（<strong>速度不同</strong>）包括：<code>json</code>、<code>simplejson</code>、<code>ujson</code>、<code>orjson</code>、<code>simdjson</code>、<code>rapidjson</code>。一般情况下的<code>json</code>文件，存储的是<code>python</code>中的一个<code>dict</code>。这里以<code>map.geojson</code>文件和<strong>CPython</strong> 本身的<code>json</code>模块为例，源文件内容如下。<a href="https://blog.csdn.net/qq_46293423/article/details/105785007">参考博客①</a>、<a href="https://zhuanlan.zhihu.com/p/360368839">参考博客②</a></p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;FeatureCollection&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;features&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Feature&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;geometry&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;coordinates&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">[</span><span class="punctuation">[</span><span class="number">116.3591064789793</span><span class="punctuation">,</span> <span class="number">40.0611769097348</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="punctuation">[</span><span class="number">116.35882714532096</span><span class="punctuation">,</span> <span class="number">40.06035824493355</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="punctuation">[</span><span class="number">116.3588680234169</span><span class="punctuation">,</span> <span class="number">40.06017052423036</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="punctuation">[</span><span class="number">116.3592154872361</span><span class="punctuation">,</span> <span class="number">40.05968557668524</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="punctuation">[</span><span class="number">116.35964470724883</span><span class="punctuation">,</span> <span class="number">40.05949263960517</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="punctuation">[</span><span class="number">116.36125939205749</span><span class="punctuation">,</span> <span class="number">40.05968557668524</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="punctuation">[</span><span class="number">116.36073478982053</span><span class="punctuation">,</span> <span class="number">40.06143241456951</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="punctuation">[</span><span class="number">116.3591064789793</span><span class="punctuation">,</span> <span class="number">40.0611769097348</span><span class="punctuation">]</span><span class="punctuation">]</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Polygon&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Feature&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;geometry&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;coordinates&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="number">116.35838429946176</span><span class="punctuation">,</span> <span class="number">40.0595499993847</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Point&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Feature&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;geometry&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;coordinates&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="number">116.36078873507478</span><span class="punctuation">,</span> <span class="number">40.06152377992771</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Point&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>使用<code>JSON</code>函数需要导入<code>json</code>库：<code>import json</code></p><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td><code>json.loads()</code></td><td>将已编码的<code>JSON</code>字符串解码为<code>Python</code>对象</td></tr><tr><td><code>json.dumps()</code></td><td>将<code>Python</code>对象编码成<code>JSON</code>字符串</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">json.loads(s, *, cls=<span class="literal">None</span>, object_hook=<span class="literal">None</span>, parse_float=<span class="literal">None</span>, parse_int=<span class="literal">None</span>, parse_constant=<span class="literal">None</span>, object_pairs_hook=<span class="literal">None</span>, **kw)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 参数详解</span></span><br><span class="line">（<span class="number">1</span>）s：要解码的JSON字符串。</span><br><span class="line">（<span class="number">2</span>）cls：指定用于解码JSON字符串的自定义类。</span><br><span class="line">（<span class="number">3</span>）object_hook：指定一个回调函数，将解码后的JSON对象转换成其他Python对象。</span><br><span class="line">（<span class="number">4</span>）parse_float：指定一个回调函数，将解码后的JSON浮点数转换成Python浮点数。</span><br><span class="line">（<span class="number">5</span>）parse_int：指定一个回调函数，将解码后的JSON整数转换成Python整数。</span><br><span class="line">（<span class="number">6</span>）parse_constant：指定一个回调函数，用于解析JSON中的常量（例如null，true，false）。</span><br><span class="line">（<span class="number">7</span>）object_pairs_hook：指定一个回调函数，将解码后的JSON对象返回为Python的键值对。</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">json.dumps(obj, *, skipkeys=<span class="literal">False</span>, ensure_ascii=<span class="literal">True</span>, check_circular=<span class="literal">True</span>, allow_nan=<span class="literal">True</span>, cls=<span class="literal">None</span>, indent=<span class="literal">None</span>, separators=<span class="literal">None</span>, default=<span class="literal">None</span>, sort_keys=<span class="literal">False</span>, **kw)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 参数详解</span></span><br><span class="line">（<span class="number">1</span>）obj：转化成json的对象。</span><br><span class="line">（<span class="number">2</span>）skipkeys：是否跳过无法被JSON序列化的key（包括<span class="built_in">str</span>, <span class="built_in">int</span>, <span class="built_in">float</span>, <span class="built_in">bool</span>, <span class="literal">None</span>）。</span><br><span class="line">（<span class="number">3</span>）ensure_ascii：输出保证将所有输入的非ASCII字符转义。</span><br><span class="line">（<span class="number">4</span>）check_circular：是否检查循环引用。</span><br><span class="line">（<span class="number">5</span>）allow_nan：是否允许JSON规范外的<span class="built_in">float</span>数据(nan, inf, -inf)。</span><br><span class="line">（<span class="number">6</span>）indent：是一个正整数, 代表序列化后的缩进。</span><br><span class="line">（<span class="number">7</span>）separators：是一个格式为 (item_separator, key_separator) 的元组, 默认取值为 (<span class="string">&#x27;,&#x27;</span>,<span class="string">&#x27;:&#x27;</span>)。</span><br><span class="line">（<span class="number">8</span>）default：是一个函数, 当某个value无法被序列化时, 对其调用该函数。</span><br><span class="line">（<span class="number">9</span>）sort_keys：是否对数据按照key进行排序。</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 读取json</span></span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">r&quot;D:\Desktop\map.geojson&quot;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    content = f.read()</span><br><span class="line">    a = json.loads(content)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">type</span>(a))</span><br><span class="line">    <span class="built_in">print</span>(a)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">20</span>)</span><br><span class="line">    <span class="built_in">print</span>(a[<span class="string">&quot;features&quot;</span>][<span class="number">2</span>][<span class="string">&quot;geometry&quot;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;dict&#x27;</span>&gt;</span><br><span class="line">&#123;<span class="string">&#x27;type&#x27;</span>: <span class="string">&#x27;FeatureCollection&#x27;</span>, <span class="string">&#x27;features&#x27;</span>: [&#123;<span class="string">&#x27;type&#x27;</span>: <span class="string">&#x27;Feature&#x27;</span>, <span class="string">&#x27;properties&#x27;</span>: &#123;&#125;, <span class="string">&#x27;geometry&#x27;</span>: &#123;<span class="string">&#x27;coordinates&#x27;</span>: [[[<span class="number">116.3591064789793</span>, <span class="number">40.0611769097348</span>], [<span class="number">116.35882714532096</span>, <span class="number">40.06035824493355</span>], [<span class="number">116.3588680234169</span>, <span class="number">40.06017052423036</span>], [<span class="number">116.3592154872361</span>, <span class="number">40.05968557668524</span>], [<span class="number">116.35964470724883</span>, <span class="number">40.05949263960517</span>], [<span class="number">116.36125939205749</span>, <span class="number">40.05968557668524</span>], [<span class="number">116.36073478982053</span>, <span class="number">40.06143241456951</span>], [<span class="number">116.3591064789793</span>, <span class="number">40.0611769097348</span>]]], <span class="string">&#x27;type&#x27;</span>: <span class="string">&#x27;Polygon&#x27;</span>&#125;&#125;, &#123;<span class="string">&#x27;type&#x27;</span>: <span class="string">&#x27;Feature&#x27;</span>, <span class="string">&#x27;properties&#x27;</span>: &#123;&#125;, <span class="string">&#x27;geometry&#x27;</span>: &#123;<span class="string">&#x27;coordinates&#x27;</span>: [<span class="number">116.35838429946176</span>, <span class="number">40.0595499993847</span>], <span class="string">&#x27;type&#x27;</span>: <span class="string">&#x27;Point&#x27;</span>&#125;&#125;, &#123;<span class="string">&#x27;type&#x27;</span>: <span class="string">&#x27;Feature&#x27;</span>, <span class="string">&#x27;properties&#x27;</span>: &#123;&#125;, <span class="string">&#x27;geometry&#x27;</span>: &#123;<span class="string">&#x27;coordinates&#x27;</span>: [<span class="number">116.36078873507478</span>, <span class="number">40.06152377992771</span>], <span class="string">&#x27;type&#x27;</span>: <span class="string">&#x27;Point&#x27;</span>&#125;&#125;]&#125;</span><br><span class="line">********************</span><br><span class="line">&#123;<span class="string">&#x27;coordinates&#x27;</span>: [<span class="number">116.36078873507478</span>, <span class="number">40.06152377992771</span>], <span class="string">&#x27;type&#x27;</span>: <span class="string">&#x27;Point&#x27;</span>&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将字典保存成json</span></span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line">a = &#123;</span><br><span class="line">     <span class="string">&quot;type&quot;</span>: <span class="string">&quot;Feature&quot;</span>,</span><br><span class="line">     <span class="string">&quot;properties&quot;</span>: &#123;&#125;,</span><br><span class="line">     <span class="string">&quot;geometry&quot;</span>: &#123;</span><br><span class="line">         <span class="string">&quot;coordinates&quot;</span>: [<span class="number">116.36078873507478</span>, <span class="number">40.06152377992771</span>],</span><br><span class="line">         <span class="string">&quot;type&quot;</span>: <span class="string">&quot;Point&quot;</span></span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">b_str = json.dumps(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(b_str))</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">r&quot;D:\Desktop\new_json.json&quot;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(b_str)</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">r&quot;D:\Desktop\new_json.json&quot;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    content = f.read()</span><br><span class="line">    a = json.loads(content)</span><br><span class="line">    <span class="built_in">print</span>(a)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;str&#x27;</span>&gt;</span><br><span class="line">&#123;<span class="string">&#x27;type&#x27;</span>: <span class="string">&#x27;Feature&#x27;</span>, <span class="string">&#x27;properties&#x27;</span>: &#123;&#125;, <span class="string">&#x27;geometry&#x27;</span>: &#123;<span class="string">&#x27;coordinates&#x27;</span>: [<span class="number">116.36078873507478</span>, <span class="number">40.06152377992771</span>], <span class="string">&#x27;type&#x27;</span>: <span class="string">&#x27;Point&#x27;</span>&#125;&#125;</span><br></pre></td></tr></table></figure><h3 id="👀XML"><a href="#👀XML" class="headerlink" title="👀XML"></a>👀XML</h3><p>在<code>Python</code>中，有多个库可以用来读取和处理<code>XML</code>文档。以下是其中一些常用的库：</p><ul><li><code>xml.etree.ElementTree（</code>内置库）：这是<code>Python</code>标准库中的一个模块，提供了基本的<code>XML</code>文档解析和操作功能。它具有简单的API和高效的性能，适合处理小型到中型的<code>XML</code>文档。</li><li><code>lxml</code>：<code>lxml</code>是<code>Python</code>中一个功能强大的<code>XML/HTML</code>解析库，基于<code>libxml2</code>和<code>libxslt</code>库。它提供了与<code>ElementTree</code>相似的<code>API</code>，但具有更好的性能和更多的功能。<code>lxml</code>支持<code>XPath</code>、<code>XSLT</code>、<code>XML Schema</code>等高级特性，适用于处理大型和复杂的<code>XML</code>文档。</li><li><code>xmltodict</code>：<code>xmltodict</code>库可以将<code>XML</code>文档解析为<code>Python</code>字典，使<code>XML</code>数据的处理更加简便。它提供了一个简单的<code>API</code>，将<code>XML</code>数据转换为<code>Python</code>数据结构，便于数据的操作和处理。</li><li><code>minidom</code>：<code>xml.dom.minidom</code>是<code>Python</code>标准库中的一个模块，提供了基本的<code>DOM</code>（文档对象模型）接口来解析和操作<code>XML</code>文档。尽管它的<code>API</code>相对较复杂，但它具有更多的功能和灵活性，适用于需要更高级控制的场景。</li></ul><blockquote><p>这些库都有各自的优点和适用场景。在选择库时，可以考虑以下因素：</p><ul><li>对于简单的<code>XML</code>操作和小型文档，内置库<code>xml.etree.ElementTree</code>是一个轻量级且易于使用的选择。</li><li>如果需要更好的性能、更多的功能和高级特性（如<code>XPath</code>、<code>XSLT</code>），可以选择<code>lxml</code>库。</li><li>如果希望将<code>XML</code>数据解析为<code>Python</code>字典以便于处理，可以使用<code>xmltodict</code>库。</li><li>如果对<code>DOM</code>接口熟悉并且需要更多的灵活性和控制能力，可以考虑使用<code>minidom</code>库。</li></ul></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 说明</span></span><br><span class="line"><span class="comment"># 加载和读取xml文件，获取xml文档对象</span></span><br><span class="line"><span class="keyword">from</span> xml.dom <span class="keyword">import</span> minidom  </span><br><span class="line">doc = minidom.parse(xmlfile)</span><br><span class="line"><span class="comment"># 获取xml文档根节点</span></span><br><span class="line">root = doc.documentElement</span><br><span class="line"><span class="comment"># 节点属性</span></span><br><span class="line">root.nodeName<span class="comment"># 每个节点都有它的nodeName，nodeValue，nodeType属性</span></span><br><span class="line">root.nodeValue<span class="comment"># nodeValue是节点的值，只对本节点有效</span></span><br><span class="line">root.nodeType<span class="comment"># 节点类型；</span></span><br><span class="line">root.ELEMENT_NODE</span><br><span class="line"><span class="comment"># 属性值的获取、修改、删除</span></span><br><span class="line">root.getAttribute(attributeName)<span class="comment"># 获取xml节点属性值</span></span><br><span class="line">root.setAttribute(attributeName, value)<span class="comment"># 修改或添加xml节点属性值</span></span><br><span class="line">root.getElementsByTagName(TagName)<span class="comment"># 根据标签获取xml节点对象集合</span></span><br><span class="line">root.removeAttribute(attributeName)<span class="comment"># 删除xml节点属性值</span></span><br><span class="line"><span class="comment"># 子节点的访问</span></span><br><span class="line">root.childNodes  <span class="comment"># 获取子节点列表</span></span><br><span class="line">root.childNodes[index].nodeValue<span class="comment"># 获取xml节点值</span></span><br><span class="line">root.firstChild<span class="comment"># 访问第一个节点（相当于root.childNodes[0]）</span></span><br><span class="line">root.childNodes[<span class="number">0</span>].data<span class="comment"># 获得文本值</span></span><br><span class="line"><span class="comment"># 删除子节点</span></span><br><span class="line">node.removeChild(childnode_in_node)<span class="comment"># 删除node节点下面的子节点childnode_in_node</span></span><br><span class="line"><span class="comment"># 生成节点</span></span><br><span class="line">node.createElement(<span class="string">&#x27;activity&#x27;</span>)<span class="comment"># 生成节点  # 文本节点.createTextNode(&#x27;xxxxx&#x27;)</span></span><br></pre></td></tr></table></figure><h4 id="（1）读取XML"><a href="#（1）读取XML" class="headerlink" title="（1）读取XML"></a><strong>（1）读取XML</strong></h4><p><code>XML</code>示例文件：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;ISO-8859-1&quot;</span>?&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Edited by XMLSpyÂ® --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">breakfast_menu</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">food</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>Belgian Waffles<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">price</span>&gt;</span>$5.95<span class="tag">&lt;/<span class="name">price</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">calories</span>&gt;</span>650<span class="tag">&lt;/<span class="name">calories</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">cropRegion</span> <span class="attr">x</span>=<span class="string">&quot;0&quot;</span> <span class="attr">y</span>=<span class="string">&quot;0&quot;</span> <span class="attr">width</span>=<span class="string">&quot;0000&quot;</span> <span class="attr">height</span>=<span class="string">&quot;1234&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">food</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">food</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>Strawberry Belgian Waffles<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">price</span>&gt;</span>$7.95<span class="tag">&lt;/<span class="name">price</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">calories</span>&gt;</span>900<span class="tag">&lt;/<span class="name">calories</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">cropRegion</span> <span class="attr">x</span>=<span class="string">&quot;1&quot;</span> <span class="attr">y</span>=<span class="string">&quot;1&quot;</span> <span class="attr">width</span>=<span class="string">&quot;1111&quot;</span> <span class="attr">height</span>=<span class="string">&quot;2345&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">food</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">food</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>Berry-Berry Belgian Waffles<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">price</span>&gt;</span>$8.95<span class="tag">&lt;/<span class="name">price</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">calories</span>&gt;</span>900<span class="tag">&lt;/<span class="name">calories</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">cropRegion</span> <span class="attr">x</span>=<span class="string">&quot;2&quot;</span> <span class="attr">y</span>=<span class="string">&quot;2&quot;</span> <span class="attr">width</span>=<span class="string">&quot;2222&quot;</span> <span class="attr">height</span>=<span class="string">&quot;3456&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">food</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">food</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>French Toast<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">price</span>&gt;</span>$4.50<span class="tag">&lt;/<span class="name">price</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">calories</span>&gt;</span>600<span class="tag">&lt;/<span class="name">calories</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">cropRegion</span> <span class="attr">x</span>=<span class="string">&quot;3&quot;</span> <span class="attr">y</span>=<span class="string">&quot;3&quot;</span> <span class="attr">width</span>=<span class="string">&quot;3333&quot;</span> <span class="attr">height</span>=<span class="string">&quot;4567&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">food</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">food</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>Homestyle Breakfast<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">price</span>&gt;</span>$6.95<span class="tag">&lt;/<span class="name">price</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">calories</span>&gt;</span>950<span class="tag">&lt;/<span class="name">calories</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">cropRegion</span> <span class="attr">x</span>=<span class="string">&quot;4&quot;</span> <span class="attr">y</span>=<span class="string">&quot;4&quot;</span> <span class="attr">width</span>=<span class="string">&quot;4444&quot;</span> <span class="attr">height</span>=<span class="string">&quot;5678&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">food</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">breakfast_menu</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>DOM</code>解析<code>XML</code>文件</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> xml.dom <span class="keyword">import</span> minidom</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解析xml文件(句柄或文件路径)</span></span><br><span class="line">doc = minidom.parse(<span class="string">r&quot;D:\Desktop\simple.xml&quot;</span>)</span><br><span class="line"><span class="comment"># doc = minidom.parseString()  # 解析xml字符串</span></span><br><span class="line"><span class="built_in">print</span>(doc)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 获得根节点</span></span><br><span class="line">root_node = doc.documentElement  </span><br><span class="line"><span class="built_in">print</span>(root_node)</span><br><span class="line"><span class="comment"># 节点名称</span></span><br><span class="line"><span class="built_in">print</span>(root_node.nodeName)</span><br><span class="line"><span class="comment"># 节点类型（元素节点，文本节点，属性节点）</span></span><br><span class="line"><span class="built_in">print</span>(root_node.nodeType)</span><br><span class="line"><span class="comment"># 所有子节点，为列表</span></span><br><span class="line"><span class="built_in">print</span>(root_node.childNodes)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 通过节点名称寻找节点，返回列表</span></span><br><span class="line">filename_node = root_node.getElementsByTagName(<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(filename_node)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 子节点为文本节点，文本节点有data属性即为文本值</span></span><br><span class="line">filename = filename_node[<span class="number">1</span>].childNodes[<span class="number">0</span>].data</span><br><span class="line"><span class="built_in">print</span>(filename)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 读取指定属性值,root.setAttribute(attributeName, value)更新修改属性值</span></span><br><span class="line">cropRegion_node = root_node.getElementsByTagName(<span class="string">&#x27;cropRegion&#x27;</span>)</span><br><span class="line">width = cropRegion_node[<span class="number">1</span>].getAttribute(<span class="string">&quot;width&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(width)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">&lt;xml.dom.minidom.Document <span class="built_in">object</span> at <span class="number">0x0000016F45D0EDC0</span>&gt;</span><br><span class="line">********************</span><br><span class="line">&lt;DOM Element: breakfast_menu at <span class="number">0x16f45d011f0</span>&gt;</span><br><span class="line">breakfast_menu</span><br><span class="line"><span class="number">1</span></span><br><span class="line">[&lt;DOM Text node <span class="string">&quot;&#x27;\n\t&#x27;&quot;</span>&gt;, &lt;DOM Element: food at <span class="number">0x16f45d01f70</span>&gt;, &lt;DOM Text node <span class="string">&quot;&#x27;\n\t&#x27;&quot;</span>&gt;, &lt;DOM Element: food at <span class="number">0x16f45d01b80</span>&gt;, &lt;DOM Text node <span class="string">&quot;&#x27;\n\t&#x27;&quot;</span>&gt;, &lt;DOM Element: food at <span class="number">0x16f45ccddc0</span>&gt;, &lt;DOM Text node <span class="string">&quot;&#x27;\n\t&#x27;&quot;</span>&gt;, &lt;DOM Element: food at <span class="number">0x16f458e0dc0</span>&gt;, &lt;DOM Text node <span class="string">&quot;&#x27;\n\t&#x27;&quot;</span>&gt;, &lt;DOM Element: food at <span class="number">0x16f45cf05e0</span>&gt;, &lt;DOM Text node <span class="string">&quot;&#x27;\n&#x27;&quot;</span>&gt;]</span><br><span class="line">********************</span><br><span class="line">[&lt;DOM Element: name at <span class="number">0x16f45d01dc0</span>&gt;, &lt;DOM Element: name at <span class="number">0x16f45d018b0</span>&gt;, &lt;DOM Element: name at <span class="number">0x16f45ccdd30</span>&gt;, &lt;DOM Element: name at <span class="number">0x16f45cf0af0</span>&gt;, &lt;DOM Element: name at <span class="number">0x16f45cf0280</span>&gt;]</span><br><span class="line">********************</span><br><span class="line">Strawberry Belgian Waffles</span><br><span class="line">********************</span><br><span class="line"><span class="number">1111</span></span><br></pre></td></tr></table></figure><h4 id="（2）写入XML"><a href="#（2）写入XML" class="headerlink" title="（2）写入XML"></a><strong>（2）写入XML</strong></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 写入文件</span></span><br><span class="line">DOM树对象.writexml(fh,indent=<span class="string">&#x27;&#x27;</span>,addindent=<span class="string">&#x27;\t&#x27;</span>,newl=<span class="string">&#x27;\n&#x27;</span>,encoding=<span class="string">&#x27;UTF-8&#x27;</span>)</span><br><span class="line"><span class="comment"># writexml()第一个参数是目标文件对象，第二个参数是根节点的缩进格式，第三个参数是其他子节点的缩进格式，第四个参数制定了换行格式，第五个参数制定了xml内容的编码。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># zip()函数用于将可迭代的对象作为参数，将对象中对应的元素打包成一个个元组，然后返回由这些元组组成的列表。如果各个迭代器的元素个数不一致，则返回列表长度与最短的对象相同，利用 * 号操作符，可以将元组解压为列表。</span></span><br><span class="line"><span class="comment"># zip()方法在Python2和Python3中的不同：在Python3.x中为了减少内存，zip()返回的是一个对象。如需展示列表，需手动list()转换。</span></span><br><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">b = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">c = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>]</span><br><span class="line"><span class="comment"># 返回一个对象</span></span><br><span class="line">zipped = <span class="built_in">zip</span>(a,b)</span><br><span class="line"><span class="built_in">print</span>(zipped)</span><br><span class="line"><span class="comment"># list()转换为列表</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(zipped))</span><br><span class="line"><span class="comment"># 元素个数与最短的列表一致</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(<span class="built_in">zip</span>(a,c)))</span><br><span class="line"><span class="comment"># 与zip相反，*zip()函数是zip()函数的逆过程，将zip对象变成原先组合前的数据</span></span><br><span class="line">a1 = <span class="built_in">zip</span>(*<span class="built_in">zip</span>(a,b))</span><br><span class="line"><span class="built_in">print</span>(a1)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(a1))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">&lt;<span class="built_in">zip</span> <span class="built_in">object</span> at <span class="number">0x0000016F45CD6200</span>&gt;</span><br><span class="line">[(<span class="number">1</span>, <span class="number">4</span>), (<span class="number">2</span>, <span class="number">5</span>), (<span class="number">3</span>, <span class="number">6</span>)]</span><br><span class="line">[(<span class="number">1</span>, <span class="number">4</span>), (<span class="number">2</span>, <span class="number">5</span>), (<span class="number">3</span>, <span class="number">6</span>)]</span><br><span class="line">&lt;<span class="built_in">zip</span> <span class="built_in">object</span> at <span class="number">0x0000016F45CD0FC0</span>&gt;</span><br><span class="line">[(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>), (<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)]</span><br></pre></td></tr></table></figure><p><code>DOM</code>写<code>XML</code>文件</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 写入XML文件</span></span><br><span class="line"><span class="keyword">from</span> xml.dom <span class="keyword">import</span> minidom</span><br><span class="line"><span class="comment"># (1)创建DOM树对象</span></span><br><span class="line">dom = minidom.Document()</span><br><span class="line"><span class="comment"># (2)创建根节点，每次都要用DOM对象来创建任何节点</span></span><br><span class="line">root_node = dom.createElement(<span class="string">&quot;people&quot;</span>)</span><br><span class="line"><span class="comment"># (3)用DOM对象添加根节点</span></span><br><span class="line">dom.appendChild(root_node)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用DOM对象创建元素字节点</span></span><br><span class="line">name_node = dom.createElement(<span class="string">&quot;name&quot;</span>)</span><br><span class="line"><span class="comment"># 用父节点对象添加元素子节点</span></span><br><span class="line">root_node.appendChild(name_node)</span><br><span class="line"><span class="comment"># 设置该节点的属性</span></span><br><span class="line">name_node.setAttribute(<span class="string">&quot;sex&quot;</span>,<span class="string">&quot;男&quot;</span>)</span><br><span class="line">name_node.setAttribute(<span class="string">&quot;height&quot;</span>,<span class="string">&quot;180&quot;</span>)</span><br><span class="line"><span class="comment"># 用DOM创建文本节点，把文本节点（文字内容）看成子节点</span></span><br><span class="line">name_text = dom.createTextNode(<span class="string">&quot;小汤&quot;</span>)</span><br><span class="line"><span class="comment"># 用添加了文本的节点对象（看成文本节点的父节点）添加文本节点</span></span><br><span class="line">name_node.appendChild(name_text)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用DOM对象创建元素字节点</span></span><br><span class="line">hobby_node = dom.createElement(<span class="string">&quot;hobby&quot;</span>)</span><br><span class="line"><span class="comment"># 用父节点对象添加元素子节点</span></span><br><span class="line">root_node.appendChild(hobby_node)</span><br><span class="line"><span class="comment"># 用添加了文本的节点对象（看成文本节点的父节点）添加文本节点</span></span><br><span class="line">hobby_node.appendChild(dom.createTextNode(<span class="string">&quot;篮球&quot;</span>))</span><br><span class="line"></span><br><span class="line">score_node = dom.createElement(<span class="string">&quot;score&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> item, value <span class="keyword">in</span> <span class="built_in">zip</span>([<span class="string">&quot;语文&quot;</span>, <span class="string">&quot;数学&quot;</span>, <span class="string">&quot;英语&quot;</span>, <span class="string">&quot;理综&quot;</span>], [<span class="number">150</span>, <span class="number">150</span>, <span class="number">150</span>, <span class="number">300</span>]):</span><br><span class="line">        elem = dom.createElement(item)</span><br><span class="line">        elem.appendChild(dom.createTextNode(<span class="built_in">str</span>(value)))</span><br><span class="line">        score_node.appendChild(elem)</span><br><span class="line">root_node.appendChild(score_node)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">r&quot;D:\Desktop\write.xml&quot;</span>,<span class="string">&#x27;w&#x27;</span>,encoding=<span class="string">&#x27;UTF-8&#x27;</span>) <span class="keyword">as</span> fh:</span><br><span class="line">        <span class="comment"># dom.writexml()第一个参数是目标文件对象，第二个参数是根节点的缩进格式，第三个参数是其他子节点的缩进格式，</span></span><br><span class="line">        <span class="comment"># 第四个参数制定了换行格式，第五个参数制定了xml内容的编码。</span></span><br><span class="line">        dom.writexml(fh, indent=<span class="string">&#x27;&#x27;</span>, addindent=<span class="string">&#x27;\t&#x27;</span>, newl=<span class="string">&#x27;\n&#x27;</span>, encoding=<span class="string">&#x27;UTF-8&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;OK&#x27;</span>)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> err:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;错误：&#123;err&#125;&#x27;</span>.<span class="built_in">format</span>(err=err))</span><br></pre></td></tr></table></figure><p>输出的<code>XML</code>文件内容如下：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">people</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span> <span class="attr">sex</span>=<span class="string">&quot;男&quot;</span> <span class="attr">height</span>=<span class="string">&quot;180&quot;</span>&gt;</span>小汤<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hobby</span>&gt;</span>篮球<span class="tag">&lt;/<span class="name">hobby</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">score</span>&gt;</span></span><br><span class="line">&lt;语文&gt;150&lt;/语文&gt;</span><br><span class="line">&lt;数学&gt;150&lt;/数学&gt;</span><br><span class="line">&lt;英语&gt;150&lt;/英语&gt;</span><br><span class="line">&lt;理综&gt;300&lt;/理综&gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">score</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">people</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="👀TXT"><a href="#👀TXT" class="headerlink" title="👀TXT"></a>👀TXT</h3><h4 id="（1）读取TXT"><a href="#（1）读取TXT" class="headerlink" title="（1）读取TXT"></a><strong>（1）读取TXT</strong></h4><p>源数据<code>data.txt</code>内容如下：</p><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">namegenderagehobby</span><br><span class="line">小红女20跑步</span><br><span class="line">小汤男22篮球</span><br><span class="line">小李男24足球</span><br><span class="line">小ai男21篮球</span><br><span class="line">小张男25篮球</span><br><span class="line">小小男20跳绳</span><br><span class="line">小耿男25羽毛球</span><br></pre></td></tr></table></figure><p>操作<code>txt</code>文件，<code>read()</code>、<code>readline()</code>、<code>readlines()</code>、以及获取某一列内容，代码示例如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># (1)read()一次性读取所有文本</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">r&quot;D:\Desktop\data.txt&quot;</span>, <span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> f:  <span class="comment">#打开文本</span></span><br><span class="line">    data1 = f.read()   <span class="comment">#读取文本</span></span><br><span class="line">    <span class="built_in">print</span>(data1)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># (2)readline()读取第一行的内容</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">r&quot;D:\Desktop\data.txt&quot;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    data2 = f.readline()</span><br><span class="line">    <span class="built_in">print</span>(data2)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># (3)readlines()读取全部内容，以列表的格式返回结果</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">r&quot;D:\Desktop\data.txt&quot;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    data3 = f.readlines()</span><br><span class="line">    <span class="built_in">print</span>(data3)</span><br><span class="line">    <span class="keyword">for</span> ann <span class="keyword">in</span> data3:</span><br><span class="line">        <span class="comment"># 去除文本中的换行符</span></span><br><span class="line">        ann = ann.strip(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(ann)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># (4)读取txt某一列数据，第一种方法</span></span><br><span class="line"><span class="comment"># 要读取第i列数据则可以读取每行的第i个数据再将其拼接起来</span></span><br><span class="line">column_list = []</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">r&quot;D:\Desktop\data.txt&quot;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    data = f.readlines()</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> data:</span><br><span class="line">        <span class="comment"># 去除文本中的换行符</span></span><br><span class="line">        ann = line.strip(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        a = ann.split(<span class="string">&quot;\t&quot;</span>)</span><br><span class="line">        column_list.append(a[<span class="number">3</span>])</span><br><span class="line"><span class="built_in">print</span>(column_list)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># (5)读取txt某一列数据，第二种方法</span></span><br><span class="line">column_list2 = []</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">r&quot;D:\Desktop\data.txt&quot;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="comment"># 以行的形式进行读取文件</span></span><br><span class="line">    line2 = f.readline()</span><br><span class="line">    <span class="keyword">while</span> line2:</span><br><span class="line">        ann2 = line2.strip(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        aa = ann2.split(<span class="string">&quot;\t&quot;</span>)</span><br><span class="line">        column_list2.append(aa[<span class="number">2</span>])</span><br><span class="line">        line2 = f.readline()</span><br><span class="line"><span class="built_in">print</span>(column_list2)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># (6)读取txt某一列数据，第三种方法</span></span><br><span class="line"><span class="keyword">import</span> codecs</span><br><span class="line">column_list3 = []</span><br><span class="line"><span class="keyword">with</span> codecs.<span class="built_in">open</span>(<span class="string">r&quot;D:\Desktop\data.txt&quot;</span>, mode = <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="comment"># 以行的形式进行读取文件</span></span><br><span class="line">    line3 = f.readline()</span><br><span class="line">    <span class="keyword">while</span> line3:</span><br><span class="line">        ann3 = line3.strip(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        aaa = ann3.split(<span class="string">&quot;\t&quot;</span>)</span><br><span class="line">        column_list3.append(aaa[<span class="number">1</span>])</span><br><span class="line">        line3 = f.readline()</span><br><span class="line"><span class="built_in">print</span>(column_list3)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">namegenderagehobby</span><br><span class="line">小红女<span class="number">20</span>跑步</span><br><span class="line">小汤男<span class="number">22</span>篮球</span><br><span class="line">小李男<span class="number">24</span>足球</span><br><span class="line">小ai男<span class="number">21</span>篮球</span><br><span class="line">小张男<span class="number">25</span>篮球</span><br><span class="line">小小男<span class="number">20</span>跳绳</span><br><span class="line">小耿男<span class="number">25</span>羽毛球</span><br><span class="line"></span><br><span class="line">********************</span><br><span class="line">namegenderagehobby</span><br><span class="line"></span><br><span class="line">********************</span><br><span class="line">[<span class="string">&#x27;name\tgender\tage\thobby\n&#x27;</span>, <span class="string">&#x27;小红\t女\t20\t跑步\n&#x27;</span>, <span class="string">&#x27;小汤\t男\t22\t篮球\n&#x27;</span>, <span class="string">&#x27;小李\t男\t24\t足球\n&#x27;</span>, <span class="string">&#x27;小ai\t男\t21\t篮球\n&#x27;</span>, <span class="string">&#x27;小张\t男\t25\t篮球\n&#x27;</span>, <span class="string">&#x27;小小\t男\t20\t跳绳\n&#x27;</span>, <span class="string">&#x27;小耿\t男\t25\t羽毛球\n&#x27;</span>]</span><br><span class="line">namegenderagehobby</span><br><span class="line">小红女<span class="number">20</span>跑步</span><br><span class="line">小汤男<span class="number">22</span>篮球</span><br><span class="line">小李男<span class="number">24</span>足球</span><br><span class="line">小ai男<span class="number">21</span>篮球</span><br><span class="line">小张男<span class="number">25</span>篮球</span><br><span class="line">小小男<span class="number">20</span>跳绳</span><br><span class="line">小耿男<span class="number">25</span>羽毛球</span><br><span class="line">********************</span><br><span class="line">[<span class="string">&#x27;hobby&#x27;</span>, <span class="string">&#x27;跑步&#x27;</span>, <span class="string">&#x27;篮球&#x27;</span>, <span class="string">&#x27;足球&#x27;</span>, <span class="string">&#x27;篮球&#x27;</span>, <span class="string">&#x27;篮球&#x27;</span>, <span class="string">&#x27;跳绳&#x27;</span>, <span class="string">&#x27;羽毛球&#x27;</span>]</span><br><span class="line">********************</span><br><span class="line">[<span class="string">&#x27;age&#x27;</span>, <span class="string">&#x27;20&#x27;</span>, <span class="string">&#x27;22&#x27;</span>, <span class="string">&#x27;24&#x27;</span>, <span class="string">&#x27;21&#x27;</span>, <span class="string">&#x27;25&#x27;</span>, <span class="string">&#x27;20&#x27;</span>, <span class="string">&#x27;25&#x27;</span>]</span><br><span class="line">********************</span><br><span class="line">[<span class="string">&#x27;gender&#x27;</span>, <span class="string">&#x27;女&#x27;</span>, <span class="string">&#x27;男&#x27;</span>, <span class="string">&#x27;男&#x27;</span>, <span class="string">&#x27;男&#x27;</span>, <span class="string">&#x27;男&#x27;</span>, <span class="string">&#x27;男&#x27;</span>, <span class="string">&#x27;男&#x27;</span>]</span><br></pre></td></tr></table></figure><h4 id="（2）写入TXT"><a href="#（2）写入TXT" class="headerlink" title="（2）写入TXT"></a><strong>（2）写入TXT</strong></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 写入txt</span></span><br><span class="line">hobby =[<span class="string">&quot;hobby&quot;</span>, <span class="string">&quot;跑步&quot;</span>, <span class="string">&quot;篮球&quot;</span>, <span class="string">&quot;足球&quot;</span>, <span class="string">&quot;篮球&quot;</span>, <span class="string">&quot;篮球&quot;</span>, <span class="string">&quot;跳绳&quot;</span>, <span class="string">&quot;羽毛球&quot;</span>]</span><br><span class="line">name = [<span class="string">&quot;name&quot;</span>, <span class="string">&quot;小红&quot;</span>, <span class="string">&quot;小汤&quot;</span>, <span class="string">&quot;小李&quot;</span>, <span class="string">&quot;小ai&quot;</span>, <span class="string">&quot;小张&quot;</span>, <span class="string">&quot;小小&quot;</span>, <span class="string">&quot;小耿&quot;</span>]</span><br><span class="line">age = [<span class="string">&quot;age&quot;</span>, <span class="string">&quot;20&quot;</span>, <span class="string">&quot;22&quot;</span>, <span class="string">&quot;24&quot;</span>, <span class="string">&quot;21&quot;</span>, <span class="string">&quot;25&quot;</span>, <span class="string">&quot;30&quot;</span>, <span class="string">&quot;25&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">r&quot;D:\Desktop\writeTXT.txt&quot;</span>,<span class="string">&quot;a&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    length = <span class="built_in">len</span>(age)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length):</span><br><span class="line">        line = [hobby[i], name[i], age[i]]</span><br><span class="line">        lines = <span class="string">&quot;\t&quot;</span>.join(line)</span><br><span class="line">        <span class="comment"># lines = hobby[i] + &quot;\t&quot; + name[i] + &quot;\t&quot; + age[i]</span></span><br><span class="line">        <span class="built_in">print</span>(lines)</span><br><span class="line">        f.write(lines + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">column_list = []</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">r&quot;D:\Desktop\writeTXT.txt&quot;</span>,<span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    data = f.readlines()</span><br><span class="line">    <span class="comment"># print(data)</span></span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> data:</span><br><span class="line">        <span class="comment"># 去除文本中的换行符</span></span><br><span class="line">        ann = line.strip(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        a = ann.split(<span class="string">&quot;\t&quot;</span>)</span><br><span class="line">        column_list.append(a[<span class="number">2</span>])</span><br><span class="line"><span class="built_in">print</span>(column_list)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">hobbynameage</span><br><span class="line">跑步小红<span class="number">20</span></span><br><span class="line">篮球小汤<span class="number">22</span></span><br><span class="line">足球小李<span class="number">24</span></span><br><span class="line">篮球小ai<span class="number">21</span></span><br><span class="line">篮球小张<span class="number">25</span></span><br><span class="line">跳绳小小<span class="number">30</span></span><br><span class="line">羽毛球小耿<span class="number">25</span></span><br><span class="line">[<span class="string">&#x27;age&#x27;</span>, <span class="string">&#x27;20&#x27;</span>, <span class="string">&#x27;22&#x27;</span>, <span class="string">&#x27;24&#x27;</span>, <span class="string">&#x27;21&#x27;</span>, <span class="string">&#x27;25&#x27;</span>, <span class="string">&#x27;30&#x27;</span>, <span class="string">&#x27;25&#x27;</span>]</span><br></pre></td></tr></table></figure><h2 id="⛄Matlab之读写文件"><a href="#⛄Matlab之读写文件" class="headerlink" title="⛄Matlab之读写文件"></a>⛄Matlab之读写文件</h2><blockquote><p><strong>使用过程中注意<code>MATLAB</code>版本差异问题。</strong></p><p><code>MATLAB</code>每一条语句后加分号与否的区别：</p><ul><li><p>代码后加分号，运行结果不会显示在命令窗口；</p></li><li><p>代码后不加分号，当点击回车时，运行结果会立即在命令窗口（<code>window command</code>）显示。</p></li></ul></blockquote><h3 id="👀CSV-1"><a href="#👀CSV-1" class="headerlink" title="👀CSV"></a>👀CSV</h3><h4 id="（1）csvread-不推荐"><a href="#（1）csvread-不推荐" class="headerlink" title="（1）csvread()(不推荐)"></a><strong>（1）<code>csvread()</code>(不推荐)</strong></h4><p><code>CSV</code>文件源数据：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">name,gender,age,语文,数学,英语</span><br><span class="line">小红,女,20,130,140,135</span><br><span class="line">小汤,男,22,131,141,136</span><br><span class="line">小李,男,24,132,142,137</span><br><span class="line">小ai,男,21,133,143,138</span><br><span class="line">小张,男,25,134,144,139</span><br><span class="line">小小,男,20,135,145,140</span><br><span class="line">小耿,男,25,136,146,141</span><br></pre></td></tr></table></figure><p>利用<code>csvread</code>读取<code>CSV</code>文件</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% 读取逗号分隔值格式的文件名，结果直接返回给result，CSV文件只能包含数值。</span></span><br><span class="line">result = csvread(<span class="string">&quot;filename&quot;</span>)</span><br><span class="line"><span class="comment">% 从CSV文件中读取数据（从R行和C列开始）</span></span><br><span class="line">result = csvread(<span class="string">&quot;filename&quot;</span>, R, C)</span><br><span class="line"><span class="comment">% 只读取由range=[R1 C1 R2 C2]指定的范围，其中(R1，C1)是要读取数据的左上角，(R2，C2)是右下角。也可以使用电子表格表示法指定RNG，如range=&quot;A1..B7&quot;，而非[0 0 6 1]。</span></span><br><span class="line">result = csvread(<span class="string">&quot;filename&quot;</span>,R1,C1,[R1 C1 R2 C2])</span><br></pre></td></tr></table></figure><p><code>MATLAB</code>代码：<code>CTRL+R</code>（注释）、<code>CTRL+T</code>（取消注释）</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clc</span><br><span class="line">clear all</span><br><span class="line">result1 = csvread(<span class="string">&#x27;D:\Desktop\data1.csv&#x27;</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">result2 = csvread(<span class="string">&#x27;D:\Desktop\data1.csv&#x27;</span>, <span class="number">1</span>, <span class="number">2</span>, [<span class="number">1</span> <span class="number">2</span> <span class="number">6</span> <span class="number">4</span>])</span><br><span class="line">result3 = csvread(<span class="string">&#x27;D:\Desktop\data1.csv&#x27;</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="string">&quot;C2..F8&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">% 命令行窗口输出</span></span><br><span class="line">result1 =</span><br><span class="line">    <span class="number">20</span>   <span class="number">130</span>   <span class="number">140</span>   <span class="number">135</span></span><br><span class="line">    <span class="number">22</span>   <span class="number">131</span>   <span class="number">141</span>   <span class="number">136</span></span><br><span class="line">    <span class="number">24</span>   <span class="number">132</span>   <span class="number">142</span>   <span class="number">137</span></span><br><span class="line">    <span class="number">21</span>   <span class="number">133</span>   <span class="number">143</span>   <span class="number">138</span></span><br><span class="line">    <span class="number">25</span>   <span class="number">134</span>   <span class="number">144</span>   <span class="number">139</span></span><br><span class="line">    <span class="number">20</span>   <span class="number">135</span>   <span class="number">145</span>   <span class="number">140</span></span><br><span class="line">    <span class="number">25</span>   <span class="number">136</span>   <span class="number">146</span>   <span class="number">141</span></span><br><span class="line">result2 =</span><br><span class="line">    <span class="number">20</span>   <span class="number">130</span>   <span class="number">140</span></span><br><span class="line">    <span class="number">22</span>   <span class="number">131</span>   <span class="number">141</span></span><br><span class="line">    <span class="number">24</span>   <span class="number">132</span>   <span class="number">142</span></span><br><span class="line">    <span class="number">21</span>   <span class="number">133</span>   <span class="number">143</span></span><br><span class="line">    <span class="number">25</span>   <span class="number">134</span>   <span class="number">144</span></span><br><span class="line">    <span class="number">20</span>   <span class="number">135</span>   <span class="number">145</span></span><br><span class="line">result3 =</span><br><span class="line">    <span class="number">20</span>   <span class="number">130</span>   <span class="number">140</span>   <span class="number">135</span></span><br><span class="line">    <span class="number">22</span>   <span class="number">131</span>   <span class="number">141</span>   <span class="number">136</span></span><br><span class="line">    <span class="number">24</span>   <span class="number">132</span>   <span class="number">142</span>   <span class="number">137</span></span><br><span class="line">    <span class="number">21</span>   <span class="number">133</span>   <span class="number">143</span>   <span class="number">138</span></span><br><span class="line">    <span class="number">25</span>   <span class="number">134</span>   <span class="number">144</span>   <span class="number">139</span></span><br><span class="line">    <span class="number">20</span>   <span class="number">135</span>   <span class="number">145</span>   <span class="number">140</span></span><br><span class="line">    <span class="number">25</span>   <span class="number">136</span>   <span class="number">146</span>   <span class="number">141</span></span><br></pre></td></tr></table></figure><blockquote><p><code>MATLAB</code>帮助中心已经不推荐使用 <code>csvread</code>，请改用 <code>readmatrix</code>。</p></blockquote><h4 id="（2）readmatrix"><a href="#（2）readmatrix" class="headerlink" title="（2）readmatrix()"></a><strong>（2）<code>readmatrix()</code></strong></h4><blockquote><p><strong>参数详解见<code>MATLAB</code>帮助中心。</strong></p><ul><li>从文本文件中读取矩阵</li><li>从电子表格文件中读取矩阵</li><li>使用导入选项从指定的工作表和范围中读取矩阵</li><li>从指定的工作表和范围中读取矩阵</li></ul></blockquote><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% （1）通过从文件中读取列向数据来创建数组，readmatrix函数可自动检测文件的导入参数。</span></span><br><span class="line"><span class="comment">% readmatrix基于文件的扩展名确定文件格式：</span></span><br><span class="line"><span class="comment">% .txt、.dat或.csv（带分隔符的文本文件）</span></span><br><span class="line"><span class="comment">% .xls、.xlsb、.xlsm、.xlsx、.xltm、.xltx或.ods（电子表格文件）</span></span><br><span class="line"><span class="comment">% 对于包含数值和文本混合数据的文件，默认情况下，readmatrix将数据作为数值数组导入。</span></span><br><span class="line">result = readmatrix(filename)</span><br><span class="line"><span class="comment">% （2）还使用导入选项opts</span></span><br><span class="line">result = readmatrix(filename,opts)</span><br><span class="line"><span class="comment">% （3）基于文件创建一个数组，并通过一个或多个名称-值对组参数指定其他选项。需要在输入参数之后指定名称-值对组。</span></span><br><span class="line"><span class="comment">% 要为数据设置特定的导入选项，您可以使用opts对象，也可以指定名称-值对组。当您指定除opts之外的名称-值对组时，readmatrix仅支持下列名称-值对组：</span></span><br><span class="line"><span class="comment">% 文本文件：DateLocale、Encoding</span></span><br><span class="line"><span class="comment">% 电子表格文件：Sheet、UseExcel</span></span><br><span class="line">A = readmatrix(___,Name,Value)</span><br></pre></td></tr></table></figure><p>利用<code>readmatrix()</code>读取<code>CSV</code>文件：</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clc</span><br><span class="line">clear all</span><br><span class="line"><span class="comment">% readmatrix第一个参数是文件名。第二个参数指输出类型。如果不带这个参数，那字符串那一列的输出结果是Nan值</span></span><br><span class="line"><span class="comment">% 加上之后，则全部输出文本类型，后面再把要作为数值型的内容转换数据类型。</span></span><br><span class="line">result4 = readmatrix(<span class="string">&#x27;D:\Desktop\data1.csv&#x27;</span>)</span><br><span class="line">result5 = readmatrix(<span class="string">&#x27;D:\Desktop\data1.csv&#x27;</span>, <span class="string">&#x27;OutputType&#x27;</span>, <span class="string">&#x27;string&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">% 命令行窗口输出</span></span><br><span class="line">result4 =</span><br><span class="line">   NaN   NaN    <span class="number">20</span>   <span class="number">130</span>   <span class="number">140</span>   <span class="number">135</span></span><br><span class="line">   NaN     <span class="number">7</span>    <span class="number">22</span>   <span class="number">131</span>   <span class="number">141</span>   <span class="number">136</span></span><br><span class="line">   NaN     <span class="number">7</span>    <span class="number">24</span>   <span class="number">132</span>   <span class="number">142</span>   <span class="number">137</span></span><br><span class="line">   NaN     <span class="number">7</span>    <span class="number">21</span>   <span class="number">133</span>   <span class="number">143</span>   <span class="number">138</span></span><br><span class="line">   NaN     <span class="number">7</span>    <span class="number">25</span>   <span class="number">134</span>   <span class="number">144</span>   <span class="number">139</span></span><br><span class="line">   NaN     <span class="number">7</span>    <span class="number">20</span>   <span class="number">135</span>   <span class="number">145</span>   <span class="number">140</span></span><br><span class="line">   NaN     <span class="number">7</span>    <span class="number">25</span>   <span class="number">136</span>   <span class="number">146</span>   <span class="number">141</span></span><br><span class="line">result5 = </span><br><span class="line">  <span class="number">7</span>×<span class="number">6</span> string 数组</span><br><span class="line">    <span class="string">&quot;小红&quot;</span>    <span class="string">&quot;女&quot;</span>    <span class="string">&quot;20&quot;</span>    <span class="string">&quot;130&quot;</span>    <span class="string">&quot;140&quot;</span>    <span class="string">&quot;135&quot;</span></span><br><span class="line">    <span class="string">&quot;小汤&quot;</span>    <span class="string">&quot;男&quot;</span>    <span class="string">&quot;22&quot;</span>    <span class="string">&quot;131&quot;</span>    <span class="string">&quot;141&quot;</span>    <span class="string">&quot;136&quot;</span></span><br><span class="line">    <span class="string">&quot;小李&quot;</span>    <span class="string">&quot;男&quot;</span>    <span class="string">&quot;24&quot;</span>    <span class="string">&quot;132&quot;</span>    <span class="string">&quot;142&quot;</span>    <span class="string">&quot;137&quot;</span></span><br><span class="line">    <span class="string">&quot;小ai&quot;</span>    <span class="string">&quot;男&quot;</span>    <span class="string">&quot;21&quot;</span>    <span class="string">&quot;133&quot;</span>    <span class="string">&quot;143&quot;</span>    <span class="string">&quot;138&quot;</span></span><br><span class="line">    <span class="string">&quot;小张&quot;</span>    <span class="string">&quot;男&quot;</span>    <span class="string">&quot;25&quot;</span>    <span class="string">&quot;134&quot;</span>    <span class="string">&quot;144&quot;</span>    <span class="string">&quot;139&quot;</span></span><br><span class="line">    <span class="string">&quot;小小&quot;</span>    <span class="string">&quot;男&quot;</span>    <span class="string">&quot;20&quot;</span>    <span class="string">&quot;135&quot;</span>    <span class="string">&quot;145&quot;</span>    <span class="string">&quot;140&quot;</span></span><br><span class="line">    <span class="string">&quot;小耿&quot;</span>    <span class="string">&quot;男&quot;</span>    <span class="string">&quot;25&quot;</span>    <span class="string">&quot;136&quot;</span>    <span class="string">&quot;146&quot;</span>    <span class="string">&quot;141&quot;</span></span><br></pre></td></tr></table></figure><h4 id="（3）importdata"><a href="#（3）importdata" class="headerlink" title="（3）importdata()"></a><strong>（3）<code>importdata()</code></strong></h4><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% （1）将数据加载到数组A中</span></span><br><span class="line">A = importdata(filename)</span><br><span class="line"><span class="comment">% （2）从系统剪贴板而不是文件加载数据。</span></span><br><span class="line">A = importdata(<span class="string">&#x27;-pastespecial&#x27;</span>)</span><br><span class="line"><span class="comment">% （3）将delimiterIn解释为ASCII文件filename或剪贴板数据中的列分隔符。您可以将delimiterIn与以上语法中的任何输入参数结合使用。</span></span><br><span class="line">A = importdata(___,delimiterIn)</span><br><span class="line"><span class="comment">% （4）从ASCII文件filename或剪贴板加载数据，并读取从第headerlinesIn+1 开始的数值数据。</span></span><br><span class="line">A = importdata(___,delimiterIn,headerlinesIn)</span><br><span class="line"><span class="comment">% （5）支持上述语法中的任何输入参数，并在delimiterOut中额外返回检测到的输入ASCII文件中的分隔符，以及在headerlinesOut中返回检测到的标题行数。</span></span><br><span class="line">[A,delimiterOut,headerlinesOut] = importdata(___)</span><br></pre></td></tr></table></figure><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clc</span><br><span class="line">clear all</span><br><span class="line"><span class="comment">% 返回一个struct类型，默认将文本与数值分开</span></span><br><span class="line"><span class="comment">% 此方法虽然简便，但是貌似对数据量过大的数据不太友好</span></span><br><span class="line"><span class="comment">% matlab实现输出的几种方式（disp函数、fprintf函数、print函数）</span></span><br><span class="line">result6 = importdata(<span class="string">&#x27;D:\Desktop\data1.csv&#x27;</span>)</span><br><span class="line"><span class="built_in">disp</span>(result6)</span><br><span class="line">data = result6.data</span><br><span class="line">textdata = result6.textdata</span><br><span class="line"></span><br><span class="line"><span class="comment">% 命令行窗口输出</span></span><br><span class="line">        data: [<span class="number">7</span>×<span class="number">4</span> double]</span><br><span class="line">    textdata: &#123;<span class="number">8</span>×<span class="number">6</span> cell&#125;</span><br><span class="line">data =</span><br><span class="line">    <span class="number">20</span>   <span class="number">130</span>   <span class="number">140</span>   <span class="number">135</span></span><br><span class="line">    <span class="number">22</span>   <span class="number">131</span>   <span class="number">141</span>   <span class="number">136</span></span><br><span class="line">    <span class="number">24</span>   <span class="number">132</span>   <span class="number">142</span>   <span class="number">137</span></span><br><span class="line">    <span class="number">21</span>   <span class="number">133</span>   <span class="number">143</span>   <span class="number">138</span></span><br><span class="line">    <span class="number">25</span>   <span class="number">134</span>   <span class="number">144</span>   <span class="number">139</span></span><br><span class="line">    <span class="number">20</span>   <span class="number">135</span>   <span class="number">145</span>   <span class="number">140</span></span><br><span class="line">    <span class="number">25</span>   <span class="number">136</span>   <span class="number">146</span>   <span class="number">141</span></span><br><span class="line">textdata =</span><br><span class="line">  <span class="number">8</span>×<span class="number">6</span> cell 数组</span><br><span class="line">    &#123;<span class="string">&#x27;name&#x27;</span>&#125;    &#123;<span class="string">&#x27;gender&#x27;</span>&#125;    &#123;<span class="string">&#x27;age&#x27;</span>   &#125;    &#123;<span class="string">&#x27;语文&#x27;</span>  &#125;    &#123;<span class="string">&#x27;数学&#x27;</span>  &#125;    &#123;<span class="string">&#x27;英语&#x27;</span>  &#125;</span><br><span class="line">    &#123;<span class="string">&#x27;小红&#x27;</span>&#125;    &#123;<span class="string">&#x27;女&#x27;</span>    &#125;    &#123;<span class="number">0</span>×<span class="number">0</span> char&#125;    &#123;<span class="number">0</span>×<span class="number">0</span> char&#125;    &#123;<span class="number">0</span>×<span class="number">0</span> char&#125;    &#123;<span class="number">0</span>×<span class="number">0</span> char&#125;</span><br><span class="line">    &#123;<span class="string">&#x27;小汤&#x27;</span>&#125;    &#123;<span class="string">&#x27;男&#x27;</span>    &#125;    &#123;<span class="number">0</span>×<span class="number">0</span> char&#125;    &#123;<span class="number">0</span>×<span class="number">0</span> char&#125;    &#123;<span class="number">0</span>×<span class="number">0</span> char&#125;    &#123;<span class="number">0</span>×<span class="number">0</span> char&#125;</span><br><span class="line">    &#123;<span class="string">&#x27;小李&#x27;</span>&#125;    &#123;<span class="string">&#x27;男&#x27;</span>    &#125;    &#123;<span class="number">0</span>×<span class="number">0</span> char&#125;    &#123;<span class="number">0</span>×<span class="number">0</span> char&#125;    &#123;<span class="number">0</span>×<span class="number">0</span> char&#125;    &#123;<span class="number">0</span>×<span class="number">0</span> char&#125;</span><br><span class="line">    &#123;<span class="string">&#x27;小ai&#x27;</span>&#125;    &#123;<span class="string">&#x27;男&#x27;</span>    &#125;    &#123;<span class="number">0</span>×<span class="number">0</span> char&#125;    &#123;<span class="number">0</span>×<span class="number">0</span> char&#125;    &#123;<span class="number">0</span>×<span class="number">0</span> char&#125;    &#123;<span class="number">0</span>×<span class="number">0</span> char&#125;</span><br><span class="line">    &#123;<span class="string">&#x27;小张&#x27;</span>&#125;    &#123;<span class="string">&#x27;男&#x27;</span>    &#125;    &#123;<span class="number">0</span>×<span class="number">0</span> char&#125;    &#123;<span class="number">0</span>×<span class="number">0</span> char&#125;    &#123;<span class="number">0</span>×<span class="number">0</span> char&#125;    &#123;<span class="number">0</span>×<span class="number">0</span> char&#125;</span><br><span class="line">    &#123;<span class="string">&#x27;小小&#x27;</span>&#125;    &#123;<span class="string">&#x27;男&#x27;</span>    &#125;    &#123;<span class="number">0</span>×<span class="number">0</span> char&#125;    &#123;<span class="number">0</span>×<span class="number">0</span> char&#125;    &#123;<span class="number">0</span>×<span class="number">0</span> char&#125;    &#123;<span class="number">0</span>×<span class="number">0</span> char&#125;</span><br><span class="line">    &#123;<span class="string">&#x27;小耿&#x27;</span>&#125;    &#123;<span class="string">&#x27;男&#x27;</span>    &#125;    &#123;<span class="number">0</span>×<span class="number">0</span> char&#125;    &#123;<span class="number">0</span>×<span class="number">0</span> char&#125;    &#123;<span class="number">0</span>×<span class="number">0</span> char&#125;    &#123;<span class="number">0</span>×<span class="number">0</span> char&#125;</span><br></pre></td></tr></table></figure><h4 id="（4）readtable"><a href="#（4）readtable" class="headerlink" title="（4）readtable()"></a><strong>（4）<code>readtable()</code></strong></h4><blockquote><p><strong>参数详解见<code>MATLAB</code>帮助中心。</strong></p><ul><li>基于文本文件创建表</li><li>忽略标题并填充缺失值</li><li>基于文本文件创建表，无列标题</li><li>基于文本文件创建格式表</li><li>从文本文件读取外语日期</li><li>基于包含行名称的电子表格创建表</li><li>从电子表格中读取特定范围的数据</li><li>检测并使用针对文本文件的导入选项</li><li>检测并使用针对电子表格文件的导入选项</li><li>读取包含任意变量名称的表格数据</li><li>从文件中读取十六进制和二进制数字</li><li>为<code>XML</code>文件创建<code>XML</code>导入选项</li><li>注册自定义<code>XML</code>命名空间前缀</li><li>从<code>Microsoft Word</code>文档中读取特定表</li><li>从<code>HTML</code>网页读取表</li></ul></blockquote><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% (1)通过从文件中读取列向数据来创建表。</span></span><br><span class="line"><span class="comment">% readtable基于文件的扩展名确定文件格式：</span></span><br><span class="line"><span class="comment">% .txt、.dat或.csv（带分隔符的文本文件）</span></span><br><span class="line"><span class="comment">% .xls、.xlsb、.xlsm、.xlsx、.xltm、.xltx或.ods（电子表格文件）</span></span><br><span class="line"><span class="comment">% .xml（可扩展标记语言(XML)文件）</span></span><br><span class="line"><span class="comment">% .docx（Microsoft® Word文档文件）</span></span><br><span class="line"><span class="comment">% .html、.xhtml或.htm（超文本标记语言(HTML)文件）</span></span><br><span class="line"><span class="comment">% 对于文本和电子表格文件，readtable为该文件中的每列在T中创建一个变量并从文件的第一行中读取变量名称。对于XML文件，readtable在T中为检测为表变量的每个元素或属性节点创建一个变量。变量名称对应于元素和属性名称。对于 Microsoft Word文档文件，默认情况下readtable从文档中的第一个表导入数据，为该文件中的每列在T中创建一个变量并从该表的第一行中读取变量名称。对于HTML文件，默认情况下readtable从第一个&lt;TABLE&gt;元素导入数据，为该文件中的每列在T中创建一个变量并从该表的第一行中读取变量名称。</span></span><br><span class="line"><span class="comment">% 默认情况下，readtable会根据在输入文件的每列中检测到的数据值来创建具有适当数据类型的变量。</span></span><br><span class="line">T = <span class="built_in">readtable</span>(filename)</span><br><span class="line"><span class="comment">% （2）使用导入选项opts创建表。</span></span><br><span class="line">T = <span class="built_in">readtable</span>(filename,opts)</span><br><span class="line"><span class="comment">% （3）基于文件创建一个表，并通过一个或多个名称-值对组参数指定其他选项。例如，您可以指定readtable是将文件的第一行读取为变量名称还是数据。</span></span><br><span class="line"><span class="comment">% 要为数据设置特定的导入选项，您可以使用opts对象，也可以指定名称-值对组。当您指定除opts之外的名称-值对组时，readtable仅支持下列名称-值对组：</span></span><br><span class="line"><span class="comment">% 文本和电子表格参数 -ReadVariableNames、ReadRowNames</span></span><br><span class="line"><span class="comment">% 仅文本参数 -DateLocale、Encoding</span></span><br><span class="line"><span class="comment">% 仅电子表格参数 -Sheet、UseExcel</span></span><br><span class="line">T = <span class="built_in">readtable</span>(___,Name,Value)</span><br></pre></td></tr></table></figure><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clc</span><br><span class="line">clear all</span><br><span class="line">result7 = <span class="built_in">readtable</span>(<span class="string">&#x27;D:\Desktop\data1.csv&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">% 命令行窗口输出</span></span><br><span class="line">result7 =</span><br><span class="line">  <span class="number">7</span>×<span class="number">6</span> <span class="built_in">table</span></span><br><span class="line">     name     gender    age    x__    x___1    x___2</span><br><span class="line">    ______    ______    ___    ___    _____    _____</span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;小红&#x27;</span>     <span class="string">&#x27;女&#x27;</span>      <span class="number">20</span>     <span class="number">130</span>     <span class="number">140</span>      <span class="number">135</span> </span><br><span class="line">    <span class="string">&#x27;小汤&#x27;</span>     <span class="string">&#x27;男&#x27;</span>      <span class="number">22</span>     <span class="number">131</span>     <span class="number">141</span>      <span class="number">136</span> </span><br><span class="line">    <span class="string">&#x27;小李&#x27;</span>     <span class="string">&#x27;男&#x27;</span>      <span class="number">24</span>     <span class="number">132</span>     <span class="number">142</span>      <span class="number">137</span> </span><br><span class="line">    <span class="string">&#x27;小ai&#x27;</span>     <span class="string">&#x27;男&#x27;</span>     <span class="number">21</span>     <span class="number">133</span>     <span class="number">143</span>      <span class="number">138</span> </span><br><span class="line">    <span class="string">&#x27;小张&#x27;</span>     <span class="string">&#x27;男&#x27;</span>      <span class="number">25</span>     <span class="number">134</span>     <span class="number">144</span>      <span class="number">139</span> </span><br><span class="line">    <span class="string">&#x27;小小&#x27;</span>     <span class="string">&#x27;男&#x27;</span>      <span class="number">20</span>     <span class="number">135</span>     <span class="number">145</span>      <span class="number">140</span> </span><br><span class="line">    <span class="string">&#x27;小耿&#x27;</span>     <span class="string">&#x27;男&#x27;</span>      <span class="number">25</span>     <span class="number">136</span>     <span class="number">146</span>      <span class="number">141</span> </span><br></pre></td></tr></table></figure><h4 id="（5）csvwrite-不推荐"><a href="#（5）csvwrite-不推荐" class="headerlink" title="（5）csvwrite()(不推荐)"></a><strong>（5）<code>csvwrite()</code>(不推荐)</strong></h4><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% 可查看帮助中心函数说明</span></span><br><span class="line"><span class="comment">% 将矩阵M以逗号分隔值形式写入文件filename。</span></span><br><span class="line">csvwrite(filename,M)</span><br><span class="line"><span class="comment">% 从指定的行和列偏移量开始将矩阵M写入文件filename。行和列参数从0开始，因此row=0和col=0指定文件中的第一个值。</span></span><br><span class="line">csvwrite(filename,M,row,col)</span><br></pre></td></tr></table></figure><blockquote><ul><li>对于字符串类型<code>csvwrite</code>可能不支持；</li><li><strong>帮助中心</strong>：不推荐使用<code>csvwrite</code>，请改用<code>writematrix</code>。</li></ul></blockquote><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clc</span><br><span class="line">clear all</span><br><span class="line"></span><br><span class="line">csv_data = importdata(<span class="string">&#x27;D:\Desktop\data1.csv&#x27;</span>)</span><br><span class="line">data = csv_data.data;</span><br><span class="line">textdata = csv_data.textdata;</span><br><span class="line">csvwrite(<span class="string">&#x27;D:\Desktop\output.csv&#x27;</span>,data, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"><span class="comment">% 输出结果为double</span></span><br><span class="line">res1 = readmatrix(<span class="string">&#x27;D:\Desktop\output.csv&#x27;</span>)</span><br><span class="line"><span class="comment">% 输出结果为string</span></span><br><span class="line">res2 = readmatrix(<span class="string">&#x27;D:\Desktop\output.csv&#x27;</span>, <span class="string">&#x27;OutputType&#x27;</span>, <span class="string">&#x27;string&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">% 命令行窗口输出结果</span></span><br><span class="line">csv_data = </span><br><span class="line">  包含以下字段的 struct:</span><br><span class="line">        data: [<span class="number">7</span>×<span class="number">4</span> double]</span><br><span class="line">    textdata: &#123;<span class="number">8</span>×<span class="number">6</span> cell&#125;</span><br><span class="line">res1 =</span><br><span class="line">    <span class="number">20</span>   <span class="number">130</span>   <span class="number">140</span>   <span class="number">135</span></span><br><span class="line">    <span class="number">22</span>   <span class="number">131</span>   <span class="number">141</span>   <span class="number">136</span></span><br><span class="line">    <span class="number">24</span>   <span class="number">132</span>   <span class="number">142</span>   <span class="number">137</span></span><br><span class="line">    <span class="number">21</span>   <span class="number">133</span>   <span class="number">143</span>   <span class="number">138</span></span><br><span class="line">    <span class="number">25</span>   <span class="number">134</span>   <span class="number">144</span>   <span class="number">139</span></span><br><span class="line">    <span class="number">20</span>   <span class="number">135</span>   <span class="number">145</span>   <span class="number">140</span></span><br><span class="line">    <span class="number">25</span>   <span class="number">136</span>   <span class="number">146</span>   <span class="number">141</span></span><br><span class="line">res2 = </span><br><span class="line">  <span class="number">7</span>×<span class="number">4</span> string 数组</span><br><span class="line">    <span class="string">&quot;20&quot;</span>    <span class="string">&quot;130&quot;</span>    <span class="string">&quot;140&quot;</span>    <span class="string">&quot;135&quot;</span></span><br><span class="line">    <span class="string">&quot;22&quot;</span>    <span class="string">&quot;131&quot;</span>    <span class="string">&quot;141&quot;</span>    <span class="string">&quot;136&quot;</span></span><br><span class="line">    <span class="string">&quot;24&quot;</span>    <span class="string">&quot;132&quot;</span>    <span class="string">&quot;142&quot;</span>    <span class="string">&quot;137&quot;</span></span><br><span class="line">    <span class="string">&quot;21&quot;</span>    <span class="string">&quot;133&quot;</span>    <span class="string">&quot;143&quot;</span>    <span class="string">&quot;138&quot;</span></span><br><span class="line">    <span class="string">&quot;25&quot;</span>    <span class="string">&quot;134&quot;</span>    <span class="string">&quot;144&quot;</span>    <span class="string">&quot;139&quot;</span></span><br><span class="line">    <span class="string">&quot;20&quot;</span>    <span class="string">&quot;135&quot;</span>    <span class="string">&quot;145&quot;</span>    <span class="string">&quot;140&quot;</span></span><br><span class="line">    <span class="string">&quot;25&quot;</span>    <span class="string">&quot;136&quot;</span>    <span class="string">&quot;146&quot;</span>    <span class="string">&quot;141&quot;</span></span><br></pre></td></tr></table></figure><h4 id="（6）writematrix"><a href="#（6）writematrix" class="headerlink" title="（6）writematrix()"></a><strong>（6）<code>writematrix()</code></strong></h4><blockquote><p><strong>参数详解见<code>MATLAB</code>帮助中心。</strong></p><ul><li>将矩阵写入到文本文件</li><li>将矩阵写入电子表格文件</li><li>将矩阵写入指定的工作表和范围</li><li>将数据追加到电子表格</li><li>将矩阵数据追加到文本文件</li></ul></blockquote><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% writematrix()将矩阵写入文件，自R2019a起</span></span><br><span class="line"><span class="comment">% （1）将同构数组A写入以逗号分隔的文本文件。文件名为数组的工作区变量名称，附加扩展名.txt。如果writematrix无法根据数组名称构造文件名，那么它会写入matrix.txt文件中。A中每个变量的每一列都将成为输出文件中的列。writematrix函数会覆盖任何现有文件。</span></span><br><span class="line">writematrix(A)</span><br><span class="line"><span class="comment">% （2）写入具有filename指定的名称和扩展名的文件。</span></span><br><span class="line"><span class="comment">% writematrix 根据指定扩展名确定文件格式。扩展名必须是下列格式之一：</span></span><br><span class="line"><span class="comment">% .txt、.dat或.csv（带分隔符的文本文件）</span></span><br><span class="line"><span class="comment">% .xls、.xlsm或.xlsx（适用于Excel® 电子表格文件）</span></span><br><span class="line"><span class="comment">% .xlsb（适用于安装了Windows® Excel的系统上支持的Excel电子表格文件）</span></span><br><span class="line">writematrix(A,filename)</span><br><span class="line"><span class="comment">% （3）支持上述语法中的任何输入参数，且可使用一个或多个Name,Value对组参数指定其他选项将数组写入文件中。</span></span><br><span class="line">writematrix(___,Name,Value)</span><br></pre></td></tr></table></figure><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clc</span><br><span class="line">clear all</span><br><span class="line"></span><br><span class="line">csv_data = readmatrix(<span class="string">&#x27;D:\Desktop\data1.csv&#x27;</span>, <span class="string">&#x27;OutputType&#x27;</span>, <span class="string">&#x27;string&#x27;</span>)</span><br><span class="line"><span class="comment">% 没有标题,可以根据自己创建的矩阵添加标题</span></span><br><span class="line">writematrix(csv_data,<span class="string">&#x27;D:\Desktop\output1.csv&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">% 命令行窗口输出结果</span></span><br><span class="line">csv_data = </span><br><span class="line">  <span class="number">7</span>×<span class="number">6</span> string 数组</span><br><span class="line">    <span class="string">&quot;小红&quot;</span>    <span class="string">&quot;女&quot;</span>    <span class="string">&quot;20&quot;</span>    <span class="string">&quot;130&quot;</span>    <span class="string">&quot;140&quot;</span>    <span class="string">&quot;135&quot;</span></span><br><span class="line">    <span class="string">&quot;小汤&quot;</span>    <span class="string">&quot;男&quot;</span>    <span class="string">&quot;22&quot;</span>    <span class="string">&quot;131&quot;</span>    <span class="string">&quot;141&quot;</span>    <span class="string">&quot;136&quot;</span></span><br><span class="line">    <span class="string">&quot;小李&quot;</span>    <span class="string">&quot;男&quot;</span>    <span class="string">&quot;24&quot;</span>    <span class="string">&quot;132&quot;</span>    <span class="string">&quot;142&quot;</span>    <span class="string">&quot;137&quot;</span></span><br><span class="line">    <span class="string">&quot;小ai&quot;</span>    <span class="string">&quot;男&quot;</span>    <span class="string">&quot;21&quot;</span>    <span class="string">&quot;133&quot;</span>    <span class="string">&quot;143&quot;</span>    <span class="string">&quot;138&quot;</span></span><br><span class="line">    <span class="string">&quot;小张&quot;</span>    <span class="string">&quot;男&quot;</span>    <span class="string">&quot;25&quot;</span>    <span class="string">&quot;134&quot;</span>    <span class="string">&quot;144&quot;</span>    <span class="string">&quot;139&quot;</span></span><br><span class="line">    <span class="string">&quot;小小&quot;</span>    <span class="string">&quot;男&quot;</span>    <span class="string">&quot;20&quot;</span>    <span class="string">&quot;135&quot;</span>    <span class="string">&quot;145&quot;</span>    <span class="string">&quot;140&quot;</span></span><br><span class="line">    <span class="string">&quot;小耿&quot;</span>    <span class="string">&quot;男&quot;</span>    <span class="string">&quot;25&quot;</span>    <span class="string">&quot;136&quot;</span>    <span class="string">&quot;146&quot;</span>    <span class="string">&quot;141&quot;</span></span><br></pre></td></tr></table></figure><h4 id="（7）dlmwrite-不推荐"><a href="#（7）dlmwrite-不推荐" class="headerlink" title="（7）dlmwrite()(不推荐)"></a><strong>（7）<code>dlmwrite()</code>(不推荐)</strong></h4><blockquote><p>帮助中心：不推荐使用<code>dlmwrite</code>，请改用<code>writematrix</code>。</p><p><code>dlmwrite</code>支持数值数据，不支持字符串类型。具体参数解释可以查看<code>MATLAB</code>帮助中心文档。</p></blockquote><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% (1)将数组M中的数值数据写入一个ASCII格式的文件filename，并使用默认分隔符(,)分隔各数组元素。如果文件filename已存在，则dlmwrite将覆盖该文件。</span></span><br><span class="line">dlmwrite(filename,M)</span><br><span class="line"><span class="comment">% (2)将数据追加到现有文件filename的末尾。</span></span><br><span class="line">dlmwrite(filename,M,<span class="string">&#x27;-append&#x27;</span>)</span><br><span class="line"><span class="comment">% (3)使用一个或多个名称-值对组参数另外指定分隔符、换行符、偏移量和精度选项。</span></span><br><span class="line">dlmwrite(___,Name,Value)</span><br><span class="line"><span class="comment">% (4)将数组M写入文件filename，并使用指定分隔符delimiter分隔各数组元素。</span></span><br><span class="line">dlmwrite(filename,M,delimiter)</span><br><span class="line"><span class="comment">% (5)从目标文件中指定的第row行和第col列开始写入数组。前导行和列用delimiter分隔的空元素填充。</span></span><br><span class="line">dlmwrite(filename,M,delimiter,row,col)</span><br></pre></td></tr></table></figure><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clc</span><br><span class="line">clear all</span><br><span class="line"></span><br><span class="line"><span class="comment">% 支持数值型</span></span><br><span class="line">csv_data = importdata(<span class="string">&#x27;D:\Desktop\data1.csv&#x27;</span>)</span><br><span class="line">data = csv_data.data</span><br><span class="line"><span class="comment">% 添加到csv中，并且以逗号为分隔符</span></span><br><span class="line">dlmwrite(<span class="string">&#x27;D:\Desktop\output2.csv&#x27;</span>,data,<span class="string">&#x27;delimiter&#x27;</span>,<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line"><span class="comment">% 添加到csv中，并且从行后添加</span></span><br><span class="line">dlmwrite(<span class="string">&#x27;D:\Desktop\output2.csv&#x27;</span>,data,<span class="string">&#x27;delimiter&#x27;</span>,<span class="string">&#x27;,&#x27;</span>,<span class="string">&#x27;-append&#x27;</span>)</span><br><span class="line"><span class="comment">% 添加到csv中，并且以相对于已有数据偏移的方式</span></span><br><span class="line">dlmwrite(<span class="string">&#x27;D:\Desktop\output2.csv&#x27;</span>,data,<span class="string">&#x27;delimiter&#x27;</span>,<span class="string">&#x27;,&#x27;</span>,<span class="string">&#x27;-append&#x27;</span>,<span class="string">&#x27;roffset&#x27;</span>,<span class="number">2</span>,<span class="string">&#x27;coffset&#x27;</span>,<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">% 命令行窗口输出结果</span></span><br><span class="line">csv_data = </span><br><span class="line">  包含以下字段的 struct:</span><br><span class="line">        data: [<span class="number">7</span>×<span class="number">4</span> double]</span><br><span class="line">    textdata: &#123;<span class="number">8</span>×<span class="number">6</span> cell&#125;</span><br><span class="line">data =</span><br><span class="line">    <span class="number">20</span>   <span class="number">130</span>   <span class="number">140</span>   <span class="number">135</span></span><br><span class="line">    <span class="number">22</span>   <span class="number">131</span>   <span class="number">141</span>   <span class="number">136</span></span><br><span class="line">    <span class="number">24</span>   <span class="number">132</span>   <span class="number">142</span>   <span class="number">137</span></span><br><span class="line">    <span class="number">21</span>   <span class="number">133</span>   <span class="number">143</span>   <span class="number">138</span></span><br><span class="line">    <span class="number">25</span>   <span class="number">134</span>   <span class="number">144</span>   <span class="number">139</span></span><br><span class="line">    <span class="number">20</span>   <span class="number">135</span>   <span class="number">145</span>   <span class="number">140</span></span><br><span class="line">    <span class="number">25</span>   <span class="number">136</span>   <span class="number">146</span>   <span class="number">141</span></span><br></pre></td></tr></table></figure><h4 id="（8）writetable"><a href="#（8）writetable" class="headerlink" title="（8）writetable()"></a><strong>（8）<code>writetable()</code></strong></h4><blockquote><p><strong>参数详解见<code>MATLAB</code>帮助中心</strong>。也可实现：</p><ul><li>将表写入到<strong>文本文件</strong></li><li>将表写入空格分隔的文本文件</li><li>将表写入包含行名称的文本文件</li><li>将外语日期写入文本文件</li><li>将外语字符写入文本文件</li><li>将引用文本写入**<code>CSV</code>文件**</li><li>将表写入到电子表格中特定的工作表和范围</li><li>写入包含任意变量名称的表格数据</li><li>将数据追加到表的底部</li><li>保留现有列宽（将数据追加到文件底部时，保留电子表格文件的现有列宽）</li><li>修改现有单元格格式</li><li>将表写入**<code>XML</code>文件**</li></ul></blockquote><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% (1)将表T写入逗号分隔的文本文件。文件名为表的工作区变量名称，附加扩展名.txt。如果writetable无法根据输入表名称构造文件名，那么它会写入table.txt 文件中。</span></span><br><span class="line"><span class="comment">% 对于文本文件和电子表格文件，T中每个变量的每列都成为输出文件中的一列。T的变量名称将成为文件第一行的列标题。</span></span><br><span class="line"><span class="comment">% 对于XML文件，T中的每列都成为输出文件中的一个XML节点。T的变量名称成为输出XML文件中元素节点的名称。</span></span><br><span class="line"><span class="built_in">writetable</span>(T)</span><br><span class="line"><span class="comment">% (2)写入具有filename指定的名称和扩展名的文件。</span></span><br><span class="line"><span class="comment">% writetable根据指定扩展名确定文件格式。扩展名必须是下列格式之一：</span></span><br><span class="line"><span class="comment">% .txt、.dat或.csv（带分隔符的文本文件）</span></span><br><span class="line"><span class="comment">% .xls、.xlsm或.xlsx（适用于Excel®电子表格文件）</span></span><br><span class="line"><span class="comment">% .xlsb（适用于安装了Windows® Excel的系统上支持的Excel电子表格文件）</span></span><br><span class="line"><span class="comment">% .xml（可扩展标记语言(XML)文件）</span></span><br><span class="line"><span class="built_in">writetable</span>(T,filename)</span><br><span class="line"><span class="comment">% (3)通过一个或多个Name,Value对组参数指定的其他选项将表写入文件中，并且可以包含以前语法中的任何输入参数。例如，您可以指定是否将变量名称写入为输出文件中的列标题。</span></span><br><span class="line"><span class="built_in">writetable</span>(___,Name,Value)</span><br></pre></td></tr></table></figure><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clc</span><br><span class="line">clear all</span><br><span class="line"></span><br><span class="line">LastName = &#123;<span class="string">&#x27;Sanchez&#x27;</span>;<span class="string">&#x27;Johnson&#x27;</span>;<span class="string">&#x27;Li&#x27;</span>;<span class="string">&#x27;Diaz&#x27;</span>;<span class="string">&#x27;Brown&#x27;</span>&#125;</span><br><span class="line">Age = [<span class="number">38</span>;<span class="number">43</span>;<span class="number">38</span>;<span class="number">40</span>;<span class="number">49</span>]</span><br><span class="line">Smoker = logical([<span class="number">1</span>;<span class="number">0</span>;<span class="number">1</span>;<span class="number">0</span>;<span class="number">1</span>])</span><br><span class="line">Height = [<span class="number">71</span>;<span class="number">69</span>;<span class="number">64</span>;<span class="number">67</span>;<span class="number">64</span>]</span><br><span class="line">Weight = [<span class="number">176</span>;<span class="number">163</span>;<span class="number">131</span>;<span class="number">133</span>;<span class="number">119</span>]</span><br><span class="line">BloodPressure = [<span class="number">124</span> <span class="number">93</span>; <span class="number">109</span> <span class="number">77</span>; <span class="number">125</span> <span class="number">83</span>; <span class="number">117</span> <span class="number">75</span>; <span class="number">122</span> <span class="number">80</span>]</span><br><span class="line">table_csv = <span class="built_in">table</span>(LastName,Age,Smoker,Height,Weight,BloodPressure)</span><br><span class="line"><span class="comment">% 自定义列索引和行索引</span></span><br><span class="line">table_csv.Properties.VariableNames = &#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;f&#x27;</span>&#125;</span><br><span class="line">table_csv.Properties.RowNames = &#123;<span class="string">&#x27;g&#x27;</span>,<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;i&#x27;</span>,<span class="string">&#x27;j&#x27;</span>,<span class="string">&#x27;k&#x27;</span>&#125;</span><br><span class="line"><span class="built_in">writetable</span>(table_csv,<span class="string">&quot;D:\Desktop\output3.csv&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="👀Excel-1"><a href="#👀Excel-1" class="headerlink" title="👀Excel"></a>👀Excel</h3><blockquote><p>函数详解见上，或者<code>MATLAB</code>帮助中心。</p><p><strong>读取全部内容</strong>、<strong>读取特定部分内容</strong>、<strong>追加内容</strong>……</p></blockquote><h4 id="（1）xlsread-不推荐"><a href="#（1）xlsread-不推荐" class="headerlink" title="（1）xlsread()(不推荐)"></a><strong>（1）<code>xlsread()</code>(不推荐)</strong></h4><blockquote><ul><li>将工作表读取到数值矩阵</li><li>读取元胞的范围</li><li>读取列</li><li>请求数值、文本和原始数据</li><li>对工作表执行函数</li><li>请求自定义输出</li></ul></blockquote><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% （1）读取名为filename的 Microsoft®Excel®电子表格工作表中的第一个工作表，并在一个矩阵中返回数值数据。</span></span><br><span class="line">num = xlsread(filename)</span><br><span class="line"><span class="comment">% （2）读取指定的工作表。</span></span><br><span class="line">num = xlsread(filename,sheet)</span><br><span class="line"><span class="comment">% （3）从工作簿的第一个工作表的指定范围内读取数据。使用Excel范围语法，例如&#x27;A1:C3&#x27;。</span></span><br><span class="line">num = xlsread(filename,xlRange)</span><br><span class="line"><span class="comment">% （4）读取指定的工作表和范围。</span></span><br><span class="line">num = xlsread(filename,sheet,xlRange)</span><br><span class="line"><span class="comment">% （5）在basic导入模式下读取电子表格中的数据。如果您的计算机未安装Windows®版 Excel或者您正在使用MATLAB®Online™，xlsread会自动在basic导入模式下运行，该模式支持XLS、XLSX、XLSM、XLTX和XLTM文件。</span></span><br><span class="line"><span class="comment">% 如果不指定所有参数，请使用空字符向量&#x27;&#x27;作为占位符，例如，num=xlsread(filename,&#x27;&#x27;,&#x27;&#x27;,&#x27;basic&#x27;)。</span></span><br><span class="line">num = xlsread(filename,sheet,xlRange,<span class="string">&#x27;basic&#x27;</span>)</span><br><span class="line"><span class="comment">% （6）支持上述语法中的任何输入参数，且可在元胞数组txt中返回文本字段，在元胞数组raw中返回数值数据和文本数据。</span></span><br><span class="line">[num,txt,raw] = xlsread(___)</span><br><span class="line"><span class="comment">% （7）打开一个Excel窗口以便按交互方式来选择数据。选择工作表，将鼠标拖放到所需范围上，然后点击确定。只有安装了Microsoft Excel软件的Windows计算机才支持此语法。</span></span><br><span class="line">___ = xlsread(filename,<span class="number">-1</span>)</span><br><span class="line"><span class="comment">% （8）读取电子表格，对数据调用processFcn，并在数组num中以数值数据的形式返回最终结果。xlsread函数在元胞数组txt中返回文本字段、在元胞数组raw中返回数值和文本数据，并在数组custom中返回processFcn的第二个输出。xlsread函数不会更改电子表格中存储的数据。只有安装了Excel软件的Windows计算机才支持此语法。</span></span><br><span class="line"><span class="comment">% （其中processFcn是函数句柄）</span></span><br><span class="line">[num,txt,raw,custom] = xlsread(filename,sheet,xlRange,<span class="string">&#x27;&#x27;</span>,processFcn)</span><br></pre></td></tr></table></figure><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clc</span><br><span class="line">clear all</span><br><span class="line"></span><br><span class="line">values = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> ; <span class="number">4</span>, <span class="number">5</span>, <span class="string">&#x27;x&#x27;</span> ; <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;</span><br><span class="line">headers = &#123;<span class="string">&#x27;First&#x27;</span>,<span class="string">&#x27;Second&#x27;</span>,<span class="string">&#x27;Third&#x27;</span>&#125;</span><br><span class="line">xlswrite(<span class="string">&#x27;D:\Desktop\myExample.xlsx&#x27;</span>,[headers; values])</span><br><span class="line">filename = <span class="string">&#x27;D:\Desktop\myExample.xlsx&#x27;</span></span><br><span class="line">data = xlsread(filename)</span><br><span class="line"></span><br><span class="line"><span class="comment">% 命令行窗口输出结果</span></span><br><span class="line">values =</span><br><span class="line">  <span class="number">3</span>×<span class="number">3</span> cell 数组</span><br><span class="line">    &#123;[<span class="number">1</span>]&#125;    &#123;[<span class="number">2</span>]&#125;    &#123;[<span class="number">3</span>]&#125;</span><br><span class="line">    &#123;[<span class="number">4</span>]&#125;    &#123;[<span class="number">5</span>]&#125;    &#123;<span class="string">&#x27;x&#x27;</span>&#125;</span><br><span class="line">    &#123;[<span class="number">7</span>]&#125;    &#123;[<span class="number">8</span>]&#125;    &#123;[<span class="number">9</span>]&#125;</span><br><span class="line">headers =</span><br><span class="line">  <span class="number">1</span>×<span class="number">3</span> cell 数组</span><br><span class="line">    &#123;<span class="string">&#x27;First&#x27;</span>&#125;    &#123;<span class="string">&#x27;Second&#x27;</span>&#125;    &#123;<span class="string">&#x27;Third&#x27;</span>&#125;</span><br><span class="line">data =</span><br><span class="line">     <span class="number">1</span>     <span class="number">2</span>     <span class="number">3</span></span><br><span class="line">     <span class="number">4</span>     <span class="number">5</span>   NaN</span><br><span class="line">     <span class="number">7</span>     <span class="number">8</span>     <span class="number">9</span></span><br></pre></td></tr></table></figure><h4 id="（2）readmatrix-1"><a href="#（2）readmatrix-1" class="headerlink" title="（2）readmatrix()"></a><strong>（2）<code>readmatrix()</code></strong></h4><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clc</span><br><span class="line">clear all</span><br><span class="line"><span class="comment">% readmatrix第一个参数是文件名。第二个参数指输出类型。如果不带这个参数，那么字符串那一列的输出结果是Nan值</span></span><br><span class="line"><span class="comment">% 加上之后，则全部输出文本类型，后面再把要作为数值型的内容转换数据类型。</span></span><br><span class="line">data1 = readmatrix(<span class="string">&#x27;D:\Desktop\data2.xlsx&#x27;</span>, <span class="string">&#x27;OutputType&#x27;</span>, <span class="string">&#x27;string&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">% 命令行窗口输出结果</span></span><br><span class="line">data1 = </span><br><span class="line">  <span class="number">7</span>×<span class="number">6</span> string 数组</span><br><span class="line">    <span class="string">&quot;小红&quot;</span>    <span class="string">&quot;女&quot;</span>    <span class="string">&quot;20&quot;</span>    <span class="string">&quot;130&quot;</span>    <span class="string">&quot;140&quot;</span>    <span class="string">&quot;135&quot;</span></span><br><span class="line">    <span class="string">&quot;小汤&quot;</span>    <span class="string">&quot;男&quot;</span>    <span class="string">&quot;22&quot;</span>    <span class="string">&quot;131&quot;</span>    <span class="string">&quot;141&quot;</span>    <span class="string">&quot;136&quot;</span></span><br><span class="line">    <span class="string">&quot;小李&quot;</span>    <span class="string">&quot;男&quot;</span>    <span class="string">&quot;24&quot;</span>    <span class="string">&quot;132&quot;</span>    <span class="string">&quot;142&quot;</span>    <span class="string">&quot;137&quot;</span></span><br><span class="line">    <span class="string">&quot;小ai&quot;</span>    <span class="string">&quot;男&quot;</span>    <span class="string">&quot;21&quot;</span>    <span class="string">&quot;133&quot;</span>    <span class="string">&quot;143&quot;</span>    <span class="string">&quot;138&quot;</span></span><br><span class="line">    <span class="string">&quot;小张&quot;</span>    <span class="string">&quot;男&quot;</span>    <span class="string">&quot;25&quot;</span>    <span class="string">&quot;134&quot;</span>    <span class="string">&quot;144&quot;</span>    <span class="string">&quot;139&quot;</span></span><br><span class="line">    <span class="string">&quot;小小&quot;</span>    <span class="string">&quot;男&quot;</span>    <span class="string">&quot;20&quot;</span>    <span class="string">&quot;135&quot;</span>    <span class="string">&quot;145&quot;</span>    <span class="string">&quot;140&quot;</span></span><br><span class="line">    <span class="string">&quot;小耿&quot;</span>    <span class="string">&quot;男&quot;</span>    <span class="string">&quot;25&quot;</span>    <span class="string">&quot;136&quot;</span>    <span class="string">&quot;146&quot;</span>    <span class="string">&quot;141&quot;</span></span><br></pre></td></tr></table></figure><h4 id="（3）readtable"><a href="#（3）readtable" class="headerlink" title="（3）readtable()"></a><strong>（3）<code>readtable()</code></strong></h4><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clc</span><br><span class="line">clear all</span><br><span class="line">data2 = <span class="built_in">readtable</span>(<span class="string">&#x27;D:\Desktop\data2.xlsx&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">% 命令行窗口输出结果</span></span><br><span class="line">data2 =</span><br><span class="line">  <span class="number">7</span>×<span class="number">6</span> <span class="built_in">table</span></span><br><span class="line">     name     gender    age    x__    x___1    x___2</span><br><span class="line">    ______    ______    ___    ___    _____    _____</span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;小红&#x27;</span>     <span class="string">&#x27;女&#x27;</span>      <span class="number">20</span>     <span class="number">130</span>     <span class="number">140</span>      <span class="number">135</span> </span><br><span class="line">    <span class="string">&#x27;小汤&#x27;</span>     <span class="string">&#x27;男&#x27;</span>      <span class="number">22</span>     <span class="number">131</span>     <span class="number">141</span>      <span class="number">136</span> </span><br><span class="line">    <span class="string">&#x27;小李&#x27;</span>     <span class="string">&#x27;男&#x27;</span>      <span class="number">24</span>     <span class="number">132</span>     <span class="number">142</span>      <span class="number">137</span> </span><br><span class="line">    <span class="string">&#x27;小ai&#x27;</span>     <span class="string">&#x27;男&#x27;</span>     <span class="number">21</span>     <span class="number">133</span>     <span class="number">143</span>      <span class="number">138</span> </span><br><span class="line">    <span class="string">&#x27;小张&#x27;</span>     <span class="string">&#x27;男&#x27;</span>      <span class="number">25</span>     <span class="number">134</span>     <span class="number">144</span>      <span class="number">139</span> </span><br><span class="line">    <span class="string">&#x27;小小&#x27;</span>     <span class="string">&#x27;男&#x27;</span>      <span class="number">20</span>     <span class="number">135</span>     <span class="number">145</span>      <span class="number">140</span> </span><br><span class="line">    <span class="string">&#x27;小耿&#x27;</span>     <span class="string">&#x27;男&#x27;</span>      <span class="number">25</span>     <span class="number">136</span>     <span class="number">146</span>      <span class="number">141</span> </span><br></pre></td></tr></table></figure><h4 id="（4）xlswrite-不推荐"><a href="#（4）xlswrite-不推荐" class="headerlink" title="（4）xlswrite()(不推荐)"></a><strong>（4）<code>xlswrite()</code>(不推荐)</strong></h4><blockquote><ul><li>将向量写入电子表格</li><li>写入电子表格的特定工作表和范围</li></ul></blockquote><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% （1）将矩阵A写入Microsoft®Excel®电子表格工作簿filename中的第一个工作表，从单元格A1开始写入。</span></span><br><span class="line">xlswrite(filename,A)</span><br><span class="line"><span class="comment">% （2）将数据写入指定的工作表。</span></span><br><span class="line">xlswrite(filename,A,sheet)</span><br><span class="line"><span class="comment">% （3）将数据写入工作簿的第一个工作表中由xlRange指定的矩形区域内。使用Excel范围语法，例如&#x27;A1:C3&#x27;。</span></span><br><span class="line">xlswrite(filename,A,xlRange)</span><br><span class="line"><span class="comment">% （4）将数据写入指定的工作表和范围。</span></span><br><span class="line">xlswrite(filename,A,sheet,xlRange)</span><br><span class="line"><span class="comment">% （5）使用先前语法中的任何输入参数返回写入操作的状态。当操作成功时，status为1。否则，status为0。</span></span><br><span class="line">status = xlswrite(___)</span><br><span class="line"><span class="comment">% （6）还在结构体message中返回写入操作生成的任何警告或错误消息。</span></span><br><span class="line">[status,message] = xlswrite(___)</span><br></pre></td></tr></table></figure><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clc</span><br><span class="line">clear all</span><br><span class="line"></span><br><span class="line"><span class="comment">% 写入电子表格的特定工作表和范围</span></span><br><span class="line">A = &#123;<span class="string">&#x27;Time&#x27;</span>,<span class="string">&#x27;Temperature&#x27;</span>; <span class="number">12</span>,<span class="number">98</span>; <span class="number">13</span>,<span class="number">99</span>; <span class="number">14</span>,<span class="number">97</span>&#125;</span><br><span class="line">sheet = <span class="number">2</span></span><br><span class="line">xlRange = <span class="string">&#x27;E1&#x27;</span></span><br><span class="line">xlswrite(<span class="string">&#x27;D:\Desktop\mytest.xlsx&#x27;</span>,A,sheet,xlRange)</span><br></pre></td></tr></table></figure><h4 id="（5）writematrix"><a href="#（5）writematrix" class="headerlink" title="（5）writematrix()"></a><strong>（5）<code>writematrix()</code></strong></h4><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clc</span><br><span class="line">clear all</span><br><span class="line"></span><br><span class="line">Excel_data = readmatrix(<span class="string">&#x27;D:\Desktop\data2.xlsx&#x27;</span>, <span class="string">&#x27;OutputType&#x27;</span>, <span class="string">&#x27;string&#x27;</span>)</span><br><span class="line">writematrix(Excel_data,<span class="string">&#x27;D:\Desktop\output2.xlsx&#x27;</span>)</span><br><span class="line"><span class="comment">% 我的MATLAB版本是R2019a,追加时显示参数名称 WriteMode无效</span></span><br><span class="line"><span class="comment">% writematrix(Excel_data,&#x27;D:\Desktop\output2.xlsx&#x27;,&#x27;WriteMode&#x27;,&#x27;append&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 命令行窗口输出结果</span></span><br><span class="line">Excel_data = </span><br><span class="line">  <span class="number">7</span>×<span class="number">6</span> string 数组</span><br><span class="line">    <span class="string">&quot;小红&quot;</span>    <span class="string">&quot;女&quot;</span>    <span class="string">&quot;20&quot;</span>    <span class="string">&quot;130&quot;</span>    <span class="string">&quot;140&quot;</span>    <span class="string">&quot;135&quot;</span></span><br><span class="line">    <span class="string">&quot;小汤&quot;</span>    <span class="string">&quot;男&quot;</span>    <span class="string">&quot;22&quot;</span>    <span class="string">&quot;131&quot;</span>    <span class="string">&quot;141&quot;</span>    <span class="string">&quot;136&quot;</span></span><br><span class="line">    <span class="string">&quot;小李&quot;</span>    <span class="string">&quot;男&quot;</span>    <span class="string">&quot;24&quot;</span>    <span class="string">&quot;132&quot;</span>    <span class="string">&quot;142&quot;</span>    <span class="string">&quot;137&quot;</span></span><br><span class="line">    <span class="string">&quot;小ai&quot;</span>    <span class="string">&quot;男&quot;</span>    <span class="string">&quot;21&quot;</span>    <span class="string">&quot;133&quot;</span>    <span class="string">&quot;143&quot;</span>    <span class="string">&quot;138&quot;</span></span><br><span class="line">    <span class="string">&quot;小张&quot;</span>    <span class="string">&quot;男&quot;</span>    <span class="string">&quot;25&quot;</span>    <span class="string">&quot;134&quot;</span>    <span class="string">&quot;144&quot;</span>    <span class="string">&quot;139&quot;</span></span><br><span class="line">    <span class="string">&quot;小小&quot;</span>    <span class="string">&quot;男&quot;</span>    <span class="string">&quot;20&quot;</span>    <span class="string">&quot;135&quot;</span>    <span class="string">&quot;145&quot;</span>    <span class="string">&quot;140&quot;</span></span><br><span class="line">    <span class="string">&quot;小耿&quot;</span>    <span class="string">&quot;男&quot;</span>    <span class="string">&quot;25&quot;</span>    <span class="string">&quot;136&quot;</span>    <span class="string">&quot;146&quot;</span>    <span class="string">&quot;141&quot;</span></span><br></pre></td></tr></table></figure><h4 id="（6）writetable"><a href="#（6）writetable" class="headerlink" title="（6）writetable()"></a><strong>（6）<code>writetable()</code></strong></h4><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clc</span><br><span class="line">clear all</span><br><span class="line"></span><br><span class="line">LastName = &#123;<span class="string">&#x27;Sanchez&#x27;</span>;<span class="string">&#x27;Johnson&#x27;</span>;<span class="string">&#x27;Li&#x27;</span>;<span class="string">&#x27;Diaz&#x27;</span>;<span class="string">&#x27;Brown&#x27;</span>&#125;</span><br><span class="line">Age = [<span class="number">38</span>;<span class="number">43</span>;<span class="number">38</span>;<span class="number">40</span>;<span class="number">49</span>]</span><br><span class="line">Smoker = logical([<span class="number">1</span>;<span class="number">0</span>;<span class="number">1</span>;<span class="number">0</span>;<span class="number">1</span>])</span><br><span class="line">Height = [<span class="number">71</span>;<span class="number">69</span>;<span class="number">64</span>;<span class="number">67</span>;<span class="number">64</span>]</span><br><span class="line">Weight = [<span class="number">176</span>;<span class="number">163</span>;<span class="number">131</span>;<span class="number">133</span>;<span class="number">119</span>]</span><br><span class="line">BloodPressure = [<span class="number">124</span> <span class="number">93</span>; <span class="number">109</span> <span class="number">77</span>; <span class="number">125</span> <span class="number">83</span>; <span class="number">117</span> <span class="number">75</span>; <span class="number">122</span> <span class="number">80</span>]</span><br><span class="line">table_csv = <span class="built_in">table</span>(LastName,Age,Smoker,Height,Weight,BloodPressure)</span><br><span class="line"><span class="comment">% 自定义列索引和行索引</span></span><br><span class="line">table_csv.Properties.VariableNames = &#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;f&#x27;</span>&#125;</span><br><span class="line">table_csv.Properties.RowNames = &#123;<span class="string">&#x27;g&#x27;</span>,<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;i&#x27;</span>,<span class="string">&#x27;j&#x27;</span>,<span class="string">&#x27;k&#x27;</span>&#125;</span><br><span class="line"><span class="built_in">writetable</span>(table_csv,<span class="string">&quot;D:\Desktop\output3.xlsx&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">% 命令行窗口输出结果</span></span><br><span class="line">table_csv =</span><br><span class="line">  <span class="number">5</span>×<span class="number">6</span> <span class="built_in">table</span></span><br><span class="line">             a        b       c      d      e         f     </span><br><span class="line">         _________    __    _____    __    ___    __________</span><br><span class="line">    g    <span class="string">&#x27;Sanchez&#x27;</span>    <span class="number">38</span>    <span class="built_in">true</span>     <span class="number">71</span>    <span class="number">176</span>    <span class="number">124</span>     <span class="number">93</span></span><br><span class="line">    h    <span class="string">&#x27;Johnson&#x27;</span>    <span class="number">43</span>    <span class="built_in">false</span>    <span class="number">69</span>    <span class="number">163</span>    <span class="number">109</span>     <span class="number">77</span></span><br><span class="line">    <span class="built_in">i</span>    <span class="string">&#x27;Li&#x27;</span>         <span class="number">38</span>    <span class="built_in">true</span>     <span class="number">64</span>    <span class="number">131</span>    <span class="number">125</span>     <span class="number">83</span></span><br><span class="line">    <span class="built_in">j</span>    <span class="string">&#x27;Diaz&#x27;</span>       <span class="number">40</span>    <span class="built_in">false</span>    <span class="number">67</span>    <span class="number">133</span>    <span class="number">117</span>     <span class="number">75</span></span><br><span class="line">    k    <span class="string">&#x27;Brown&#x27;</span>      <span class="number">49</span>    <span class="built_in">true</span>     <span class="number">64</span>    <span class="number">119</span>    <span class="number">122</span>     <span class="number">80</span></span><br></pre></td></tr></table></figure><h3 id="👀JSON-1"><a href="#👀JSON-1" class="headerlink" title="👀JSON"></a>👀JSON</h3><blockquote><p><code>MATLAB</code>读取<code>JSON</code>的方式利用<a href="https://github.com/fangq/jsonlab"><strong><code>JSONlab</code>工具箱</strong></a></p><p>①将下载的工具箱安装包解压缩放入<code>MATLAB</code>安装目录下的<code>toolbox</code>文件夹下；</p><p>②打开<code>MATLAB</code>，选择”主页“→”设置路径“，将工具箱所在文件夹导入。</p></blockquote><p><code>JSON</code>源文件</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;FeatureCollection&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;features&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Feature&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;geometry&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;coordinates&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">[</span><span class="punctuation">[</span><span class="number">116.3591064789793</span><span class="punctuation">,</span> <span class="number">40.0611769097348</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="punctuation">[</span><span class="number">116.35882714532096</span><span class="punctuation">,</span> <span class="number">40.06035824493355</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="punctuation">[</span><span class="number">116.3588680234169</span><span class="punctuation">,</span> <span class="number">40.06017052423036</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="punctuation">[</span><span class="number">116.3592154872361</span><span class="punctuation">,</span> <span class="number">40.05968557668524</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="punctuation">[</span><span class="number">116.35964470724883</span><span class="punctuation">,</span> <span class="number">40.05949263960517</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="punctuation">[</span><span class="number">116.36125939205749</span><span class="punctuation">,</span> <span class="number">40.05968557668524</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="punctuation">[</span><span class="number">116.36073478982053</span><span class="punctuation">,</span> <span class="number">40.06143241456951</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="punctuation">[</span><span class="number">116.3591064789793</span><span class="punctuation">,</span> <span class="number">40.0611769097348</span><span class="punctuation">]</span><span class="punctuation">]</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Polygon&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Feature&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;geometry&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;coordinates&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="number">116.35838429946176</span><span class="punctuation">,</span> <span class="number">40.0595499993847</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Point&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Feature&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;geometry&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;coordinates&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="number">116.36078873507478</span><span class="punctuation">,</span> <span class="number">40.06152377992771</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Point&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>利用<code>Matlab</code>读取<code>JSON</code></p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clc</span><br><span class="line">clear all</span><br><span class="line"></span><br><span class="line"><span class="comment">% 读取json需要导入JSONlab工具箱</span></span><br><span class="line">jsonData = loadjson(<span class="string">&#x27;D:\Desktop\map.geojson&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">% 命令行窗口输出结果</span></span><br><span class="line">jsonData = </span><br><span class="line">  包含以下字段的 struct:</span><br><span class="line">        <span class="built_in">type</span>: <span class="string">&#x27;FeatureCollection&#x27;</span></span><br><span class="line">    features: [<span class="number">1</span>×<span class="number">3</span> struct]</span><br></pre></td></tr></table></figure><p>利用<code>Matlab</code>写入<code>JSON</code></p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clc</span><br><span class="line">clear all</span><br><span class="line"></span><br><span class="line"><span class="comment">% 创建结构体变量</span></span><br><span class="line">data.<span class="built_in">type</span> = <span class="string">&#x27;Feature&#x27;</span></span><br><span class="line">data.<span class="keyword">properties</span> = &#123;&#125;</span><br><span class="line">data.geometry.coordinates = [<span class="number">116.36078873507478</span>, <span class="number">40.06152377992771</span>]</span><br><span class="line">data.geometry.<span class="built_in">type</span> = <span class="string">&#x27;Point&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 将结构体变量写入JSON文件</span></span><br><span class="line">savejson(<span class="string">&#x27;&#x27;</span>, data, <span class="string">&#x27;D:\Desktop\test.json&#x27;</span>)</span><br><span class="line"><span class="comment">% 从JSON文件中读取数据</span></span><br><span class="line">jsonData = loadjson(<span class="string">&#x27;D:\Desktop\test.json&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">% 命令行窗口输出结果</span></span><br><span class="line">data = </span><br><span class="line">  包含以下字段的 struct:</span><br><span class="line">    <span class="built_in">type</span>: <span class="string">&#x27;Feature&#x27;</span></span><br><span class="line">data = </span><br><span class="line">  包含以下字段的 struct:</span><br><span class="line">          <span class="built_in">type</span>: <span class="string">&#x27;Feature&#x27;</span></span><br><span class="line">    <span class="keyword">properties</span>: &#123;&#125;</span><br><span class="line">data = </span><br><span class="line">  包含以下字段的 struct:</span><br><span class="line">          <span class="built_in">type</span>: <span class="string">&#x27;Feature&#x27;</span></span><br><span class="line">    <span class="keyword">properties</span>: &#123;&#125;</span><br><span class="line">      geometry: [<span class="number">1</span>×<span class="number">1</span> struct]</span><br><span class="line">data = </span><br><span class="line">  包含以下字段的 struct:</span><br><span class="line">          <span class="built_in">type</span>: <span class="string">&#x27;Feature&#x27;</span></span><br><span class="line">    <span class="keyword">properties</span>: &#123;&#125;</span><br><span class="line">      geometry: [<span class="number">1</span>×<span class="number">1</span> struct]</span><br><span class="line">jsonData = </span><br><span class="line">  包含以下字段的 struct:</span><br><span class="line">          <span class="built_in">type</span>: <span class="string">&#x27;Feature&#x27;</span></span><br><span class="line">    <span class="keyword">properties</span>: &#123;<span class="number">0</span>×<span class="number">1</span> cell&#125;</span><br><span class="line">      geometry: [<span class="number">1</span>×<span class="number">1</span> struct]</span><br></pre></td></tr></table></figure><h3 id="👀XML-1"><a href="#👀XML-1" class="headerlink" title="👀XML"></a>👀XML</h3><blockquote><p><strong>参数详解见<code>MATLAB</code>帮助中心。</strong></p><p><code>xmlread()</code>读取<code>XML</code>文档并返回文档对象模型节点</p><ul><li><p>将<code>XML</code>文件读入文档对象模型 (<code>DOM</code>) 节点中</p></li><li><p>将该<code>XML</code>文件读入<code>MATLAB®</code>结构体数组中</p></li></ul><p><code>xmlwrite()</code>写入<code>XML</code>文档对象模型节点</p><ul><li><p>创建<code>XML</code>文件</p></li><li><p>以串行化文本形式获取文档对象模型 (<code>DOM</code>) 节点</p></li></ul></blockquote><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% （1）读取指定的XML文件并返回一个Apache®Xerces-J文档对象，该对象表示该XML文件的解析版本。Apache Xerces-J实现用于XML处理的Java®API(JAXP)。使用JAXP函数来操作此文档对象。有关Apache Xerces-J的详细信息，请参阅https://xerces.apache.org/xerces-j/apiDocs/。</span></span><br><span class="line">DOMnode = xmlread(filename)</span><br><span class="line"><span class="comment">% （2）还指定是否允许DOCTYPE声明。如果tf为false，则读取包含DOCTYPE声明的输入XML文件会导致错误。如果为true，xmlread则会为XML文件返回输出DOMnode。tf的默认值是true。</span></span><br><span class="line">DOMnode = xmlread(filename,<span class="string">&#x27;AllowDoctype&#x27;</span>,tf)</span><br></pre></td></tr></table></figure><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% （1）将文档对象模型(DOM)节点DOMnode写入到文件filename。使用xmlwrite要求您使用用于XML处理的Java® API(JAXP)。有关详细信息，请参阅https://docs.oracle.com/javase/7/docs/api。</span></span><br><span class="line">xmlwrite(filename,DOMnode)</span><br><span class="line"><span class="comment">% （2）以字符向量形式返回串行化DOM节点。</span></span><br><span class="line">chr = xmlwrite(DOMnode)</span><br></pre></td></tr></table></figure><h4 id="（1）读取XML-1"><a href="#（1）读取XML-1" class="headerlink" title="（1）读取XML"></a><strong>（1）读取XML</strong></h4><p><code>XML</code>源文件：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;ISO-8859-1&quot;</span>?&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Edited by XMLSpyÂ® --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">breakfast_menu</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">food</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>Belgian Waffles<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">price</span>&gt;</span>$5.95<span class="tag">&lt;/<span class="name">price</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">calories</span>&gt;</span>650<span class="tag">&lt;/<span class="name">calories</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">cropRegion</span> <span class="attr">x</span>=<span class="string">&quot;0&quot;</span> <span class="attr">y</span>=<span class="string">&quot;0&quot;</span> <span class="attr">width</span>=<span class="string">&quot;0000&quot;</span> <span class="attr">height</span>=<span class="string">&quot;1234&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">food</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">food</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>Strawberry Belgian Waffles<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">price</span>&gt;</span>$7.95<span class="tag">&lt;/<span class="name">price</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">calories</span>&gt;</span>900<span class="tag">&lt;/<span class="name">calories</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">cropRegion</span> <span class="attr">x</span>=<span class="string">&quot;1&quot;</span> <span class="attr">y</span>=<span class="string">&quot;1&quot;</span> <span class="attr">width</span>=<span class="string">&quot;1111&quot;</span> <span class="attr">height</span>=<span class="string">&quot;2345&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">food</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">food</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>Berry-Berry Belgian Waffles<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">price</span>&gt;</span>$8.95<span class="tag">&lt;/<span class="name">price</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">calories</span>&gt;</span>900<span class="tag">&lt;/<span class="name">calories</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">cropRegion</span> <span class="attr">x</span>=<span class="string">&quot;2&quot;</span> <span class="attr">y</span>=<span class="string">&quot;2&quot;</span> <span class="attr">width</span>=<span class="string">&quot;2222&quot;</span> <span class="attr">height</span>=<span class="string">&quot;3456&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">food</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">food</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>French Toast<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">price</span>&gt;</span>$4.50<span class="tag">&lt;/<span class="name">price</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">calories</span>&gt;</span>600<span class="tag">&lt;/<span class="name">calories</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">cropRegion</span> <span class="attr">x</span>=<span class="string">&quot;3&quot;</span> <span class="attr">y</span>=<span class="string">&quot;3&quot;</span> <span class="attr">width</span>=<span class="string">&quot;3333&quot;</span> <span class="attr">height</span>=<span class="string">&quot;4567&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">food</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">food</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>Homestyle Breakfast<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">price</span>&gt;</span>$6.95<span class="tag">&lt;/<span class="name">price</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">calories</span>&gt;</span>950<span class="tag">&lt;/<span class="name">calories</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">cropRegion</span> <span class="attr">x</span>=<span class="string">&quot;4&quot;</span> <span class="attr">y</span>=<span class="string">&quot;4&quot;</span> <span class="attr">width</span>=<span class="string">&quot;4444&quot;</span> <span class="attr">height</span>=<span class="string">&quot;5678&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">food</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">breakfast_menu</span>&gt;</span></span><br></pre></td></tr></table></figure><p>利用<code>xmlread()</code>读取<code>XML</code>，同时利用函数 <code>parseXML()</code>将该<code>XML</code>文件读入<code>MATLAB</code>®结构体数组中：</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% 创建一个解析函数以将一个XML文件读入MATLAB®结构体中，然后将一个示例XML文件读入MATLAB工作区中。要创建函数parseXML，请将以下代码复制并粘贴到m文件parseXML.m中。parseXML函数将一个XML文件中的数据解析为一个MATLAB结构体数组，该数组包含字段Name、Attributes、Data和Children。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">theStruct</span> = <span class="title">parseXML</span><span class="params">(filename)</span></span></span><br><span class="line"><span class="comment">% PARSEXML Convert XML file to a MATLAB structure.</span></span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">   tree = xmlread(filename);</span><br><span class="line"><span class="keyword">catch</span></span><br><span class="line">   error(<span class="string">&#x27;Failed to read XML file %s.&#x27;</span>,filename);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% Recurse over child nodes. This could run into problems </span></span><br><span class="line"><span class="comment">% with very deeply nested trees.</span></span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">   theStruct = parseChildNodes(tree);</span><br><span class="line"><span class="keyword">catch</span></span><br><span class="line">   error(<span class="string">&#x27;Unable to parse XML file %s.&#x27;</span>,filename);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">% ----- Local function PARSECHILDNODES -----</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">children</span> = <span class="title">parseChildNodes</span><span class="params">(theNode)</span></span></span><br><span class="line"><span class="comment">% Recurse over node children.</span></span><br><span class="line">children = [];</span><br><span class="line"><span class="keyword">if</span> theNode.hasChildNodes</span><br><span class="line">   childNodes = theNode.getChildNodes;</span><br><span class="line">   numChildNodes = childNodes.getLength;</span><br><span class="line">   allocCell = cell(<span class="number">1</span>, numChildNodes);</span><br><span class="line"></span><br><span class="line">   children = struct(             ...</span><br><span class="line">      <span class="string">&#x27;Name&#x27;</span>, allocCell, <span class="string">&#x27;Attributes&#x27;</span>, allocCell,    ...</span><br><span class="line">      <span class="string">&#x27;Data&#x27;</span>, allocCell, <span class="string">&#x27;Children&#x27;</span>, allocCell);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> count = <span class="number">1</span>:numChildNodes</span><br><span class="line">        theChild = childNodes.item(count<span class="number">-1</span>);</span><br><span class="line">        children(count) = makeStructFromNode(theChild);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% ----- Local function MAKESTRUCTFROMNODE -----</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">nodeStruct</span> = <span class="title">makeStructFromNode</span><span class="params">(theNode)</span></span></span><br><span class="line"><span class="comment">% Create structure of node info.</span></span><br><span class="line"></span><br><span class="line">nodeStruct = struct(                        ...</span><br><span class="line">   <span class="string">&#x27;Name&#x27;</span>, char(theNode.getNodeName),       ...</span><br><span class="line">   <span class="string">&#x27;Attributes&#x27;</span>, parseAttributes(theNode),  ...</span><br><span class="line">   <span class="string">&#x27;Data&#x27;</span>, <span class="string">&#x27;&#x27;</span>,                              ...</span><br><span class="line">   <span class="string">&#x27;Children&#x27;</span>, parseChildNodes(theNode));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> any(strcmp(<span class="keyword">methods</span>(theNode), <span class="string">&#x27;getData&#x27;</span>))</span><br><span class="line">   nodeStruct.Data = char(theNode.getData); </span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   nodeStruct.Data = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% ----- Local function PARSEATTRIBUTES -----</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">attributes</span> = <span class="title">parseAttributes</span><span class="params">(theNode)</span></span></span><br><span class="line"><span class="comment">% Create attributes structure.</span></span><br><span class="line"></span><br><span class="line">attributes = [];</span><br><span class="line"><span class="keyword">if</span> theNode.hasAttributes</span><br><span class="line">   theAttributes = theNode.getAttributes;</span><br><span class="line">   numAttributes = theAttributes.getLength;</span><br><span class="line">   allocCell = cell(<span class="number">1</span>, numAttributes);</span><br><span class="line">   attributes = struct(<span class="string">&#x27;Name&#x27;</span>, allocCell, <span class="string">&#x27;Value&#x27;</span>, ...</span><br><span class="line">                       allocCell);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> count = <span class="number">1</span>:numAttributes</span><br><span class="line">      attrib = theAttributes.item(count<span class="number">-1</span>);</span><br><span class="line">      attributes(count).Name = char(attrib.getName);</span><br><span class="line">      attributes(count).Value = char(attrib.getValue);</span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clc</span><br><span class="line">clear all</span><br><span class="line"></span><br><span class="line">sampleXMLfile = <span class="string">&#x27;D:\Desktop\simple.xml&#x27;</span>;</span><br><span class="line"><span class="comment">% 显示simple.xml文件内容</span></span><br><span class="line"><span class="built_in">type</span>(sampleXMLfile)</span><br><span class="line"><span class="comment">% 将该XML文件读入DOM节点中</span></span><br><span class="line"><span class="comment">% DOMnode = xmlread(sampleXMLfile)</span></span><br><span class="line"><span class="comment">% 使用parseXML函数将示例文件info.xml解析为一个MATLAB结构体。</span></span><br><span class="line">mlStruct = parseXML(sampleXMLfile)</span><br><span class="line"></span><br><span class="line"><span class="comment">% 命令行窗口输出结果</span></span><br><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;ISO-8859-1&quot;</span>?&gt;</span><br><span class="line">&lt;!-- Edited by XMLSpy庐 --&gt;</span><br><span class="line">&lt;breakfast_menu&gt;</span><br><span class="line">&lt;food&gt;</span><br><span class="line">&lt;name&gt;Belgian Waffles&lt;/name&gt;</span><br><span class="line">&lt;price&gt;$<span class="number">5.95</span>&lt;/price&gt;</span><br><span class="line">&lt;calories&gt;<span class="number">650</span>&lt;/calories&gt;</span><br><span class="line">&lt;cropRegion x=<span class="string">&quot;0&quot;</span> y=<span class="string">&quot;0&quot;</span> width=<span class="string">&quot;0000&quot;</span> height=<span class="string">&quot;1234&quot;</span>/&gt;</span><br><span class="line">&lt;/food&gt;</span><br><span class="line">&lt;food&gt;</span><br><span class="line">&lt;name&gt;Strawberry Belgian Waffles&lt;/name&gt;</span><br><span class="line">&lt;price&gt;$<span class="number">7.95</span>&lt;/price&gt;</span><br><span class="line">&lt;calories&gt;<span class="number">900</span>&lt;/calories&gt;</span><br><span class="line">&lt;cropRegion x=<span class="string">&quot;1&quot;</span> y=<span class="string">&quot;1&quot;</span> width=<span class="string">&quot;1111&quot;</span> height=<span class="string">&quot;2345&quot;</span>/&gt;</span><br><span class="line">&lt;/food&gt;</span><br><span class="line">&lt;food&gt;</span><br><span class="line">&lt;name&gt;Berry-Berry Belgian Waffles&lt;/name&gt;</span><br><span class="line">&lt;price&gt;$<span class="number">8.95</span>&lt;/price&gt;</span><br><span class="line">&lt;calories&gt;<span class="number">900</span>&lt;/calories&gt;</span><br><span class="line">&lt;cropRegion x=<span class="string">&quot;2&quot;</span> y=<span class="string">&quot;2&quot;</span> width=<span class="string">&quot;2222&quot;</span> height=<span class="string">&quot;3456&quot;</span>/&gt;</span><br><span class="line">&lt;/food&gt;</span><br><span class="line">&lt;food&gt;</span><br><span class="line">&lt;name&gt;French Toast&lt;/name&gt;</span><br><span class="line">&lt;price&gt;$<span class="number">4.50</span>&lt;/price&gt;</span><br><span class="line">&lt;calories&gt;<span class="number">600</span>&lt;/calories&gt;</span><br><span class="line">&lt;cropRegion x=<span class="string">&quot;3&quot;</span> y=<span class="string">&quot;3&quot;</span> width=<span class="string">&quot;3333&quot;</span> height=<span class="string">&quot;4567&quot;</span>/&gt;</span><br><span class="line">&lt;/food&gt;</span><br><span class="line">&lt;food&gt;</span><br><span class="line">&lt;name&gt;Homestyle Breakfast&lt;/name&gt;</span><br><span class="line">&lt;price&gt;$<span class="number">6.95</span>&lt;/price&gt;</span><br><span class="line">&lt;calories&gt;<span class="number">950</span>&lt;/calories&gt;</span><br><span class="line">&lt;cropRegion x=<span class="string">&quot;4&quot;</span> y=<span class="string">&quot;4&quot;</span> width=<span class="string">&quot;4444&quot;</span> height=<span class="string">&quot;5678&quot;</span>/&gt;</span><br><span class="line">&lt;/food&gt;</span><br><span class="line">&lt;/breakfast_menu&gt;</span><br><span class="line"></span><br><span class="line">mlStruct = </span><br><span class="line">  包含以下字段的 <span class="number">1</span>×<span class="number">2</span> struct 数组:</span><br><span class="line">    Name</span><br><span class="line">    Attributes</span><br><span class="line">    Data</span><br><span class="line">    Children</span><br></pre></td></tr></table></figure><h4 id="（2）写入XML-1"><a href="#（2）写入XML-1" class="headerlink" title="（2）写入XML"></a><strong>（2）写入XML</strong></h4><blockquote><p>分两步编写<code>XML</code>文件：</p><p>①创建一个包含<code>XML</code>数据的文档对象模型 (<code>DOM</code>) 节点；</p><p>②将该<code>DOM</code>节点写入一个<code>XML</code>文件。</p></blockquote><p>要实现的写入内容：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">toc</span> <span class="attr">version</span>=<span class="string">&quot;2.0&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tocitem</span> <span class="attr">target</span>=<span class="string">&quot;upslope_product_page.html&quot;</span>&gt;</span>Upslope Area Toolbox<span class="comment">&lt;!-- Functions --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tocitem</span> <span class="attr">target</span>=<span class="string">&quot;demFlow_help.html&quot;</span>&gt;</span>demFlow<span class="tag">&lt;/<span class="name">tocitem</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tocitem</span> <span class="attr">target</span>=<span class="string">&quot;facetFlow_help.html&quot;</span>&gt;</span>facetFlow<span class="tag">&lt;/<span class="name">tocitem</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tocitem</span> <span class="attr">target</span>=<span class="string">&quot;flowMatrix_help.html&quot;</span>&gt;</span>flowMatrix<span class="tag">&lt;/<span class="name">tocitem</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tocitem</span> <span class="attr">target</span>=<span class="string">&quot;pixelFlow_help.html&quot;</span>&gt;</span>pixelFlow<span class="tag">&lt;/<span class="name">tocitem</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tocitem</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">toc</span>&gt;</span></span><br></pre></td></tr></table></figure><p>利用<code>xmlwrite()</code>写入<code>XML</code>文档：</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clc</span><br><span class="line">clear all</span><br><span class="line"></span><br><span class="line"><span class="comment">% 创建DOM节点对象和根元素，然后根据XML数据填充节点元素和节点属性。</span></span><br><span class="line">docNode = com.mathworks.xml.XMLUtils.createDocument(<span class="string">&#x27;toc&#x27;</span>);</span><br><span class="line"><span class="comment">% 确定根元素并设置version属性。</span></span><br><span class="line">toc = docNode.getDocumentElement;</span><br><span class="line">toc.setAttribute(<span class="string">&#x27;version&#x27;</span>,<span class="string">&#x27;2.0&#x27;</span>);</span><br><span class="line"><span class="comment">% 添加tocitem元素。此文件中的每个tocitem元素都有一个target属性和一个子文本节点。</span></span><br><span class="line">product = docNode.createElement(<span class="string">&#x27;tocitem&#x27;</span>);</span><br><span class="line">product.setAttribute(<span class="string">&#x27;target&#x27;</span>,<span class="string">&#x27;upslope_product_page.html&#x27;</span>);</span><br><span class="line">product.appendChild(docNode.createTextNode(<span class="string">&#x27;Upslope Area Toolbox&#x27;</span>));</span><br><span class="line">toc.appendChild(product);</span><br><span class="line"><span class="comment">% 添加注释</span></span><br><span class="line">product.appendChild(docNode.createComment(<span class="string">&#x27; Functions &#x27;</span>));</span><br><span class="line"><span class="comment">% 为每个函数添加一个tocitem元素</span></span><br><span class="line">functions = &#123;<span class="string">&#x27;demFlow&#x27;</span>,<span class="string">&#x27;facetFlow&#x27;</span>,<span class="string">&#x27;flowMatrix&#x27;</span>,<span class="string">&#x27;pixelFlow&#x27;</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> idx = <span class="number">1</span>:<span class="built_in">numel</span>(functions)</span><br><span class="line">    curr_node = docNode.createElement(<span class="string">&#x27;tocitem&#x27;</span>);</span><br><span class="line">    </span><br><span class="line">    curr_file = [functions&#123;idx&#125; <span class="string">&#x27;_help.html&#x27;</span>]; </span><br><span class="line">    curr_node.setAttribute(<span class="string">&#x27;target&#x27;</span>,curr_file);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">% Child text is the function name.</span></span><br><span class="line">    curr_node.appendChild(docNode.createTextNode(functions&#123;idx&#125;));</span><br><span class="line">    product.appendChild(curr_node);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">% 将DOM节点导出到名为infoUAT.xml的XML文件中，并使用type函数查看该文件</span></span><br><span class="line">xmlwrite(<span class="string">&#x27;D:\Desktop\infoUAT.xml&#x27;</span>,docNode);</span><br><span class="line"><span class="built_in">type</span>(<span class="string">&#x27;D:\Desktop\infoUAT.xml&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 命令行窗口输出结果</span></span><br><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="line">&lt;toc version=<span class="string">&quot;2.0&quot;</span>&gt;</span><br><span class="line">   &lt;tocitem target=<span class="string">&quot;upslope_product_page.html&quot;</span>&gt;Upslope Area Toolbox&lt;!-- Functions --&gt;  &lt;tocitem target=<span class="string">&quot;demFlow_help.html&quot;</span>&gt;demFlow&lt;/tocitem&gt;</span><br><span class="line">      &lt;tocitem target=<span class="string">&quot;facetFlow_help.html&quot;</span>&gt;facetFlow&lt;/tocitem&gt;</span><br><span class="line">      &lt;tocitem target=<span class="string">&quot;flowMatrix_help.html&quot;</span>&gt;flowMatrix&lt;/tocitem&gt;</span><br><span class="line">      &lt;tocitem target=<span class="string">&quot;pixelFlow_help.html&quot;</span>&gt;pixelFlow&lt;/tocitem&gt;</span><br><span class="line">   &lt;/tocitem&gt;</span><br><span class="line">&lt;/toc&gt;</span><br></pre></td></tr></table></figure><h3 id="👀TXT（函数例举）"><a href="#👀TXT（函数例举）" class="headerlink" title="👀TXT（函数例举）"></a>👀TXT（函数例举）</h3><blockquote><ul><li><p><code>textread()</code></p></li><li><p><code>textscan()</code></p></li><li><p><code>readmatrix()</code></p></li><li><p><code>writematrix()</code></p></li><li><p><code>readtable()</code></p></li><li><p><code>writetable()</code></p></li><li><p><code>load()</code></p></li><li><p><code>dlmread()</code></p></li><li><p><code>dlmwrite()</code></p></li><li><p><code>importdata()</code></p></li><li><p><code>save()</code></p></li><li><p>……</p></li></ul></blockquote><h2 id="⛄IDL之读写文件"><a href="#⛄IDL之读写文件" class="headerlink" title="⛄IDL之读写文件"></a>⛄IDL之读写文件</h2><p><code>IDL</code>从磁盘上的文件读写数据，必须首先把一个逻辑设备号连接到一个特定的文件，然后进行文件操作如打开、关闭和读取等。<code>IDL</code>中的逻辑设备号范围是<code>-2—128</code>，其中<code>1-99</code>是可以用户任意指定的，<code>100-128</code>是根据<code>get_lun</code>和<code>free_lun</code>来管理的，其他是特殊函数专用的。<code>IDL</code>中文件操作的函数列表：</p><table><thead><tr><th>函数名字</th><th>作用</th></tr></thead><tbody><tr><td><code>OpenR</code></td><td>以只读方式打开已存在文件；</td></tr><tr><td><code>OpenW</code></td><td>创建一个可以读写的新文件；</td></tr><tr><td><code>OpenU</code></td><td>以更新模式打开已存在文件；</td></tr><tr><td><code>File_Search()</code></td><td>对文件名进行特定的查找；</td></tr><tr><td><code>Dialog_Pickfile()</code></td><td>对话框方式选择文件；</td></tr><tr><td><code>Fstat()</code></td><td>返回一个已打开文件的信息；</td></tr><tr><td><code>EOF()</code></td><td>检测是否到文件末；</td></tr><tr><td><code>CLOSE</code></td><td>关闭一个文件；</td></tr><tr><td><code>Free_Lun</code></td><td>释放一个逻辑设备号并关闭文件；</td></tr></tbody></table><p><code>IDL</code>在读写该文件分为有两种格式化文件：自由文件格式和确定的文件格式。</p><p>自由文件格式是用逗号或空白（<code>tab</code>键和空格键）分开文件中的每个元素的<code>ASCII</code>文件。确定的格式文件是用格式说明按照给定的规范进行编排的。二者相比后者比前者更正规一些。</p><p><strong>读写自由文件格式：</strong><code>IDL</code>下用<code>ReadF</code>从文件中读入自由格式数据，<code>Printf</code>写入自由格式数据到文件中。<code>IDL</code>中读写自由格式文件遵循下面的几个规则：</p><ul><li><p>如果读入到字符串变量中，那么，在当前行剩下的所有字符都将读入该变量中；</p></li><li><p>输入数据必须用逗号或空白分隔（空格键或 tab 键）；</p></li><li><p>输入通过数字变量完成。数组和结构都可作为数字变量的集合；</p></li><li><p>如果当前读入行是空的，并且还有变量要求输入，则读取另一行；</p></li><li><p>如果当前读入行不是空的，但是没有变量要求输入，则忽略此行剩下的数；</p></li><li><p>尽量将数据转换为变量所希望的数据类型；</p></li><li><p>复数数据必须有实数和虚数两部分，用逗号分隔，并用括号括起来。</p></li></ul><p><strong>读写确定的文件格式：</strong>读写确定文件格式可同样用<code>ReadF</code>和<code>PrintF</code>命令，它们刚才已用于自由格式文件，但现在文件格式已由<code>Format</code>关键字明确声明。（在读写标准输入和输出时，也可将<code>Format</code>关键字用于<code>Read</code>和<code>Print</code>令）。</p><h3 id="👀CSV-2"><a href="#👀CSV-2" class="headerlink" title="👀CSV"></a>👀CSV</h3><p><code>CSV</code>示例源文件：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lon,lat,area</span><br><span class="line">101,50,20</span><br><span class="line">102,51,22</span><br><span class="line">103,52,24</span><br><span class="line">104,53,21</span><br><span class="line">105,54,25</span><br><span class="line">106,55,20</span><br><span class="line">107,56,25</span><br><span class="line">108,57,20</span><br><span class="line">109,58,18</span><br><span class="line">110,59,20.58333333</span><br><span class="line">111,60,20.36666667</span><br><span class="line">112,61,20.15</span><br><span class="line">113,62,19.93333333</span><br><span class="line">114,63,19.71666667</span><br><span class="line">115,64,19.5</span><br><span class="line">116,65,19.28333333</span><br></pre></td></tr></table></figure><p>读取<code>CSV</code>文件：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pro Demo02</span><br><span class="line">  ; 打开csv文件</span><br><span class="line">  csv_file = &#x27;D:\Desktop\data_p2.csv&#x27;</span><br><span class="line">  ; 读取文件</span><br><span class="line">  ; 第一行是索引,参数par_name(无论需不需要第一行索引数据，read_csv()函数默认都不会去读取第一行的数据)</span><br><span class="line">  data_csv = Read_csv(csv_file, header=par_name)</span><br><span class="line">  ; 查看data的类型,是一个结构体</span><br><span class="line">  ; Help, data_csv</span><br><span class="line">  ; 输出第一列数据</span><br><span class="line">  Print, data_csv.(0)</span><br><span class="line">  ; 输出第一行的索引数据</span><br><span class="line">  Print, par_name</span><br><span class="line">  ; 输出列索引是lat的数据(第一种方法可以数它所在的列号按上面的方式进行读取并输出，也可按下面这种方法)</span><br><span class="line">  lon = Where(par_name EQ &#x27;lat&#x27;)</span><br><span class="line">  Print, data_csv.(lon) </span><br><span class="line">END</span><br><span class="line"></span><br><span class="line">; IDL控制台输出结果（结果样式与控制台的宽度有关）</span><br><span class="line">% Compiled module: DEMO02.</span><br><span class="line">         101         102         103         104         105</span><br><span class="line">         106         107         108         109         110</span><br><span class="line">         111         112         113         114         115</span><br><span class="line">         116</span><br><span class="line">lon lat area</span><br><span class="line">          50          51          52          53          54</span><br><span class="line">          55          56          57          58          59</span><br><span class="line">          60          61          62          63          64</span><br><span class="line">          65</span><br></pre></td></tr></table></figure><p>写入<code>CSV</code>文件：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pro Demo04_csv</span><br><span class="line">    ; 打开csv文件,获取数据</span><br><span class="line">    csv_file = &#x27;D:\Desktop\data_p2.csv&#x27;</span><br><span class="line">    ; 读取文件</span><br><span class="line">    ; 第一行的索引给了,参数par_name(但是无论你需不需要第一行索引数据，read_csv()函数默认都不会去读取第一行的数据)</span><br><span class="line">    data_csv = Read_csv(csv_file, header=par_name)</span><br><span class="line">    ; 查看data的类型,是一个结构体</span><br><span class="line">    ; Help, data_csv</span><br><span class="line">    ; 输出第一列数据</span><br><span class="line">    Print, data_csv.(0)</span><br><span class="line">    ; 输出第一行的索引数据</span><br><span class="line">    Print, par_name</span><br><span class="line">    ; 输出列索引是lat的数据(第一种方法你可以自己去数它所在的列号按上面的方式进行读取并输出，也可以按下面这种方法)</span><br><span class="line">    lon = Where(par_name EQ &#x27;lat&#x27;)</span><br><span class="line">    Print, data_csv.(lon)</span><br><span class="line">    </span><br><span class="line">    ; 写入csv文件</span><br><span class="line">    save_file = &#x27;D:\Desktop\data_p3.csv&#x27;</span><br><span class="line">    data_size = size(data_csv.(2))</span><br><span class="line">    length = data_size[-1]</span><br><span class="line">    data_box = fltarr(3,length)</span><br><span class="line">    data_box[0,*] = data_csv.(0)</span><br><span class="line">    data_box[1,*] = data_csv.(1)</span><br><span class="line">    data_box[2,*] = data_csv.(2)</span><br><span class="line">    print,data_box</span><br><span class="line">    Write_csv, save_file, data_box</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">; IDL控制台输出结果</span><br><span class="line">% Compiled module: DEMO04_CSV.</span><br><span class="line">         101         102         103</span><br><span class="line">         104         105         106</span><br><span class="line">         107         108         109</span><br><span class="line">         110         111         112</span><br><span class="line">         113         114         115</span><br><span class="line">         116</span><br><span class="line">lon lat area</span><br><span class="line">          50          51          52</span><br><span class="line">          53          54          55</span><br><span class="line">          56          57          58</span><br><span class="line">          59          60          61</span><br><span class="line">          62          63          64</span><br><span class="line">          65</span><br><span class="line">      101.000      50.0000      20.0000</span><br><span class="line">      102.000      51.0000      22.0000</span><br><span class="line">      103.000      52.0000      24.0000</span><br><span class="line">      104.000      53.0000      21.0000</span><br><span class="line">      105.000      54.0000      25.0000</span><br><span class="line">      106.000      55.0000      20.0000</span><br><span class="line">      107.000      56.0000      25.0000</span><br><span class="line">      108.000      57.0000      20.0000</span><br><span class="line">      109.000      58.0000      18.0000</span><br><span class="line">      110.000      59.0000      20.5833</span><br><span class="line">      111.000      60.0000      20.3667</span><br><span class="line">      112.000      61.0000      20.1500</span><br><span class="line">      113.000      62.0000      19.9333</span><br><span class="line">      114.000      63.0000      19.7167</span><br><span class="line">      115.000      64.0000      19.5000</span><br><span class="line">      116.000      65.0000      19.2833</span><br><span class="line">% Compiled module: WRITE_CSV.</span><br></pre></td></tr></table></figure><h3 id="👀XML-2"><a href="#👀XML-2" class="headerlink" title="👀XML"></a>👀XML</h3><p><code>XML</code>示例源文件：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;ISO-8859-1&quot;</span>?&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Edited by XMLSpyÂ® --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">breakfast_menu</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">food</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>Belgian Waffles<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">price</span>&gt;</span>$5.95<span class="tag">&lt;/<span class="name">price</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">calories</span>&gt;</span>650<span class="tag">&lt;/<span class="name">calories</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">cropRegion</span> <span class="attr">x</span>=<span class="string">&quot;0&quot;</span> <span class="attr">y</span>=<span class="string">&quot;0&quot;</span> <span class="attr">width</span>=<span class="string">&quot;0000&quot;</span> <span class="attr">height</span>=<span class="string">&quot;1234&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">food</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">food</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>Strawberry Belgian Waffles<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">price</span>&gt;</span>$7.95<span class="tag">&lt;/<span class="name">price</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">calories</span>&gt;</span>900<span class="tag">&lt;/<span class="name">calories</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">cropRegion</span> <span class="attr">x</span>=<span class="string">&quot;1&quot;</span> <span class="attr">y</span>=<span class="string">&quot;1&quot;</span> <span class="attr">width</span>=<span class="string">&quot;1111&quot;</span> <span class="attr">height</span>=<span class="string">&quot;2345&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">food</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">food</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>Berry-Berry Belgian Waffles<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">price</span>&gt;</span>$8.95<span class="tag">&lt;/<span class="name">price</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">calories</span>&gt;</span>900<span class="tag">&lt;/<span class="name">calories</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">cropRegion</span> <span class="attr">x</span>=<span class="string">&quot;2&quot;</span> <span class="attr">y</span>=<span class="string">&quot;2&quot;</span> <span class="attr">width</span>=<span class="string">&quot;2222&quot;</span> <span class="attr">height</span>=<span class="string">&quot;3456&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">food</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">food</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>French Toast<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">price</span>&gt;</span>$4.50<span class="tag">&lt;/<span class="name">price</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">calories</span>&gt;</span>600<span class="tag">&lt;/<span class="name">calories</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">cropRegion</span> <span class="attr">x</span>=<span class="string">&quot;3&quot;</span> <span class="attr">y</span>=<span class="string">&quot;3&quot;</span> <span class="attr">width</span>=<span class="string">&quot;3333&quot;</span> <span class="attr">height</span>=<span class="string">&quot;4567&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">food</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">food</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>Homestyle Breakfast<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">price</span>&gt;</span>$6.95<span class="tag">&lt;/<span class="name">price</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">calories</span>&gt;</span>950<span class="tag">&lt;/<span class="name">calories</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">cropRegion</span> <span class="attr">x</span>=<span class="string">&quot;4&quot;</span> <span class="attr">y</span>=<span class="string">&quot;4&quot;</span> <span class="attr">width</span>=<span class="string">&quot;4444&quot;</span> <span class="attr">height</span>=<span class="string">&quot;5678&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">food</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">breakfast_menu</span>&gt;</span></span><br></pre></td></tr></table></figure><p>读取<code>XML</code>文件：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pro Demo02</span><br><span class="line">  XML_file = &#x27;D:\Desktop\simple.xml&#x27;</span><br><span class="line">  XML = IDLffXMLDOMDocument(filename = XML_file)</span><br><span class="line">  name = XML.Getelementsbytagname(&#x27;name&#x27;)</span><br><span class="line">  name = name.item(4)</span><br><span class="line">  print,(name.getfirstchild()).getnodevalue()</span><br><span class="line">  ; 获取属性值</span><br><span class="line">  cropRegion = XML.Getelementsbytagname(&#x27;cropRegion&#x27;)</span><br><span class="line">  cropRegion = cropRegion.Item(4)</span><br><span class="line">  print,cropRegion.GetAttribute(&#x27;height&#x27;)</span><br><span class="line">  ; 销毁对象</span><br><span class="line">  Obj_destroy, name</span><br><span class="line">  Obj_destroy, XML</span><br><span class="line">END</span><br><span class="line"></span><br><span class="line">; IDL控制台输出结果</span><br><span class="line">% Compiled module: DEMO02.</span><br><span class="line">Homestyle Breakfast</span><br><span class="line">5678</span><br></pre></td></tr></table></figure><h3 id="👀TXT-1"><a href="#👀TXT-1" class="headerlink" title="👀TXT"></a>👀TXT</h3><p><code>TXT</code>示例源文件：</p><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">lonlatarea</span><br><span class="line">1015020</span><br><span class="line">1025122</span><br><span class="line">1035224</span><br><span class="line">1045321</span><br><span class="line">1055425</span><br><span class="line">1065520</span><br><span class="line">1075625</span><br><span class="line">1085720</span><br><span class="line">1095818</span><br><span class="line">1105920.58333333</span><br><span class="line">1116020.36666667</span><br><span class="line">1126120.15</span><br><span class="line">1136219.93333333</span><br><span class="line">1146319.71666667</span><br><span class="line">1156419.5</span><br><span class="line">1166519.28333333</span><br></pre></td></tr></table></figure><p>读取<code>TXT</code>文件：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pro Demo02</span><br><span class="line">  ; 文件路径 </span><br><span class="line">  fn = &#x27;D:\Desktop\data_p1.txt&#x27;</span><br><span class="line">  ; （1）第一种方法，打开txt文件</span><br><span class="line">  ; 如果你只是读文件openr就可以了，openw既可以读也可以写(会覆盖原来的文件，慎用)</span><br><span class="line">  ; 第一个lun用来表示这个文件的内存地址,第二个fn是该文件的路径，第三个/get_lun动态获取地址</span><br><span class="line">  openr, lun, fn, /get_lun</span><br><span class="line">  ; 由于第一行是索引，索引是文字，索引下面是数字， 两者类型不一致，不能放在一个数组里面存储，所以需要跳过</span><br><span class="line">  ; 第一个lun表示文件的编号或者说是内存地址的代称，第二个1表示需要跳过的行数，这里只跳过第一行，所以是1，第三个表示第二个参数的单位是行而不是列</span><br><span class="line">  skip_lun, lun, 1, /lines</span><br><span class="line">  ; 创建存储的数组</span><br><span class="line">  ; 通过记事本打开该文件事先查看到该文件的数据的行列数(共有3列17行，但是第一行跳过所以只需要16行)</span><br><span class="line">  data = fltarr(3,16)</span><br><span class="line">  ; 获取文件的数据</span><br><span class="line">  readf, lun, data</span><br><span class="line">  ; 检验一下，获取某一个数据</span><br><span class="line">  print, data[2, -1]</span><br><span class="line">  ; 关闭文件</span><br><span class="line">  free_lun,lun</span><br><span class="line">  </span><br><span class="line">  ; （2）第二种方法，打开txt文件</span><br><span class="line">  openr, lun, fn, /get_lun</span><br><span class="line">  ; 获得第一行的索引数据，也是有用的(获取列数)</span><br><span class="line">  ; 预先有一个str变量存储</span><br><span class="line">  str = &#x27;&#x27;</span><br><span class="line">  ; readf是秉承着有多少给多少，现在str是一个字符串，默认输出一行，如果你是数组，那么根据数组的行列数有多少给多少</span><br><span class="line">  ; 对得到的存储有第一行索引数据的str变量进行分析，通过该字符串分析出整个数据有多少列</span><br><span class="line">  Readf, lun, str</span><br><span class="line">  ; 默认以空格作为该字符串的分隔符  </span><br><span class="line">  son_str_array = Strsplit(str, /extract)</span><br><span class="line">  ; son_str_array里面有几个元素，那么整个数据就有几列</span><br><span class="line">  column = N_elements(son_str_array)</span><br><span class="line">  ; 现在获取行数,第一行是索引,所以需要减去1</span><br><span class="line">  row = File_lines(fn) - 1</span><br><span class="line">  ; 创建存储的数组</span><br><span class="line">  box_data = Fltarr(column, row)</span><br><span class="line">  ; 获取数据（这里行数是从第二行开头开始的，因为前面已经readf, lun, str，文件指针已经指到第二行开头处）</span><br><span class="line">  Readf, lun, box_data</span><br><span class="line">  ; 检验一下，获取某一个数据</span><br><span class="line">  Print, box_data[2, -1]</span><br><span class="line">  ; 关闭文件</span><br><span class="line">  Free_lun, 1</span><br><span class="line">  </span><br><span class="line">  ; （3）第三种方法，打开txt文件</span><br><span class="line">  Openr, lun, fn, /get_lun</span><br><span class="line">  skip_lun, lun, 1, /lines</span><br><span class="line">  ; 读取文件的行数</span><br><span class="line">  row = File_lines(fn) - 1</span><br><span class="line">  ; 创建存储的列表,列数是通过txt记事本打开看到的</span><br><span class="line">  ; 相对来说，列数比较固定，行数不确定</span><br><span class="line">  box_data2 = Fltarr(5, row)</span><br><span class="line">  Readf, lun, box_data</span><br><span class="line">  ; 检验一下</span><br><span class="line">  Print, box_data[2, -1]</span><br><span class="line">  ; 关闭文件</span><br><span class="line">  Free_lun, lun</span><br><span class="line">END</span><br><span class="line"></span><br><span class="line">; IDL控制台输出结果</span><br><span class="line">% Compiled module: DEMO02.</span><br><span class="line">      19.2833</span><br><span class="line">      19.2833</span><br><span class="line">      19.2833</span><br></pre></td></tr></table></figure><p>写入<code>TXT</code>文件：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pro print_test</span><br><span class="line">  ;  写入txt</span><br><span class="line">  outfilepath=&#x27;D:\Desktop\&#x27;</span><br><span class="line">  outfilename = STRCOMPRESS(outfilepath+&#x27;navi_route.txt&#x27;,/remove_all)</span><br><span class="line">  openw,var_lun,outfilename,/get_lun</span><br><span class="line">  for i=1,365 do begin</span><br><span class="line">      z=i/2</span><br><span class="line">      if z gt 10 then begin</span><br><span class="line">        z=1024</span><br><span class="line">      endif else begin</span><br><span class="line">        z=150+i</span><br><span class="line">      endelse</span><br><span class="line">      printf,var_lun,FORMAT=&#x27;(I3,I10)&#x27;,i,z</span><br><span class="line">  endfor</span><br><span class="line">  close,var_lun</span><br><span class="line">  free_lun,var_lun</span><br><span class="line">  </span><br><span class="line">  ; 读取对应txt</span><br><span class="line">  infilepath=&#x27;D:\Desktop\&#x27;</span><br><span class="line">  Cd,infilepath</span><br><span class="line">  thesefiles = File_search(&#x27;navi_route.txt&#x27;)</span><br><span class="line">  result=Intarr(2,365)</span><br><span class="line">  Openr,lun,thesefiles[0],/get_lun</span><br><span class="line">  FOR i=0,365-1 DO BEGIN</span><br><span class="line">    Readf,lun,FORMAT=&#x27;(I3,I10)&#x27;,day,value</span><br><span class="line">    result[0,i]=Long(day)</span><br><span class="line">    result[1,i]=Long(value)</span><br><span class="line">  ENDFOR</span><br><span class="line">  Free_lun,lun</span><br><span class="line">  Print,result</span><br><span class="line">END</span><br><span class="line"></span><br><span class="line">; IDL控制台输出结果</span><br><span class="line">% Compiled module: PRINT_TEST.</span><br><span class="line">       1     151</span><br><span class="line">       2     152</span><br><span class="line">       3     153</span><br><span class="line">       4     154</span><br><span class="line">       5     155</span><br><span class="line">       6     156</span><br><span class="line">       7     157</span><br><span class="line">       8     158</span><br><span class="line">       9     159</span><br><span class="line">      10     160</span><br><span class="line">      11     161</span><br><span class="line">      ... ...</span><br><span class="line">     358    1024</span><br><span class="line"> 359    1024</span><br><span class="line">     360    1024</span><br><span class="line">     361    1024</span><br><span class="line">     362    1024</span><br><span class="line">     363    1024</span><br><span class="line">     364    1024</span><br><span class="line">     365    1024</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> Matlab </category>
          
          <category> IDL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文件读写 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>哨兵系列数据下载地址及流程更新【202310】</title>
      <link href="/2023/10/28/Sentinel-Download/"/>
      <url>/2023/10/28/Sentinel-Download/</url>
      
        <content type="html"><![CDATA[<p>﻿<strong>哨兵系列卫星</strong>作为哥白尼计划的一部分，主要目标便是对地球的观测任务。哥白尼计划由三部分组成：</p><ul><li>空间部分（<strong>哨兵系列</strong>太空任务与其他太空机构任务）</li><li>测量部分（提供海洋、大陆表面和大气信息的陆基和机载数据收集网络）</li><li>数据管理与全球共享</li></ul><table><thead><tr><th>卫星名</th><th>发射时间</th><th>终止时间</th><th>卫星定位</th></tr></thead><tbody><tr><td>Sentinel-1A</td><td>2014.04.03</td><td>在轨运行，预期寿命7年</td><td>雷达</td></tr><tr><td>Sentinel-1B</td><td>2016.04.25</td><td>在轨运行，预期寿命7年</td><td>雷达</td></tr><tr><td>Sentinel-2A</td><td>2015.06.23</td><td>在轨运行，预期寿命7年</td><td>高分辨率光学</td></tr><tr><td>Sentinel-2B</td><td>2017.03.07</td><td>在轨运行，预期寿命7年</td><td>高分辨率光学</td></tr><tr><td>Sentinel-3A</td><td>2016.02.16</td><td>在轨运行，预期寿命7年</td><td>包含雷达、光学、定位等7类传感器</td></tr><tr><td>Sentinel-3B</td><td>2018.04.25</td><td>在轨运行，预期寿命7年</td><td>包含雷达、光学、定位等7类传感器</td></tr><tr><td>Sentinel-5P</td><td>2017.10.13</td><td>在轨运行，预期寿命7年</td><td>大气污染观测</td></tr><tr><td>…</td><td>…</td><td>…</td><td>…</td></tr></tbody></table><h2 id="⛄Sentinel数据下载问题及新服务"><a href="#⛄Sentinel数据下载问题及新服务" class="headerlink" title="⛄Sentinel数据下载问题及新服务"></a>⛄Sentinel数据下载问题及新服务</h2><p>当前，在<a href="https://scihub.copernicus.eu/">欧空局官网</a>下载哨兵数据时，筛选合适的数据（包括<code>online</code>和<code>Offline</code>两种形式数据）添加到购物车，申请<code>offline</code>状态的数据再次上线，等待半天或者一天仍然申请失败。通过查询<a href="https://scihub.copernicus.eu/">欧空局官网</a>的<a href="https://scihub.copernicus.eu/news/News01242">最新消息</a>可知：</p><blockquote><p><strong>Copernicus Open Access Hub is closing at the end of October 2023. Copernicus Sentinel Data Access is now fully available in the Copernicus Data Space Ecosystem</strong></p><p>As previously announced in <a href="https://scihub.copernicus.eu/news/News01146">January</a> the Copernicus Open Access Hub service continued its full operations until the end of June 2023, followed up by a gradual ramp-down phase until September 2023. The Copernicus Open Access Hub will be exceptionally extended for another month and will cease operations at the end of October 2023. To continue accessing Copernicus Sentinel data users will need to <a href="https://documentation.dataspace.copernicus.eu/Registration.html">self-register</a> on the new <a href="https://dataspace.copernicus.eu/">Copernicus Data Space Ecosystem</a>. A guide for migration is available <a href="https://dataspace.copernicus.eu/news/2023-7-13-accessing-sentinel-mission-data-new-copernicus-data-space-ecosystem-apis">here</a>.</p><p>The new service offers access to a wide range of Earth observation data and services as well as new <a href="https://dataspace.copernicus.eu/analyse">tools</a>, <a href="https://dataspace.copernicus.eu/browser/">GUI</a> and <a href="https://documentation.dataspace.copernicus.eu/APIs.html">APIs</a> to help users explore and analyse satellite imagery. Discover more about the Copernicus Data Space Ecosystem at <a href="https://dataspace.copernicus.eu/">https://dataspace.copernicus.eu</a></p><p>17 Oct 2023 - 13:18 UTC</p></blockquote><p>哥白尼开放访问中心将于2023年10月底关闭，哥白尼哨兵数据访问现在在哥白尼数据空间生态系统中完全可用。</p><p>正如之前在1月份宣布的那样，哥白尼开放访问中心服务将继续全面运营至2023年6月底，随后逐步减少，直到2023年9月。哥白尼开放访问中心将特别延长一个月，并将于2023年10月底停止运营。为了继续访问哥白尼哨兵数据，用户需要在新的哥白尼数据空间生态系统上自我注册。</p><p>新服务提供广泛的地球观测数据和服务，以及新的工具、<code>GUI</code>和<code>api</code>，以帮助用户探索和分析卫星图像。了解更多关于哥白尼数据空间生态系统的信息，请访问<a href="https://dataspace.copernicus.eu/">https://dataspace.copernicus.eu</a></p><h2 id="⛄Sentinel数据下载流程"><a href="#⛄Sentinel数据下载流程" class="headerlink" title="⛄Sentinel数据下载流程"></a>⛄Sentinel数据下载流程</h2><p><a href="https://dataspace.copernicus.eu/">哥白尼数据空间生态系统</a>（<a href="https://dataspace.copernicus.eu/">https://dataspace.copernicus.eu/</a>）</p><h3 id="👀打开网址"><a href="#👀打开网址" class="headerlink" title="👀打开网址"></a>👀打开<a href="https://dataspace.copernicus.eu/">网址</a></h3><p><a href="https://imgse.com/i/pieQouD"><img src="https://z1.ax1x.com/2023/10/28/pieQouD.jpg" alt="pieQouD.jpg"></a></p><h3 id="👀登录账户（自行注册：教程）"><a href="#👀登录账户（自行注册：教程）" class="headerlink" title="👀登录账户（自行注册：教程）"></a>👀登录账户（自行注册：<a href="https://documentation.dataspace.copernicus.eu/Registration.html">教程</a>）</h3><p><a href="https://imgse.com/i/pieQ4gK"><img src="https://z1.ax1x.com/2023/10/28/pieQ4gK.jpg" alt="pieQ4gK.jpg"></a></p><h3 id="👀打开下载界面"><a href="#👀打开下载界面" class="headerlink" title="👀打开下载界面"></a>👀打开<a href="https://dataspace.copernicus.eu/browser/">下载界面</a></h3><blockquote><p>主界面：<code>EXPLORE DATA</code>→<code>Copernicus Browser</code></p></blockquote><p><a href="https://imgse.com/i/pieQR41"><img src="https://z1.ax1x.com/2023/10/28/pieQR41.jpg" alt="pieQR41.jpg"></a><br><a href="https://imgse.com/i/pieQ2NR"><img src="https://z1.ax1x.com/2023/10/28/pieQ2NR.jpg" alt="pieQ2NR.jpg"></a></p><h3 id="👀哨兵数据筛选和添加"><a href="#👀哨兵数据筛选和添加" class="headerlink" title="👀哨兵数据筛选和添加"></a>👀哨兵数据筛选和添加</h3><blockquote><p>（1）目前支持：<code>Sentinel-1</code>、<code>Sentinel-2</code>、<code>Sentinel-3</code>、<code>Sentinel-5P</code></p><p>（2）对于少量数据可以直接点击下载；对于大量数据可以添加至工作空间。</p></blockquote><ul><li>点击”<code>SEARCH</code>“一栏，选择对应数据源和区域，设置时间，点击”<code>Search</code>“</li></ul><p><a href="https://imgse.com/i/pieQf9x"><img src="https://z1.ax1x.com/2023/10/28/pieQf9x.jpg" alt="pieQf9x.jpg"></a></p><ul><li>查看数据属性，筛选符合要求的数据源，添加到工作空间”<code>Add to workspace</code>“</li></ul><p><a href="https://imgse.com/i/pieQTDe"><img src="https://z1.ax1x.com/2023/10/28/pieQTDe.jpg" alt="pieQTDe.jpg"></a></p><h3 id="👀下载数据"><a href="#👀下载数据" class="headerlink" title="👀下载数据"></a>👀下载数据</h3><ul><li>打开工作空间：界面上方账户名（下箭头）→”<code>Workspace</code>“</li></ul><p><a href="https://imgse.com/i/pieQ5jO"><img src="https://z1.ax1x.com/2023/10/28/pieQ5jO.jpg" alt="pieQ5jO.jpg"></a><br><a href="https://imgse.com/i/pie1Tkd"><img src="https://z1.ax1x.com/2023/10/28/pie1Tkd.jpg" alt="pie1Tkd.jpg"></a></p><ul><li>勾选需要下载的数据，点击”<code>Download</code>“</li></ul><p><a href="https://imgse.com/i/pie1ITH"><img src="https://z1.ax1x.com/2023/10/28/pie1ITH.jpg" alt="pie1ITH.jpg"></a><br><a href="https://imgse.com/i/pieQ7HH"><img src="https://z1.ax1x.com/2023/10/28/pieQ7HH.jpg" alt="pieQ7HH.jpg"></a><br>多谢！多谢！<br>笔者不才，请多交流！！！</p>]]></content>
      
      
      <categories>
          
          <category> 遥感数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Sentinel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Himawari8-9数据下载和预处理教程</title>
      <link href="/2023/04/09/RS-Data-Process01/"/>
      <url>/2023/04/09/RS-Data-Process01/</url>
      
        <content type="html"><![CDATA[<p><code>Himawari-8</code>是2015年7月7日凌晨2点（<code>UTC</code>）发射并投入运行，<code>Himawari-9</code>是2016年11月2日发射的，于2017年3月开始后备作业。这两个卫星都计划运行到2029年。早期阶段，<code>Himawari-8</code>号将主要用于观测，而<code>Himawari-9</code>号将起到辅助作用。他们的运行将在2022年进行切换，将<code>Himawari-9</code>号置于主要观测角色，并以<code>Himawari-8</code>号为后备。</p><p><code>Himawari-8/9</code>的<code>AHIS</code>有16个观测波段(3个为可见光，3个为近红外，10个为红外)，全盘观测时间间隔为10分钟。<code>Himawari-8/9</code>的可见光波段分辨率为0.5-1公里，近红外和红外波段分辨率为1-2公里。</p><h2 id="⛄Himawari8-x2F-9数据下载"><a href="#⛄Himawari8-x2F-9数据下载" class="headerlink" title="⛄Himawari8&#x2F;9数据下载"></a>⛄Himawari8&#x2F;9数据下载</h2><h3 id="👀前期准备"><a href="#👀前期准备" class="headerlink" title="👀前期准备"></a>👀前期准备</h3><p>①进入<strong>Himawari8-9</strong>官网，<a href="https://www.eorc.jaxa.jp/ptree/index.html">JAXA Himawari Monitor</a>，<a href="https://www.eorc.jaxa.jp/ptree/registration_top.html">注册新用户</a>（已有请忽略）</p><p>②在注册的邮箱里面收到邮件，包括：<code>Address</code>、<code>UID</code>、<code>PW</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Arrress:ftp.ptree.jaxa.jp</span><br><span class="line">UID:**********</span><br><span class="line">PW:**********</span><br></pre></td></tr></table></figure><h3 id="👀FileZilla-Client方式下载"><a href="#👀FileZilla-Client方式下载" class="headerlink" title="👀FileZilla Client方式下载"></a>👀FileZilla Client方式下载</h3><p>①安装<code>FileZilla Client</code>；</p><p>②在“站点管理器”里面创建“新站点”，输入主机名称，即<code>Address</code>；输入用户，即<code>UID</code>；输入密码，即<code>PW</code>；</p><p>③连接远程站点，下载所需数据；</p><p>④文件夹和文件描述。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/jma/：Himawari标准数据(Himawari Standard Data)</span><br><span class="line">/pub/：Himawari地球物理参数数据(Himawari Geophysical Parameter Data)，基本实时可用</span><br></pre></td></tr></table></figure><h3 id="👀-x2F-jma-x2F-hsd"><a href="#👀-x2F-jma-x2F-hsd" class="headerlink" title="👀&#x2F;jma&#x2F;hsd"></a>👀&#x2F;jma&#x2F;hsd</h3><p><strong>（标准格式）数据描述，文件命名格式</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">********************************************************************************</span><br><span class="line"></span><br><span class="line"># Available Himawari Standard Data</span><br><span class="line"></span><br><span class="line">## Full-disk</span><br><span class="line"> Observation area: Full-disk</span><br><span class="line"> Temporal resolution: 10-minutes</span><br><span class="line"> Spatial resolution: 0.5km (band 3), 1km (band 1,2,4), 2km (band 5-16)</span><br><span class="line"></span><br><span class="line">## Japan Area</span><br><span class="line"> Observation area: Japan area (Region 1 &amp; 2)</span><br><span class="line"> Temporal resolution: 2.5-minutes</span><br><span class="line"> Spatial resolution: 0.5km (band 3), 1km (band 1,2,4), 2km (band 5-16)</span><br><span class="line"></span><br><span class="line">## Target Area</span><br><span class="line"> Observation area: Target area (Region 3)</span><br><span class="line"> Temporal resolution: 2.5-minutes</span><br><span class="line"> Spatial resolution: 0.5km (band 3), 1km (band 1,2,4), 2km (band 5-16)</span><br><span class="line"></span><br><span class="line">## Color Image Data</span><br><span class="line"> png images of Full-disk, Japan area and Target area, compositing three visible</span><br><span class="line"> bands (blue: 0.47 micron; green: 0.51 micron; red: 0.64 micron).</span><br><span class="line"></span><br><span class="line">********************************************************************************</span><br><span class="line"></span><br><span class="line"># TOP FTP Directory</span><br><span class="line"></span><br><span class="line"> /jma/</span><br><span class="line"></span><br><span class="line">********************************************************************************</span><br><span class="line"></span><br><span class="line"># Structure of FTP Directories</span><br><span class="line"></span><br><span class="line"> /jma/hsd</span><br><span class="line">       +---/[YYYYMM]</span><br><span class="line">              +---/[DD]</span><br><span class="line">                     +---/[hh]</span><br><span class="line"></span><br><span class="line"> where YYYY: 4-digit year of observation start time (timeline);</span><br><span class="line">       MM: 2-digit month of timeline;</span><br><span class="line">       DD: 2-digit day of timeline; and</span><br><span class="line">       hh: 2-digit hour of timeline.</span><br><span class="line"></span><br><span class="line">********************************************************************************</span><br><span class="line"></span><br><span class="line"># File Naming Convention</span><br><span class="line"></span><br><span class="line">## Full-disk</span><br><span class="line"> HS_Hnn_YYYYMMDD_hhmm_Bbb_FLDK_Rjj_Skkll.DAT</span><br><span class="line"></span><br><span class="line"> where nn: 2-digit number of Himawari satellite;</span><br><span class="line">         08: Himawari-8</span><br><span class="line">         09: Himawari-9</span><br><span class="line">       YYYY: 4-digit year of observation start time (timeline);</span><br><span class="line">       MM: 2-digit month of timeline;</span><br><span class="line">       DD: 2-digit day of timeline;</span><br><span class="line">       hh: 2-digit hour of timeline;</span><br><span class="line">       mm: 2-gidit minutes of timeline;</span><br><span class="line">       bb: 2-digit band number (varies from &quot;01&quot; to &quot;16&quot;);</span><br><span class="line">       jj: spatial resolution (&quot;05&quot;: 0.5km, &quot;10&quot;: 1.0km, &quot;20&quot;: 2.0km);</span><br><span class="line">       kk: segment number (varies from &quot;01&quot; to &quot;10&quot;); and</span><br><span class="line">       ll: total number of segments (fixed to &quot;10&quot;).</span><br><span class="line"></span><br><span class="line"> example: HS_H08_20150728_2200_B01_FLDK_R10_S0110.DAT</span><br><span class="line"></span><br><span class="line">## Japan Area</span><br><span class="line"> HS_Hnn_YYYYMMDD_hhmm_Bbb_JPee_Rjj_S0101.DAT</span><br><span class="line"></span><br><span class="line"> where nn: 2-digit number of Himawari satellite;</span><br><span class="line">         08: Himawari-8</span><br><span class="line">         09: Himawari-9</span><br><span class="line">       YYYY: 4-digit year of observation start time (timeline);</span><br><span class="line">       MM: 2-digit month of timeline;</span><br><span class="line">       DD: 2-digit day of timeline;</span><br><span class="line">       hh: 2-digit hour of timeline;</span><br><span class="line">       mm: 2-gidit minutes of timeline;</span><br><span class="line">       bb: 2-digit band number (varies from &quot;01&quot; to &quot;16&quot;);</span><br><span class="line">       ee: observation number on the timeline (varies from &quot;01&quot; to &quot;04&quot;); and</span><br><span class="line">       jj: spatial resolution (&quot;05&quot;: 0.5km, &quot;10&quot;: 1.0km, &quot;20&quot;: 2.0km);</span><br><span class="line"></span><br><span class="line"> example: HS_H08_20150728_2200_B01_JP01_R10_S0101.DAT</span><br><span class="line"></span><br><span class="line">## Target Area</span><br><span class="line"> HS_Hnn_YYYYMMDD_hhmm_Bbb_R3ee_Rjj_S0101.DAT</span><br><span class="line"></span><br><span class="line"> where nn: 2-digit number of Himawari satellite;</span><br><span class="line">         08: Himawari-8</span><br><span class="line">         09: Himawari-9</span><br><span class="line">       YYYY: 4-digit year of observation start time (timeline);</span><br><span class="line">       MM: 2-digit month of timeline;</span><br><span class="line">       DD: 2-digit day of timeline;</span><br><span class="line">       hh: 2-digit hour of timeline;</span><br><span class="line">       mm: 2-gidit minutes of timeline;</span><br><span class="line">       bb: 2-digit band number (varies from &quot;01&quot; to &quot;16&quot;);</span><br><span class="line">       ee: observation number on the timeline (varies from &quot;01&quot; to &quot;04&quot;); and</span><br><span class="line">       jj: spatial resolution (&quot;05&quot;: 0.5km, &quot;10&quot;: 1.0km, &quot;20&quot;: 2.0km);</span><br><span class="line"></span><br><span class="line"> example: HS_H08_20150728_2200_B01_R301_R10_S0101.DAT</span><br><span class="line"></span><br><span class="line">## Color Image Data</span><br><span class="line"> PI_Hnn_YYYYMMDD_hhmm_TRC_FLDK_Rjj_PGPDF,png (Full-disk)</span><br><span class="line"> PI_Hnn_YYYYMMDD_hhmm_TRC_JPee_Rjj_PLLJP.png (Japan Area)</span><br><span class="line"> PI_Hnn_YYYYMMDD_hhmm_TRC_R3ee_Rjj_PLLTG.png (Target Area)</span><br><span class="line"></span><br><span class="line"> where nn: 2-digit number of Himawari satellite;</span><br><span class="line">         08: Himawari-8</span><br><span class="line">         09: Himawari-9</span><br><span class="line">       YYYY: 4-digit year of observation start time (timeline);</span><br><span class="line">       MM: 2-digit month of timeline;</span><br><span class="line">       DD: 2-digit day of timeline;</span><br><span class="line">       hh: 2-digit hour of timeline;</span><br><span class="line">       mm: 2-gidit minutes of timeline;</span><br><span class="line">       ee: observation number on the timeline (varies from &quot;01&quot; to &quot;04&quot;); and</span><br><span class="line">       jj: spatial resolution (&quot;05&quot;: 0.5km, &quot;10&quot;: 1.0km, &quot;20&quot;: 2.0km);</span><br><span class="line"></span><br><span class="line"> example: PI_H08_20150728_2200_TRC_FLDK_R10_PGPFD.png (Full-disk)</span><br><span class="line">          PI_H08_20150728_2200_TRC_JP01_R10_PLLJP.png (Japan Area)</span><br><span class="line">          PI_H08_20150728_2200_TRC_R301_R10_PLLTG.png (Target Area)</span><br><span class="line"></span><br><span class="line">********************************************************************************</span><br><span class="line"></span><br><span class="line"># Format</span><br><span class="line"></span><br><span class="line"> All data is in Himawari Standard Data (HSD) format and compressed with bzip2, </span><br><span class="line"> except the Color Image Data which is archived in png format.</span><br><span class="line"></span><br><span class="line">********************************************************************************</span><br></pre></td></tr></table></figure><h3 id="👀-x2F-jma-x2F-netcdf"><a href="#👀-x2F-jma-x2F-netcdf" class="headerlink" title="👀&#x2F;jma&#x2F;netcdf"></a>👀&#x2F;jma&#x2F;netcdf</h3><p><strong>（NC格式）数据描述，文件命名格式</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">********************************************************************************</span><br><span class="line"></span><br><span class="line"># Available Himawari  L1 Gridded Data </span><br><span class="line"></span><br><span class="line">## Full-disk</span><br><span class="line"> Projection: EQR</span><br><span class="line"> Observation area: 60S-60N, 80E-160W</span><br><span class="line"> Temporal resolution: 10-minutes</span><br><span class="line"> Spatial resolution: 5km (Pixel number: 2401, Line number: 2401)</span><br><span class="line">                     2km (Pixel number: 6001, Line number: 6001)</span><br><span class="line"> Data: albedo(reflectance*cos(SOZ) of band01~band06)</span><br><span class="line">       Brightness temperature of band07~band16</span><br><span class="line">       satellite zenith angle, satellite azimuth angle, </span><br><span class="line">       solar zenith angle, solar azimuth angle, observation hours (UT)</span><br><span class="line"></span><br><span class="line">## Japan Area</span><br><span class="line"> Projection: EQR</span><br><span class="line"> Observation area: 24N-50N, 123E-150E</span><br><span class="line"> Temporal resolution: 10-minutes</span><br><span class="line"> Spatial resolution: 1km (Pixel number: 2701, Line number: 2601)</span><br><span class="line"> Data: albedo(reflectance*cos(SOZ) of band01~band06)</span><br><span class="line">       Brightness temperature of band07, 14, 15</span><br><span class="line">       satellite zenith angle, satellite azimuth angle, </span><br><span class="line">       solar zenith angle, solar azimuth angle, observation hours (UT)</span><br><span class="line"></span><br><span class="line">********************************************************************************</span><br><span class="line"></span><br><span class="line"># TOP FTP Directory</span><br><span class="line"></span><br><span class="line"> /jma/</span><br><span class="line"></span><br><span class="line">********************************************************************************</span><br><span class="line"></span><br><span class="line"># Structure of FTP Directories</span><br><span class="line"></span><br><span class="line"> /jma/netcdf</span><br><span class="line">       +---/[YYYYMM]</span><br><span class="line">              +---/[DD]</span><br><span class="line">                     +---/[hh]</span><br><span class="line"></span><br><span class="line"> where YYYY: 4-digit year of observation start time (timeline);</span><br><span class="line">       MM: 2-digit month of timeline;</span><br><span class="line">       DD: 2-digit day of timeline; and</span><br><span class="line">       hh: 2-digit hour of timeline.</span><br><span class="line"></span><br><span class="line">********************************************************************************</span><br><span class="line"></span><br><span class="line"># File Naming Convention</span><br><span class="line"></span><br><span class="line">## Full-disk</span><br><span class="line"> NC_Hnn_YYYYMDD_hhmm_Rbb_FLDK.xxxxx_yyyyy.nc</span><br><span class="line"></span><br><span class="line"> where nn: 2-digit number of Himawari satellite;</span><br><span class="line">         08: Himawari-8</span><br><span class="line">         09: Himawari-9</span><br><span class="line">       YYYY: 4-digit year of observation start time (timeline);</span><br><span class="line">       MM: 2-digit month of timeline;</span><br><span class="line">       DD: 2-digit day of timeline;</span><br><span class="line">       hh: 2-digit hour of timeline;</span><br><span class="line">       mm: 2-gidit minutes of timeline;</span><br><span class="line">       bb: 2-digit band number (varies from &quot;01&quot; to &quot;16&quot;);</span><br><span class="line">       xxxxx: pixel number; (&quot;2401&quot;: 5km resolution, </span><br><span class="line">                             &quot;6001&quot;: 2km resolution, )</span><br><span class="line">       yyyyy: line number; (&quot;2401&quot;: 5km resolution, </span><br><span class="line">                             &quot;6001&quot;: 2km resolution, )</span><br><span class="line"></span><br><span class="line"> Example: </span><br><span class="line">   NC_H08_20160831_0000_R21_FLDK.02401_02401.nc</span><br><span class="line">   NC_H08_20160831_0000_R21_FLDK.06001_06001.nc</span><br><span class="line"></span><br><span class="line">## Japan Area</span><br><span class="line"> NC_Hnn_YYYYMMDD_hhmm_rbb_FLDK.xxxxx_yyyyy.nc</span><br><span class="line"></span><br><span class="line"> where nn: 2-digit number of Himawari satellite;</span><br><span class="line">         08: Himawari-8</span><br><span class="line">         09: Himawari-9</span><br><span class="line">       YYYY: 4-digit year of observation start time (timeline);</span><br><span class="line">       MM: 2-digit month of timeline;</span><br><span class="line">       DD: 2-digit day of timeline;</span><br><span class="line">       hh: 2-digit hour of timeline;</span><br><span class="line">       mm: 2-gidit minutes of timeline;</span><br><span class="line">       bb: 2-digit band number (fixed to &quot;14&quot;);</span><br><span class="line">       xxxxx: pixel number; (fixed to &quot;2701&quot; : 1km resolution)</span><br><span class="line">       yyyyy: line number; (fixed to &quot;2601&quot; : 1km resolution)</span><br><span class="line"></span><br><span class="line"> Example: </span><br><span class="line">   NC_H08_20160831_0000_r14_FLDK.02701_02601.nc</span><br><span class="line"></span><br><span class="line">********************************************************************************</span><br><span class="line"></span><br><span class="line"># Format</span><br><span class="line"></span><br><span class="line"> All data is netCDF4 format.</span><br><span class="line"></span><br><span class="line">********************************************************************************</span><br></pre></td></tr></table></figure><h3 id="👀-x2F-pub-x2F-Himawari"><a href="#👀-x2F-pub-x2F-Himawari" class="headerlink" title="👀&#x2F;pub&#x2F;Himawari"></a>👀&#x2F;pub&#x2F;Himawari</h3><p><strong>（1）产品数据介绍</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">## Level 2 (every 10 minutes)</span><br><span class="line">    Aerosol Property (ARP)</span><br><span class="line">    Sea Surface Temperature (SST)(near-real-time)</span><br><span class="line">    Short Wave Radiation(SWR)</span><br><span class="line">    Photosynthetically Available Radiation(PAR)</span><br><span class="line">    Cloud Property (CLP)</span><br><span class="line">    Wild Fire (WLF)</span><br><span class="line">## Level 3 (hourly, daily, monthly)</span><br><span class="line">    Aerosol Property</span><br><span class="line">    Sea Surface Temperature (SST)(near-real-time)</span><br><span class="line">    Nighttime Sea Surface Temperature (SST)(near-real-time)</span><br><span class="line">    Short Wave Radiation(SWR)</span><br><span class="line">    Photosynthetically Available Radiation(PAR)</span><br><span class="line">    Chlorophyll-a (CHL)</span><br><span class="line">    Wild Fire (WLF)</span><br><span class="line"></span><br><span class="line">## 2级(每10分钟一次)</span><br><span class="line">    气溶胶特性(ARP)</span><br><span class="line">    海面温度(SST)(近实时)</span><br><span class="line">    短波辐射</span><br><span class="line">    光合有效辐射(PAR)</span><br><span class="line">    云属性(CLP)</span><br><span class="line">    野火(WLF)</span><br><span class="line">## 3级(每小时、每天、每月)</span><br><span class="line">    气溶胶特性</span><br><span class="line">    海面温度(SST)(近实时)</span><br><span class="line">    夜间海面温度(近实时)</span><br><span class="line">    短波辐射</span><br><span class="line">    光合有效辐射(PAR)</span><br><span class="line">    叶绿素a(CHL)</span><br><span class="line">    野火(WLF)</span><br></pre></td></tr></table></figure><p><strong>（2）数据描述，文件命名格式</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">********************************************************************************</span><br><span class="line"></span><br><span class="line"># Available Geophysical Parameters</span><br><span class="line"></span><br><span class="line">## Aerosol Property (day-time only)</span><br><span class="line"> Latest version: Version 3.1 (Level 2), Version 3.1 (Level 3)</span><br><span class="line"> Observation area: Full-disk</span><br><span class="line"> Temporal resolution: 10-minutes (Level 2),1-hour (Level 3), </span><br><span class="line">                      1-day (Level 3), 1-month (Level 3)</span><br><span class="line"> Spatial resolution: 5km (Pixel number: 2401, Line number: 2401)</span><br><span class="line"> NOTE: Angstrom exponent included this product is under validation. </span><br><span class="line">       Users should keep in mind that the data is NOT quality assured. </span><br><span class="line">       Improvement in Version 3.1:</span><br><span class="line">        Updated error covariance of aerosol model used for a priori estimate or retrieval.</span><br><span class="line">        Updated alternative calibration coefficients for Himawari-9.</span><br><span class="line"></span><br><span class="line">## Sea Surface Temperature (SST)</span><br><span class="line"> Latest version: Version 2.1</span><br><span class="line"> Observation area: Full-disk</span><br><span class="line"> Temporal resolution: 10-minutes (Level 2), 1-hour (Level 3),</span><br><span class="line">                      1-day (Level 3), 1-month (Level 3)</span><br><span class="line"> Spatial resolution: 2km (Pixel number: 6001, Line number: 6001)</span><br><span class="line"></span><br><span class="line"> NOTE: Hourly data (Level 3 with temporal resolution of 1-hour) is calculated </span><br><span class="line">       from 10-minute data (Level 2) with quality level 5. Daily data (Level 3 </span><br><span class="line">       with temporal resolution of 1-day) is &quot;daily minimum SST&quot; calculated from </span><br><span class="line">       hourly data. Monthly data (Level 3 with temporal resolution of 1-month) </span><br><span class="line">       is &quot;monthly mean SST&quot; calculated from hourly data at each pixel.</span><br><span class="line">  </span><br><span class="line">       File version index (fv):</span><br><span class="line">        Himawari SST product file has a file version index (fvXX) in the filename to describe </span><br><span class="line">        the number of processing times. File version index will be updated for example when </span><br><span class="line">        the L3 product file will be re-generated due to L1 missing or delay. </span><br><span class="line">        The P-tree system distributes the newest product file regarding the file version index.</span><br><span class="line"></span><br><span class="line">       Improvement in Version 2.0:</span><br><span class="line">         The SST method has been updated with an improved optimal estimation scheme and some minor changes.</span><br><span class="line">         Cloud masking has been updated with additional use of visible and short wavelength infrared data </span><br><span class="line">         and a new test to detect clouds with the cloud top temperature higher than SST. </span><br><span class="line">         In the update, some tests were modified based on the cloud masking developed for SGLI SST.</span><br><span class="line"></span><br><span class="line">       Improvement in Version 2.1:</span><br><span class="line">         Small changes were made for Himawari-9 data processing.</span><br><span class="line">         The Bi-Spectral Filter (DOI: 10.1175/JTECH-D-22-0051.1) is applied for denoising the AHI infrared data.</span><br><span class="line"></span><br><span class="line">## Nighttime Sea Surface Temperature</span><br><span class="line"> Latest version: Version 2.1</span><br><span class="line"> Observation area: Full-disk</span><br><span class="line"> Temporal resolution: 1-hour (Level 3)</span><br><span class="line"> Spatial resolution: 2km (Pixel number: 6001, Line number: 6001)</span><br><span class="line"></span><br><span class="line">## Short Wave Radiation / Photosynthetically Available Radiation</span><br><span class="line"> Latest version: Version 2.1 </span><br><span class="line"> Observation area: Full-disk</span><br><span class="line"> Temporal resolution: 10-minutes (Level 2), 1-hour (Level 3), </span><br><span class="line">                      1-day (Level 3), 1-month (Level 3)</span><br><span class="line"> Spatial resolution: 5km (Pixel number: 2401, Line number: 2401)</span><br><span class="line">                     1km Japan* (Pixel number: 2701, Line number: 2601)</span><br><span class="line">                     * This area coverd 24N-50N, 123E-150E.</span><br><span class="line"> NOTE: This product is a beta version and is intended to show the</span><br><span class="line">       preliminary result from Himawari-8. Users should keep in mind </span><br><span class="line">       that the data is NOT quality assured.</span><br><span class="line"></span><br><span class="line">       Ver. 2.0:</span><br><span class="line">        Vicarious calibration coefficients are updated by considering their temporal change.</span><br><span class="line">        Ancillary ozone data source is changed to JMA global chemical transport model data (MRI-CCM2).</span><br><span class="line"></span><br><span class="line">       Ver. 2.1:</span><br><span class="line">        Vicarious calibration coefficients are updated.</span><br><span class="line"></span><br><span class="line">## Chlorophyll-a</span><br><span class="line"> Latest version: 2.1 </span><br><span class="line"> Observation area: Full-disk</span><br><span class="line"> Temporal resolution: 1-hour (Level 3), 1-day (Level 3), 1-month (Level 3)</span><br><span class="line"> Spatial resolution: 5km (Pixel number: 2401, Line number: 2401)</span><br><span class="line">                     1km Japan* (Pixel number: 2701, Line number: 2601)</span><br><span class="line"> NOTE: This product is a beta version and is intended to show the</span><br><span class="line">       preliminary result from Himawari-8. Users should keep in mind </span><br><span class="line">       that the data is NOT quality assured.</span><br><span class="line"></span><br><span class="line">       Ver. 2.0:</span><br><span class="line">        Vicarious calibration coefficients are updated by considering their temporal change.</span><br><span class="line">        Ancillary ozone data source is changed to JMA global chemical transport model data (MRI-CCM2).</span><br><span class="line"></span><br><span class="line">       Ver. 2.1:</span><br><span class="line">        Vicarious calibration coefficients are updated.</span><br><span class="line"></span><br><span class="line">## Cloud Property (day-time only)</span><br><span class="line"> Latest version: 1.0 </span><br><span class="line"> Observation area: Full-disk</span><br><span class="line"> Temporal resolution: 10-minutes (Level 2)</span><br><span class="line"> Spatial resolution: 5km (Pixel number: 2401, Line number: 2401)</span><br><span class="line"></span><br><span class="line">## Wild Fire</span><br><span class="line"> Latest version: 1.0</span><br><span class="line"> Observation area: Full-disk</span><br><span class="line"> Temporal resolution: 10-minutes (Level 2), 1-hour (Level 3),</span><br><span class="line">                      1-day (Level 3), 1-month (Level 3)</span><br><span class="line"> Spatial resolution: 2km (10-minutes, 1-hour, 1-day), 0.25 degree (1-month) </span><br><span class="line"></span><br><span class="line">********************************************************************************</span><br><span class="line"></span><br><span class="line"># TOP FTP Directory</span><br><span class="line"></span><br><span class="line"> /pub/</span><br><span class="line"></span><br><span class="line">********************************************************************************</span><br><span class="line"></span><br><span class="line"># Structure of FTP Directories</span><br><span class="line"></span><br><span class="line">## Level 2 (every 10 minutes)</span><br><span class="line">### Aerosol Property (ARP) Level 2</span><br><span class="line"> /pub/himawari</span><br><span class="line">       +---/L2</span><br><span class="line">             +---/ARP</span><br><span class="line">                   +---/[VER]</span><br><span class="line">                          +---/[YYYYMM]</span><br><span class="line">                                 +---/[DD]</span><br><span class="line">                                        +---/[hh]</span><br><span class="line"></span><br><span class="line">### Sea Surface Temperature (SST) Level 2 (near-real-time)</span><br><span class="line"> /pub/himawari</span><br><span class="line">       +---/L2</span><br><span class="line">             +---/SST</span><br><span class="line">                   +---/[VER]_nc4_normal_nrt</span><br><span class="line">                          +---/[YYYYMM]</span><br><span class="line">                                 +---/[DD]</span><br><span class="line"></span><br><span class="line">### Short Wave Radiation(SWR)/Photosynthetically Available Radiation(PAR) Level 2</span><br><span class="line"> /pub/himawari</span><br><span class="line">       +---/L2</span><br><span class="line">             +---/PAR</span><br><span class="line">                   +---/[VER]</span><br><span class="line">                          +---/[YYYYMM]</span><br><span class="line">                                 +---/[DD]</span><br><span class="line"></span><br><span class="line">### Cloud Property (CLP) Level 2</span><br><span class="line"> /pub/himawari</span><br><span class="line">       +---/L2</span><br><span class="line">             +---/CLP</span><br><span class="line">                   +---/[VER]</span><br><span class="line">                          +---/[YYYYMM]</span><br><span class="line">                                 +---/[DD]</span><br><span class="line">                                        +---/[hh]</span><br><span class="line"></span><br><span class="line">### Wild Fire (WLF) Level 2</span><br><span class="line"> /pub/himawari</span><br><span class="line">       +---/L2</span><br><span class="line">             +---/WLF</span><br><span class="line">                   +---/[VER]</span><br><span class="line">                          +---/[YYYYMM]</span><br><span class="line">                                 +---/[DD]</span><br><span class="line">                                        +---/[hh]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## Level 3 (hourly, daily, monthly)</span><br><span class="line">### Aerosol Property Level 3</span><br><span class="line"> /pub/himawari</span><br><span class="line">       +---/L3</span><br><span class="line">             +---/ARP</span><br><span class="line">                   +---/[VER]</span><br><span class="line">                          +---/[YYYYMM]</span><br><span class="line">                                 +---/[DD]</span><br><span class="line">                                 +---/[daily]</span><br><span class="line">                                 +---/[monthly]</span><br><span class="line"></span><br><span class="line">### Sea Surface Temperature (SST) Level 3 (near-real-time)</span><br><span class="line"> /pub/himawari</span><br><span class="line">       +---/L3</span><br><span class="line">             +---/SST</span><br><span class="line">                   +---/[VER]_nc4_normal_nrt</span><br><span class="line">                          +---/[YYYYMM]</span><br><span class="line">                                 +---/[DD]</span><br><span class="line">                   +---/[VER]_nc4_normal_nrt_daily</span><br><span class="line">                          +---/[YYYYMM]</span><br><span class="line">                                 +---/[DD]</span><br><span class="line">                   +---/[VER]_nc4_normal_nrt_monthly</span><br><span class="line">                          +---/[YYYYMM]</span><br><span class="line"></span><br><span class="line">### Nighttime Sea Surface Temperature (SST) Level 3 (near-real-time)</span><br><span class="line"> /pub/himawari</span><br><span class="line">       +---/L3</span><br><span class="line">             +---/SST</span><br><span class="line">                   +---/[VER]_nc4_nightt_nrt</span><br><span class="line">                          +---/[YYYYMM]</span><br><span class="line">                                 +---/[DD]</span><br><span class="line"></span><br><span class="line">### Short Wave Radiation(SWR)/Photosynthetically Available Radiation(PAR) Level 3</span><br><span class="line"> /pub/himawari</span><br><span class="line">       +---/L3</span><br><span class="line">             +---/PAR</span><br><span class="line">                   +---/[VER]</span><br><span class="line">                          +---/[YYYYMM]</span><br><span class="line">                                 +---/[DD]</span><br><span class="line">                                 +---/[daily]</span><br><span class="line">                                 +---/[monthly]</span><br><span class="line"></span><br><span class="line">### Chlorophyll-a (CHL) Level 3</span><br><span class="line"> /pub/himawari</span><br><span class="line">       +---/L3</span><br><span class="line">             +---/CHL</span><br><span class="line">                   +---/[VER]</span><br><span class="line">                          +---/[YYYYMM]</span><br><span class="line">                                 +---/[DD]</span><br><span class="line">                                 +---/[daily]</span><br><span class="line">                                 +---/[monthly]</span><br><span class="line"></span><br><span class="line">### Wild Fire (WLF) Level 3</span><br><span class="line"> /pub/himawari</span><br><span class="line">       +---/L3</span><br><span class="line">             +---/WLF</span><br><span class="line">                   +---/[VER]</span><br><span class="line">                          +---/[YYYYMM]</span><br><span class="line">                                 +---/[DD]</span><br><span class="line">                                 +---/[daily]</span><br><span class="line">                                 +---/[monthly]</span><br><span class="line"></span><br><span class="line"> where VER: algorithm version;</span><br><span class="line">       YYYY: 4-digit year observation start time (timeline);</span><br><span class="line">       MM: 2-digit month of timeline;</span><br><span class="line">       DD: 2-digit day of timeline; and</span><br><span class="line">       hh: 2-digit hour of timeline.</span><br><span class="line"></span><br><span class="line">********************************************************************************</span><br><span class="line"></span><br><span class="line"># File Naming Convention</span><br><span class="line"></span><br><span class="line">## Level 2</span><br><span class="line">### Aerosol Property</span><br><span class="line"> NC_Hnn_YYYYMMDD_hhmm_L2ARPVER_FLDK.xxxxx_yyyyy.nc</span><br><span class="line"></span><br><span class="line"> where nn: 2-digit number of Himawari satellite;</span><br><span class="line">         08: Himawari-8</span><br><span class="line">         09: Himawari-9</span><br><span class="line">       YYYY: 4-digit year of observation start time (timeline);</span><br><span class="line">       MM: 2-digit month of timeline;</span><br><span class="line">       DD: 2-digit day of timeline;</span><br><span class="line">       hh: 2-digit hour of timeline;</span><br><span class="line">       mm: 2-digit minutes of timeline;</span><br><span class="line">       VER: version;</span><br><span class="line">       xxxxx: pixel number; and</span><br><span class="line">       yyyyy: line number.</span><br><span class="line"></span><br><span class="line"> Example: H08_20150727_0800_L2ARP030_FLDK.02401_02401.nc</span><br><span class="line"></span><br><span class="line">### Sea Surface Temperature</span><br><span class="line"> YYYYMMDDhhmmss-JAXA-L2P_GHRSST-SSTskin-Hnn_AHI-vVER-v02.0-fvFVER.nc</span><br><span class="line"></span><br><span class="line"> where YYYY: 4-digit year of observation start time (timeline);</span><br><span class="line">       MM: 2-digit month of timeline;</span><br><span class="line">       DD: 2-digit day of timeline;</span><br><span class="line">       hh: 2-digit hour of timeline;</span><br><span class="line">       mm: 2-digit minutes of timeline;</span><br><span class="line">       ss: 2-digit seconds (fixed to &quot;00&quot;);</span><br><span class="line">       nn: 2-digit number of Himawari satellite;</span><br><span class="line">         08: Himawari-8</span><br><span class="line">         09: Himawari-9</span><br><span class="line">       VER: algorithm version; and</span><br><span class="line">       FVER: file version;.</span><br><span class="line"></span><br><span class="line"> Example: </span><br><span class="line"> 20150728081000-JAXA-L2P_GHRSST-SSTskin-H08_AHI-v2.0-v02.0-fv01.0.nc</span><br><span class="line"></span><br><span class="line">### Short Wave Radiation/Photosynthetically Available Radiation</span><br><span class="line"> Hnn_YYYYMMDD_hhmm_RFLVER_FLDK_xxxxx_yyyyy.nc (5km)</span><br><span class="line"> Hnn_YYYYMMDD_hhmm_rFLVER_FLDK_xxxxx_yyyyy.nc (1km)</span><br><span class="line"></span><br><span class="line"> where nn: 2-digit number of Himawari satellite;</span><br><span class="line">         08: Himawari-8</span><br><span class="line">         09: Himawari-9</span><br><span class="line">       YYYY: 4-digit year of observation start time (timeline);</span><br><span class="line">       MM: 2-digit month of timeline;</span><br><span class="line">       DD: 2-digit day of timeline;</span><br><span class="line">       hh: 2-digit hour of timeline;</span><br><span class="line">       mm: 2-digit minutes of timeline;</span><br><span class="line">       VER: algorithm version; </span><br><span class="line">       xxxxx: pixel number; and</span><br><span class="line">       yyyyy: line number.</span><br><span class="line"></span><br><span class="line"> Example: NC_H08_20150727_0800_RFL001_FLDK_02401_02401.nc</span><br><span class="line"></span><br><span class="line">### Cloud Property</span><br><span class="line"> NC_Hnn_YYYYMMDD_hhmm_L2CLPVER_FLDK.xxxxx_yyyyy.nc</span><br><span class="line"></span><br><span class="line"> where nn: 2-digit number of Himawari satellite;</span><br><span class="line">         08: Himawari-8</span><br><span class="line">         09: Himawari-9</span><br><span class="line">       YYYY: 4-digit year of observation start time (timeline);</span><br><span class="line">       MM: 2-digit month of timeline;</span><br><span class="line">       DD: 2-digit day of timeline;</span><br><span class="line">       hh: 2-digit hour of timeline;</span><br><span class="line">       mm: 2-digit minutes of timeline;</span><br><span class="line">       VER: version;</span><br><span class="line">       xxxxx: pixel number; and</span><br><span class="line">       yyyyy: line number.</span><br><span class="line"></span><br><span class="line"> Example: H08_20150727_0800_L2CLPbet_FLDK.02401_02401.nc</span><br><span class="line"></span><br><span class="line">### Wildfire</span><br><span class="line"> NC_Hnn_YYYYMMDD_hhmm_L2WLFVER_FLDK.xxxxx_yyyyy.csv</span><br><span class="line"></span><br><span class="line"> where nn: 2-digit number of Himawari satellite;</span><br><span class="line">         08: Himawari-8</span><br><span class="line">         09: Himawari-9YYYY: 4-digit year of observation start time (timeline);</span><br><span class="line">       MM: 2-digit month of timeline;</span><br><span class="line">       DD: 2-digit day of timeline;</span><br><span class="line">       hh: 2-digit hour of timeline;</span><br><span class="line">       mm: 2-digit minutes of timeline;</span><br><span class="line">       VER: version;</span><br><span class="line">       xxxxx: pixel number; and</span><br><span class="line">       yyyyy: line number.</span><br><span class="line"></span><br><span class="line"> Example: H08_20150727_0800_L2WLF010_FLDK.06001_06001.csv</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## Level 3</span><br><span class="line">### Aerosol Property</span><br><span class="line"> Hnn_YYYYMMDD_hhmm_LL_ARPVER_FLDK.xxxxx_yyyyy.nc (5km)</span><br><span class="line"></span><br><span class="line"> where nn: 2-digit number of Himawari satellite;</span><br><span class="line">         08: Himawari-8</span><br><span class="line">         09: Himawari-9YYYY: 4-digit year of observation start time (timeline);</span><br><span class="line">       MM: 2-digit month of timeline;</span><br><span class="line">       DD: 2-digit day of timeline;</span><br><span class="line">       hh: 2-digit hour of timeline;</span><br><span class="line">       mm: 2-digit minutes of timeline;</span><br><span class="line">       LL: 2-digit temporal resolution (L3:hourly, 1D:daily, 1M:monthly) </span><br><span class="line">       VER: algorithm version; </span><br><span class="line">       xxxxx: pixel number; and</span><br><span class="line">       yyyyy: line number.</span><br><span class="line"></span><br><span class="line"> Example: H08_20150727_0800_1H_ARP031_FLDK.02401_02401.nc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### Sea Surface Temperature</span><br><span class="line"> YYYYMMDDhhmmss-JAXA-L3C_GHRSST-SSTskin-Hnn_AHI-vVER-v02.0-fvFVER.nc (hourly)</span><br><span class="line"> YYYYMMDDhhmmss-JAXA-L3C_GHRSST-SSTskin-Hnn_AHI-vVER_daily-v02.0-fvFVER.nc (daily)</span><br><span class="line"> Hnn_YYYYMMDD_HHMM_1MSSTVER_FLDK.xxxxx_yyyyy.nc  (monthly)</span><br><span class="line"></span><br><span class="line"> where YYYY: 4-digit year of observation start time (timeline);</span><br><span class="line">       MM: 2-digit month of timeline;</span><br><span class="line">       DD: 2-digit day of timeline;</span><br><span class="line">       hh: 2-digit hour of timeline;</span><br><span class="line">       mm: 2-digit minutes of timeline (fixed to &quot;00&quot;);</span><br><span class="line">       ss: 2-digit seconds of timeline (fixed to &quot;00&quot;);</span><br><span class="line">       nn: 2-digit number of Himawari satellite;</span><br><span class="line">         08: Himawari-8</span><br><span class="line">         09: Himawari-9</span><br><span class="line">       VER: algorithm version;</span><br><span class="line">       FVER: file version;</span><br><span class="line">       xxxxx: pixel number; and</span><br><span class="line">       yyyyy: line number.</span><br><span class="line"></span><br><span class="line"> Example:</span><br><span class="line"> 20180804000000-JAXA-L3C_GHRSST-SSTskin-H08_AHI-v2.0-v02.0-fv01.0.nc (hourly)</span><br><span class="line"> 20180804000000-JAXA-L3C_GHRSST-SSTskin-H08_AHI-v2.0_daily-v02.0-fv01.0.nc (daily)</span><br><span class="line"> H08_20180701_0000_1MSST200_FLDK.06001_06001.nc (monthly)</span><br><span class="line"></span><br><span class="line">### Nighttime Sea Surface Temperature</span><br><span class="line"> YYYYMMDDhhmmss-JAXA-L3C_GHRSST-SSTskin-Hnn_AHI-vVER_nighttime-v02.0-fvFVER.nc</span><br><span class="line"></span><br><span class="line"> where YYYY: 4-digit year observation start time (timeline);</span><br><span class="line">       MM: 2-digit month of timeline;</span><br><span class="line">       DD: 2-digit day of timeline;</span><br><span class="line">       hh: 2-digit hour of timeline;</span><br><span class="line">       mm: 2-digit minutes of timeline(fixed to &quot;00&quot;);</span><br><span class="line">       ss: 2-digit seconds of timeline(fixed to &quot;00&quot;);</span><br><span class="line">       nn: 2-digit number of Himawari satellite;</span><br><span class="line">         08: Himawari-8</span><br><span class="line">         09: Himawari-9</span><br><span class="line">       VER: algorithm version; and</span><br><span class="line">       FVER: file version;.</span><br><span class="line"></span><br><span class="line"> Example: </span><br><span class="line"> 20150728080000-JAXA-L3C_GHRSST-SSTskin-H08_AHI-v2.0_nighttime-v02.0-fv01.0.nc</span><br><span class="line"></span><br><span class="line">### Short Wave Radiation/Photosynthetically Available Radiation</span><br><span class="line"> Hnn_YYYYMMDD_hhmm_LL_RFLVER_FLDK.xxxxx_yyyyy.nc (5km)</span><br><span class="line"> Hnn_YYYYMMDD_hhmm_LL_rFLVER_FLDK.xxxxx_yyyyy.nc (1km)</span><br><span class="line"></span><br><span class="line"> where nn: 2-digit number of Himawari satellite;</span><br><span class="line">         08: Himawari-8</span><br><span class="line">         09: Himawari-9</span><br><span class="line">       YYYY: 4-digit year of observation start time (timeline);</span><br><span class="line">       MM: 2-digit month of timeline;</span><br><span class="line">       DD: 2-digit day of timeline;</span><br><span class="line">       hh: 2-digit hour of timeline;</span><br><span class="line">       mm: 2-digit minutes of timeline;</span><br><span class="line">       LL: 2-digit temporal resolution (L3:hourly, 1D:daily, 1M:monthly) </span><br><span class="line">       VER: algorithm version; </span><br><span class="line">       xxxxx: pixel number; and</span><br><span class="line">       yyyyy: line number.</span><br><span class="line"></span><br><span class="line"> Example: H08_20150727_0800_1H_RFL001_FLDK.02401_02401.nc</span><br><span class="line"></span><br><span class="line">### Chlorophyll-a</span><br><span class="line"> Hnn_YYYYMMDD_hhmm_LL_ROCVER_FLDK.xxxxx_yyyyy.nc (5km)</span><br><span class="line"> Hnn_YYYYMMDD_hhmm_LL_rOCVER_FLDK.xxxxx_yyyyy.nc (1km)</span><br><span class="line"></span><br><span class="line"> where nn: 2-digit number of Himawari satellite;</span><br><span class="line">         08: Himawari-8</span><br><span class="line">         09: Himawari-9YYYY: 4-digit year of observation start time (timeline);</span><br><span class="line">       MM: 2-digit month of timeline;</span><br><span class="line">       DD: 2-digit day of timeline;</span><br><span class="line">       hh: 2-digit hour of timeline;</span><br><span class="line">       mm: 2-digit minutes of timeline;</span><br><span class="line">       LL: 2-digit temporal resolution (1H:hourly, 1D:daily, 1M:monthly) </span><br><span class="line">       VER: algorithm version; </span><br><span class="line">       xxxxx: pixel number; and</span><br><span class="line">       yyyyy: line number.</span><br><span class="line"></span><br><span class="line"> Example: H08_20150727_0800_1H_ROC001_FLDK.02401_02401.nc</span><br><span class="line"></span><br><span class="line">### Wild Fire </span><br><span class="line"> Hnn_YYYYMMDD_hhmm_LLWLFVER_FLDK.xxxxx_yyyyy.csv</span><br><span class="line"></span><br><span class="line"> where nn: 2-digit number of Himawari satellite;</span><br><span class="line">         08: Himawari-8</span><br><span class="line">         09: Himawari-9</span><br><span class="line">       YYYY: 4-digit year of observation start time (timeline);</span><br><span class="line">       MM: 2-digit month of timeline;</span><br><span class="line">       DD: 2-digit day of timeline;</span><br><span class="line">       hh: 2-digit hour of timeline;</span><br><span class="line">       mm: 2-digit minutes of timeline;</span><br><span class="line">       LL: 2-digit temporal resolution (L3:hourly, 1D:daily, 1M:monthly) </span><br><span class="line">       VER: algorithm version; </span><br><span class="line">       xxxxx: pixel number; and</span><br><span class="line">       yyyyy: line number.</span><br><span class="line"></span><br><span class="line"> Example: H08_20180501_0000_L3WLF010_FLDK.06001_06001.csv</span><br><span class="line"></span><br><span class="line">********************************************************************************</span><br><span class="line"></span><br><span class="line"># Format</span><br><span class="line"></span><br><span class="line">  All data except for Wild Fire is in NetCDF4 format and compressed with gzip.</span><br><span class="line">  Please note that NetCDF format of SST (except monthly product) follows</span><br><span class="line">  the GHRSST Data Specification (GDS) 2.0. Details of GDS2.0, see the Group of </span><br><span class="line">  High Resolution Sea Surface Temperature (GHRSST) web site</span><br><span class="line">  (https://www.ghrsst.org/). </span><br><span class="line"></span><br><span class="line">  File format of Wild Fire product is CSV. Please see following file</span><br><span class="line">  (H8_WLF_format.txt) for more details. </span><br><span class="line"></span><br><span class="line">********************************************************************************</span><br></pre></td></tr></table></figure><h3 id="👀-x2F-pub-x2F-model"><a href="#👀-x2F-pub-x2F-model" class="headerlink" title="👀&#x2F;pub&#x2F;model"></a>👀&#x2F;pub&#x2F;model</h3><p><strong>（1）产品数据介绍</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">### Level 4 (model parameters)</span><br><span class="line">    Model Aerosol Property</span><br><span class="line">    Model Sea Surface Temperature</span><br><span class="line">    Ensemble ocean analysis product &quot;LORA&quot;</span><br><span class="line"></span><br><span class="line">## 4级(模型参数)</span><br><span class="line">    模型气溶胶特性</span><br><span class="line">    海面温度模型</span><br><span class="line">    集成海洋分析产品“LORA”</span><br></pre></td></tr></table></figure><p><strong>（2）数据描述，文件命名格式</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">********************************************************************************</span><br><span class="line"></span><br><span class="line"># Model Outputs</span><br><span class="line"> </span><br><span class="line">## Model Aerosol Property by MRI/JMA</span><br><span class="line"> Latest version: Beta Version</span><br><span class="line"> Area: Global</span><br><span class="line"> Temporal resolution: 1-hour (Level 4)</span><br><span class="line"> Spatial resolution: Longitude 0.375 deg., Latitude 0.37147 to 0.37461 deg. (Gaussian)</span><br><span class="line"> (Pixel number: 960, Line number: 480)</span><br><span class="line"> NOTE: This product is the forecast (every one hour) of aerosol properties by</span><br><span class="line">       the MRI/JMA global aerosol model called Model of Aerosol Species IN the Global</span><br><span class="line">       AtmospheRe (MASINGAR). This product is assimilated by Himawari L3 aerosol</span><br><span class="line">       optical depth at 00, 03, 06, and 09UTC. The opposite side of the Himawari</span><br><span class="line">       observation area is assimilated at 12 and 18UTC using MODIS/Terra+Aqua L3</span><br><span class="line">       Value-added Aerosol Optical Depth - NRT dataset due to lack of aerosol</span><br><span class="line">       retrievals by Himawari.(As for the image on the top page, there are cases</span><br><span class="line">       where preliminary forecast is displayed that was derived by assimilating</span><br><span class="line">       observation data before the previous day.)</span><br><span class="line">       Please refer to the reference below for the assimilation method etc. </span><br><span class="line">       The aerosol data assimilation system based on MASINGER was developed </span><br><span class="line">       by Meteorological Research Institute and Kyushu University. </span><br><span class="line">       The products are produced at Meteorological Research Institute, and provided </span><br><span class="line">       by JAXA P-Tree System, Japan Aerospace Exploration Agency (JAXA). </span><br><span class="line"></span><br><span class="line"> Acknowledgements: </span><br><span class="line">    MODIS/Terra+Aqua L3 Value-added Aerosol Optical Depth - NRT datasets</span><br><span class="line">    were acquired from the Level-1 and Atmosphere Archive &amp; Distribution System</span><br><span class="line">    (LAADS) Distributed Active Archive Center (DAAC), located in the Goddard Space</span><br><span class="line">    Flight Center in Greenbelt, Maryland (https://ladsweb.nascom.nasa.gov/).</span><br><span class="line"></span><br><span class="line">## Model Sea Surface Temperature by JAXA/JAMSTEC</span><br><span class="line"> Latest version: v20170705</span><br><span class="line"> Area: Around Japan (117E-150E, 17N-50N)</span><br><span class="line"> Temporal resolution: 1-hour (Level 4)</span><br><span class="line"> Spatial resolution: About 3km (1/36 deg.) (Pixel number: 1190, Line number: 1190)</span><br><span class="line"> NOTE: This research is JAXA-JAMSTEC joint research and a part of the Japan Coastal </span><br><span class="line">       Ocean Predictability Experiment (JCOPE).</span><br><span class="line">       This product is constructed by data assimilation using high resolution </span><br><span class="line">       regional ocean model &quot;JCOPE-T&quot; developed by JAMSTEC and observation data </span><br><span class="line">       including the 4 types satellite SST data provided by JAXA. </span><br><span class="line">       When we do the data assimilation, we do the bias correction of satellite </span><br><span class="line">       SST data using GCOM-W/AMSR2 SST data as refer to reference value, </span><br><span class="line">       because the bias in observation data is undesirable for data assimilation. </span><br><span class="line">       Near Real-Time data (analysis and forecast) and Best Estimate data are </span><br><span class="line">       included in this product. </span><br><span class="line"></span><br><span class="line">       Update frequency and period are follow.</span><br><span class="line"></span><br><span class="line">       Near Real-Time data: Every day except Saturdays.</span><br><span class="line">        - Analysis (ANAL): 5-days (replaced every update)</span><br><span class="line">        - Forecast (FCST): 16-days (replaced every update)</span><br><span class="line">       Best Estimate data: Every week</span><br><span class="line">        (update in the beginning of the week; Sunday or Monday)</span><br><span class="line">        - This is delay mode data which is provided about two weeks late.</span><br><span class="line">        - 7-days data are added every update.</span><br><span class="line"></span><br><span class="line">## Ensemble ocean analysis product &quot;LORA&quot; by JAXA/RIKEN</span><br><span class="line"> Latest version: v1.0</span><br><span class="line"> Area: Western North Pacific (108E-180,12N-50N), Maritime Continent (95E-136E,18S-30N)</span><br><span class="line"> Temporal resolution: 1-day (Level 4)</span><br><span class="line"> Spatial resolution: About 10km (0.1 degree), 50 sigma-layers</span><br><span class="line"> Data:</span><br><span class="line">    - Daily averaged ensemble mean and spread (one 2D-variable, five 3D-variables): </span><br><span class="line">       Sea surface height, temperature, salinity, and zonal, meridional, and vertical velocities</span><br><span class="line">    - Daily averaged all sea surface ensemble (five 2D-128 ensemble variables): </span><br><span class="line">       Sea surface height, temperature, salinity, and zonal and meridional velocities</span><br><span class="line">    - Ensemble mean of each term in the daily averaged mixed layer temperature and salinity </span><br><span class="line">       budget equations and of the daily averaged related variables (forty-one 2D-variables, </span><br><span class="line">       see MLT_MLS_namelist_en.pdf for more details)</span><br><span class="line"> Note: An ensemble ocean analysis product, LORA, is created by a regional ocean data assimilation</span><br><span class="line">       system, sbPOM-LETKF, which is developed by RIKEN. sbPOM-LETKF assimilates the following</span><br><span class="line">       satellite and in-situ observations at a 1-day interval:</span><br><span class="line">        - Satellite-based sea surface temperature (Himawari-8/AHI and GCOM-W/AMSR2) </span><br><span class="line">          provided by JAXA</span><br><span class="line">        - Satellite-based sea surface salinity (SMAP and SMOS, respectively) </span><br><span class="line">          provided by NASA and ESA</span><br><span class="line">        - Satellite-based sea surface height provided by CMEMS</span><br><span class="line">        - in-situ temperature and salinity (GTSPP and AQC Argo, respectively) </span><br><span class="line">           provided by NOAA and JAMSTEC</span><br><span class="line"></span><br><span class="line">        This product has been created under a JAXA-RIKEN collaborative research project.</span><br><span class="line"></span><br><span class="line">********************************************************************************</span><br><span class="line"></span><br><span class="line"># TOP FTP Directory</span><br><span class="line"></span><br><span class="line"> /pub/</span><br><span class="line"></span><br><span class="line">********************************************************************************</span><br><span class="line"></span><br><span class="line"># Structure of FTP Directories</span><br><span class="line"></span><br><span class="line">### Level 4 (model parameters) </span><br><span class="line">### Model Aerosol Property (MRI/JMA)</span><br><span class="line"> /pub/model</span><br><span class="line">        +---/ARP</span><br><span class="line">             +---/MS</span><br><span class="line">                   +---/[VER]</span><br><span class="line">                          +---/[YYYYMM]</span><br><span class="line">                                 +---/[DD]</span><br><span class="line"></span><br><span class="line"> where VER: algorithm version;</span><br><span class="line">       YYYY: 4-digit year observation start time (timeline);</span><br><span class="line">       MM: 2-digit month of timeline;</span><br><span class="line">       DD: 2-digit day of timeline; and</span><br><span class="line">       hh: 2-digit hour of timeline.</span><br><span class="line"></span><br><span class="line">### Mpdel Sea Surface Temperature (JAXA/JAMSTEC)</span><br><span class="line"> /pub/model</span><br><span class="line">       +---/SST</span><br><span class="line">              +---/JCPT_DA</span><br><span class="line">                   +---/[VER]</span><br><span class="line">                          +---/FCST</span><br><span class="line">                          +---/ANAL</span><br><span class="line">                          +---/BEST</span><br><span class="line">                              +---/[YYYYMM]</span><br><span class="line">                                     +---/[DD]</span><br><span class="line"> where VER: algorithm version;</span><br><span class="line">       YYYY: 4-digit year observation start time (timeline);</span><br><span class="line">       MM: 2-digit month of timeline;</span><br><span class="line">       DD: 2-digit day of timeline; and</span><br><span class="line">       hh: 2-digit hour of timeline.</span><br><span class="line"></span><br><span class="line"> FCST: Near Real-Time data (Forecast)</span><br><span class="line"> ANAL: Near Real-Time data (Analysis)</span><br><span class="line"> BEST: Best Estimate data </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Ensemble ocean analysis product &quot;LORA&quot; (JAXA/RIKEN)</span><br><span class="line"> /pub/model</span><br><span class="line">       +---/OCN</span><br><span class="line">              +---/LORA</span><br><span class="line">                   +---/[VER]</span><br><span class="line">                         +---/[AREA]</span><br><span class="line">                               +---/[CAT]</span><br><span class="line">                                    +---/[YYYYMMDD]</span><br><span class="line"></span><br><span class="line"> where VER: algorithm version;</span><br><span class="line">       AREA: Analysis area;</span><br><span class="line">　　　        MC: Maritime Continent</span><br><span class="line">　　　        WNP: North West Pacific</span><br><span class="line">       CAT: category</span><br><span class="line">　     　　   ens: Daily averaged all sea surface ensemble</span><br><span class="line">　　　        mean: Ensemble mean and daily average of mixed layer related variabless</span><br><span class="line">　　　        sprd: Daily averaged ensemble mean and spread</span><br><span class="line">       YYYY: 4-digit year observation start time (timeline);</span><br><span class="line">       MM: 2-digit month of timeline; and</span><br><span class="line">       DD: 2-digit day of timeline.</span><br><span class="line"></span><br><span class="line">********************************************************************************</span><br><span class="line"></span><br><span class="line"># File Naming Convention</span><br><span class="line"></span><br><span class="line">## Level 4 (model parameters) </span><br><span class="line">### Model Aerosol Property (MRI/JMA)</span><br><span class="line"></span><br><span class="line"> Hnn_YYYYMMDD_hhmm_MSARPVER_ANL.xxxxx_yyyyy.nc</span><br><span class="line"></span><br><span class="line">where  nn: 2-digit number of Himawari satellite;</span><br><span class="line">         08: Himawari-8</span><br><span class="line">         09: Himawari-9</span><br><span class="line">       YYYY: 4-digit year of observation start time (timeline);</span><br><span class="line">       MM: 2-digit month of timeline;</span><br><span class="line">       DD: 2-digit day of timeline;</span><br><span class="line">       hh: 2-digit hour of timeline;</span><br><span class="line">       mm: 2-gidit minutes of timeline;</span><br><span class="line">       VER: algorithm version;</span><br><span class="line">       xxxxx: pixel number; and</span><br><span class="line">       yyyyy: line number.</span><br><span class="line"></span><br><span class="line">Example:  H08_20180727_0000_MSARPbet_ANL.00960_00480.nc</span><br><span class="line"></span><br><span class="line">### Model Sea Surface Temperature (JAXA/JAMSTEC)</span><br><span class="line"> JCPT_DA_JPN03_SST_YYYYMMDD_hhmm.nc</span><br><span class="line"></span><br><span class="line">where YYYY: 4-digit year of observation start time (timeline);</span><br><span class="line">       MM: 2-digit month of timeline;</span><br><span class="line">       DD: 2-digit day of timeline;</span><br><span class="line">       hh: 2-digit hour of timeline;</span><br><span class="line">       mm: 2-gidit minutes of timeline;</span><br><span class="line"></span><br><span class="line">Example: JCPT_DA_JPN03_SST_20181024_1200.nc</span><br><span class="line"></span><br><span class="line">## Ensemble ocean analysis product &quot;LORA&quot; (JAXA/RIKEN)</span><br><span class="line"> prmYYYYMMDD.nc</span><br><span class="line"></span><br><span class="line">where prm: parameters;</span><br><span class="line">            el: sea surface height</span><br><span class="line">　　　      s: salimity</span><br><span class="line">　      　　t: temprature</span><br><span class="line">　　　      u: zonal velocity</span><br><span class="line">      　　　v: meridional velocity</span><br><span class="line">    w: vertical velocity</span><br><span class="line">　　　      ** See MLT_MLS_namelist_en.pd for mixed layer related parameters</span><br><span class="line">      YYYY: 4-digit year of observation start time (timeline);</span><br><span class="line">      MM: 2-digit month of timeline; and</span><br><span class="line">      DD: 2-digit day of timeline.</span><br><span class="line"></span><br><span class="line">Example: el20230330.nc</span><br><span class="line"></span><br><span class="line">********************************************************************************</span><br><span class="line"></span><br><span class="line"># Format</span><br><span class="line"></span><br><span class="line">  All data is in NetCDF4 format. </span><br><span class="line"></span><br><span class="line">********************************************************************************</span><br></pre></td></tr></table></figure><h2 id="⛄Himawari8-x2F-9数据预处理"><a href="#⛄Himawari8-x2F-9数据预处理" class="headerlink" title="⛄Himawari8&#x2F;9数据预处理"></a>⛄Himawari8&#x2F;9数据预处理</h2><p>这里以<code>NC</code>格式的数据处理为例：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> netCDF4 <span class="keyword">as</span> nc</span><br><span class="line"><span class="keyword">from</span> osgeo <span class="keyword">import</span> gdal, osr</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> os</span><br></pre></td></tr></table></figure><p>（1）读取nc文件</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tep_data = nc.Dataset(input_path)</span><br></pre></td></tr></table></figure><p>（2）查看并获取nc文件中对应变量的信息，读取数据</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看nc文件中的变量信息</span></span><br><span class="line"><span class="built_in">print</span>(tep_data.variables.keys())</span><br></pre></td></tr></table></figure><p>（3）根据数据的经纬度，计算分辨率，确定六参数</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 获取nc文件中对应变量的信息</span></span><br><span class="line">lon_data = tep_data.variables[<span class="string">&quot;longitude&quot;</span>][:]</span><br><span class="line">lat_data = tep_data.variables[<span class="string">&quot;latitude&quot;</span>][:]</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 影像的左上角&amp;右下角坐标</span></span><br><span class="line">lonmin,latmax,lonmax,latmin=[lon_data.<span class="built_in">min</span>(),lat_data.<span class="built_in">max</span>(),lon_data.<span class="built_in">max</span>(),lat_data.<span class="built_in">min</span>()]</span><br><span class="line"><span class="comment"># print(lonmin, latmax, lonmax, latmin)</span></span><br><span class="line">    </span><br><span class="line"><span class="comment"># 分辨率计算</span></span><br><span class="line">num_lon = <span class="built_in">len</span>(lon_data)</span><br><span class="line">num_lat = <span class="built_in">len</span>(lat_data)</span><br><span class="line">lon_res = (lonmax - lonmin) / (<span class="built_in">float</span>(num_lon) - <span class="number">1</span>)</span><br><span class="line">lat_res = (latmax - latmin) / (<span class="built_in">float</span>(num_lat) - <span class="number">1</span>)</span><br><span class="line"><span class="comment"># 定义六参数，设置影像的显示范围和分辨率</span></span><br><span class="line"><span class="comment"># 影像左上角横坐标：geoTransform[0]</span></span><br><span class="line"><span class="comment"># 影像左上角纵坐标：geoTransform[3]</span></span><br><span class="line"><span class="comment"># 遥感图像的水平空间分辨率为geoTransform[1]</span></span><br><span class="line"><span class="comment"># 遥感图像的垂直空间分辨率为geoTransform[5]</span></span><br><span class="line"><span class="comment"># 通常geoTransform[5]与geoTransform[1]相等</span></span><br><span class="line"><span class="comment"># 如果遥感影像方向没有发生旋转，即上北、下南，则geoTransform[2] 与 row *geoTransform[4] 为零。</span></span><br><span class="line">geotransform = (lonmin, lon_res, <span class="number">0.0</span>, latmax, <span class="number">0.0</span>, -lat_res)</span><br></pre></td></tr></table></figure><p>（4）定义投影</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义投影</span></span><br><span class="line">proj = osr.SpatialReference()</span><br><span class="line">proj.ImportFromEPSG(<span class="number">4326</span>)  <span class="comment"># WGS84</span></span><br><span class="line">proj = proj.ExportToWkt()  <span class="comment"># 重点，转成wkt格式</span></span><br><span class="line"><span class="comment"># print(prj)               字符串</span></span><br></pre></td></tr></table></figure><p>（5）波段合成，保存数据为tif格式</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 获取葵花数据16个波段变量名称</span></span><br><span class="line">H_Keys = [<span class="string">&#x27;albedo_01&#x27;</span>, <span class="string">&#x27;albedo_02&#x27;</span>, <span class="string">&#x27;albedo_03&#x27;</span>, <span class="string">&#x27;albedo_04&#x27;</span>, <span class="string">&#x27;albedo_05&#x27;</span>, <span class="string">&#x27;albedo_06&#x27;</span>, <span class="string">&#x27;tbb_07&#x27;</span>, <span class="string">&#x27;tbb_08&#x27;</span>, <span class="string">&#x27;tbb_09&#x27;</span>, <span class="string">&#x27;tbb_10&#x27;</span>, <span class="string">&#x27;tbb_11&#x27;</span>, <span class="string">&#x27;tbb_12&#x27;</span>, <span class="string">&#x27;tbb_13&#x27;</span>, <span class="string">&#x27;tbb_14&#x27;</span>, <span class="string">&#x27;tbb_15&#x27;</span>, <span class="string">&#x27;tbb_16&#x27;</span>]</span><br><span class="line"></span><br><span class="line">im_height = tep_data.dimensions[<span class="string">&quot;latitude&quot;</span>].size</span><br><span class="line">im_width = tep_data.dimensions[<span class="string">&quot;longitude&quot;</span>].size</span><br><span class="line">bands = tep_data.dimensions[<span class="string">&quot;band&quot;</span>].size</span><br><span class="line">H_bands = np.zeros((im_height, im_width, bands), dtype = np.float64)  </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(H_Keys)):</span><br><span class="line">   band_key = H_Keys[i]</span><br><span class="line">   H_bands[:,:,i] = tep_data.variables[band_key][:]</span><br><span class="line"></span><br><span class="line">filename = os.path.basename(input_path).split(<span class="string">&quot;.&quot;</span>)[<span class="number">0</span>] + <span class="string">&quot;.tif&quot;</span></span><br><span class="line"><span class="comment"># 注意区分os.sep.join()和os.path.join()的区别</span></span><br><span class="line">output_filepath = os.path.join(output_path,filename)</span><br><span class="line">write_img(output_filepath, proj, geotransform, H_bands)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 遥感数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据处理 </tag>
            
            <tag> Himawari8-9 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python之Pandas读写文件及索引操作</title>
      <link href="/2023/03/27/Python-Pandas-RWF/"/>
      <url>/2023/03/27/Python-Pandas-RWF/</url>
      
        <content type="html"><![CDATA[<p>当使用<code>Pandas</code>做数据分析时，需要读取事先准备好的数据集，这是做数据分析的第一步。<code>Pandas</code>提供了多种读取数据的方法：</p><ul><li><code>read_csv()</code>用于读取文本文件</li><li><code>read_json()</code>用于读取<code>json</code>文件</li><li><code>read_sql_query()</code>读取<code>sql</code>语句的</li></ul><h2 id="⛄CSV读写文件"><a href="#⛄CSV读写文件" class="headerlink" title="⛄CSV读写文件"></a>⛄CSV读写文件</h2><p> <code>CSV</code>又称逗号分隔值文件，是一种简单的文件格式，以特定的结构来排列表格数据。 <code>CSV</code>文件能够以纯文本形式存储表格数据，比如电子表格、数据库文件，并具有数据交换的通用格式。<code>CSV</code>文件会在<code>Excel</code>文件中被打开，其行和列都定义了标准的数据格式。</p><p>将<code>CSV</code>中的数据转换为<code>DataFrame</code>对象是非常便捷的。和一般文件读写不一样，它不需要你做打开文件、读取文件、关闭文件等操作。相反，您只需要一行代码就可以完成上述所有步骤，并将数据存储在<code>DataFrame</code>中。  </p><p>在<code>Pandas</code>中用于读取文本的函数有两个，分别是：<code>read_csv()</code>和<code>read_table()</code>，它们能够自动地将表格数据转换为<code>DataFrame</code>对象。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pandas.read_csv(filepath_or_buffer, sep=<span class="string">&#x27;,&#x27;</span>, delimiter=<span class="literal">None</span>, header=<span class="string">&#x27;infer&#x27;</span>,names=<span class="literal">None</span>, index_col=<span class="literal">None</span>, usecols=<span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建txt文件，添加数据，另存为csv文件</span></span><br><span class="line">ID,Name,Age,City,Salary</span><br><span class="line"><span class="number">1</span>,Jack,<span class="number">28</span>,Beijing,<span class="number">22000</span></span><br><span class="line"><span class="number">2</span>,Lida,<span class="number">32</span>,Shanghai,<span class="number">19000</span></span><br><span class="line"><span class="number">3</span>,John,<span class="number">43</span>,Shenzhen,<span class="number">12000</span></span><br><span class="line"><span class="number">4</span>,Helen,<span class="number">38</span>,Hengshui,<span class="number">3500</span></span><br></pre></td></tr></table></figure><h3 id="👀read-csv"><a href="#👀read-csv" class="headerlink" title="👀read_csv()"></a>👀read_csv()</h3><p><code>read_csv()</code>表示从<code>CSV</code>文件中读取数据，并创建<code>DataFrame</code>对象。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="comment">#需要注意文件的路径</span></span><br><span class="line">df = pd.read_csv(<span class="string">r&quot;D:\Desktop\one.csv&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">   ID   Name  Age      City  Salary</span><br><span class="line"><span class="number">0</span>   <span class="number">1</span>   Jack   <span class="number">28</span>   Beijing   <span class="number">22000</span></span><br><span class="line"><span class="number">1</span>   <span class="number">2</span>   Lida   <span class="number">32</span>  Shanghai   <span class="number">19000</span></span><br><span class="line"><span class="number">2</span>   <span class="number">3</span>   John   <span class="number">43</span>  Shenzhen   <span class="number">12000</span></span><br><span class="line"><span class="number">3</span>   <span class="number">4</span>  Helen   <span class="number">38</span>  Hengshui    <span class="number">3500</span></span><br></pre></td></tr></table></figure><p>（1）自定义索引</p><p>在<code>CSV</code>文件中指定了一个列，然后使用<code>index_col</code>可以实现自定义索引。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">df = pd.read_csv(<span class="string">r&quot;D:\Desktop\one.csv&quot;</span>,index_col=[<span class="string">&#x27;ID&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">     Name  Age      City  Salary</span><br><span class="line">ID                              </span><br><span class="line"><span class="number">1</span>    Jack   <span class="number">28</span>   Beijing   <span class="number">22000</span></span><br><span class="line"><span class="number">2</span>    Lida   <span class="number">32</span>  Shanghai   <span class="number">19000</span></span><br><span class="line"><span class="number">3</span>    John   <span class="number">43</span>  Shenzhen   <span class="number">12000</span></span><br><span class="line"><span class="number">4</span>   Helen   <span class="number">38</span>  Hengshui    <span class="number">3500</span></span><br></pre></td></tr></table></figure><p>（2）查看每一列的<code>dtype</code></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">df1 = pd.read_csv(<span class="string">r&quot;D:\Desktop\one.csv&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(df1.dtypes)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 转换salary为float类型</span></span><br><span class="line">df2 = pd.read_csv(<span class="string">r&quot;D:\Desktop\one.csv&quot;</span>,dtype=&#123;<span class="string">&#x27;Salary&#x27;</span>:np.float64&#125;)</span><br><span class="line"><span class="built_in">print</span>(df2.dtypes)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">ID         int64</span><br><span class="line">Name      <span class="built_in">object</span></span><br><span class="line">Age        int64</span><br><span class="line">City      <span class="built_in">object</span></span><br><span class="line">Salary     int64</span><br><span class="line">dtype: <span class="built_in">object</span></span><br><span class="line">********************</span><br><span class="line">ID          int64</span><br><span class="line">Name       <span class="built_in">object</span></span><br><span class="line">Age         int64</span><br><span class="line">City       <span class="built_in">object</span></span><br><span class="line">Salary    float64</span><br><span class="line">dtype: <span class="built_in">object</span></span><br></pre></td></tr></table></figure><p>（3）更改文件标头名</p><p>使用<code>names</code>参数可以指定头文件的名称。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">df1 = pd.read_csv(<span class="string">r&quot;D:\Desktop\one.csv&quot;</span>,names=[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(df1)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 文件标头名是附加的自定义名称，但是您会发现，原来的标头名（列标签名）并没有被删除，此时您可以使用`header`参数来删除它。</span></span><br><span class="line">df2 = pd.read_csv(<span class="string">r&quot;D:\Desktop\one.csv&quot;</span>,names=[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>],header=<span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(df2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">    a      b    c         d       e</span><br><span class="line"><span class="number">0</span>  ID   Name  Age      City  Salary</span><br><span class="line"><span class="number">1</span>   <span class="number">1</span>   Jack   <span class="number">28</span>   Beijing   <span class="number">22000</span></span><br><span class="line"><span class="number">2</span>   <span class="number">2</span>   Lida   <span class="number">32</span>  Shanghai   <span class="number">19000</span></span><br><span class="line"><span class="number">3</span>   <span class="number">3</span>   John   <span class="number">43</span>  Shenzhen   <span class="number">12000</span></span><br><span class="line"><span class="number">4</span>   <span class="number">4</span>  Helen   <span class="number">38</span>  Hengshui    <span class="number">3500</span></span><br><span class="line">********************</span><br><span class="line">   a      b   c         d      e</span><br><span class="line"><span class="number">0</span>  <span class="number">1</span>   Jack  <span class="number">28</span>   Beijing  <span class="number">22000</span></span><br><span class="line"><span class="number">1</span>  <span class="number">2</span>   Lida  <span class="number">32</span>  Shanghai  <span class="number">19000</span></span><br><span class="line"><span class="number">2</span>  <span class="number">3</span>   John  <span class="number">43</span>  Shenzhen  <span class="number">12000</span></span><br><span class="line"><span class="number">3</span>  <span class="number">4</span>  Helen  <span class="number">38</span>  Hengshui   <span class="number">3500</span></span><br></pre></td></tr></table></figure><p>（4）跳过指定的行数</p><p><code>skiprows</code>参数表示跳过指定的行数。注意：包含标头所在行。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">df = pd.read_csv(<span class="string">r&quot;D:\Desktop\one.csv&quot;</span>,skiprows=<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">   <span class="number">2</span>   Lida  <span class="number">32</span>  Shanghai  <span class="number">19000</span></span><br><span class="line"><span class="number">0</span>  <span class="number">3</span>   John  <span class="number">43</span>  Shenzhen  <span class="number">12000</span></span><br><span class="line"><span class="number">1</span>  <span class="number">4</span>  Helen  <span class="number">38</span>  Hengshui   <span class="number">3500</span></span><br></pre></td></tr></table></figure><h3 id="👀to-csv"><a href="#👀to-csv" class="headerlink" title="👀to_csv()"></a>👀to_csv()</h3><p><code>Pandas</code>提供的<code>to_csv()</code>函数用于将<code>DataFrame</code>转换为<code>CSV</code>数据。如果想要把<code>CSV</code>数据写入文件，只需向函数传递一个文件对象即可。否则，<code>CSV</code>数据将以字符串格式返回。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd </span><br><span class="line">data = &#123;<span class="string">&#x27;Name&#x27;</span>:[<span class="string">&#x27;Smith&#x27;</span>,<span class="string">&#x27;Parker&#x27;</span>], <span class="string">&#x27;ID&#x27;</span>:[<span class="number">101</span>, <span class="number">102</span>], <span class="string">&#x27;Language&#x27;</span>:[<span class="string">&#x27;Py&#x27;</span>, <span class="string">&#x27;JS&#x27;</span>]&#125; </span><br><span class="line">info = pd.DataFrame(data) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;DataFrame Values:\n&#x27;</span>, info) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 转换为csv数据</span></span><br><span class="line">csv_data = info.to_csv() </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;CSV数据:\n&#x27;</span>, csv_data) </span><br><span class="line"><span class="comment"># 指定CSV文件输出时的分隔符，并将其保存在pandas.csv文件中</span></span><br><span class="line">csv_data = info.to_csv(<span class="string">r&quot;D:\Desktop\two.csv&quot;</span>,sep=<span class="string">&#x27;|&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">DataFrame Values:</span><br><span class="line">      Name   ID Language</span><br><span class="line"><span class="number">0</span>   Smith  <span class="number">101</span>       Py</span><br><span class="line"><span class="number">1</span>  Parker  <span class="number">102</span>       JS</span><br><span class="line">********************</span><br><span class="line">CSV数据:</span><br><span class="line"> ,Name,ID,Language</span><br><span class="line"><span class="number">0</span>,Smith,<span class="number">101</span>,Py</span><br><span class="line"><span class="number">1</span>,Parker,<span class="number">102</span>,JS</span><br></pre></td></tr></table></figure><h2 id="⛄Excel读写操作"><a href="#⛄Excel读写操作" class="headerlink" title="⛄Excel读写操作"></a>⛄Excel读写操作</h2><p>在数据量较少的情况下，<code>Excel</code>对于数据的处理、分析、可视化有其独特的优势，因此可以显著提升您的工作效率。但是，当数据量非常大时，<code>Excel</code>的劣势就暴露出来了，比如，操作重复、数据分析难等问题。<code>Pandas</code>提供了操作<code>Excel</code>文件的函数，可以很方便地处理<code>Excel</code>表格。</p><h3 id="👀read-excel"><a href="#👀read-excel" class="headerlink" title="👀read_excel()"></a>👀read_excel()</h3><p>如果您想读取<code>Excel</code>表格中的数据，可以使用<code>read_excel()</code>方法，其语法格式如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pd.read_excel(io, sheet_name=<span class="number">0</span>, header=<span class="number">0</span>, names=<span class="literal">None</span>, index_col=<span class="literal">None</span>, usecols=<span class="literal">None</span>, squeeze=<span class="literal">False</span>, dtype=<span class="literal">None</span>, engine=<span class="literal">None</span>, converters=<span class="literal">None</span>, true_values=<span class="literal">None</span>, false_values=<span class="literal">None</span>, skiprows=<span class="literal">None</span>, nrows=<span class="literal">None</span>, na_values=<span class="literal">None</span>, parse_dates=<span class="literal">False</span>, date_parser=<span class="literal">None</span>, thousands=<span class="literal">None</span>, comment=<span class="literal">None</span>, skipfooter=<span class="number">0</span>, convert_float=<span class="literal">True</span>, **kwds)</span><br><span class="line"></span><br><span class="line">参数说明</span><br><span class="line">io表示Excel文件的存储路径。</span><br><span class="line">sheet_name要读取的工作表名称。</span><br><span class="line">header指定作为列名的行，默认<span class="number">0</span>，即取第一行的值为列名；若数据不包含列名，则设定header=<span class="literal">None</span>。若将其设置为header=<span class="number">2</span>，则表示将前两行作为多重索引。</span><br><span class="line">names一般适用于Excel缺少列名，或者需要重新定义列名的情况；names的长度必须等于Excel表格列的长度，否则会报错。</span><br><span class="line">index_col用做行索引的列，可以是工作表的列名称，如index_col=<span class="string">&#x27;列名&#x27;</span>，也可以是整数或者列表。</span><br><span class="line">usecols<span class="built_in">int</span>或<span class="built_in">list</span>类型，默认为<span class="literal">None</span>，表示需要读取所有列。</span><br><span class="line">squeezeboolean，默认为<span class="literal">False</span>，如果解析的数据只包含一列，则返回一个Series。</span><br><span class="line">converters规定每一列的数据类型。</span><br><span class="line">skiprows接受一个列表，表示跳过指定行数的数据，从头部第一行开始。</span><br><span class="line">nrows需要读取的行数。</span><br><span class="line">skipfooter接受一个列表，省略指定行数的数据，从尾部最后一行开始。</span><br></pre></td></tr></table></figure><p>读取操作<code>xlsx</code>文件：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="comment"># 读取excel数据</span></span><br><span class="line">df1 = pd.read_excel(<span class="string">r&quot;D:\Desktop\学习网站.xlsx&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(df1)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">20</span>)</span><br><span class="line">df2 = pd.read_excel(<span class="string">r&quot;D:\Desktop\学习网站.xlsx&quot;</span>,index_col=<span class="string">&#x27;name&#x27;</span>,skiprows=[<span class="number">2</span>])</span><br><span class="line"><span class="built_in">print</span>(df2)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 处理未命名列</span></span><br><span class="line">df2.columns = df2.columns.<span class="built_in">str</span>.replace(<span class="string">&#x27;Unnamed.*&#x27;</span>, <span class="string">&#x27;col_label&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(df2)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># index_col选择前两列作为索引列，选择前三列数据</span></span><br><span class="line">df3 = pd.read_excel(<span class="string">r&quot;D:\Desktop\学习网站.xlsx&quot;</span>,index_col=[<span class="number">0</span>,<span class="number">1</span>],usecols=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"><span class="built_in">print</span>(df3)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">   Unnamed: <span class="number">0</span>      name  rank language                 url</span><br><span class="line"><span class="number">0</span>           <span class="number">0</span>       编程帮     <span class="number">1</span>      PHP   www.bianchneg.com</span><br><span class="line"><span class="number">1</span>           <span class="number">1</span>    c语言中文网     <span class="number">2</span>        C     c.bianchneg.net</span><br><span class="line"><span class="number">2</span>           <span class="number">2</span>       微学苑     <span class="number">3</span>      PHP  www.weixueyuan.com</span><br><span class="line"><span class="number">3</span>           <span class="number">3</span>  92python     <span class="number">4</span>   Python    www<span class="number">.92</span>python.com</span><br><span class="line">********************</span><br><span class="line">          Unnamed: <span class="number">0</span>  rank language                 url</span><br><span class="line">name                                                   </span><br><span class="line">编程帮                <span class="number">0</span>     <span class="number">1</span>      PHP   www.bianchneg.com</span><br><span class="line">微学苑                <span class="number">2</span>     <span class="number">3</span>      PHP  www.weixueyuan.com</span><br><span class="line">92python           <span class="number">3</span>     <span class="number">4</span>   Python    www<span class="number">.92</span>python.com</span><br><span class="line">********************</span><br><span class="line">          col_label  rank language                 url</span><br><span class="line">name                                                  </span><br><span class="line">编程帮               <span class="number">0</span>     <span class="number">1</span>      PHP   www.bianchneg.com</span><br><span class="line">微学苑               <span class="number">2</span>     <span class="number">3</span>      PHP  www.weixueyuan.com</span><br><span class="line">92python          <span class="number">3</span>     <span class="number">4</span>   Python    www<span class="number">.92</span>python.com</span><br><span class="line">********************</span><br><span class="line">              language</span><br><span class="line">name     rank         </span><br><span class="line">编程帮      <span class="number">1</span>         PHP</span><br><span class="line">c语言中文网   <span class="number">2</span>           C</span><br><span class="line">微学苑      <span class="number">3</span>         PHP</span><br><span class="line">92python <span class="number">4</span>      Python</span><br></pre></td></tr></table></figure><h3 id="👀to-excel"><a href="#👀to-excel" class="headerlink" title="👀to_excel()"></a>👀to_excel()</h3><p>通过<code>to_excel()</code>函数可以将<code>Dataframe</code>中的数据写入到<code>Excel</code>文件。如果想要把单个对象写入<code>Excel</code>文件，那么必须指定目标文件名；如果想要写入到多张工作表中，则需要创建一个带有目标文件名的<code>ExcelWriter</code>对象，并通过<code>sheet_name</code>参数依次指定工作表的名称。 </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">DataFrame.to_excel(excel_writer, sheet_name=<span class="string">&#x27;Sheet1&#x27;</span>, na_rep=<span class="string">&#x27;&#x27;</span>, float_format=<span class="literal">None</span>, columns=<span class="literal">None</span>, header=<span class="literal">True</span>, index=<span class="literal">True</span>, index_label=<span class="literal">None</span>, startrow=<span class="number">0</span>, startcol=<span class="number">0</span>, engine=<span class="literal">None</span>, merge_cells=<span class="literal">True</span>, encoding=<span class="literal">None</span>, inf_rep=<span class="string">&#x27;inf&#x27;</span>, verbose=<span class="literal">True</span>, freeze_panes=<span class="literal">None</span>)  </span><br><span class="line"></span><br><span class="line">参数说明</span><br><span class="line">excel_wirter文件路径或者ExcelWrite对象。</span><br><span class="line">sheet_name指定要写入数据的工作表名称。</span><br><span class="line">na_rep缺失值的表示形式。</span><br><span class="line">float_format它是一个可选参数，用于格式化浮点数字符串。</span><br><span class="line">columns指要写入的列。</span><br><span class="line">header写出每一列的名称，如果给出的是字符串列表，则表示列的别名。</span><br><span class="line">index表示要写入的索引。</span><br><span class="line">index_label 引用索引列的列标签。如果未指定，且hearder和index均为<span class="literal">True</span>，则使用索引名称。如果DataFrame使用MultiIndex，则需要给出一个序列。</span><br><span class="line">startrow初始写入的行位置，默认值<span class="number">0</span>。表示引用左上角的行单元格来储存DataFrame。</span><br><span class="line">startcol初始写入的列位置，默认值<span class="number">0</span>。表示引用左上角的列单元格来储存DataFrame。</span><br><span class="line">engine它是一个可选参数，用于指定要使用的引擎，可以是openpyxl或xlsxwriter。</span><br></pre></td></tr></table></figure><p>创建DataFrame数据，保存xlsx文件。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="comment">#创建DataFrame数据</span></span><br><span class="line">info_website = pd.DataFrame(&#123;</span><br><span class="line"><span class="string">&#x27;name&#x27;</span>: [<span class="string">&#x27;编程帮&#x27;</span>, <span class="string">&#x27;c语言中文网&#x27;</span>, <span class="string">&#x27;微学苑&#x27;</span>, <span class="string">&#x27;92python&#x27;</span>],</span><br><span class="line"><span class="string">&#x27;rank&#x27;</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line"><span class="string">&#x27;language&#x27;</span>: [<span class="string">&#x27;PHP&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;PHP&#x27;</span>,<span class="string">&#x27;Python&#x27;</span> ],</span><br><span class="line"><span class="string">&#x27;url&#x27;</span>: [<span class="string">&#x27;www.bianchneg.com&#x27;</span>,<span class="string">&#x27;c.bianchneg.net&#x27;</span>,<span class="string">&#x27;www.weixueyuan.com&#x27;</span>,<span class="string">&#x27;www.92python.com&#x27;</span>]&#125;)</span><br><span class="line"><span class="comment"># 创建ExcelWrite对象</span></span><br><span class="line">writer = pd.ExcelWriter(<span class="string">r&quot;D:\Desktop\学习网站.xlsx&quot;</span>)</span><br><span class="line">info_website.to_excel(writer)</span><br><span class="line">writer.save()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;输出成功&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="⛄index操作索引"><a href="#⛄index操作索引" class="headerlink" title="⛄index操作索引"></a>⛄index操作索引</h2><p>索引（<code>index</code>）是<code>Pandas</code>的重要工具，通过索引可以从<code>DataFame</code>中选择特定的行数和列数，这种选择数据的方式称为“子集选择”。在<code>Pandas</code>中，索引值也被称为标签（<code>label</code>），它在<code>Jupyter</code>笔记本中以粗体字进行显示。索引可以加快数据访问的速度，它就好比数据的书签，通过它可以实现数据的快速查找。  </p><p>（1）创建索引</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd    </span><br><span class="line">data1 = pd.read_csv(<span class="string">r&quot;D:\Desktop\one.csv&quot;</span>) </span><br><span class="line"><span class="built_in">print</span>(data1)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment">#设置&quot;Name&quot;为行索引    </span></span><br><span class="line">data2 = pd.read_csv(<span class="string">r&quot;D:\Desktop\one.csv&quot;</span>, index_col =<span class="string">&quot;Name&quot;</span>)   </span><br><span class="line"><span class="comment"># 通过列标签选取多列数据  </span></span><br><span class="line">a1 = data2[[<span class="string">&quot;City&quot;</span>,<span class="string">&quot;Salary&quot;</span>]]</span><br><span class="line"><span class="built_in">print</span>(a1)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 获取单列数据，或者以列表的形式传入[&quot;Salary&quot;] </span></span><br><span class="line">a2 = data2[<span class="string">&quot;Salary&quot;</span>]</span><br><span class="line"><span class="built_in">print</span>(a2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">   ID   Name  Age      City  Salary</span><br><span class="line"><span class="number">0</span>   <span class="number">1</span>   Jack   <span class="number">28</span>   Beijing   <span class="number">22000</span></span><br><span class="line"><span class="number">1</span>   <span class="number">2</span>   Lida   <span class="number">32</span>  Shanghai   <span class="number">19000</span></span><br><span class="line"><span class="number">2</span>   <span class="number">3</span>   John   <span class="number">43</span>  Shenzhen   <span class="number">12000</span></span><br><span class="line"><span class="number">3</span>   <span class="number">4</span>  Helen   <span class="number">38</span>  Hengshui    <span class="number">3500</span></span><br><span class="line">********************</span><br><span class="line">           City  Salary</span><br><span class="line">Name                   </span><br><span class="line">Jack    Beijing   <span class="number">22000</span></span><br><span class="line">Lida   Shanghai   <span class="number">19000</span></span><br><span class="line">John   Shenzhen   <span class="number">12000</span></span><br><span class="line">Helen  Hengshui    <span class="number">3500</span></span><br><span class="line">********************</span><br><span class="line">Name</span><br><span class="line">Jack     <span class="number">22000</span></span><br><span class="line">Lida     <span class="number">19000</span></span><br><span class="line">John     <span class="number">12000</span></span><br><span class="line">Helen     <span class="number">3500</span></span><br><span class="line">Name: Salary, dtype: int64</span><br></pre></td></tr></table></figure><p>（2）设置索引</p><p><code>set_index()</code>将已存在的列标签设置为<code>DataFrame</code>行索引。除了可以添加索引外，也可以替换已经存在的索引。比如您也可以把<code>Series</code>或者一个<code>DataFrme</code>设置成另一个<code>DataFrame</code>的索引。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd  </span><br><span class="line">info = pd.DataFrame(&#123;<span class="string">&#x27;Name&#x27;</span>:[<span class="string">&#x27;Parker&#x27;</span>,<span class="string">&#x27;Terry&#x27;</span>,<span class="string">&#x27;Smith&#x27;</span>,<span class="string">&#x27;William&#x27;</span>], </span><br><span class="line">                     <span class="string">&#x27;Year&#x27;</span>:[<span class="number">2011</span>,<span class="number">2009</span>,<span class="number">2014</span>,<span class="number">2010</span>],</span><br><span class="line">                     <span class="string">&#x27;Leaves&#x27;</span>: [<span class="number">10</span>,<span class="number">15</span>,<span class="number">9</span>,<span class="number">4</span>]&#125;)</span><br><span class="line"><span class="built_in">print</span>(info)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 设置Name为行索引</span></span><br><span class="line"><span class="built_in">print</span>(info.set_index(<span class="string">&#x27;Name&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">      Name  Year  Leaves</span><br><span class="line"><span class="number">0</span>   Parker  <span class="number">2011</span>      <span class="number">10</span></span><br><span class="line"><span class="number">1</span>    Terry  <span class="number">2009</span>      <span class="number">15</span></span><br><span class="line"><span class="number">2</span>    Smith  <span class="number">2014</span>       <span class="number">9</span></span><br><span class="line"><span class="number">3</span>  William  <span class="number">2010</span>       <span class="number">4</span></span><br><span class="line">********************</span><br><span class="line">         Year  Leaves</span><br><span class="line">Name                 </span><br><span class="line">Parker   <span class="number">2011</span>      <span class="number">10</span></span><br><span class="line">Terry    <span class="number">2009</span>      <span class="number">15</span></span><br><span class="line">Smith    <span class="number">2014</span>       <span class="number">9</span></span><br><span class="line">William  <span class="number">2010</span>       <span class="number">4</span></span><br></pre></td></tr></table></figure><p>（3）重置索引</p><p>使用<code>reset_index()</code>来恢复初始行索引</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">info = pd.DataFrame([(<span class="string">&#x27;William&#x27;</span>, <span class="string">&#x27;C&#x27;</span>), (<span class="string">&#x27;Smith&#x27;</span>, <span class="string">&#x27;Java&#x27;</span>), (<span class="string">&#x27;Parker&#x27;</span>, <span class="string">&#x27;Python&#x27;</span>), (<span class="string">&#x27;Phill&#x27;</span>, np.nan)], index=[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], columns=(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;Language&#x27;</span>)) </span><br><span class="line"><span class="built_in">print</span>(info)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="built_in">print</span>(info.reset_index())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">      name Language</span><br><span class="line"><span class="number">1</span>  William        C</span><br><span class="line"><span class="number">2</span>    Smith     Java</span><br><span class="line"><span class="number">3</span>   Parker   Python</span><br><span class="line"><span class="number">4</span>    Phill      NaN</span><br><span class="line">********************</span><br><span class="line">   index     name Language</span><br><span class="line"><span class="number">0</span>      <span class="number">1</span>  William        C</span><br><span class="line"><span class="number">1</span>      <span class="number">2</span>    Smith     Java</span><br><span class="line"><span class="number">2</span>      <span class="number">3</span>   Parker   Python</span><br><span class="line"><span class="number">3</span>      <span class="number">4</span>    Phill      NaN</span><br></pre></td></tr></table></figure><h2 id="⛄Pandas分层索引"><a href="#⛄Pandas分层索引" class="headerlink" title="⛄Pandas分层索引"></a>⛄Pandas分层索引</h2><p>分层索引（<code>Multiple Index</code>）是<code>Pandas</code>中非常重要的索引类型，它指的是在一个轴上拥有多个（即两个以上）索引层数，这使得我们可以用低维度的结构来处理更高维的数据。比如，当想要处理三维及以上的高维数据时，就需要用到分层索引。</p><p>分层索引的目的是用低维度的结构（<code>Series</code>或者<code>DataFrame</code>）更好地处理高维数据。通过分层索引，我们可以像处理二维数据一样，处理三维及以上的数据。分层索引的存在使得分析高维数据变得简单，让抽象的高维数据变得容易理解，同时它比废弃的<code>Panel</code>结构更容易使用。</p><p><code>Pandas</code>可以通过<code>MultiIndex()</code>方法来创建分层索引对象，该对象本质上是一个元组序列，序列中每一个元组都是唯一的。 </p><h2 id="⛄Pandas执行SQL操作"><a href="#⛄Pandas执行SQL操作" class="headerlink" title="⛄Pandas执行SQL操作"></a>⛄Pandas执行SQL操作</h2><p>如果想要从<code>SQL</code>数据库读取数据，首先您应该使用<code>Python</code>和数据库建立连接，然后将查询语句传递给<code>read_sql_query()</code>方法。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> sqlite3</span><br><span class="line"><span class="comment"># 建立数据连接</span></span><br><span class="line">con = sqlite3.connect(<span class="string">&quot;database.db&quot;</span>)</span><br><span class="line"><span class="comment"># 数据库读取数据,在SQLite数据库中创建一张信息表，您可以随意添加一些信息</span></span><br><span class="line"><span class="comment"># con参数指定操作数据库的引擎，可以指定，也可默认</span></span><br><span class="line">df = pd.read_sql_query(<span class="string">&quot;SELECT * FROM information&quot;</span>,con)  </span><br></pre></td></tr></table></figure><p><code>SELECT</code>查询语句使用<code>,</code>把要查询的每个字段分开，当然您也可以使用<code>*</code>来选择所有的字段。</p><p><code>WHERE</code>子句完成条件查询。</p><p><code>GroupBy</code>分组操作。</p><p><code>LIMIT</code>语句主要起到限制作用，比如查询前n行记录。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 科学计算 </tag>
            
            <tag> 数据分析 </tag>
            
            <tag> Pandas </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python之Pandas详解</title>
      <link href="/2023/03/07/Python-Pandas/"/>
      <url>/2023/03/07/Python-Pandas/</url>
      
        <content type="html"><![CDATA[<p><strong><code>Pandas</code>是<code>Python</code>语言的一个扩展程序库，用于数据分析。</strong></p><p><code>Pandas</code>是一个开放源码、<code>BSD</code>许可的库，提供高性能、易于使用的数据结构和数据分析工具。</p><p><code>Pandas</code>名字衍生自术语 “<code>panel data</code>“（面板数据）和 “<code>Python data analysis</code>“（<code>Python</code>数据分析）。</p><p><code>Pandas</code>一个强大的分析结构化数据的工具集，基础是<code>NumPy</code>（提供高性能的矩阵运算）。</p><p><code>Pandas</code>可以从各种文件格式比如<code>CSV</code>、<code>JSON</code>、<code>SQL</code>、<code>Microsoft Excel</code> 导入数据。</p><p><code>Pandas</code>可以对各种数据进行运算操作，比如归并、再成形、选择，还有数据清洗和数据加工特征。</p><p><code>Pandas</code>广泛应用在学术、金融、统计学等各个数据分析领域。</p><p><code>Pandas</code>主要包括以下几个特点：</p><ul><li>它提供了一个简单、高效、带有默认标签（也可以自定义标签）的<code>DataFrame</code>对象。</li><li>能够快速从不同格式的文件中加载数据（比如 <code>Excel</code>、<code>CSV</code> 、<code>SQL</code>文件），然后转换为可处理的对象；</li><li>能够按数据的行、列标签进行分组，并对分组后的对象执行聚合和转换操作；</li><li>能够很方便地实现数据归一化操作和缺失值处理；</li><li>能够很方便地对<code>DataFrame</code>的数据列进行增加、修改或者删除的操作；</li><li>能够处理不同格式的数据集，比如矩阵数据、异构数据表、时间序列等；</li><li>提供了多种处理数据集的方式，比如构建子集、切片、过滤、分组以及重新排序等。</li></ul><h2 id="⛄Pandas数据结构"><a href="#⛄Pandas数据结构" class="headerlink" title="⛄Pandas数据结构"></a>⛄Pandas数据结构</h2><p><code>Pandas</code>的主要数据结构是<code>Series</code>（一维数据）与<code>DataFrame</code>（二维数据），这两种数据结构足以处理金融、统计、社会科学、工程等领域里的大多数典型用例。</p><p>**<code>Series</code>**是一种类似于一维数组的对象，它由一组数据（各种<code>Numpy</code>数据类型）以及一组与之相关的数据标签（即索引）组成。</p><p>**<code>DataFrame</code>**是一个表格型的数据结构，它含有一组有序的列，每列可以是不同的值类型（数值、字符串、布尔型值）。<code>DataFrame</code>既有行索引也有列索引，它可以被看做由<code>Series</code>组成的字典（共同用一个索引）。</p><h2 id="⛄Pandas-Series"><a href="#⛄Pandas-Series" class="headerlink" title="⛄Pandas Series"></a>⛄Pandas Series</h2><p><code>Pandas Series</code>类似表格中的一个列（<code>column</code>），类似于一维数组，由一组数据值（<code>value</code>）和一组标签组成，其中标签与数据值之间是一一对应的关系。<code>Series</code>可以保存任何数据类型，比如整数、字符串、浮点数、<code>Python</code>对象等，它的标签默认为整数，从0开始依次递增。</p><h3 id="👀创建Series对象"><a href="#👀创建Series对象" class="headerlink" title="👀创建Series对象"></a>👀创建Series对象</h3><p><code>Series</code>由索引（<code>index</code>）和列组成，函数如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pandas.Series(data, index, dtype, name, copy)</span><br><span class="line">参数说明：</span><br><span class="line">    data：一组数据(ndarray类型)。</span><br><span class="line">    index：数据索引标签，如果不指定，默认从<span class="number">0</span>开始。</span><br><span class="line">    dtype：数据类型，默认会自己判断。</span><br><span class="line">    name：设置名称。</span><br><span class="line">    copy：拷贝数据，默认为<span class="literal">False</span>。</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">myvar = pd.Series(a)</span><br><span class="line"><span class="built_in">print</span>(myvar)</span><br><span class="line"><span class="built_in">print</span>(myvar[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果：第一列为索引，第二列为数据</span></span><br><span class="line"><span class="comment"># 如果没有指定索引，索引值就从0开始，我们可以根据索引值读取数据：</span></span><br><span class="line"><span class="number">0</span>    <span class="number">1</span></span><br><span class="line"><span class="number">1</span>    <span class="number">2</span></span><br><span class="line"><span class="number">2</span>    <span class="number">3</span></span><br><span class="line">dtype: int64</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><p>我们也可以使用数组、字典、标量值或者<code>Python</code>对象来创建<code>Series</code>对象。</p><p>（1）创建一个空<code>Series</code>对象</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="comment">#输出数据为空</span></span><br><span class="line">s = pd.Series()</span><br><span class="line"><span class="built_in">print</span>(s)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">Series([], dtype: float64)</span><br></pre></td></tr></table></figure><p>（2）<code>ndarray</code>创建<code>Series</code>对象</p><p><code>ndarray</code>是<code>NumPy</code>中的数组类型，当<code>data</code>是<code>ndarry</code>时，传递的索引必须具有与数组相同的长度。如果没有指定索引（隐式索引)，索引值就从0开始（索引值将使用是<code>range(n)</code> 生成，其中n代表数组长度）；我们可以根据索引值读取数据。可以指定索引值（显式索引），如下实例。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定索引值</span></span><br><span class="line">a = np.array([<span class="string">&quot;Google&quot;</span>, <span class="string">&quot;Runoob&quot;</span>, <span class="string">&quot;Wiki&quot;</span>])</span><br><span class="line">myvar = pd.Series(a, index = [<span class="string">&quot;x&quot;</span>, <span class="string">&quot;y&quot;</span>, <span class="string">&quot;z&quot;</span>])</span><br><span class="line"><span class="built_in">print</span>(myvar)</span><br><span class="line"><span class="built_in">print</span>(myvar[<span class="string">&quot;y&quot;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">#输出结果</span></span><br><span class="line">x    Google</span><br><span class="line">y    Runoob</span><br><span class="line">z      Wiki</span><br><span class="line">dtype: <span class="built_in">object</span></span><br><span class="line">Runoob</span><br></pre></td></tr></table></figure><p>（3）<code>dict</code>创建<code>Series</code>对象</p><p>我们也可以使用<code>key/value</code>对象，类似字典来创建<code>Series</code>：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用字典创建Series</span></span><br><span class="line"><span class="comment"># 没有传递索引，字典的key变成了索引值。</span></span><br><span class="line">sites = &#123;<span class="number">1</span>: <span class="string">&quot;Google&quot;</span>, <span class="number">2</span>: <span class="string">&quot;Runoob&quot;</span>, <span class="number">3</span>: <span class="string">&quot;Wiki&quot;</span>&#125;</span><br><span class="line">myvar1 = pd.Series(sites)</span><br><span class="line"><span class="built_in">print</span>(myvar1)</span><br><span class="line"><span class="comment"># 如果我们只需要字典中的一部分数据，只需要指定需要数据的索引即可，如下实例：</span></span><br><span class="line">myvar2 = pd.Series(sites, index = [<span class="number">1</span>,<span class="number">2</span>])</span><br><span class="line"><span class="built_in">print</span>(myvar2)</span><br><span class="line"><span class="comment"># 当传递的索引值无法找到与其对应的值时，使用NaN（非数字）填充。</span></span><br><span class="line">myvar3 = pd.Series(sites, index = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>])</span><br><span class="line"><span class="built_in">print</span>(myvar3)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="number">1</span>    Google</span><br><span class="line"><span class="number">2</span>    Runoob</span><br><span class="line"><span class="number">3</span>      Wiki</span><br><span class="line">dtype: <span class="built_in">object</span></span><br><span class="line"><span class="number">1</span>    Google</span><br><span class="line"><span class="number">2</span>    Runoob</span><br><span class="line">dtype: <span class="built_in">object</span></span><br><span class="line"><span class="number">1</span>    Google</span><br><span class="line"><span class="number">3</span>      Wiki</span><br><span class="line"><span class="number">2</span>    Runoob</span><br><span class="line"><span class="number">4</span>       NaN</span><br><span class="line">dtype: <span class="built_in">object</span></span><br></pre></td></tr></table></figure><blockquote><p>当传递的索引值无法找到与其对应的值时，使用<code>NaN</code>（非数字）填充。</p></blockquote><p>（4）标量创建<code>Series</code>对象</p><p>如果<code>data</code>是标量值，则必须提供索引，示例如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">s = pd.Series(<span class="number">5</span>, index = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"><span class="built_in">print</span>(s)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="number">0</span>    <span class="number">5</span></span><br><span class="line"><span class="number">1</span>    <span class="number">5</span></span><br><span class="line"><span class="number">2</span>    <span class="number">5</span></span><br><span class="line"><span class="number">3</span>    <span class="number">5</span></span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure><blockquote><p>标量值按照<code>index</code>的数量进行重复，并与其一一对应。</p></blockquote><p>设置<code>Series</code>名称参数：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">sites = &#123;<span class="number">1</span>: <span class="string">&quot;Google&quot;</span>, <span class="number">2</span>: <span class="string">&quot;Runoob&quot;</span>, <span class="number">3</span>: <span class="string">&quot;Wiki&quot;</span>&#125;</span><br><span class="line">myvar = pd.Series(sites, index = [<span class="number">1</span>, <span class="number">2</span>], name=<span class="string">&quot;RUNOOB-Series-TEST&quot;</span> )</span><br><span class="line"><span class="built_in">print</span>(myvar)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="number">1</span>    Google</span><br><span class="line"><span class="number">2</span>    Runoob</span><br><span class="line">Name: RUNOOB-Series-TEST, dtype: <span class="built_in">object</span></span><br></pre></td></tr></table></figure><h3 id="👀访问Series数据"><a href="#👀访问Series数据" class="headerlink" title="👀访问Series数据"></a>👀访问Series数据</h3><p>（1）位置索引访问</p><p>这种访问方式与<code>ndarray</code>和<code>list</code>相同，使用元素自身的下标进行访问。我们知道数组的索引计数从0开始，这表示第一个元素存储在第0个索引位置上，以此类推，就可以获得<code>Series</code>序列中的每个元素。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">s = pd.Series([<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],index = [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(s[<span class="number">0</span>])  <span class="comment"># 位置下标</span></span><br><span class="line"><span class="built_in">print</span>(s[<span class="string">&#x27;a&#x27;</span>]) <span class="comment"># 标签下标</span></span><br><span class="line"><span class="comment"># 通过切片的方式访问Series序列中的数据</span></span><br><span class="line"><span class="built_in">print</span>(s[:<span class="number">3</span>])</span><br><span class="line"><span class="comment"># 获取最后三个元素</span></span><br><span class="line"><span class="built_in">print</span>(s[-<span class="number">3</span>:])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line">a    <span class="number">5</span></span><br><span class="line">b    <span class="number">2</span></span><br><span class="line">c    <span class="number">3</span></span><br><span class="line">dtype: int64</span><br><span class="line">c    <span class="number">3</span></span><br><span class="line">d    <span class="number">4</span></span><br><span class="line">e    <span class="number">5</span></span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure><p>（2）索引标签访问</p><p><code>Series</code>类似于固定大小的<code>dict</code>，把<code>index</code>中的索引标签当做<code>key</code>，而把<code>Series</code>序列中的元素值当做<code>value</code>，然后通过<code>index</code>索引标签来访问或者修改元素值。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="comment"># 使用索标签访问单个元素值</span></span><br><span class="line">s = pd.Series([<span class="number">16</span>,<span class="number">17</span>,<span class="number">18</span>,<span class="number">19</span>,<span class="number">20</span>],index = [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(s[<span class="string">&#x27;a&#x27;</span>])</span><br><span class="line"><span class="comment"># 使用索引标签访问多个元素值</span></span><br><span class="line"><span class="built_in">print</span>(s[[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>]])</span><br><span class="line"><span class="comment"># 如果使用了index中不包含的标签，则会触发异常</span></span><br><span class="line"><span class="built_in">print</span>(s[<span class="string">&#x27;f&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="number">16</span></span><br><span class="line">a    <span class="number">16</span></span><br><span class="line">c    <span class="number">18</span></span><br><span class="line">d    <span class="number">19</span></span><br><span class="line">dtype: int64</span><br><span class="line">......</span><br><span class="line">KeyError: <span class="string">&#x27;f&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="👀Series常用属性"><a href="#👀Series常用属性" class="headerlink" title="👀Series常用属性"></a>👀Series常用属性</h3><p><code>Series</code>的常用属性和方法：</p><table><thead><tr><th>名称</th><th>属性</th></tr></thead><tbody><tr><td><code>axes</code></td><td>以列表的形式返回所有行索引标签</td></tr><tr><td><code>dtype</code></td><td>返回对象的数据类型</td></tr><tr><td><code>empty</code></td><td>返回一个空的<code>Series</code>对象</td></tr><tr><td><code>ndim</code></td><td>返回输入数据的维数</td></tr><tr><td><code>size</code></td><td>返回输入数据的元素数量</td></tr><tr><td><code>values</code></td><td>以<code>ndarray</code>的形式返回<code>Series</code>对象</td></tr><tr><td><code>index</code></td><td>返回一个<code>RangeIndex</code>对象，用来描述索引的取值范围</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">s = pd.Series(np.random.randn(<span class="number">6</span>))</span><br><span class="line"><span class="built_in">print</span>(s)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># axes属性</span></span><br><span class="line"><span class="built_in">print</span>(s.axes)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># dtype属性</span></span><br><span class="line"><span class="built_in">print</span>(s.dtype)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># empty</span></span><br><span class="line"><span class="built_in">print</span>(s.empty)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># ndim，Series是一维数据结构，因此它始终返回1</span></span><br><span class="line"><span class="built_in">print</span>(s.ndim)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># size返回Series对象的大小(长度)</span></span><br><span class="line"><span class="built_in">print</span>(s.size)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># value以数组的形式返回Series对象中的数据</span></span><br><span class="line"><span class="built_in">print</span>(s.values)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># index该属性用来查看Series中索引的取值范围</span></span><br><span class="line"><span class="comment">#显示索引</span></span><br><span class="line">s1 = pd.Series([<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">8</span>],index = [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(s1.index)</span><br><span class="line"><span class="comment">#隐式索引</span></span><br><span class="line">s2 = pd.Series([<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">8</span>])</span><br><span class="line"><span class="built_in">print</span>(s2.index)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="number">0</span>   -<span class="number">0.674501</span></span><br><span class="line"><span class="number">1</span>    <span class="number">1.030106</span></span><br><span class="line"><span class="number">2</span>   -<span class="number">1.636359</span></span><br><span class="line"><span class="number">3</span>   -<span class="number">1.540996</span></span><br><span class="line"><span class="number">4</span>    <span class="number">1.312837</span></span><br><span class="line"><span class="number">5</span>   -<span class="number">0.735986</span></span><br><span class="line">dtype: float64</span><br><span class="line">********************</span><br><span class="line">[RangeIndex(start=<span class="number">0</span>, stop=<span class="number">6</span>, step=<span class="number">1</span>)]</span><br><span class="line">********************</span><br><span class="line">float64</span><br><span class="line">********************</span><br><span class="line"><span class="literal">False</span></span><br><span class="line">********************</span><br><span class="line"><span class="number">1</span></span><br><span class="line">********************</span><br><span class="line"><span class="number">6</span></span><br><span class="line">********************</span><br><span class="line">[-<span class="number">0.67450078</span>  <span class="number">1.03010573</span> -<span class="number">1.63635856</span> -<span class="number">1.54099596</span>  <span class="number">1.31283698</span> -<span class="number">0.73598645</span>]</span><br><span class="line">********************</span><br><span class="line">Index([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>], dtype=<span class="string">&#x27;object&#x27;</span>)</span><br><span class="line">RangeIndex(start=<span class="number">0</span>, stop=<span class="number">4</span>, step=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><h3 id="👀Series常用方法"><a href="#👀Series常用方法" class="headerlink" title="👀Series常用方法"></a>👀Series常用方法</h3><p>（1）<code>head()</code>&amp;<code>tail()</code>查看数据</p><p>如果想要查看<code>Series</code>的某一部分数据，可以使用<code>head()</code>或者tail()方法。其中<code>head()</code>返回前n行数据，默认显示前5行数据。<code>tail()</code>返回的是后n行数据，默认为后5行。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">s = pd.Series(np.random.randn(<span class="number">5</span>))</span><br><span class="line"><span class="built_in">print</span> (s)</span><br><span class="line"><span class="comment"># 返回前三行数据</span></span><br><span class="line"><span class="built_in">print</span>(s.head(<span class="number">3</span>))</span><br><span class="line"><span class="comment"># 返回后两行数据</span></span><br><span class="line"><span class="built_in">print</span>(s.tail(<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="number">0</span>   -<span class="number">0.264915</span></span><br><span class="line"><span class="number">1</span>   -<span class="number">1.120671</span></span><br><span class="line"><span class="number">2</span>    <span class="number">0.621638</span></span><br><span class="line"><span class="number">3</span>   -<span class="number">0.449170</span></span><br><span class="line"><span class="number">4</span>    <span class="number">0.533876</span></span><br><span class="line">dtype: float64</span><br><span class="line"><span class="number">0</span>   -<span class="number">0.264915</span></span><br><span class="line"><span class="number">1</span>   -<span class="number">1.120671</span></span><br><span class="line"><span class="number">2</span>    <span class="number">0.621638</span></span><br><span class="line">dtype: float64</span><br><span class="line"><span class="number">2</span>    <span class="number">0.621638</span></span><br><span class="line"><span class="number">3</span>   -<span class="number">0.449170</span></span><br><span class="line"><span class="number">4</span>    <span class="number">0.533876</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure><p>（2）<code>isnull()</code>&amp;<code>notnull()</code>检测缺失值</p><p><code>isnull()</code>和<code>notnull()</code>用于检测<code>Series</code>中的缺失值。所谓缺失值，顾名思义就是值不存在、丢失、缺少。</p><ul><li><code>isnull()</code>：如果为值不存在或者缺失，则返回<code>True</code>。</li><li><code>notnull()</code>：如果值不存在或者缺失，则返回<code>False</code>。</li></ul><p>其实不难理解，在实际的数据分析任物中，数据的收集往往要经历一个繁琐的过程。在这个过程中难免会因为一些不可抗力，或者人为因素导致数据丢失的现象。这时，我们可以使用相应的方法对缺失值进行处理，比如均值插值、数据补齐等方法。上述两个方法就是帮助我们检测是否存在缺失值。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="comment">#None代表缺失数据</span></span><br><span class="line">s = pd.Series([<span class="number">1</span>,<span class="number">6</span>,<span class="literal">None</span>,<span class="number">8</span>,<span class="literal">None</span>])</span><br><span class="line"><span class="built_in">print</span>(pd.isnull(s))  <span class="comment">#是空值返回True</span></span><br><span class="line"><span class="built_in">print</span>(pd.notnull(s)) <span class="comment">#空值返回False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="number">0</span>    <span class="literal">False</span></span><br><span class="line"><span class="number">1</span>    <span class="literal">False</span></span><br><span class="line"><span class="number">2</span>     <span class="literal">True</span></span><br><span class="line"><span class="number">3</span>    <span class="literal">False</span></span><br><span class="line"><span class="number">4</span>     <span class="literal">True</span></span><br><span class="line">dtype: <span class="built_in">bool</span></span><br><span class="line"><span class="number">0</span>     <span class="literal">True</span></span><br><span class="line"><span class="number">1</span>     <span class="literal">True</span></span><br><span class="line"><span class="number">2</span>    <span class="literal">False</span></span><br><span class="line"><span class="number">3</span>     <span class="literal">True</span></span><br><span class="line"><span class="number">4</span>    <span class="literal">False</span></span><br><span class="line">dtype: <span class="built_in">bool</span></span><br></pre></td></tr></table></figure><h2 id="⛄Pandas-DataFrame"><a href="#⛄Pandas-DataFrame" class="headerlink" title="⛄Pandas DataFrame"></a>⛄Pandas DataFrame</h2><p><code>DataFrame</code>是表格型的数据结构，既有行标签（<code>index</code>），又有列标签（<code>columns</code>），它也被称异构数据表。</p><p>它含有一组有序的列，每列可以是不同的值类型（数值、字符串、布尔型值）。<code>DataFrame</code>既有<strong>行索引</strong>也有<strong>列索引</strong>，它可以被看做由<code>Series</code>组成的字典（共同用一个索引），每一行数据都可以看成一个<code>Series</code>结构，<code>DataFrame</code>为这些行中每个数据值增加了一个列标签。</p><p>同<code>Series</code>一样，<code>DataFrame</code>自带行标签索引，默认为“隐式索引”即从0开始依次递增，行标签与<code>DataFrame</code>中的数据项一一对应。<code>DataFrame</code>数据结构的特点：</p><ul><li><code>DataFrame</code>每一列的标签值允许使用不同的数据类型；</li><li><code>DataFrame</code>是表格型的数据结构，具有行和列；</li><li><code>DataFrame</code>中的每个数据值都可以被修改；</li><li><code>DataFrame</code>结构的行数、列数允许增加或者删除；</li><li><code>DataFrame</code>有两个方向的标签轴，分别是行标签和列标签；</li><li><code>DataFrame</code>可以对行和列执行算术运算。</li></ul><h3 id="👀创建DF对象"><a href="#👀创建DF对象" class="headerlink" title="👀创建DF对象"></a>👀创建DF对象</h3><p><code>DataFrame</code>构造方法如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pandas.DataFrame(data, index, columns, dtype, copy)</span><br><span class="line">参数说明：</span><br><span class="line">    data：一组数据(ndarray、series, <span class="built_in">map</span>, lists, <span class="built_in">dict</span>等类型)。</span><br><span class="line">    index：索引值，或者可以称为行标签。</span><br><span class="line">    columns：列标签，默认为RangeIndex(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, …, n) 。</span><br><span class="line">    dtype：数据类型。</span><br><span class="line">    copy：拷贝数据，默认为<span class="literal">False</span>。</span><br></pre></td></tr></table></figure><p><code>Pandas DataFrame</code>是一个二维的数组结构，类似二维数组。</p><p><code>Pandas</code>提供了多种创建<code>DataFrame</code>对象的方式，主要包含以下五种：</p><p>（1）创建空的<code>DataFrame</code>对象</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">df = pd.DataFrame()</span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">Empty DataFrame</span><br><span class="line">Columns: []</span><br><span class="line">Index: []</span><br></pre></td></tr></table></figure><p>（2）列表创建<code>DataFame</code>对象</p><p>可以使用单一列表或嵌套列表来创建一个<code>DataFrame</code>。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 单一列表创建DataFrame对象</span></span><br><span class="line">data1 = [<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>]</span><br><span class="line">df1 = pd.DataFrame(data1)</span><br><span class="line"><span class="built_in">print</span>(df1)</span><br><span class="line"><span class="comment"># 嵌套列表创建DataFrame对象，并指定数值元素的数据类型为float</span></span><br><span class="line">data2 = [[<span class="string">&#x27;Google&#x27;</span>,<span class="number">10</span>],[<span class="string">&#x27;Runoob&#x27;</span>,<span class="number">12</span>],[<span class="string">&#x27;Wiki&#x27;</span>,<span class="number">13</span>]]</span><br><span class="line">df2 = pd.DataFrame(data2,columns = [<span class="string">&#x27;Site&#x27;</span>,<span class="string">&#x27;Age&#x27;</span>],dtype = <span class="built_in">float</span>)</span><br><span class="line"><span class="built_in">print</span>(df2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">    <span class="number">0</span></span><br><span class="line"><span class="number">0</span>   <span class="number">6</span></span><br><span class="line"><span class="number">1</span>   <span class="number">7</span></span><br><span class="line"><span class="number">2</span>   <span class="number">8</span></span><br><span class="line"><span class="number">3</span>   <span class="number">9</span></span><br><span class="line"><span class="number">4</span>  <span class="number">10</span></span><br><span class="line">     Site   Age</span><br><span class="line"><span class="number">0</span>  Google  <span class="number">10.0</span></span><br><span class="line"><span class="number">1</span>  Runoob  <span class="number">12.0</span></span><br><span class="line"><span class="number">2</span>    Wiki  <span class="number">13.0</span></span><br></pre></td></tr></table></figure><p>（3）字典嵌套列表创建<code>DataFame</code>对象</p><p><code>dict</code>字典中，键对应的值的元素长度必须相同（也就是列表长度相同）。如果传递了索引，那么索引的长度应该等于数组的长度；如果没有传递索引，那么默认情况下，索引将是<code>range(n)</code>，其中n代表数组长度。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里使用了默认行标签，也就是range(n)。它生成了0,1,2,3，并分别对应了列表中的每个元素值</span></span><br><span class="line">data = &#123;<span class="string">&#x27;Site&#x27;</span>:[<span class="string">&#x27;Google&#x27;</span>, <span class="string">&#x27;Runoob&#x27;</span>, <span class="string">&#x27;Wiki&#x27;</span>], <span class="string">&#x27;Age&#x27;</span>:[<span class="number">10</span>, <span class="number">12</span>, <span class="number">13</span>]&#125;</span><br><span class="line">df = pd.DataFrame(data)</span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line"><span class="comment"># 添加自定义的行标签,index参数为每行分配了一个索引</span></span><br><span class="line">df2 = pd.DataFrame(data,index = [<span class="string">&#x27;one&#x27;</span>,<span class="string">&#x27;two&#x27;</span>,<span class="string">&#x27;three&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(df2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">     Site  Age</span><br><span class="line"><span class="number">0</span>  Google   <span class="number">10</span></span><br><span class="line"><span class="number">1</span>  Runoob   <span class="number">12</span></span><br><span class="line"><span class="number">2</span>    Wiki   <span class="number">13</span></span><br><span class="line">         Site  Age</span><br><span class="line">one    Google   <span class="number">10</span></span><br><span class="line">two    Runoob   <span class="number">12</span></span><br><span class="line">three    Wiki   <span class="number">13</span></span><br></pre></td></tr></table></figure><p>从以上输出结果可以知道， <code>DataFrame</code>数据类型一个表格，包含<code>rows</code>（行）和<code>columns</code>（列）。</p><p>（4）列表嵌套字典创建<code>DataFrame</code>对象</p><p>列表嵌套字典可以作为输入数据传递给<code>DataFrame</code>构造函数。默认情况下，字典的键被用作列名。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列表嵌套字典</span></span><br><span class="line">data1 = [&#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>&#125;, &#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">5</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">10</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">20</span>&#125;]</span><br><span class="line"><span class="comment"># 字典嵌套列表</span></span><br><span class="line">data2 = &#123;<span class="string">&#x27;a&#x27;</span>:[<span class="number">1</span>, <span class="number">5</span>], <span class="string">&#x27;b&#x27;</span>:[<span class="number">2</span>, <span class="number">10</span>], <span class="string">&#x27;c&#x27;</span>:[<span class="number">15</span>, <span class="number">20</span>]&#125;</span><br><span class="line">df1 = pd.DataFrame(data1)</span><br><span class="line"><span class="built_in">print</span>(df1)</span><br><span class="line">df2 = pd.DataFrame(data2)</span><br><span class="line"><span class="built_in">print</span>(df2)</span><br><span class="line"><span class="comment"># 添加行标签索引</span></span><br><span class="line">df3 = pd.DataFrame(data1,index = [<span class="string">&#x27;one&#x27;</span>,<span class="string">&#x27;two&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(df3)</span><br><span class="line"><span class="comment"># 行标签索引</span></span><br><span class="line"><span class="comment"># 注意：因为&#x27;abc&#x27;在字典键中不存在，所以对应值为NaN</span></span><br><span class="line">df4 = pd.DataFrame(data1,index = [<span class="string">&#x27;one&#x27;</span>,<span class="string">&#x27;two&#x27;</span>],columns = [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;abc&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(df4)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果，没有对应的部分数据为NaN。</span></span><br><span class="line">   a   b     c</span><br><span class="line"><span class="number">0</span>  <span class="number">1</span>   <span class="number">2</span>   NaN</span><br><span class="line"><span class="number">1</span>  <span class="number">5</span>  <span class="number">10</span>  <span class="number">20.0</span></span><br><span class="line">   a   b   c</span><br><span class="line"><span class="number">0</span>  <span class="number">1</span>   <span class="number">2</span>  <span class="number">15</span></span><br><span class="line"><span class="number">1</span>  <span class="number">5</span>  <span class="number">10</span>  <span class="number">20</span></span><br><span class="line">     a   b     c</span><br><span class="line">one  <span class="number">1</span>   <span class="number">2</span>   NaN</span><br><span class="line">two  <span class="number">5</span>  <span class="number">10</span>  <span class="number">20.0</span></span><br><span class="line">     a  abc</span><br><span class="line">one  <span class="number">1</span>  NaN</span><br><span class="line">two  <span class="number">5</span>  NaN</span><br></pre></td></tr></table></figure><p>（5）<code>Series</code>创建<code>DataFrame</code>对象</p><p>可以传递一个字典形式的<code>Series</code>，从而创建一个<code>DataFrame</code>对象，其输出结果的行索引是所有index的合集。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">d = &#123;<span class="string">&#x27;one&#x27;</span> : pd.Series([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], index = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]),</span><br><span class="line">   <span class="string">&#x27;two&#x27;</span> : pd.Series([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], index = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>])&#125;</span><br><span class="line">df = pd.DataFrame(d)</span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果，对于one列而言，此处虽然显示了行索引&#x27;d&#x27;，但由于没有与其对应的值，所以它的值为NaN</span></span><br><span class="line">   one  two</span><br><span class="line">a  <span class="number">1.0</span>    <span class="number">1</span></span><br><span class="line">b  <span class="number">2.0</span>    <span class="number">2</span></span><br><span class="line">c  <span class="number">3.0</span>    <span class="number">3</span></span><br><span class="line">d  NaN    <span class="number">4</span></span><br></pre></td></tr></table></figure><h3 id="👀列索引操作DF对象"><a href="#👀列索引操作DF对象" class="headerlink" title="👀列索引操作DF对象"></a>👀列索引操作DF对象</h3><p><code>DataFrame</code>可以使用列索（<code>columns index</code>）引来完成数据的选取、添加和删除操作。</p><p>（1）列索引选取数据列</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">data = &#123;</span><br><span class="line">  <span class="string">&quot;calories&quot;</span>: [<span class="number">420</span>, <span class="number">380</span>, <span class="number">390</span>],</span><br><span class="line">  <span class="string">&quot;duration&quot;</span>: [<span class="number">50</span>, <span class="number">40</span>, <span class="number">45</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 数据载入到DataFrame对象</span></span><br><span class="line">df = pd.DataFrame(data, index = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line"><span class="comment"># 返回第一列 </span></span><br><span class="line"><span class="built_in">print</span>(df[<span class="string">&#x27;calories&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">   calories  duration</span><br><span class="line">a       <span class="number">420</span>        <span class="number">50</span></span><br><span class="line">b       <span class="number">380</span>        <span class="number">40</span></span><br><span class="line">c       <span class="number">390</span>        <span class="number">45</span></span><br><span class="line">a    <span class="number">420</span></span><br><span class="line">b    <span class="number">380</span></span><br><span class="line">c    <span class="number">390</span></span><br><span class="line">Name: calories, dtype: int64</span><br></pre></td></tr></table></figure><p>（2）列索引添加数据列</p><p>使用<code>columns</code>列索引表标签可以实现添加新的数据列。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">data = &#123;</span><br><span class="line">  <span class="string">&quot;calories&quot;</span>: [<span class="number">420</span>, <span class="number">380</span>, <span class="number">390</span>],</span><br><span class="line">  <span class="string">&quot;duration&quot;</span>: [<span class="number">50</span>, <span class="number">40</span>, <span class="number">45</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 数据载入到DataFrame对象</span></span><br><span class="line">df = pd.DataFrame(data, index = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line"><span class="comment"># 返回第一列 </span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 使用df[&#x27;列&#x27;]=值，插入新的数据列</span></span><br><span class="line">df[<span class="string">&#x27;height&#x27;</span>] = pd.Series([<span class="number">160</span>,<span class="number">170</span>,<span class="number">180</span>], index = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 将已经存在的数据列做相加运算</span></span><br><span class="line">df[<span class="string">&#x27;sums&#x27;</span>] = df[<span class="string">&#x27;calories&#x27;</span>] + df[<span class="string">&#x27;duration&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">   calories  duration</span><br><span class="line">a       <span class="number">420</span>        <span class="number">50</span></span><br><span class="line">b       <span class="number">380</span>        <span class="number">40</span></span><br><span class="line">c       <span class="number">390</span>        <span class="number">45</span></span><br><span class="line">********************</span><br><span class="line">   calories  duration  height</span><br><span class="line">a       <span class="number">420</span>        <span class="number">50</span>     <span class="number">160</span></span><br><span class="line">b       <span class="number">380</span>        <span class="number">40</span>     <span class="number">170</span></span><br><span class="line">c       <span class="number">390</span>        <span class="number">45</span>     <span class="number">180</span></span><br><span class="line">********************</span><br><span class="line">   calories  duration  height  sums</span><br><span class="line">a       <span class="number">420</span>        <span class="number">50</span>     <span class="number">160</span>  <span class="number">470</span></span><br><span class="line">b       <span class="number">380</span>        <span class="number">40</span>     <span class="number">170</span>  <span class="number">420</span></span><br><span class="line">c       <span class="number">390</span>        <span class="number">45</span>     <span class="number">180</span>  <span class="number">435</span></span><br></pre></td></tr></table></figure><p>我们初次使用了<code>DataFrame</code>的算术运算，这和<code>NumPy</code>非常相似。除了使用<code>df[]=value</code>的方式外，您还可以使用<code>insert()</code>方法插入新的列.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">info = [[<span class="string">&#x27;Jack&#x27;</span>,<span class="number">18</span>],[<span class="string">&#x27;Helen&#x27;</span>,<span class="number">19</span>],[<span class="string">&#x27;John&#x27;</span>,<span class="number">17</span>]]</span><br><span class="line">df = pd.DataFrame(info,columns = [<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;age&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line"><span class="comment"># 注意是column参数</span></span><br><span class="line"><span class="comment"># 数值1代表插入到columns列表的索引位置</span></span><br><span class="line">df.insert(<span class="number">1</span>,column = <span class="string">&#x27;score&#x27;</span>,value = [<span class="number">91</span>,<span class="number">90</span>,<span class="number">75</span>])</span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">    name  age</span><br><span class="line"><span class="number">0</span>   Jack   <span class="number">18</span></span><br><span class="line"><span class="number">1</span>  Helen   <span class="number">19</span></span><br><span class="line"><span class="number">2</span>   John   <span class="number">17</span></span><br><span class="line">    name  score  age</span><br><span class="line"><span class="number">0</span>   Jack     <span class="number">91</span>   <span class="number">18</span></span><br><span class="line"><span class="number">1</span>  Helen     <span class="number">90</span>   <span class="number">19</span></span><br><span class="line"><span class="number">2</span>   John     <span class="number">75</span>   <span class="number">17</span></span><br></pre></td></tr></table></figure><p>（3）列索引删除数据列</p><p>通过<code>del</code>和<code>pop()</code>都能够删除<code>DataFrame</code>中的数据列。示例如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">d = &#123;<span class="string">&#x27;one&#x27;</span>: pd.Series([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], index = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]),</span><br><span class="line">   <span class="string">&#x27;two&#x27;</span>: pd.Series([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], index = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>]),</span><br><span class="line">   <span class="string">&#x27;three&#x27;</span>: pd.Series([<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>], index = [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>])&#125;</span><br><span class="line">df = pd.DataFrame(d)</span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 使用del删除</span></span><br><span class="line"><span class="keyword">del</span> df[<span class="string">&#x27;one&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 使用pop方法删除</span></span><br><span class="line">df.pop(<span class="string">&#x27;two&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">   one  two  three</span><br><span class="line">a  <span class="number">1.0</span>    <span class="number">1</span>   <span class="number">10.0</span></span><br><span class="line">b  <span class="number">2.0</span>    <span class="number">2</span>   <span class="number">20.0</span></span><br><span class="line">c  <span class="number">3.0</span>    <span class="number">3</span>   <span class="number">30.0</span></span><br><span class="line">d  NaN    <span class="number">4</span>    NaN</span><br><span class="line">********************</span><br><span class="line">   two  three</span><br><span class="line">a    <span class="number">1</span>   <span class="number">10.0</span></span><br><span class="line">b    <span class="number">2</span>   <span class="number">20.0</span></span><br><span class="line">c    <span class="number">3</span>   <span class="number">30.0</span></span><br><span class="line">d    <span class="number">4</span>    NaN</span><br><span class="line">********************</span><br><span class="line">   three</span><br><span class="line">a   <span class="number">10.0</span></span><br><span class="line">b   <span class="number">20.0</span></span><br><span class="line">c   <span class="number">30.0</span></span><br><span class="line">d    NaN</span><br></pre></td></tr></table></figure><h3 id="👀行索引操作DF对象"><a href="#👀行索引操作DF对象" class="headerlink" title="👀行索引操作DF对象"></a>👀行索引操作DF对象</h3><p><code>Pandas</code>可以使用**<code>loc</code>**函数返回指定行的数据，如果没有设置索引，第一行索引为0，第二行索引为1，以此类推。</p><p>（1）标签索引选取</p><p>通过将行标签传递给<code>loc</code>函数，来选取数据。</p><p><code>loc</code>允许接两个参数分别是行和列，参数之间需要使用“逗号”隔开，但该函数只能接收<strong>标签索引</strong>。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">data = &#123;</span><br><span class="line">  <span class="string">&quot;calories&quot;</span>: [<span class="number">420</span>, <span class="number">380</span>, <span class="number">390</span>],</span><br><span class="line">  <span class="string">&quot;duration&quot;</span>: [<span class="number">50</span>, <span class="number">40</span>, <span class="number">45</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 数据载入到 DataFrame 对象</span></span><br><span class="line">df = pd.DataFrame(data, index = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="built_in">print</span>(df.loc[<span class="string">&#x27;a&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">   calories  duration</span><br><span class="line">a       <span class="number">420</span>        <span class="number">50</span></span><br><span class="line">b       <span class="number">380</span>        <span class="number">40</span></span><br><span class="line">c       <span class="number">390</span>        <span class="number">45</span></span><br><span class="line">********************</span><br><span class="line">calories    <span class="number">420</span></span><br><span class="line">duration     <span class="number">50</span></span><br><span class="line">Name: a, dtype: int64</span><br></pre></td></tr></table></figure><p>（2）整数索引选取</p><p>通过将数据行所在的索引位置传递给<code>iloc</code>函数，也可以实现数据行选取。</p><p><code>iloc</code>允许接受两个参数分别是行和列，参数之间使用“逗号”隔开，但该函数只能接收<strong>整数索引</strong>。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">data = &#123;</span><br><span class="line">  <span class="string">&quot;calories&quot;</span>: [<span class="number">420</span>, <span class="number">380</span>, <span class="number">390</span>],</span><br><span class="line">  <span class="string">&quot;duration&quot;</span>: [<span class="number">50</span>, <span class="number">40</span>, <span class="number">45</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 数据载入到 DataFrame 对象</span></span><br><span class="line">df = pd.DataFrame(data, index = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 返回第一行，返回结果其实就是一个Pandas Series数据。</span></span><br><span class="line"><span class="built_in">print</span>(df.iloc[<span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 返回第二行，返回结果其实就是一个Pandas Series数据。</span></span><br><span class="line"><span class="built_in">print</span>(df.iloc[<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 也可以返回多行数据，使用[[ ... ]] 格式，... 为各行的索引，以逗号隔开：</span></span><br><span class="line"><span class="comment"># 返回第一行和第二行，返回结果其实就是一个Pandas DataFrame数据。</span></span><br><span class="line"><span class="built_in">print</span>(df.iloc[[<span class="number">0</span>, <span class="number">1</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">   calories  duration</span><br><span class="line">a       <span class="number">420</span>        <span class="number">50</span></span><br><span class="line">b       <span class="number">380</span>        <span class="number">40</span></span><br><span class="line">c       <span class="number">390</span>        <span class="number">45</span></span><br><span class="line">********************</span><br><span class="line">calories    <span class="number">420</span></span><br><span class="line">duration     <span class="number">50</span></span><br><span class="line">Name: a, dtype: int64</span><br><span class="line">********************</span><br><span class="line">calories    <span class="number">380</span></span><br><span class="line">duration     <span class="number">40</span></span><br><span class="line">Name: b, dtype: int64</span><br><span class="line">********************</span><br><span class="line">   calories  duration</span><br><span class="line">a       <span class="number">420</span>        <span class="number">50</span></span><br><span class="line">b       <span class="number">380</span>        <span class="number">40</span></span><br></pre></td></tr></table></figure><p>（3）切片操作多行数据</p><p>通过使用切片的方式同时选取多行。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">data = &#123;</span><br><span class="line">  <span class="string">&quot;calories&quot;</span>: [<span class="number">420</span>, <span class="number">380</span>, <span class="number">390</span>],</span><br><span class="line">  <span class="string">&quot;duration&quot;</span>: [<span class="number">50</span>, <span class="number">40</span>, <span class="number">45</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 数据载入到 DataFrame 对象</span></span><br><span class="line">df = pd.DataFrame(data, index = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 左闭右开</span></span><br><span class="line"><span class="built_in">print</span>(df[<span class="number">1</span>:<span class="number">3</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">   calories  duration</span><br><span class="line">a       <span class="number">420</span>        <span class="number">50</span></span><br><span class="line">b       <span class="number">380</span>        <span class="number">40</span></span><br><span class="line">c       <span class="number">390</span>        <span class="number">45</span></span><br><span class="line">********************</span><br><span class="line">   calories  duration</span><br><span class="line">b       <span class="number">380</span>        <span class="number">40</span></span><br><span class="line">c       <span class="number">390</span>        <span class="number">45</span></span><br></pre></td></tr></table></figure><p>（4）添加数据行</p><p>使用<code>append()</code>函数，可以将新的数据行添加到<code>DataFrame</code>中，该函数会在行末追加数据行。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">df = pd.DataFrame([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]], index = [<span class="string">&#x27;one&#x27;</span>,<span class="string">&#x27;two&#x27;</span>], columns = [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>])</span><br><span class="line">df2 = pd.DataFrame([[<span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>]], index = [<span class="string">&#x27;one&#x27;</span>,<span class="string">&#x27;two&#x27;</span>], columns = [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>])</span><br><span class="line"><span class="comment"># 在行末追加新数据行</span></span><br><span class="line">df = df.append(df2)</span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">     a  b</span><br><span class="line">one  <span class="number">1</span>  <span class="number">2</span></span><br><span class="line">two  <span class="number">3</span>  <span class="number">4</span></span><br><span class="line">one  <span class="number">5</span>  <span class="number">6</span></span><br><span class="line">two  <span class="number">7</span>  <span class="number">8</span></span><br></pre></td></tr></table></figure><p>（5）删除数据行</p><p>使用行索引标签，从<code>DataFrame</code>中删除某一行数据。如果索引标签存在重复，那么它们将被一起删除。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">df = pd.DataFrame([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]], index = [<span class="string">&#x27;one&#x27;</span>,<span class="string">&#x27;two&#x27;</span>], columns = [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>])</span><br><span class="line">df2 = pd.DataFrame([[<span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>]], index = [<span class="string">&#x27;one&#x27;</span>,<span class="string">&#x27;two&#x27;</span>], columns = [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>])</span><br><span class="line"><span class="comment"># 在行末追加新数据行</span></span><br><span class="line">df = df.append(df2)</span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 注意此处调用了drop()方法,drop(&#x27;one&#x27;)同时删除了两行数据</span></span><br><span class="line">df1 = df.drop(<span class="string">&#x27;one&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(df1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">     a  b</span><br><span class="line">one  <span class="number">1</span>  <span class="number">2</span></span><br><span class="line">two  <span class="number">3</span>  <span class="number">4</span></span><br><span class="line">one  <span class="number">5</span>  <span class="number">6</span></span><br><span class="line">two  <span class="number">7</span>  <span class="number">8</span></span><br><span class="line">********************</span><br><span class="line">     a  b</span><br><span class="line">two  <span class="number">3</span>  <span class="number">4</span></span><br><span class="line">two  <span class="number">7</span>  <span class="number">8</span></span><br></pre></td></tr></table></figure><h3 id="👀DF对象属性和方法"><a href="#👀DF对象属性和方法" class="headerlink" title="👀DF对象属性和方法"></a>👀DF对象属性和方法</h3><p><code>DataFrame</code>的属性和方法，与Series相差无几。</p><table><thead><tr><th>名称</th><th>属性方法描述</th></tr></thead><tbody><tr><td><code>T</code></td><td>行和列转置</td></tr><tr><td><code>axes</code></td><td>返回一个仅以行轴标签和列轴标签为成员的列表</td></tr><tr><td><code>dtypes</code></td><td>返回每列数据的数据类型</td></tr><tr><td><code>empty</code></td><td><code>DataFrame</code>中没有数据或者任意坐标轴的长度为0，则返回True</td></tr><tr><td><code>ndim</code></td><td>轴的数量，也指数组的维数。</td></tr><tr><td><code>shape</code></td><td>返回一个元组，表示了<code>DataFrame</code>维度</td></tr><tr><td><code>size</code></td><td><code>DataFrame</code>中的元素数量</td></tr><tr><td><code>values</code></td><td>使用<code>numpy</code>数组表示<code>DataFrame</code>中的元素值</td></tr><tr><td><code>head()</code></td><td>返回前n行数据</td></tr><tr><td><code>tail()</code></td><td>返回后n行数据</td></tr><tr><td><code>shift()</code></td><td>将行或列移动指定的步幅长度</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">d = &#123;<span class="string">&#x27;Name&#x27;</span>:pd.Series([<span class="string">&#x27;小汤&#x27;</span>,<span class="string">&#x27;小王&#x27;</span>,<span class="string">&quot;小明&quot;</span>,<span class="string">&#x27;小红&#x27;</span>,<span class="string">&#x27;小小&#x27;</span>,<span class="string">&#x27;小微&#x27;</span>,<span class="string">&#x27;小黄&#x27;</span>]),</span><br><span class="line">   <span class="string">&#x27;years&#x27;</span>:pd.Series([<span class="number">2005</span>,<span class="number">2006</span>,<span class="number">2015</span>,<span class="number">2008</span>,<span class="number">2003</span>,<span class="number">2009</span>,<span class="number">2003</span>]),</span><br><span class="line">   <span class="string">&#x27;height&#x27;</span>:pd.Series([<span class="number">180</span>,<span class="number">175</span>,<span class="number">178</span>,<span class="number">179</span>,<span class="number">176</span>,<span class="number">170</span>,<span class="number">173</span>])&#125;</span><br><span class="line"><span class="comment"># 构建DataFrame</span></span><br><span class="line">df = pd.DataFrame(d)</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># T（Transpose）转置,返回DataFrame的转置，也就是把行和列进行交换</span></span><br><span class="line"><span class="built_in">print</span>(df.T)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 返回一个行标签、列标签组成的列表</span></span><br><span class="line"><span class="built_in">print</span>(df.axes)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 返回每一列的数据类型</span></span><br><span class="line"><span class="built_in">print</span>(df.dtypes)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 返回一个布尔值，判断输出的数据对象是否为空，若为True表示对象为空</span></span><br><span class="line"><span class="built_in">print</span>(df.empty)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 返回数据对象的维数。DataFrame是一个二维数据结构</span></span><br><span class="line"><span class="built_in">print</span>(df.ndim)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 返回一个代表DataFrame维度的元组。返回值元组(a,b)，其中a表示行数，b表示列数</span></span><br><span class="line"><span class="built_in">print</span>(df.shape)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 返回DataFrame中的元素数量</span></span><br><span class="line"><span class="built_in">print</span>(df.size)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 以ndarray数组的形式返回DataFrame中的数据</span></span><br><span class="line"><span class="built_in">print</span>(df.values)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span>*<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">  Name  years  height</span><br><span class="line"><span class="number">0</span>   小汤   <span class="number">2005</span>     <span class="number">180</span></span><br><span class="line"><span class="number">1</span>   小王   <span class="number">2006</span>     <span class="number">175</span></span><br><span class="line"><span class="number">2</span>   小明   <span class="number">2015</span>     <span class="number">178</span></span><br><span class="line"><span class="number">3</span>   小红   <span class="number">2008</span>     <span class="number">179</span></span><br><span class="line"><span class="number">4</span>   小小   <span class="number">2003</span>     <span class="number">176</span></span><br><span class="line"><span class="number">5</span>   小微   <span class="number">2009</span>     <span class="number">170</span></span><br><span class="line"><span class="number">6</span>   小黄   <span class="number">2003</span>     <span class="number">173</span></span><br><span class="line">********************</span><br><span class="line">           <span class="number">0</span>     <span class="number">1</span>     <span class="number">2</span>     <span class="number">3</span>     <span class="number">4</span>     <span class="number">5</span>     <span class="number">6</span></span><br><span class="line">Name      小汤    小王    小明    小红    小小    小微    小黄</span><br><span class="line">years   <span class="number">2005</span>  <span class="number">2006</span>  <span class="number">2015</span>  <span class="number">2008</span>  <span class="number">2003</span>  <span class="number">2009</span>  <span class="number">2003</span></span><br><span class="line">height   <span class="number">180</span>   <span class="number">175</span>   <span class="number">178</span>   <span class="number">179</span>   <span class="number">176</span>   <span class="number">170</span>   <span class="number">173</span></span><br><span class="line">********************</span><br><span class="line">[RangeIndex(start=<span class="number">0</span>, stop=<span class="number">7</span>, step=<span class="number">1</span>), Index([<span class="string">&#x27;Name&#x27;</span>, <span class="string">&#x27;years&#x27;</span>, <span class="string">&#x27;height&#x27;</span>], dtype=<span class="string">&#x27;object&#x27;</span>)]</span><br><span class="line">********************</span><br><span class="line">Name      <span class="built_in">object</span></span><br><span class="line">years      int64</span><br><span class="line">height     int64</span><br><span class="line">dtype: <span class="built_in">object</span></span><br><span class="line">********************</span><br><span class="line"><span class="literal">False</span></span><br><span class="line">********************</span><br><span class="line"><span class="number">2</span></span><br><span class="line">********************</span><br><span class="line">(<span class="number">7</span>, <span class="number">3</span>)</span><br><span class="line">********************</span><br><span class="line"><span class="number">21</span></span><br><span class="line">********************</span><br><span class="line">[[<span class="string">&#x27;小汤&#x27;</span> <span class="number">2005</span> <span class="number">180</span>]</span><br><span class="line"> [<span class="string">&#x27;小王&#x27;</span> <span class="number">2006</span> <span class="number">175</span>]</span><br><span class="line"> [<span class="string">&#x27;小明&#x27;</span> <span class="number">2015</span> <span class="number">178</span>]</span><br><span class="line"> [<span class="string">&#x27;小红&#x27;</span> <span class="number">2008</span> <span class="number">179</span>]</span><br><span class="line"> [<span class="string">&#x27;小小&#x27;</span> <span class="number">2003</span> <span class="number">176</span>]</span><br><span class="line"> [<span class="string">&#x27;小微&#x27;</span> <span class="number">2009</span> <span class="number">170</span>]</span><br><span class="line"> [<span class="string">&#x27;小黄&#x27;</span> <span class="number">2003</span> <span class="number">173</span>]]</span><br><span class="line">********************</span><br></pre></td></tr></table></figure><p><code>head()</code>&amp;<code>tail()</code>查看数据。如果想要查看<code>DataFrame</code>的一部分数据，可以使用<code>head()</code>或者<code>tail()</code>方法。<code>head()</code>返回前n行数据，默认显示前5行数据。<code>tail()</code>返回后n行数据。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">d = &#123;<span class="string">&#x27;Name&#x27;</span>:pd.Series([<span class="string">&#x27;小汤&#x27;</span>,<span class="string">&#x27;小王&#x27;</span>,<span class="string">&quot;小明&quot;</span>,<span class="string">&#x27;小红&#x27;</span>,<span class="string">&#x27;小小&#x27;</span>,<span class="string">&#x27;小微&#x27;</span>,<span class="string">&#x27;小黄&#x27;</span>]),</span><br><span class="line">   <span class="string">&#x27;years&#x27;</span>:pd.Series([<span class="number">2005</span>,<span class="number">2006</span>,<span class="number">2015</span>,<span class="number">2008</span>,<span class="number">2003</span>,<span class="number">2009</span>,<span class="number">2003</span>]),</span><br><span class="line">   <span class="string">&#x27;height&#x27;</span>:pd.Series([<span class="number">180</span>,<span class="number">175</span>,<span class="number">178</span>,<span class="number">179</span>,<span class="number">176</span>,<span class="number">170</span>,<span class="number">173</span>])&#125;</span><br><span class="line"><span class="comment"># 构建DataFrame</span></span><br><span class="line">df = pd.DataFrame(d)</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 获取前3行数据</span></span><br><span class="line"><span class="built_in">print</span>(df.head(<span class="number">3</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 获取后2行数据</span></span><br><span class="line"><span class="built_in">print</span>(df.tail(<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">  Name  years  height</span><br><span class="line"><span class="number">0</span>   小汤   <span class="number">2005</span>     <span class="number">180</span></span><br><span class="line"><span class="number">1</span>   小王   <span class="number">2006</span>     <span class="number">175</span></span><br><span class="line"><span class="number">2</span>   小明   <span class="number">2015</span>     <span class="number">178</span></span><br><span class="line"><span class="number">3</span>   小红   <span class="number">2008</span>     <span class="number">179</span></span><br><span class="line"><span class="number">4</span>   小小   <span class="number">2003</span>     <span class="number">176</span></span><br><span class="line"><span class="number">5</span>   小微   <span class="number">2009</span>     <span class="number">170</span></span><br><span class="line"><span class="number">6</span>   小黄   <span class="number">2003</span>     <span class="number">173</span></span><br><span class="line">********************</span><br><span class="line">  Name  years  height</span><br><span class="line"><span class="number">0</span>   小汤   <span class="number">2005</span>     <span class="number">180</span></span><br><span class="line"><span class="number">1</span>   小王   <span class="number">2006</span>     <span class="number">175</span></span><br><span class="line"><span class="number">2</span>   小明   <span class="number">2015</span>     <span class="number">178</span></span><br><span class="line">********************</span><br><span class="line">  Name  years  height</span><br><span class="line"><span class="number">5</span>   小微   <span class="number">2009</span>     <span class="number">170</span></span><br><span class="line"><span class="number">6</span>   小黄   <span class="number">2003</span>     <span class="number">173</span></span><br></pre></td></tr></table></figure><p><code>shift()</code>移动行或列。如果您想要移动<code>DataFrame</code>中的某一行&#x2F;列，可以使用<code>shift()</code>函数实现。它提供了一个<code>periods</code>参数，该参数表示在特定的轴上移动指定的步幅。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">DataFrame.shift(periods=<span class="number">1</span>, freq=<span class="literal">None</span>, axis=<span class="number">0</span>)  </span><br><span class="line">参数说明：</span><br><span class="line">    peroids类型为<span class="built_in">int</span>，表示移动的幅度，可以是正数，也可以是负数，默认值为<span class="number">1</span>。</span><br><span class="line">    freq日期偏移量，默认值为<span class="literal">None</span>，适用于时间序。取值为符合时间规则的字符串。</span><br><span class="line">    axis如果是<span class="number">0</span>或者<span class="string">&quot;index&quot;</span>表示上下移动，如果是<span class="number">1</span>或者<span class="string">&quot;columns&quot;</span>则会左右移动。</span><br><span class="line">    fill_value该参数用来填充缺失值。</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">d = &#123;<span class="string">&#x27;Name&#x27;</span>:pd.Series([<span class="string">&#x27;小汤&#x27;</span>,<span class="string">&#x27;小王&#x27;</span>,<span class="string">&quot;小明&quot;</span>,<span class="string">&#x27;小红&#x27;</span>,<span class="string">&#x27;小小&#x27;</span>,<span class="string">&#x27;小微&#x27;</span>,<span class="string">&#x27;小黄&#x27;</span>]),</span><br><span class="line">   <span class="string">&#x27;years&#x27;</span>:pd.Series([<span class="number">2005</span>,<span class="number">2006</span>,<span class="number">2015</span>,<span class="number">2008</span>,<span class="number">2003</span>,<span class="number">2009</span>,<span class="number">2003</span>]),</span><br><span class="line">   <span class="string">&#x27;height&#x27;</span>:pd.Series([<span class="number">180</span>,<span class="number">175</span>,<span class="number">178</span>,<span class="number">179</span>,<span class="number">176</span>,<span class="number">170</span>,<span class="number">173</span>])&#125;</span><br><span class="line"><span class="comment"># 构建DataFrame</span></span><br><span class="line">df = pd.DataFrame(d)</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 移动幅度为3</span></span><br><span class="line"><span class="built_in">print</span>(df.shift(periods=<span class="number">3</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 使用fill_value参数填充DataFrame中的缺失值</span></span><br><span class="line"><span class="built_in">print</span>(df.shift(periods=<span class="number">3</span>,fill_value=<span class="number">52</span>)) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="built_in">print</span>(df.shift(periods=<span class="number">3</span>,axis=<span class="number">1</span>,fill_value=<span class="number">52</span>)) </span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">  Name  years  height</span><br><span class="line"><span class="number">0</span>   小汤   <span class="number">2005</span>     <span class="number">180</span></span><br><span class="line"><span class="number">1</span>   小王   <span class="number">2006</span>     <span class="number">175</span></span><br><span class="line"><span class="number">2</span>   小明   <span class="number">2015</span>     <span class="number">178</span></span><br><span class="line"><span class="number">3</span>   小红   <span class="number">2008</span>     <span class="number">179</span></span><br><span class="line"><span class="number">4</span>   小小   <span class="number">2003</span>     <span class="number">176</span></span><br><span class="line"><span class="number">5</span>   小微   <span class="number">2009</span>     <span class="number">170</span></span><br><span class="line"><span class="number">6</span>   小黄   <span class="number">2003</span>     <span class="number">173</span></span><br><span class="line">********************</span><br><span class="line">  Name   years  height</span><br><span class="line"><span class="number">0</span>  NaN     NaN     NaN</span><br><span class="line"><span class="number">1</span>  NaN     NaN     NaN</span><br><span class="line"><span class="number">2</span>  NaN     NaN     NaN</span><br><span class="line"><span class="number">3</span>   小汤  <span class="number">2005.0</span>   <span class="number">180.0</span></span><br><span class="line"><span class="number">4</span>   小王  <span class="number">2006.0</span>   <span class="number">175.0</span></span><br><span class="line"><span class="number">5</span>   小明  <span class="number">2015.0</span>   <span class="number">178.0</span></span><br><span class="line"><span class="number">6</span>   小红  <span class="number">2008.0</span>   <span class="number">179.0</span></span><br><span class="line">********************</span><br><span class="line">  Name  years  height</span><br><span class="line"><span class="number">0</span>   <span class="number">52</span>     <span class="number">52</span>      <span class="number">52</span></span><br><span class="line"><span class="number">1</span>   <span class="number">52</span>     <span class="number">52</span>      <span class="number">52</span></span><br><span class="line"><span class="number">2</span>   <span class="number">52</span>     <span class="number">52</span>      <span class="number">52</span></span><br><span class="line"><span class="number">3</span>   小汤   <span class="number">2005</span>     <span class="number">180</span></span><br><span class="line"><span class="number">4</span>   小王   <span class="number">2006</span>     <span class="number">175</span></span><br><span class="line"><span class="number">5</span>   小明   <span class="number">2015</span>     <span class="number">178</span></span><br><span class="line"><span class="number">6</span>   小红   <span class="number">2008</span>     <span class="number">179</span></span><br><span class="line">********************</span><br><span class="line">  Name  years  height</span><br><span class="line"><span class="number">0</span>   <span class="number">52</span>     <span class="number">52</span>      <span class="number">52</span></span><br><span class="line"><span class="number">1</span>   <span class="number">52</span>     <span class="number">52</span>      <span class="number">52</span></span><br><span class="line"><span class="number">2</span>   <span class="number">52</span>     <span class="number">52</span>      <span class="number">52</span></span><br><span class="line"><span class="number">3</span>   <span class="number">52</span>     <span class="number">52</span>      <span class="number">52</span></span><br><span class="line"><span class="number">4</span>   <span class="number">52</span>     <span class="number">52</span>      <span class="number">52</span></span><br><span class="line"><span class="number">5</span>   <span class="number">52</span>     <span class="number">52</span>      <span class="number">52</span></span><br><span class="line"><span class="number">6</span>   <span class="number">52</span>     <span class="number">52</span>      <span class="number">52</span></span><br></pre></td></tr></table></figure><h2 id="⛄Pandas函数操作"><a href="#⛄Pandas函数操作" class="headerlink" title="⛄Pandas函数操作"></a>⛄Pandas函数操作</h2><h3 id="👀Panel结构（了解）"><a href="#👀Panel结构（了解）" class="headerlink" title="👀Panel结构（了解）"></a>👀Panel结构（了解）</h3><p><code>Panel</code>是一个用来承载数据的三维数据结构，它有三个轴，分别是<code>items</code>（0轴），<code>major_axis</code>（1轴），而 <code>minor_axis</code>（2轴）。这三个轴为描述、操作<code>Panel</code>提供了支持，其作用介绍如下：</p><ul><li><code>items</code>：axis &#x3D;0，Panel 中的每个<code>items</code>都对应一个<code>DataFrame</code>。</li><li><code>major_axis</code>：axis&#x3D;1，用来描述每个<code>DataFrame</code>的行索引。</li><li><code>minor_axis</code>：axis&#x3D;2，用来描述每个<code>DataFrame</code>的列索引。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pandas.Panel(data, items, major_axis, minor_axis, dtype, copy)</span><br><span class="line">参数说明：</span><br><span class="line">    data输入数据，可以是 ndarray，Series，列表，字典，或者 DataFrame。</span><br><span class="line">    itemsaxis=<span class="number">0</span></span><br><span class="line">    major_axisaxis=<span class="number">1</span></span><br><span class="line">    minor_axisaxis=<span class="number">2</span></span><br><span class="line">    dtype每一列的数据类型。</span><br><span class="line">    copy默认为 <span class="literal">False</span>，表示是否复制数据。</span><br></pre></td></tr></table></figure><blockquote><p>自<code>Pandas 0.25</code>版本后， <code>Panel</code>结构已经被废弃。</p></blockquote><h3 id="👀描述性统计函数"><a href="#👀描述性统计函数" class="headerlink" title="👀描述性统计函数"></a>👀描述性统计函数</h3><table><thead><tr><th>函数名称</th><th>描述说明</th></tr></thead><tbody><tr><td><code>count()</code></td><td>统计某个非空值的数量</td></tr><tr><td><code>sum()</code></td><td>求和</td></tr><tr><td><code>mean()</code></td><td>求均值</td></tr><tr><td><code>median()</code></td><td>求中位数</td></tr><tr><td><code>mode()</code></td><td>求众数</td></tr><tr><td><code>std()</code></td><td>求标准差</td></tr><tr><td><code>min()</code></td><td>求最小值</td></tr><tr><td><code>max()</code></td><td>求最大值</td></tr><tr><td><code>abs()</code></td><td>求绝对值</td></tr><tr><td><code>prod()</code></td><td>求所有数值的乘积</td></tr><tr><td><code>cumsum()</code></td><td>计算累计和，axis&#x3D;0，按照行累加；axis&#x3D;1，按照列累加</td></tr><tr><td><code>cumprod()</code></td><td>计算累计积，axis&#x3D;0，按照行累积；axis&#x3D;1，按照列累积</td></tr><tr><td><code>corr()</code></td><td>计算数列或变量之间的相关系数，取值-1到1，值越大表示关联性越强</td></tr><tr><td><code>describe()</code></td><td>显示与DataFrame数据列相关的统计信息摘要</td></tr></tbody></table><p>在<code>DataFrame</code>中，使用聚合类方法时需要指定轴(<code>axis</code>)参数。下面介绍两种传参方式：</p><ul><li>对行操作，默认使用<code>axis=0</code>或者使用 “<code>index</code>“；</li><li>对列操作，默认使用<code>axis=1</code>或者使用 “<code>columns</code>“。</li><li><code>axis=0</code>表示按垂直方向进行计算，而<code>axis=1</code>则表示按水平方向。</li></ul><p><code>describe()</code>函数输出了平均值、<code>std</code>和<code>IQR</code>值(四分位距)等一系列统计信息。通过<code>describe()</code>提供的<code>include</code>能够筛选字符列或者数字列的摘要信息。<code>include</code>相关参数值说明如下：</p><ul><li><code>object</code>： 表示对字符列进行统计信息描述；</li><li><code>number</code>：表示对数字列进行统计信息描述；</li><li><code>all</code>：汇总所有列的统计信息。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">d = &#123;<span class="string">&#x27;Name&#x27;</span>:pd.Series([<span class="string">&#x27;小汤&#x27;</span>,<span class="string">&#x27;小王&#x27;</span>,<span class="string">&quot;小明&quot;</span>,<span class="string">&#x27;小红&#x27;</span>,<span class="string">&#x27;小小&#x27;</span>,<span class="string">&#x27;小微&#x27;</span>,<span class="string">&#x27;小黄&#x27;</span>]),</span><br><span class="line">   <span class="string">&#x27;years&#x27;</span>:pd.Series([<span class="number">2005</span>,<span class="number">2006</span>,<span class="number">2015</span>,<span class="number">2008</span>,<span class="number">2003</span>,<span class="number">2009</span>,<span class="number">2003</span>]),</span><br><span class="line">   <span class="string">&#x27;height&#x27;</span>:pd.Series([<span class="number">180</span>,<span class="number">175</span>,<span class="number">178</span>,<span class="number">179</span>,<span class="number">176</span>,<span class="number">170</span>,<span class="number">173</span>])&#125;</span><br><span class="line"><span class="comment"># 构建DataFrame</span></span><br><span class="line">df = pd.DataFrame(d)</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 求出数据的所有描述信息</span></span><br><span class="line"><span class="built_in">print</span>(df.describe())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="built_in">print</span>(df.describe(include=[<span class="string">&quot;object&quot;</span>]))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="built_in">print</span>(df.describe(include=<span class="string">&quot;all&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">  Name  years  height</span><br><span class="line"><span class="number">0</span>   小汤   <span class="number">2005</span>     <span class="number">180</span></span><br><span class="line"><span class="number">1</span>   小王   <span class="number">2006</span>     <span class="number">175</span></span><br><span class="line"><span class="number">2</span>   小明   <span class="number">2015</span>     <span class="number">178</span></span><br><span class="line"><span class="number">3</span>   小红   <span class="number">2008</span>     <span class="number">179</span></span><br><span class="line"><span class="number">4</span>   小小   <span class="number">2003</span>     <span class="number">176</span></span><br><span class="line"><span class="number">5</span>   小微   <span class="number">2009</span>     <span class="number">170</span></span><br><span class="line"><span class="number">6</span>   小黄   <span class="number">2003</span>     <span class="number">173</span></span><br><span class="line">********************</span><br><span class="line">             years      height</span><br><span class="line">count     <span class="number">7.000000</span>    <span class="number">7.000000</span></span><br><span class="line">mean   <span class="number">2007.000000</span>  <span class="number">175.857143</span></span><br><span class="line">std       <span class="number">4.203173</span>    <span class="number">3.532165</span></span><br><span class="line"><span class="built_in">min</span>    <span class="number">2003.000000</span>  <span class="number">170.000000</span></span><br><span class="line"><span class="number">25</span>%    <span class="number">2004.000000</span>  <span class="number">174.000000</span></span><br><span class="line"><span class="number">50</span>%    <span class="number">2006.000000</span>  <span class="number">176.000000</span></span><br><span class="line"><span class="number">75</span>%    <span class="number">2008.500000</span>  <span class="number">178.500000</span></span><br><span class="line"><span class="built_in">max</span>    <span class="number">2015.000000</span>  <span class="number">180.000000</span></span><br><span class="line">********************</span><br><span class="line">       Name</span><br><span class="line">count     <span class="number">7</span></span><br><span class="line">unique    <span class="number">7</span></span><br><span class="line">top      小汤</span><br><span class="line">freq      <span class="number">1</span></span><br><span class="line">********************</span><br><span class="line">       Name        years      height</span><br><span class="line">count     <span class="number">7</span>     <span class="number">7.000000</span>    <span class="number">7.000000</span></span><br><span class="line">unique    <span class="number">7</span>          NaN         NaN</span><br><span class="line">top      小汤          NaN         NaN</span><br><span class="line">freq      <span class="number">1</span>          NaN         NaN</span><br><span class="line">mean    NaN  <span class="number">2007.000000</span>  <span class="number">175.857143</span></span><br><span class="line">std     NaN     <span class="number">4.203173</span>    <span class="number">3.532165</span></span><br><span class="line"><span class="built_in">min</span>     NaN  <span class="number">2003.000000</span>  <span class="number">170.000000</span></span><br><span class="line"><span class="number">25</span>%     NaN  <span class="number">2004.000000</span>  <span class="number">174.000000</span></span><br><span class="line"><span class="number">50</span>%     NaN  <span class="number">2006.000000</span>  <span class="number">176.000000</span></span><br><span class="line"><span class="number">75</span>%     NaN  <span class="number">2008.500000</span>  <span class="number">178.500000</span></span><br><span class="line"><span class="built_in">max</span>     NaN  <span class="number">2015.000000</span>  <span class="number">180.000000</span></span><br></pre></td></tr></table></figure><h3 id="👀自定义函数"><a href="#👀自定义函数" class="headerlink" title="👀自定义函数"></a>👀自定义函数</h3><p>如果想要应用自定义的函数，或者把其他库中的函数应用到Pandas对象中，有以下三种方法：</p><ul><li>操作整个<code>DataFrame</code>的函数：<code>pipe()</code></li><li>操作行或者列的函数：<code>apply()</code></li><li>操作单一元素的函数：<code>applymap()</code></li></ul><p>（1）操作整个数据表</p><p>通过给<code>pipe()</code>函数传递一个自定义函数和适当数量的参数值，从而操作<code>DataFrme</code>中的所有元素。下面示例，实现了数据表中的元素值依次加 6。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment"># 自定义函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">addsum</span>(<span class="params">a1,a2</span>):</span><br><span class="line">   <span class="keyword">return</span> a1 + a2</span><br><span class="line"><span class="comment"># 操作DataFrame</span></span><br><span class="line">df = pd.DataFrame([[<span class="number">120</span>,<span class="number">130</span>,<span class="number">150</span>],[<span class="number">90</span>,<span class="number">100</span>,<span class="number">110</span>],[<span class="number">60</span>,<span class="number">70</span>,<span class="number">80</span>]],columns=[<span class="string">&#x27;c1&#x27;</span>,<span class="string">&#x27;c2&#x27;</span>,<span class="string">&#x27;c3&#x27;</span>])</span><br><span class="line"><span class="comment"># 相加前</span></span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line"><span class="comment"># 相加后</span></span><br><span class="line"><span class="built_in">print</span>(df.pipe(addsum,<span class="number">6</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">    c1   c2   c3</span><br><span class="line"><span class="number">0</span>  <span class="number">120</span>  <span class="number">130</span>  <span class="number">150</span></span><br><span class="line"><span class="number">1</span>   <span class="number">90</span>  <span class="number">100</span>  <span class="number">110</span></span><br><span class="line"><span class="number">2</span>   <span class="number">60</span>   <span class="number">70</span>   <span class="number">80</span></span><br><span class="line">    c1   c2   c3</span><br><span class="line"><span class="number">0</span>  <span class="number">126</span>  <span class="number">136</span>  <span class="number">156</span></span><br><span class="line"><span class="number">1</span>   <span class="number">96</span>  <span class="number">106</span>  <span class="number">116</span></span><br><span class="line"><span class="number">2</span>   <span class="number">66</span>   <span class="number">76</span>   <span class="number">86</span></span><br></pre></td></tr></table></figure><p>（2）操作行或列</p><p>如果要操作<code>DataFrame</code>的某一行或者某一列，可以使用<code>apply()</code>方法，该方法与描述性统计方法类似，都有可选参数<code>axis</code>，并且默认按列操作。示例如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment"># 操作DataFrame</span></span><br><span class="line">df = pd.DataFrame([[<span class="number">120</span>,<span class="number">130</span>,<span class="number">150</span>],[<span class="number">90</span>,<span class="number">100</span>,<span class="number">110</span>],[<span class="number">60</span>,<span class="number">70</span>,<span class="number">80</span>]],columns=[<span class="string">&#x27;c1&#x27;</span>,<span class="string">&#x27;c2&#x27;</span>,<span class="string">&#x27;c3&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 默认按列操作，计算每一列均值</span></span><br><span class="line"><span class="built_in">print</span>(df.apply(np.mean))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 传递轴参axis=1，表示逐行进行操作</span></span><br><span class="line"><span class="built_in">print</span>(df.apply(np.mean,axis=<span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 求每一列中，最大值与最小值之差</span></span><br><span class="line"><span class="built_in">print</span>(df.apply(<span class="keyword">lambda</span> x: x.<span class="built_in">max</span>() - x.<span class="built_in">min</span>()))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">    c1   c2   c3</span><br><span class="line"><span class="number">0</span>  <span class="number">120</span>  <span class="number">130</span>  <span class="number">150</span></span><br><span class="line"><span class="number">1</span>   <span class="number">90</span>  <span class="number">100</span>  <span class="number">110</span></span><br><span class="line"><span class="number">2</span>   <span class="number">60</span>   <span class="number">70</span>   <span class="number">80</span></span><br><span class="line">********************</span><br><span class="line">c1     <span class="number">90.000000</span></span><br><span class="line">c2    <span class="number">100.000000</span></span><br><span class="line">c3    <span class="number">113.333333</span></span><br><span class="line">dtype: float64</span><br><span class="line">********************</span><br><span class="line"><span class="number">0</span>    <span class="number">133.333333</span></span><br><span class="line"><span class="number">1</span>    <span class="number">100.000000</span></span><br><span class="line"><span class="number">2</span>     <span class="number">70.000000</span></span><br><span class="line">dtype: float64</span><br><span class="line">********************</span><br><span class="line">c1    <span class="number">60</span></span><br><span class="line">c2    <span class="number">60</span></span><br><span class="line">c3    <span class="number">70</span></span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure><p>（3）操作单一元素</p><p><code>DataFrame</code>数据表结构的<code>applymap()</code>和<code>Series</code>系列结构的<code>map()</code>类似，它们都可以接受一个<code>Python</code>函数，并返回相应的值。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="comment"># 操作DataFrame</span></span><br><span class="line">df = pd.DataFrame([[<span class="number">120</span>,<span class="number">130</span>,<span class="number">150</span>],[<span class="number">90</span>,<span class="number">100</span>,<span class="number">110</span>],[<span class="number">60</span>,<span class="number">70</span>,<span class="number">80</span>]],columns=[<span class="string">&#x27;c1&#x27;</span>,<span class="string">&#x27;c2&#x27;</span>,<span class="string">&#x27;c3&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 自定义函数lambda函数</span></span><br><span class="line"><span class="built_in">print</span>(df[<span class="string">&#x27;c1&#x27;</span>].<span class="built_in">map</span>(<span class="keyword">lambda</span> x:x*<span class="number">10</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 使用了applymap()函数</span></span><br><span class="line"><span class="built_in">print</span>(df.applymap(<span class="keyword">lambda</span> x:x*<span class="number">10</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">    c1   c2   c3</span><br><span class="line"><span class="number">0</span>  <span class="number">120</span>  <span class="number">130</span>  <span class="number">150</span></span><br><span class="line"><span class="number">1</span>   <span class="number">90</span>  <span class="number">100</span>  <span class="number">110</span></span><br><span class="line"><span class="number">2</span>   <span class="number">60</span>   <span class="number">70</span>   <span class="number">80</span></span><br><span class="line">********************</span><br><span class="line"><span class="number">0</span>    <span class="number">1200</span></span><br><span class="line"><span class="number">1</span>     <span class="number">900</span></span><br><span class="line"><span class="number">2</span>     <span class="number">600</span></span><br><span class="line">Name: c1, dtype: int64</span><br><span class="line">********************</span><br><span class="line">     c1    c2    c3</span><br><span class="line"><span class="number">0</span>  <span class="number">1200</span>  <span class="number">1300</span>  <span class="number">1500</span></span><br><span class="line"><span class="number">1</span>   <span class="number">900</span>  <span class="number">1000</span>  <span class="number">1100</span></span><br><span class="line"><span class="number">2</span>   <span class="number">600</span>   <span class="number">700</span>   <span class="number">800</span></span><br></pre></td></tr></table></figure><h3 id="👀reindex重置索引"><a href="#👀reindex重置索引" class="headerlink" title="👀reindex重置索引"></a>👀reindex重置索引</h3><p>重置索引（<code>reindex</code>）可以更改原<code>DataFrame</code>的行标签或列标签，并使更改后的行、列标签与<code>DataFrame</code>中的数据逐一匹配。通过重置索引操作，您可以完成对现有数据的重新排序。如果重置的索引标签在原<code>DataFrame</code>中不存在，那么该标签对应的元素值将全部填充为<code>NaN</code>。</p><p>（1）重置行列标签</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="comment"># 操作DataFrame</span></span><br><span class="line">df = pd.DataFrame([[<span class="number">120</span>,<span class="number">130</span>,<span class="number">150</span>],[<span class="number">90</span>,<span class="number">100</span>,<span class="number">110</span>],[<span class="number">60</span>,<span class="number">70</span>,<span class="number">80</span>]],columns=[<span class="string">&#x27;c1&#x27;</span>,<span class="string">&#x27;c2&#x27;</span>,<span class="string">&#x27;c3&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 重置行、列索引标签</span></span><br><span class="line">df_reindexed = df.reindex(index=[<span class="number">0</span>,<span class="number">1</span>], columns=[<span class="string">&#x27;c1&#x27;</span>, <span class="string">&#x27;c3&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(df_reindexed)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">    c1   c2   c3</span><br><span class="line"><span class="number">0</span>  <span class="number">120</span>  <span class="number">130</span>  <span class="number">150</span></span><br><span class="line"><span class="number">1</span>   <span class="number">90</span>  <span class="number">100</span>  <span class="number">110</span></span><br><span class="line"><span class="number">2</span>   <span class="number">60</span>   <span class="number">70</span>   <span class="number">80</span></span><br><span class="line">********************</span><br><span class="line">    c1   c3</span><br><span class="line"><span class="number">0</span>  <span class="number">120</span>  <span class="number">150</span></span><br><span class="line"><span class="number">1</span>   <span class="number">90</span>  <span class="number">110</span></span><br></pre></td></tr></table></figure><p>现有a、b两个<code>DataFrame</code>对象，如果想让a的行索引与b相同，您可以使用<code>reindex_like()</code> 方法。示例如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = pd.DataFrame(np.random.randn(<span class="number">10</span>,<span class="number">3</span>),columns=[<span class="string">&#x27;col1&#x27;</span>,<span class="string">&#x27;col2&#x27;</span>,<span class="string">&#x27;col3&#x27;</span>])</span><br><span class="line">b = pd.DataFrame(np.random.randn(<span class="number">7</span>,<span class="number">3</span>),columns=[<span class="string">&#x27;col1&#x27;</span>,<span class="string">&#x27;col2&#x27;</span>,<span class="string">&#x27;col3&#x27;</span>])</span><br><span class="line"><span class="comment"># a会按照b的形式重建行索引。需要特别注意的是，a与b的列索引标签必须相同。</span></span><br><span class="line">a= a.reindex_like(b)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">       col1      col2      col3</span><br><span class="line"><span class="number">0</span>  <span class="number">0.669617</span>  <span class="number">0.010243</span> -<span class="number">0.091776</span></span><br><span class="line"><span class="number">1</span> -<span class="number">0.333395</span> -<span class="number">1.521432</span>  <span class="number">0.292087</span></span><br><span class="line"><span class="number">2</span> -<span class="number">0.174709</span> -<span class="number">0.623413</span>  <span class="number">1.291384</span></span><br><span class="line"><span class="number">3</span>  <span class="number">1.033132</span> -<span class="number">0.383137</span>  <span class="number">1.280788</span></span><br><span class="line"><span class="number">4</span>  <span class="number">1.052466</span> -<span class="number">1.326848</span> -<span class="number">1.390581</span></span><br><span class="line"><span class="number">5</span>  <span class="number">1.828058</span>  <span class="number">0.422678</span> -<span class="number">0.734622</span></span><br><span class="line"><span class="number">6</span>  <span class="number">0.988210</span> -<span class="number">1.047092</span> -<span class="number">1.959839</span></span><br></pre></td></tr></table></figure><p>（2）填充元素值</p><p><code>reindex_like()</code>提供了一个可选的参数<code>method</code>，使用它来填充相应的元素值，参数值介绍如下：</p><ul><li><code>pad/ffill</code>：向前填充值；</li><li><code>bfill/backfill</code>：向后填充值；</li><li><code>nearest</code>：从距离最近的索引值开始填充。</li></ul><p><code>reindex_like()</code>还提供了一个额外参数<code>limit</code>，该参数用来控制填充的最大行数。示例如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">df1 = pd.DataFrame(np.random.randn(<span class="number">6</span>,<span class="number">3</span>),columns=[<span class="string">&#x27;col1&#x27;</span>,<span class="string">&#x27;col2&#x27;</span>,<span class="string">&#x27;col3&#x27;</span>])</span><br><span class="line">df2 = pd.DataFrame(np.random.randn(<span class="number">2</span>,<span class="number">3</span>),columns=[<span class="string">&#x27;col1&#x27;</span>,<span class="string">&#x27;col2&#x27;</span>,<span class="string">&#x27;col3&#x27;</span>])</span><br><span class="line"><span class="comment"># 使df2和df1行标签相同</span></span><br><span class="line"><span class="built_in">print</span>(df2.reindex_like(df1))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 向前填充</span></span><br><span class="line"><span class="built_in">print</span>(df2.reindex_like(df1,method=<span class="string">&#x27;ffill&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 向后填充</span></span><br><span class="line"><span class="built_in">print</span>(df2.reindex_like(df1,method=<span class="string">&#x27;backfill&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># limit限制填充行数</span></span><br><span class="line"><span class="built_in">print</span>(df2.reindex_like(df1,method=<span class="string">&#x27;ffill&#x27;</span>,limit=<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">       col1      col2      col3</span><br><span class="line"><span class="number">0</span>  <span class="number">0.552991</span>  <span class="number">1.230408</span>  <span class="number">0.403586</span></span><br><span class="line"><span class="number">1</span> -<span class="number">0.135228</span>  <span class="number">1.065911</span> -<span class="number">0.624843</span></span><br><span class="line"><span class="number">2</span>       NaN       NaN       NaN</span><br><span class="line"><span class="number">3</span>       NaN       NaN       NaN</span><br><span class="line"><span class="number">4</span>       NaN       NaN       NaN</span><br><span class="line"><span class="number">5</span>       NaN       NaN       NaN</span><br><span class="line">********************</span><br><span class="line">       col1      col2      col3</span><br><span class="line"><span class="number">0</span>  <span class="number">0.552991</span>  <span class="number">1.230408</span>  <span class="number">0.403586</span></span><br><span class="line"><span class="number">1</span> -<span class="number">0.135228</span>  <span class="number">1.065911</span> -<span class="number">0.624843</span></span><br><span class="line"><span class="number">2</span> -<span class="number">0.135228</span>  <span class="number">1.065911</span> -<span class="number">0.624843</span></span><br><span class="line"><span class="number">3</span> -<span class="number">0.135228</span>  <span class="number">1.065911</span> -<span class="number">0.624843</span></span><br><span class="line"><span class="number">4</span> -<span class="number">0.135228</span>  <span class="number">1.065911</span> -<span class="number">0.624843</span></span><br><span class="line"><span class="number">5</span> -<span class="number">0.135228</span>  <span class="number">1.065911</span> -<span class="number">0.624843</span></span><br><span class="line">********************</span><br><span class="line">       col1      col2      col3</span><br><span class="line"><span class="number">0</span>  <span class="number">0.552991</span>  <span class="number">1.230408</span>  <span class="number">0.403586</span></span><br><span class="line"><span class="number">1</span> -<span class="number">0.135228</span>  <span class="number">1.065911</span> -<span class="number">0.624843</span></span><br><span class="line"><span class="number">2</span>       NaN       NaN       NaN</span><br><span class="line"><span class="number">3</span>       NaN       NaN       NaN</span><br><span class="line"><span class="number">4</span>       NaN       NaN       NaN</span><br><span class="line"><span class="number">5</span>       NaN       NaN       NaN</span><br><span class="line">********************</span><br><span class="line">       col1      col2      col3</span><br><span class="line"><span class="number">0</span>  <span class="number">0.552991</span>  <span class="number">1.230408</span>  <span class="number">0.403586</span></span><br><span class="line"><span class="number">1</span> -<span class="number">0.135228</span>  <span class="number">1.065911</span> -<span class="number">0.624843</span></span><br><span class="line"><span class="number">2</span> -<span class="number">0.135228</span>  <span class="number">1.065911</span> -<span class="number">0.624843</span></span><br><span class="line"><span class="number">3</span> -<span class="number">0.135228</span>  <span class="number">1.065911</span> -<span class="number">0.624843</span></span><br><span class="line"><span class="number">4</span>       NaN       NaN       NaN</span><br><span class="line"><span class="number">5</span>       NaN       NaN       NaN</span><br></pre></td></tr></table></figure><p>（3）重命名标签</p><p><code>rename()</code>方法允许您使用某些映射(<code>dict</code>或<code>Series</code>)或任意函数来对行、列标签重新命名，示例如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="comment"># 操作DataFrame</span></span><br><span class="line">df = pd.DataFrame([[<span class="number">120</span>,<span class="number">130</span>,<span class="number">150</span>],[<span class="number">90</span>,<span class="number">100</span>,<span class="number">110</span>],[<span class="number">60</span>,<span class="number">70</span>,<span class="number">80</span>]],columns=[<span class="string">&#x27;c1&#x27;</span>,<span class="string">&#x27;c2&#x27;</span>,<span class="string">&#x27;c3&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 对行和列重新命名</span></span><br><span class="line"><span class="built_in">print</span>(df.rename(columns=&#123;<span class="string">&#x27;c1&#x27;</span>:<span class="string">&#x27;cc1&#x27;</span>,<span class="string">&#x27;c2&#x27;</span>:<span class="string">&#x27;cc2&#x27;</span>&#125;,index = &#123;<span class="number">0</span>:<span class="string">&#x27;one&#x27;</span>,<span class="number">1</span>:<span class="string">&#x27;two&#x27;</span>,<span class="number">2</span>:<span class="string">&#x27;three&#x27;</span>&#125;))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">    c1   c2   c3</span><br><span class="line"><span class="number">0</span>  <span class="number">120</span>  <span class="number">130</span>  <span class="number">150</span></span><br><span class="line"><span class="number">1</span>   <span class="number">90</span>  <span class="number">100</span>  <span class="number">110</span></span><br><span class="line"><span class="number">2</span>   <span class="number">60</span>   <span class="number">70</span>   <span class="number">80</span></span><br><span class="line">********************</span><br><span class="line">       cc1  cc2   c3</span><br><span class="line">one    <span class="number">120</span>  <span class="number">130</span>  <span class="number">150</span></span><br><span class="line">two     <span class="number">90</span>  <span class="number">100</span>  <span class="number">110</span></span><br><span class="line">three   <span class="number">60</span>   <span class="number">70</span>   <span class="number">80</span></span><br></pre></td></tr></table></figure><blockquote><p><code>rename()</code>方法提供了一个<code>inplace</code>参数，默认值为<code>False</code>，表示拷贝一份原数据，并在复制后的数据上做重命名操作。若<code>inplace=True</code>则表示在原数据的基础上重命名。</p></blockquote><h3 id="👀iteration遍历操作"><a href="#👀iteration遍历操作" class="headerlink" title="👀iteration遍历操作"></a>👀iteration遍历操作</h3><p><code>Pandas</code>是如何遍历<code>Series</code>和<code>DataFrame</code>结构呢？对于<code>Series</code>而言，您可以把它当做一维数组进行遍历操作；而像<code>DataFrame</code>这种二维数据表结构，则类似于遍历<code>Python</code>字典。</p><p>在<code>Pandas</code>中同样也是使用<code>for</code>循环进行遍历。通过<code>for</code>遍历后，<code>Series</code>可直接获取相应的<code>value</code>，而<code>DataFrame</code>则会获取列标签。示例如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="comment"># 操作DataFrame</span></span><br><span class="line">df = pd.DataFrame([[<span class="number">120</span>,<span class="number">130</span>,<span class="number">150</span>],[<span class="number">90</span>,<span class="number">100</span>,<span class="number">110</span>],[<span class="number">60</span>,<span class="number">70</span>,<span class="number">80</span>]],columns=[<span class="string">&#x27;c1&#x27;</span>,<span class="string">&#x27;c2&#x27;</span>,<span class="string">&#x27;c3&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="keyword">for</span> col <span class="keyword">in</span> df:</span><br><span class="line">   <span class="built_in">print</span> (col)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">    c1   c2   c3</span><br><span class="line"><span class="number">0</span>  <span class="number">120</span>  <span class="number">130</span>  <span class="number">150</span></span><br><span class="line"><span class="number">1</span>   <span class="number">90</span>  <span class="number">100</span>  <span class="number">110</span></span><br><span class="line"><span class="number">2</span>   <span class="number">60</span>   <span class="number">70</span>   <span class="number">80</span></span><br><span class="line">********************</span><br><span class="line">c1</span><br><span class="line">c2</span><br><span class="line">c3</span><br></pre></td></tr></table></figure><p>如果想要遍历<code>DataFrame</code>的每一行，我们下列函数：</p><ul><li><code>iteritems()</code>：以键值对 (<code>key</code>,<code>value</code>) 的形式遍历；</li><li><code>iterrows()</code>：以 (<code>row_index</code>,<code>row</code>) 的形式遍历行;</li><li><code>itertuples()</code>：使用已命名元组的方式对行遍历。</li></ul><p><code>iteritems()</code>以键值对的形式遍历<code>DataFrame</code>对象，以<strong>列标签</strong>为键，以对应列的元素为值。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="comment"># 操作DataFrame</span></span><br><span class="line">df = pd.DataFrame([[<span class="number">120</span>,<span class="number">130</span>,<span class="number">150</span>],[<span class="number">90</span>,<span class="number">100</span>,<span class="number">110</span>],[<span class="number">60</span>,<span class="number">70</span>,<span class="number">80</span>]],columns=[<span class="string">&#x27;c1&#x27;</span>,<span class="string">&#x27;c2&#x27;</span>,<span class="string">&#x27;c3&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="keyword">for</span> key,value <span class="keyword">in</span> df.iteritems():</span><br><span class="line">   <span class="built_in">print</span>(key)</span><br><span class="line">   <span class="built_in">print</span>(value)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">    c1   c2   c3</span><br><span class="line"><span class="number">0</span>  <span class="number">120</span>  <span class="number">130</span>  <span class="number">150</span></span><br><span class="line"><span class="number">1</span>   <span class="number">90</span>  <span class="number">100</span>  <span class="number">110</span></span><br><span class="line"><span class="number">2</span>   <span class="number">60</span>   <span class="number">70</span>   <span class="number">80</span></span><br><span class="line">********************</span><br><span class="line">c1</span><br><span class="line"><span class="number">0</span>    <span class="number">120</span></span><br><span class="line"><span class="number">1</span>     <span class="number">90</span></span><br><span class="line"><span class="number">2</span>     <span class="number">60</span></span><br><span class="line">Name: c1, dtype: int64</span><br><span class="line">c2</span><br><span class="line"><span class="number">0</span>    <span class="number">130</span></span><br><span class="line"><span class="number">1</span>    <span class="number">100</span></span><br><span class="line"><span class="number">2</span>     <span class="number">70</span></span><br><span class="line">Name: c2, dtype: int64</span><br><span class="line">c3</span><br><span class="line"><span class="number">0</span>    <span class="number">150</span></span><br><span class="line"><span class="number">1</span>    <span class="number">110</span></span><br><span class="line"><span class="number">2</span>     <span class="number">80</span></span><br><span class="line">Name: c3, dtype: int64</span><br></pre></td></tr></table></figure><p><code>iterrows()</code>方法按行遍历，返回一个迭代器，以<strong>行索引</strong>标签为键，以每一行数据为值。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="comment"># 操作DataFrame</span></span><br><span class="line">df = pd.DataFrame([[<span class="number">120</span>,<span class="number">130</span>,<span class="number">150</span>],[<span class="number">90</span>,<span class="number">100</span>,<span class="number">110</span>],[<span class="number">60</span>,<span class="number">70</span>,<span class="number">80</span>]],columns=[<span class="string">&#x27;c1&#x27;</span>,<span class="string">&#x27;c2&#x27;</span>,<span class="string">&#x27;c3&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># iterrows()遍历行，其中0,1,2是行索引而c1,c2,c3是列索引。</span></span><br><span class="line"><span class="keyword">for</span> row_index,value <span class="keyword">in</span> df.iterrows():</span><br><span class="line">   <span class="built_in">print</span>(row_index)</span><br><span class="line">   <span class="built_in">print</span>(value)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">    c1   c2   c3</span><br><span class="line"><span class="number">0</span>  <span class="number">120</span>  <span class="number">130</span>  <span class="number">150</span></span><br><span class="line"><span class="number">1</span>   <span class="number">90</span>  <span class="number">100</span>  <span class="number">110</span></span><br><span class="line"><span class="number">2</span>   <span class="number">60</span>   <span class="number">70</span>   <span class="number">80</span></span><br><span class="line">********************</span><br><span class="line"><span class="number">0</span></span><br><span class="line">c1    <span class="number">120</span></span><br><span class="line">c2    <span class="number">130</span></span><br><span class="line">c3    <span class="number">150</span></span><br><span class="line">Name: <span class="number">0</span>, dtype: int64</span><br><span class="line"><span class="number">1</span></span><br><span class="line">c1     <span class="number">90</span></span><br><span class="line">c2    <span class="number">100</span></span><br><span class="line">c3    <span class="number">110</span></span><br><span class="line">Name: <span class="number">1</span>, dtype: int64</span><br><span class="line"><span class="number">2</span></span><br><span class="line">c1    <span class="number">60</span></span><br><span class="line">c2    <span class="number">70</span></span><br><span class="line">c3    <span class="number">80</span></span><br><span class="line">Name: <span class="number">2</span>, dtype: int64</span><br></pre></td></tr></table></figure><p><code>itertuples()</code>同样将返回一个迭代器，该方法会把<code>DataFrame</code>的<strong>每一行</strong>生成一个元组，示例如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="comment"># 操作DataFrame</span></span><br><span class="line">df = pd.DataFrame([[<span class="number">120</span>,<span class="number">130</span>,<span class="number">150</span>],[<span class="number">90</span>,<span class="number">100</span>,<span class="number">110</span>],[<span class="number">60</span>,<span class="number">70</span>,<span class="number">80</span>]],columns=[<span class="string">&#x27;c1&#x27;</span>,<span class="string">&#x27;c2&#x27;</span>,<span class="string">&#x27;c3&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> df.itertuples():</span><br><span class="line">    <span class="built_in">print</span>(row)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">    c1   c2   c3</span><br><span class="line"><span class="number">0</span>  <span class="number">120</span>  <span class="number">130</span>  <span class="number">150</span></span><br><span class="line"><span class="number">1</span>   <span class="number">90</span>  <span class="number">100</span>  <span class="number">110</span></span><br><span class="line"><span class="number">2</span>   <span class="number">60</span>   <span class="number">70</span>   <span class="number">80</span></span><br><span class="line">********************</span><br><span class="line">Pandas(Index=<span class="number">0</span>, c1=<span class="number">120</span>, c2=<span class="number">130</span>, c3=<span class="number">150</span>)</span><br><span class="line">Pandas(Index=<span class="number">1</span>, c1=<span class="number">90</span>, c2=<span class="number">100</span>, c3=<span class="number">110</span>)</span><br><span class="line">Pandas(Index=<span class="number">2</span>, c1=<span class="number">60</span>, c2=<span class="number">70</span>, c3=<span class="number">80</span>)</span><br></pre></td></tr></table></figure><blockquote><p>迭代器返回的是原对象的副本，如果在迭代过程中修改元素值，不会影响原对象。</p></blockquote><h3 id="👀排序和去重"><a href="#👀排序和去重" class="headerlink" title="👀排序和去重"></a>👀排序和去重</h3><h4 id="👁排序sorting"><a href="#👁排序sorting" class="headerlink" title="👁排序sorting"></a>👁排序sorting</h4><p><code>Pandas</code>提供了两种排序方法，分别是按标签排序和按数值排序。</p><p>（1）按行标签排序</p><p>使用<code>sort_index()</code>方法对<strong>行标签排序</strong>，指定轴参数（<code>axis</code>）或者排序顺序。或者可以对<code>DataFrame</code>进行排序。默认情况下，按照行标签序排序。通过将布尔值传递给<code>ascending</code>参数，可以控制排序的顺序（行号顺序）。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment"># 行标签乱序排列，列标签乱序排列</span></span><br><span class="line">unsorted_df = pd.DataFrame(np.random.randn(<span class="number">6</span>,<span class="number">2</span>),index=[<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">0</span>],columns=[<span class="string">&#x27;col2&#x27;</span>,<span class="string">&#x27;col1&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(unsorted_df)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span>*<span class="number">20</span>)</span><br><span class="line">sorted_df1 = unsorted_df.sort_index()</span><br><span class="line"><span class="built_in">print</span>(sorted_df1)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span>*<span class="number">20</span>)</span><br><span class="line">sorted_df2 = unsorted_df.sort_index(ascending=<span class="literal">False</span>)</span><br><span class="line"><span class="built_in">print</span>(sorted_df2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">       col2      col1</span><br><span class="line"><span class="number">1</span> -<span class="number">0.458463</span>  <span class="number">0.422606</span></span><br><span class="line"><span class="number">4</span>  <span class="number">0.809682</span>  <span class="number">2.489952</span></span><br><span class="line"><span class="number">2</span>  <span class="number">1.609935</span>  <span class="number">0.096181</span></span><br><span class="line"><span class="number">3</span>  <span class="number">1.087255</span>  <span class="number">1.215676</span></span><br><span class="line"><span class="number">5</span>  <span class="number">0.436520</span>  <span class="number">0.389565</span></span><br><span class="line"><span class="number">0</span>  <span class="number">0.536720</span>  <span class="number">0.820746</span></span><br><span class="line">********************</span><br><span class="line">       col2      col1</span><br><span class="line"><span class="number">0</span>  <span class="number">0.536720</span>  <span class="number">0.820746</span></span><br><span class="line"><span class="number">1</span> -<span class="number">0.458463</span>  <span class="number">0.422606</span></span><br><span class="line"><span class="number">2</span>  <span class="number">1.609935</span>  <span class="number">0.096181</span></span><br><span class="line"><span class="number">3</span>  <span class="number">1.087255</span>  <span class="number">1.215676</span></span><br><span class="line"><span class="number">4</span>  <span class="number">0.809682</span>  <span class="number">2.489952</span></span><br><span class="line"><span class="number">5</span>  <span class="number">0.436520</span>  <span class="number">0.389565</span></span><br><span class="line">********************</span><br><span class="line">       col2      col1</span><br><span class="line"><span class="number">5</span>  <span class="number">0.436520</span>  <span class="number">0.389565</span></span><br><span class="line"><span class="number">4</span>  <span class="number">0.809682</span>  <span class="number">2.489952</span></span><br><span class="line"><span class="number">3</span>  <span class="number">1.087255</span>  <span class="number">1.215676</span></span><br><span class="line"><span class="number">2</span>  <span class="number">1.609935</span>  <span class="number">0.096181</span></span><br><span class="line"><span class="number">1</span> -<span class="number">0.458463</span>  <span class="number">0.422606</span></span><br><span class="line"><span class="number">0</span>  <span class="number">0.536720</span>  <span class="number">0.820746</span></span><br></pre></td></tr></table></figure><p>（2）按列标签排序</p><p>通过给<code>axis</code>轴参数传递0或1，可以对列标签进行排序。默认情况下，<code>axis=0</code>表示按行排序；而<code>axis=1</code>则表示按列排序。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment"># 行标签乱序排列，列标签乱序排列</span></span><br><span class="line">unsorted_df = pd.DataFrame(np.random.randn(<span class="number">6</span>,<span class="number">2</span>),index=[<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">0</span>],columns=[<span class="string">&#x27;col2&#x27;</span>,<span class="string">&#x27;col1&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(unsorted_df)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span>*<span class="number">20</span>)</span><br><span class="line">sorted_df1 = unsorted_df.sort_index(axis=<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(sorted_df1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">       col2      col1</span><br><span class="line"><span class="number">1</span>  <span class="number">0.891755</span>  <span class="number">1.006258</span></span><br><span class="line"><span class="number">4</span>  <span class="number">0.232999</span>  <span class="number">0.549146</span></span><br><span class="line"><span class="number">2</span>  <span class="number">0.158894</span>  <span class="number">0.246825</span></span><br><span class="line"><span class="number">3</span>  <span class="number">0.653124</span> -<span class="number">1.695749</span></span><br><span class="line"><span class="number">5</span> -<span class="number">0.774252</span> -<span class="number">0.525881</span></span><br><span class="line"><span class="number">0</span>  <span class="number">0.082147</span>  <span class="number">0.384929</span></span><br><span class="line">********************</span><br><span class="line">       col1      col2</span><br><span class="line"><span class="number">1</span>  <span class="number">1.006258</span>  <span class="number">0.891755</span></span><br><span class="line"><span class="number">4</span>  <span class="number">0.549146</span>  <span class="number">0.232999</span></span><br><span class="line"><span class="number">2</span>  <span class="number">0.246825</span>  <span class="number">0.158894</span></span><br><span class="line"><span class="number">3</span> -<span class="number">1.695749</span>  <span class="number">0.653124</span></span><br><span class="line"><span class="number">5</span> -<span class="number">0.525881</span> -<span class="number">0.774252</span></span><br><span class="line"><span class="number">0</span>  <span class="number">0.384929</span>  <span class="number">0.082147</span></span><br></pre></td></tr></table></figure><p>（3）按值排序</p><p>与标签排序类似，<code>sort_values()</code>表示按值排序。它接受一个<code>by</code>参数，该参数值是要排序数列的<code>DataFrame</code>列名。示例如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="comment"># 行标签乱序排列，列标签乱序排列</span></span><br><span class="line">unsorted_df = pd.DataFrame(&#123;<span class="string">&#x27;col1&#x27;</span>:[<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],<span class="string">&#x27;col2&#x27;</span>:[<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>]&#125;)</span><br><span class="line"><span class="built_in">print</span>(unsorted_df)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span>*<span class="number">20</span>)</span><br><span class="line">sorted_df1 = unsorted_df.sort_values(by=<span class="string">&#x27;col1&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(sorted_df1)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 注意：当对col1列排序时，相应的col2列的元素值和行索引也会随col1一起改变。by参数可以接受一个列表参数值</span></span><br><span class="line">sorted_df2 = unsorted_df.sort_values(by=[<span class="string">&#x27;col1&#x27;</span>,<span class="string">&#x27;col2&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(sorted_df2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">   col1  col2</span><br><span class="line"><span class="number">0</span>     <span class="number">2</span>     <span class="number">1</span></span><br><span class="line"><span class="number">1</span>     <span class="number">1</span>     <span class="number">3</span></span><br><span class="line"><span class="number">2</span>     <span class="number">1</span>     <span class="number">2</span></span><br><span class="line"><span class="number">3</span>     <span class="number">1</span>     <span class="number">4</span></span><br><span class="line">********************</span><br><span class="line">   col1  col2</span><br><span class="line"><span class="number">1</span>     <span class="number">1</span>     <span class="number">3</span></span><br><span class="line"><span class="number">2</span>     <span class="number">1</span>     <span class="number">2</span></span><br><span class="line"><span class="number">3</span>     <span class="number">1</span>     <span class="number">4</span></span><br><span class="line"><span class="number">0</span>     <span class="number">2</span>     <span class="number">1</span></span><br><span class="line">********************</span><br><span class="line">   col1  col2</span><br><span class="line"><span class="number">2</span>     <span class="number">1</span>     <span class="number">2</span></span><br><span class="line"><span class="number">1</span>     <span class="number">1</span>     <span class="number">3</span></span><br><span class="line"><span class="number">3</span>     <span class="number">1</span>     <span class="number">4</span></span><br><span class="line"><span class="number">0</span>     <span class="number">2</span>     <span class="number">1</span></span><br></pre></td></tr></table></figure><p>（4）排序算法</p><p><code>sort_values()</code>提供了参数<code>kind</code>用来指定排序算法。这里有三种排序算法：</p><ul><li><code>mergesort</code></li><li><code>heapsort</code></li><li><code>quicksort</code></li></ul><p>默认为<code>quicksort</code>(快速排序) ，其中<code>Mergesort</code>归并排序是最稳定的算法。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="comment"># 行标签乱序排列，列标签乱序排列</span></span><br><span class="line">unsorted_df = pd.DataFrame(&#123;<span class="string">&#x27;col1&#x27;</span>:[<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],<span class="string">&#x27;col2&#x27;</span>:[<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>]&#125;)</span><br><span class="line"><span class="built_in">print</span>(unsorted_df)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span>*<span class="number">20</span>)</span><br><span class="line">sorted_df1 = unsorted_df.sort_values(by=<span class="string">&#x27;col1&#x27;</span>,kind=<span class="string">&#x27;mergesort&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(sorted_df1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">   col1  col2</span><br><span class="line"><span class="number">0</span>     <span class="number">2</span>     <span class="number">1</span></span><br><span class="line"><span class="number">1</span>     <span class="number">1</span>     <span class="number">3</span></span><br><span class="line"><span class="number">2</span>     <span class="number">1</span>     <span class="number">2</span></span><br><span class="line"><span class="number">3</span>     <span class="number">1</span>     <span class="number">4</span></span><br><span class="line">********************</span><br><span class="line">   col1  col2</span><br><span class="line"><span class="number">1</span>     <span class="number">1</span>     <span class="number">3</span></span><br><span class="line"><span class="number">2</span>     <span class="number">1</span>     <span class="number">2</span></span><br><span class="line"><span class="number">3</span>     <span class="number">1</span>     <span class="number">4</span></span><br><span class="line"><span class="number">0</span>     <span class="number">2</span>     <span class="number">1</span></span><br></pre></td></tr></table></figure><h4 id="👁去重drop-duplicates"><a href="#👁去重drop-duplicates" class="headerlink" title="👁去重drop_duplicates()"></a>👁去重drop_duplicates()</h4><p>  “去重”通过字面意思不难理解，就是删除重复的数据。在一个数据集中，找出重复的数据删并将其删除，最终只保存一个唯一存在的数据项，这就是数据去重的整个过程。</p><p><code>Panda DataFrame</code>对象提供了一个数据去重的函数<code>drop_duplicates()</code></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.drop_duplicates(subset=[<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;C&#x27;</span>],keep=<span class="string">&#x27;first&#x27;</span>,inplace=<span class="literal">True</span>)</span><br><span class="line">参数说明如下：</span><br><span class="line">    subset：表示要进去重的列名，默认为<span class="literal">None</span>。</span><br><span class="line">    keep：有三个可选参数，分别是first、last、<span class="literal">False</span>，默认为first，表示只保留第一次出现的重复项，删除其余重复项，last表示只保留最后一次出现的重复项，<span class="literal">False</span>则表示删除所有重复项。</span><br><span class="line">    inplace：布尔值参数，默认为<span class="literal">False</span>表示删除重复项后返回一个副本，若为Ture则表示直接在原数据上删除重复项。</span><br></pre></td></tr></table></figure><blockquote><p>删除重复项后，行标签使用的数字是原来的，并没有从0重新开始，那么我们应该怎么从0重置索引呢？<code>Pandas</code>提供的<code>reset_index()</code>函数会直接使用重置后的索引。</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">data = &#123;<span class="string">&#x27;col1&#x27;</span>:[<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>],<span class="string">&#x27;col2&#x27;</span>:[<span class="number">0</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">0</span>],<span class="string">&#x27;col3&#x27;</span>:[<span class="number">4</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">4</span>],<span class="string">&#x27;col4&#x27;</span>:[<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>]&#125;</span><br><span class="line">df = pd.DataFrame(data)</span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 默认保留第一次出现的重复项,默认为first</span></span><br><span class="line"><span class="built_in">print</span>(df.drop_duplicates())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># keep=False删除所有重复项</span></span><br><span class="line">df1 = df.drop_duplicates(keep=<span class="literal">False</span>)</span><br><span class="line"><span class="built_in">print</span>(df1)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 重置索引，从0重新开始</span></span><br><span class="line"><span class="built_in">print</span>(df1.reset_index(drop=<span class="literal">True</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 指定多列同时去重</span></span><br><span class="line"><span class="built_in">print</span>(df.drop_duplicates([<span class="string">&#x27;col3&#x27;</span>,<span class="string">&#x27;col4&#x27;</span>],keep=<span class="string">&#x27;last&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">   col1  col2  col3  col4</span><br><span class="line"><span class="number">0</span>     <span class="number">1</span>     <span class="number">0</span>     <span class="number">4</span>     <span class="number">1</span></span><br><span class="line"><span class="number">1</span>     <span class="number">0</span>     <span class="number">2</span>     <span class="number">0</span>     <span class="number">0</span></span><br><span class="line"><span class="number">2</span>     <span class="number">1</span>     <span class="number">5</span>     <span class="number">4</span>     <span class="number">1</span></span><br><span class="line"><span class="number">3</span>     <span class="number">1</span>     <span class="number">0</span>     <span class="number">4</span>     <span class="number">1</span></span><br><span class="line">********************</span><br><span class="line">   col1  col2  col3  col4</span><br><span class="line"><span class="number">0</span>     <span class="number">1</span>     <span class="number">0</span>     <span class="number">4</span>     <span class="number">1</span></span><br><span class="line"><span class="number">1</span>     <span class="number">0</span>     <span class="number">2</span>     <span class="number">0</span>     <span class="number">0</span></span><br><span class="line"><span class="number">2</span>     <span class="number">1</span>     <span class="number">5</span>     <span class="number">4</span>     <span class="number">1</span></span><br><span class="line">********************</span><br><span class="line">   col1  col2  col3  col4</span><br><span class="line"><span class="number">1</span>     <span class="number">0</span>     <span class="number">2</span>     <span class="number">0</span>     <span class="number">0</span></span><br><span class="line"><span class="number">2</span>     <span class="number">1</span>     <span class="number">5</span>     <span class="number">4</span>     <span class="number">1</span></span><br><span class="line">********************</span><br><span class="line">   col1  col2  col3  col4</span><br><span class="line"><span class="number">0</span>     <span class="number">0</span>     <span class="number">2</span>     <span class="number">0</span>     <span class="number">0</span></span><br><span class="line"><span class="number">1</span>     <span class="number">1</span>     <span class="number">5</span>     <span class="number">4</span>     <span class="number">1</span></span><br><span class="line">********************</span><br><span class="line">   col1  col2  col3  col4</span><br><span class="line"><span class="number">1</span>     <span class="number">0</span>     <span class="number">2</span>     <span class="number">0</span>     <span class="number">0</span></span><br><span class="line"><span class="number">3</span>     <span class="number">1</span>     <span class="number">0</span>     <span class="number">4</span>     <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="👀字符串处理"><a href="#👀字符串处理" class="headerlink" title="👀字符串处理"></a>👀字符串处理</h3><p><code>Pandas</code>提供了一系列的字符串函数，因此能够很方便地对字符串进行处理。</p><table><thead><tr><th>函数名称</th><th>函数功能和描述</th></tr></thead><tbody><tr><td><code>lower()</code></td><td>将的字符串转换为小写</td></tr><tr><td><code>upper()</code></td><td>将的字符串转换为大写</td></tr><tr><td><code>len()</code></td><td>得出字符串的长度</td></tr><tr><td><code>strip()</code></td><td>去除字符串两边的空格（包含换行符）</td></tr><tr><td><code>split()</code></td><td>用指定的分割符分割字符串</td></tr><tr><td><code>cat(sep=&quot;&quot;)</code></td><td>用给定的分隔符连接字符串元素</td></tr><tr><td><code>get_dummies()</code></td><td>返回一个带有独热编码值的<code>DataFrame</code>结构</td></tr><tr><td><code>contains(pattern)</code></td><td>如果子字符串包含在元素中，则为每个元素返回一个布尔值True，否则为False</td></tr><tr><td><code>replace(a,b)</code></td><td>将值a替换为值b</td></tr><tr><td><code>count(pattern)</code></td><td>返回每个字符串元素出现的次数</td></tr><tr><td><code>startswith(pattern)</code></td><td>如果<code>Series</code>中的元素以指定的字符串开头，则返回True</td></tr><tr><td><code>endswith(pattern)</code></td><td>如果<code>Series</code>中的元素以指定的字符串结尾，则返回True</td></tr><tr><td><code>findall(pattern)</code></td><td>以列表的形式返出现的字符串</td></tr><tr><td><code>swapcase()</code></td><td>交换大小写</td></tr><tr><td><code>islower()</code></td><td>返回布尔值，检查<code>Series</code>中组成每个字符串的所有字符是否都为小写</td></tr><tr><td><code>issupper()</code></td><td>返回布尔值，检查<code>Series</code>中组成每个字符串的所有字符是否都为大写</td></tr><tr><td><code>isnumeric()</code></td><td>返回布尔值，检查<code>Series</code>中组成每个字符串的所有字符是否都为数字</td></tr><tr><td><code>repeat(value)</code></td><td>以指定的次数重复每个元素</td></tr><tr><td><code>find(pattern)</code></td><td>返回字符串第一次出现的索引位置</td></tr></tbody></table><blockquote><p>注意：上述所有字符串函数全部适用于<code>DataFrame</code>对象，同时也可以与<code>Python</code>内置的字符串函数一起使用，这些函数在处理<code>Series/DataFrame</code>对象的时候会自动忽略缺失值数据（<code>NaN</code>）。</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">s = pd.Series([<span class="string">&#x27;C &#x27;</span>, <span class="string">&#x27; Python&#x27;</span>, <span class="string">&#x27;java&#x27;</span>, <span class="string">&#x27;go&#x27;</span>, np.nan, <span class="string">&#x27;1125 &#x27;</span>,<span class="string">&#x27;javascript&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(s.<span class="built_in">str</span>.lower)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="built_in">print</span>(s.<span class="built_in">str</span>.<span class="built_in">len</span>())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="built_in">print</span>(s.<span class="built_in">str</span>.strip())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="built_in">print</span>(s.<span class="built_in">str</span>.split(<span class="string">&quot; &quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="built_in">print</span>(s.<span class="built_in">str</span>.cat(sep=<span class="string">&quot;_&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="built_in">print</span>(s.<span class="built_in">str</span>.get_dummies())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="built_in">print</span>(s.<span class="built_in">str</span>.contains(<span class="string">&quot; &quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="built_in">print</span>(s.<span class="built_in">str</span>.repeat(<span class="number">3</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="built_in">print</span>(s.<span class="built_in">str</span>.startswith(<span class="string">&quot;j&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 如果返回-1表示该字符串中没有出现指定的字符</span></span><br><span class="line"><span class="built_in">print</span>(s.<span class="built_in">str</span>.find(<span class="string">&quot;j&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="built_in">print</span>(s.<span class="built_in">str</span>.swapcase())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="built_in">print</span>(s.<span class="built_in">str</span>.isnumeric())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="number">0</span>            c </span><br><span class="line"><span class="number">1</span>        python</span><br><span class="line"><span class="number">2</span>          java</span><br><span class="line"><span class="number">3</span>            go</span><br><span class="line"><span class="number">4</span>           NaN</span><br><span class="line"><span class="number">5</span>         <span class="number">1125</span> </span><br><span class="line"><span class="number">6</span>    javascript</span><br><span class="line">dtype: <span class="built_in">object</span></span><br><span class="line">********************</span><br><span class="line"><span class="number">0</span>     <span class="number">2.0</span></span><br><span class="line"><span class="number">1</span>     <span class="number">7.0</span></span><br><span class="line"><span class="number">2</span>     <span class="number">4.0</span></span><br><span class="line"><span class="number">3</span>     <span class="number">2.0</span></span><br><span class="line"><span class="number">4</span>     NaN</span><br><span class="line"><span class="number">5</span>     <span class="number">5.0</span></span><br><span class="line"><span class="number">6</span>    <span class="number">10.0</span></span><br><span class="line">dtype: float64</span><br><span class="line">********************</span><br><span class="line"><span class="number">0</span>             C</span><br><span class="line"><span class="number">1</span>        Python</span><br><span class="line"><span class="number">2</span>          java</span><br><span class="line"><span class="number">3</span>            go</span><br><span class="line"><span class="number">4</span>           NaN</span><br><span class="line"><span class="number">5</span>          <span class="number">1125</span></span><br><span class="line"><span class="number">6</span>    javascript</span><br><span class="line">dtype: <span class="built_in">object</span></span><br><span class="line">********************</span><br><span class="line"><span class="number">0</span>           [C, ]</span><br><span class="line"><span class="number">1</span>      [, Python]</span><br><span class="line"><span class="number">2</span>          [java]</span><br><span class="line"><span class="number">3</span>            [go]</span><br><span class="line"><span class="number">4</span>             NaN</span><br><span class="line"><span class="number">5</span>        [<span class="number">1125</span>, ]</span><br><span class="line"><span class="number">6</span>    [javascript]</span><br><span class="line">dtype: <span class="built_in">object</span></span><br><span class="line">********************</span><br><span class="line">C _ Python_java_go_1125 _javascript</span><br><span class="line">********************</span><br><span class="line">    Python  <span class="number">1125</span>   C   go  java  javascript</span><br><span class="line"><span class="number">0</span>        <span class="number">0</span>      <span class="number">0</span>   <span class="number">1</span>   <span class="number">0</span>     <span class="number">0</span>           <span class="number">0</span></span><br><span class="line"><span class="number">1</span>        <span class="number">1</span>      <span class="number">0</span>   <span class="number">0</span>   <span class="number">0</span>     <span class="number">0</span>           <span class="number">0</span></span><br><span class="line"><span class="number">2</span>        <span class="number">0</span>      <span class="number">0</span>   <span class="number">0</span>   <span class="number">0</span>     <span class="number">1</span>           <span class="number">0</span></span><br><span class="line"><span class="number">3</span>        <span class="number">0</span>      <span class="number">0</span>   <span class="number">0</span>   <span class="number">1</span>     <span class="number">0</span>           <span class="number">0</span></span><br><span class="line"><span class="number">4</span>        <span class="number">0</span>      <span class="number">0</span>   <span class="number">0</span>   <span class="number">0</span>     <span class="number">0</span>           <span class="number">0</span></span><br><span class="line"><span class="number">5</span>        <span class="number">0</span>      <span class="number">1</span>   <span class="number">0</span>   <span class="number">0</span>     <span class="number">0</span>           <span class="number">0</span></span><br><span class="line"><span class="number">6</span>        <span class="number">0</span>      <span class="number">0</span>   <span class="number">0</span>   <span class="number">0</span>     <span class="number">0</span>           <span class="number">1</span></span><br><span class="line">********************</span><br><span class="line"><span class="number">0</span>     <span class="literal">True</span></span><br><span class="line"><span class="number">1</span>     <span class="literal">True</span></span><br><span class="line"><span class="number">2</span>    <span class="literal">False</span></span><br><span class="line"><span class="number">3</span>    <span class="literal">False</span></span><br><span class="line"><span class="number">4</span>      NaN</span><br><span class="line"><span class="number">5</span>     <span class="literal">True</span></span><br><span class="line"><span class="number">6</span>    <span class="literal">False</span></span><br><span class="line">dtype: <span class="built_in">object</span></span><br><span class="line">********************</span><br><span class="line"><span class="number">0</span>                            C C C </span><br><span class="line"><span class="number">1</span>              Python Python Python</span><br><span class="line"><span class="number">2</span>                      javajavajava</span><br><span class="line"><span class="number">3</span>                            gogogo</span><br><span class="line"><span class="number">4</span>                               NaN</span><br><span class="line"><span class="number">5</span>                   <span class="number">1125</span> <span class="number">1125</span> <span class="number">1125</span> </span><br><span class="line"><span class="number">6</span>    javascriptjavascriptjavascript</span><br><span class="line">dtype: <span class="built_in">object</span></span><br><span class="line">********************</span><br><span class="line"><span class="number">0</span>    <span class="literal">False</span></span><br><span class="line"><span class="number">1</span>    <span class="literal">False</span></span><br><span class="line"><span class="number">2</span>     <span class="literal">True</span></span><br><span class="line"><span class="number">3</span>    <span class="literal">False</span></span><br><span class="line"><span class="number">4</span>      NaN</span><br><span class="line"><span class="number">5</span>    <span class="literal">False</span></span><br><span class="line"><span class="number">6</span>     <span class="literal">True</span></span><br><span class="line">dtype: <span class="built_in">object</span></span><br><span class="line">********************</span><br><span class="line"><span class="number">0</span>   -<span class="number">1.0</span></span><br><span class="line"><span class="number">1</span>   -<span class="number">1.0</span></span><br><span class="line"><span class="number">2</span>    <span class="number">0.0</span></span><br><span class="line"><span class="number">3</span>   -<span class="number">1.0</span></span><br><span class="line"><span class="number">4</span>    NaN</span><br><span class="line"><span class="number">5</span>   -<span class="number">1.0</span></span><br><span class="line"><span class="number">6</span>    <span class="number">0.0</span></span><br><span class="line">dtype: float64</span><br><span class="line">********************</span><br><span class="line"><span class="number">0</span>            c </span><br><span class="line"><span class="number">1</span>        pYTHON</span><br><span class="line"><span class="number">2</span>          JAVA</span><br><span class="line"><span class="number">3</span>            GO</span><br><span class="line"><span class="number">4</span>           NaN</span><br><span class="line"><span class="number">5</span>         <span class="number">1125</span> </span><br><span class="line"><span class="number">6</span>    JAVASCRIPT</span><br><span class="line">dtype: <span class="built_in">object</span></span><br><span class="line">********************</span><br><span class="line"><span class="number">0</span>    <span class="literal">False</span></span><br><span class="line"><span class="number">1</span>    <span class="literal">False</span></span><br><span class="line"><span class="number">2</span>    <span class="literal">False</span></span><br><span class="line"><span class="number">3</span>    <span class="literal">False</span></span><br><span class="line"><span class="number">4</span>      NaN</span><br><span class="line"><span class="number">5</span>    <span class="literal">False</span></span><br><span class="line"><span class="number">6</span>    <span class="literal">False</span></span><br><span class="line">dtype: <span class="built_in">object</span></span><br></pre></td></tr></table></figure><h3 id="👀设置数据显示格式"><a href="#👀设置数据显示格式" class="headerlink" title="👀设置数据显示格式"></a>👀设置数据显示格式</h3><p>在用<code>Pandas</code>做数据分析的过程中，总需要打印数据分析的结果，如果数据体量较大就会存在输出内容不全（部分内容省略）或者换行错误等问题。<code>Pandas</code>为了解决上述问题，允许你对数据显示格式进行设置。下面列出了五个用来设置显示格式的函数，分别是：</p><table><thead><tr><th>函数名称</th><th>说明</th></tr></thead><tbody><tr><td><code>get_option()</code></td><td>获取解释器的默认参数值</td></tr><tr><td><code>set_option()</code></td><td>更改解释器的默认参数值</td></tr><tr><td><code>reset_option()</code></td><td>解释器的参数重置为默认值</td></tr><tr><td><code>describe_option()</code></td><td>输出参数的描述信息</td></tr><tr><td><code>option_context()</code></td><td>临时设置解释器参数，当退出使用的语句块时，恢复为默认值</td></tr></tbody></table><p>上述函数常用的参数项：</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><code>display.max_rows</code></td><td>最大显示行数，超过该值用省略号代替，为None时显示所有行</td></tr><tr><td><code>display.max_columns</code></td><td>最大显示列数，超过该值用省略号代替，为None时显示所有列</td></tr><tr><td><code>display.expand_frame_repr</code></td><td>输出数据宽度超过设置宽度时，表示是否对其要折叠，False不折叠，True要折叠</td></tr><tr><td><code>display.max_colwidth</code></td><td>单列数据宽度，以字符个数计算，超过时用省略号表示</td></tr><tr><td><code>display.precision</code></td><td>设置输出数据的小数点位数</td></tr><tr><td><code>display.width</code></td><td>数据显示区域的宽度，以总字符数计算</td></tr><tr><td><code>display.show_dimensions</code></td><td>当数据量大需要以truncate（带引号的省略方式）显示时，该参数表示是否在最后显示数据的维数，默认True显示，False不显示。</td></tr></tbody></table><h3 id="👀loc和iloc用法详解"><a href="#👀loc和iloc用法详解" class="headerlink" title="👀loc和iloc用法详解"></a>👀loc和iloc用法详解</h3><p>在数据分析过程中，很多时候需要从数据表中提取出相应的数据，而这么做的前提是需要先“索引”出这一部分数据。虽然通过<code>Python</code>提供的索引操作符<code>&quot;[]&quot;</code>和属性操作符<code>&quot;.&quot;</code>可以访问<code>Series</code>或者<code>DataFrame</code>中的数据，但这种方式只适应与少量的数据，为了解决这一问题，<code>Pandas</code>提供了两种类型的索引方式来实现数据的访问。</p><table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td><code>.loc[]</code></td><td>基于标签索引选取数据</td></tr><tr><td><code>.iloc[]</code></td><td>基于整数索引选取数据</td></tr></tbody></table><p><code>df.loc[]</code>只能使用标签索引，不能使用整数索引。当通过标签索引的切片方式来筛选数据时，它的取值前闭后闭，也就是只包括边界值标签（开始和结束）。</p><p><code>.loc[]</code>具有多种访问方法，如下所示：</p><ul><li>一个标量标签</li><li>标签列表</li><li>切片对象</li><li>布尔数组</li></ul><p><code>loc[]</code>接受两个参数，并以<code>&#39;,&#39;</code>分隔。第一个位置表示行，第二个位置表示列。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">data = &#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: [<span class="string">&#x27;Tom&#x27;</span>, <span class="string">&#x27;Rose&#x27;</span>, <span class="string">&#x27;Mike&#x27;</span>, <span class="string">&#x27;Twg&#x27;</span>],</span><br><span class="line">  <span class="string">&quot;calories&quot;</span>: [<span class="number">420</span>, <span class="number">380</span>, <span class="number">390</span>, <span class="number">500</span>],</span><br><span class="line">  <span class="string">&quot;duration&quot;</span>: [<span class="number">50</span>, <span class="number">40</span>, <span class="number">45</span>, <span class="number">60</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 数据载入到 DataFrame 对象</span></span><br><span class="line">df = pd.DataFrame(data, index = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 对行操作，等同于df.loc[&#x27;a&#x27;:&#x27;b&#x27;]</span></span><br><span class="line"><span class="built_in">print</span>(df.loc[<span class="string">&#x27;a&#x27;</span>:<span class="string">&#x27;b&#x27;</span>,:])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 对列操作</span></span><br><span class="line"><span class="built_in">print</span>(df.loc[:,<span class="string">&#x27;name&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 对行、列操作</span></span><br><span class="line"><span class="built_in">print</span>(df.loc[[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;d&#x27;</span>],[<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;duration&#x27;</span>]])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 布尔值操作</span></span><br><span class="line"><span class="built_in">print</span>(df.loc[:,<span class="string">&#x27;duration&#x27;</span>] &gt; <span class="number">45</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">   name  calories  duration</span><br><span class="line">a   Tom       <span class="number">420</span>        <span class="number">50</span></span><br><span class="line">b  Rose       <span class="number">380</span>        <span class="number">40</span></span><br><span class="line">c  Mike       <span class="number">390</span>        <span class="number">45</span></span><br><span class="line">d   Twg       <span class="number">500</span>        <span class="number">60</span></span><br><span class="line">********************</span><br><span class="line">   name  calories  duration</span><br><span class="line">a   Tom       <span class="number">420</span>        <span class="number">50</span></span><br><span class="line">b  Rose       <span class="number">380</span>        <span class="number">40</span></span><br><span class="line">********************</span><br><span class="line">a     Tom</span><br><span class="line">b    Rose</span><br><span class="line">c    Mike</span><br><span class="line">d     Twg</span><br><span class="line">Name: name, dtype: <span class="built_in">object</span></span><br><span class="line">********************</span><br><span class="line">  name  duration</span><br><span class="line">a  Tom        <span class="number">50</span></span><br><span class="line">d  Twg        <span class="number">60</span></span><br><span class="line">********************</span><br><span class="line">a     <span class="literal">True</span></span><br><span class="line">b    <span class="literal">False</span></span><br><span class="line">c    <span class="literal">False</span></span><br><span class="line">d     <span class="literal">True</span></span><br><span class="line">Name: duration, dtype: <span class="built_in">bool</span></span><br></pre></td></tr></table></figure><p><code>df.iloc[]</code>只能使用整数索引，不能使用标签索引，通过整数索引切片选择数据时，前闭后开(不包含边界结束值)。同<code>Python</code>和<code>NumPy</code>一样，它们的索引都是从0开始。</p><p><code>.iloc[]</code>提供了以下方式来选择数据：</p><ul><li>整数索引</li><li>整数列表</li><li>数值范围</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">data = &#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: [<span class="string">&#x27;Tom&#x27;</span>, <span class="string">&#x27;Rose&#x27;</span>, <span class="string">&#x27;Mike&#x27;</span>, <span class="string">&#x27;Twg&#x27;</span>],</span><br><span class="line">  <span class="string">&quot;calories&quot;</span>: [<span class="number">420</span>, <span class="number">380</span>, <span class="number">390</span>, <span class="number">500</span>],</span><br><span class="line">  <span class="string">&quot;duration&quot;</span>: [<span class="number">50</span>, <span class="number">40</span>, <span class="number">45</span>, <span class="number">60</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 数据载入到 DataFrame 对象</span></span><br><span class="line">df = pd.DataFrame(data, index = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="built_in">print</span>(df.iloc[<span class="number">2</span>:,:])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="built_in">print</span>(df.iloc[[<span class="number">0</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">2</span>]])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="built_in">print</span>(df.iloc[:,:<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">   name  calories  duration</span><br><span class="line">a   Tom       <span class="number">420</span>        <span class="number">50</span></span><br><span class="line">b  Rose       <span class="number">380</span>        <span class="number">40</span></span><br><span class="line">c  Mike       <span class="number">390</span>        <span class="number">45</span></span><br><span class="line">d   Twg       <span class="number">500</span>        <span class="number">60</span></span><br><span class="line">********************</span><br><span class="line">   name  calories  duration</span><br><span class="line">c  Mike       <span class="number">390</span>        <span class="number">45</span></span><br><span class="line">d   Twg       <span class="number">500</span>        <span class="number">60</span></span><br><span class="line">********************</span><br><span class="line">   calories  duration</span><br><span class="line">a       <span class="number">420</span>        <span class="number">50</span></span><br><span class="line">c       <span class="number">390</span>        <span class="number">45</span></span><br><span class="line">********************</span><br><span class="line">   name  calories</span><br><span class="line">a   Tom       <span class="number">420</span></span><br><span class="line">b  Rose       <span class="number">380</span></span><br><span class="line">c  Mike       <span class="number">390</span></span><br><span class="line">d   Twg       <span class="number">500</span></span><br></pre></td></tr></table></figure><h3 id="👀日期时间操作"><a href="#👀日期时间操作" class="headerlink" title="👀日期时间操作"></a>👀日期时间操作</h3><h4 id="👁Pandas时间序列"><a href="#👁Pandas时间序列" class="headerlink" title="👁Pandas时间序列"></a>👁Pandas时间序列</h4><p>顾名思义，时间序列（<code>time series</code>），就是由时间构成的序列，它指的是在一定时间内按照时间顺序测量的某个变量的取值序列，比如一天内的温度会随时间而发生变化，或者股票的价格会随着时间不断的波动，这里用到的一系列时间，就可以看做时间序列。时间序列包含三种应用场景，分别是：</p><ul><li>特定的时刻（<code>timestamp</code>），也就是时间戳；</li><li>固定的日期（<code>period</code>），比如某年某月某日；</li><li>时间间隔（<code>interval</code>），每隔一段时间具有规律性；</li></ul><p>在处理时间序列的过程中，我们一般会遇到两个问题，第一，如何创建时间序列；第二，如何更改已生成时间序列的频率。 <code>Pandas</code>为解决上述问题提供了一套简单、易用的方法。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Python内置的datetime模块来获取当前时间，通过该模块提供的now()方法即可实现。</span></span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="comment"># 数据类型为datetime</span></span><br><span class="line"><span class="built_in">print</span>(datetime.now())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="number">2023</span>-03-<span class="number">19</span> <span class="number">17</span>:<span class="number">42</span>:<span class="number">39.528176</span></span><br></pre></td></tr></table></figure><p>创建时间戳：<code>TimeStamp</code>（时间戳） 是时间序列中的最基本的数据类型，它将数值与时间点完美结合在一起。</p><p>创建时间间隔：通过<code>date_range()</code>方法可以创建某段连续的时间或者固定间隔的时间时间段。该函数提供了三个参数，分别是：<code>start</code>开始时间；<code>end</code>结束时间；<code>freq</code>时间频率，默认为 “D”（天）。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="comment"># 创建时间戳</span></span><br><span class="line"><span class="built_in">print</span>(pd.Timestamp(<span class="string">&#x27;2023-03-16&#x27;</span>))</span><br><span class="line"><span class="comment"># 可以将整型或浮点型表示的时间转换为时间戳。默认的单位是纳秒(时间戳单位)</span></span><br><span class="line"><span class="built_in">print</span>(pd.Timestamp(<span class="number">1687687255</span>,unit=<span class="string">&#x27;s&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 创建时间范围，freq表示时间频率，每30min变化一次</span></span><br><span class="line"><span class="built_in">print</span>(pd.date_range(<span class="string">&quot;9:00&quot;</span>, <span class="string">&quot;18:10&quot;</span>, freq=<span class="string">&quot;30min&quot;</span>).time)</span><br><span class="line"><span class="comment"># 修改为按小时</span></span><br><span class="line"><span class="built_in">print</span>(pd.date_range(<span class="string">&quot;9:00&quot;</span>, <span class="string">&quot;18:10&quot;</span>, freq=<span class="string">&quot;H&quot;</span>).time)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 使用to_datetime()函数将series或list转换为日期对象，其中list会转换为DatetimeIndex</span></span><br><span class="line"><span class="comment"># 输出中，注意：NaT表示的不是时间 ，它等效于NaN</span></span><br><span class="line"><span class="comment"># 传入series，生成Datetimeindex</span></span><br><span class="line"><span class="built_in">print</span>(pd.to_datetime(pd.Series([<span class="string">&#x27;Jun 3, 2020&#x27;</span>,<span class="string">&#x27;2020-12-10&#x27;</span>, <span class="literal">None</span>])))</span><br><span class="line"><span class="comment"># 传入list，生成Datetimeindex</span></span><br><span class="line"><span class="built_in">print</span>(pd.to_datetime([<span class="string">&#x27;Jun 30, 2020&#x27;</span>,<span class="string">&#x27;2020-12-10&#x27;</span>, <span class="literal">None</span>]))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="number">2023</span>-03-<span class="number">16</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span></span><br><span class="line"><span class="number">2023</span>-06-<span class="number">25</span> <span class="number">10</span>:<span class="number">00</span>:<span class="number">55</span></span><br><span class="line">********************</span><br><span class="line">[datetime.time(<span class="number">9</span>, <span class="number">0</span>) datetime.time(<span class="number">9</span>, <span class="number">30</span>) datetime.time(<span class="number">10</span>, <span class="number">0</span>)</span><br><span class="line"> datetime.time(<span class="number">10</span>, <span class="number">30</span>) datetime.time(<span class="number">11</span>, <span class="number">0</span>) datetime.time(<span class="number">11</span>, <span class="number">30</span>)</span><br><span class="line"> datetime.time(<span class="number">12</span>, <span class="number">0</span>) datetime.time(<span class="number">12</span>, <span class="number">30</span>) datetime.time(<span class="number">13</span>, <span class="number">0</span>)</span><br><span class="line"> datetime.time(<span class="number">13</span>, <span class="number">30</span>) datetime.time(<span class="number">14</span>, <span class="number">0</span>) datetime.time(<span class="number">14</span>, <span class="number">30</span>)</span><br><span class="line"> datetime.time(<span class="number">15</span>, <span class="number">0</span>) datetime.time(<span class="number">15</span>, <span class="number">30</span>) datetime.time(<span class="number">16</span>, <span class="number">0</span>)</span><br><span class="line"> datetime.time(<span class="number">16</span>, <span class="number">30</span>) datetime.time(<span class="number">17</span>, <span class="number">0</span>) datetime.time(<span class="number">17</span>, <span class="number">30</span>)</span><br><span class="line"> datetime.time(<span class="number">18</span>, <span class="number">0</span>)]</span><br><span class="line">[datetime.time(<span class="number">9</span>, <span class="number">0</span>) datetime.time(<span class="number">10</span>, <span class="number">0</span>) datetime.time(<span class="number">11</span>, <span class="number">0</span>)</span><br><span class="line"> datetime.time(<span class="number">12</span>, <span class="number">0</span>) datetime.time(<span class="number">13</span>, <span class="number">0</span>) datetime.time(<span class="number">14</span>, <span class="number">0</span>)</span><br><span class="line"> datetime.time(<span class="number">15</span>, <span class="number">0</span>) datetime.time(<span class="number">16</span>, <span class="number">0</span>) datetime.time(<span class="number">17</span>, <span class="number">0</span>)</span><br><span class="line"> datetime.time(<span class="number">18</span>, <span class="number">0</span>)]</span><br><span class="line">********************</span><br><span class="line"><span class="number">0</span>   <span class="number">2020</span>-06-03</span><br><span class="line"><span class="number">1</span>   <span class="number">2020</span>-<span class="number">12</span>-<span class="number">10</span></span><br><span class="line"><span class="number">2</span>          NaT</span><br><span class="line">dtype: datetime64[ns]</span><br><span class="line">DatetimeIndex([<span class="string">&#x27;2020-06-30&#x27;</span>, <span class="string">&#x27;2020-12-10&#x27;</span>, <span class="string">&#x27;NaT&#x27;</span>], dtype=<span class="string">&#x27;datetime64[ns]&#x27;</span>, freq=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure><p>频率和周期转换：<code>Time Periods</code>表示时间跨度，一段时间周期，它被定义在<code>Pandas Periods</code>类中，通过该类提供的方法可以实现将频率转换为周期。比如<code>Periods()</code>方法，可以将频率 “<code>M</code>“（月）转换为 <code>Period</code>（时间段）。使用<code>asfreq()</code>和<code>start</code>参数，打印 “<code>01</code>“ ，若使用<code>end</code>参数，则打印 “<code>31</code>“。对于常用的时间序列频率，<code>Pandas</code>为其规定了一些字符串别名，我们将这些别名称为“<code>offset</code>（偏移量）”。</p><table><thead><tr><th>别名</th><th>描述</th><th>别名</th><th>描述</th></tr></thead><tbody><tr><td><code>B</code></td><td>工作日频率</td><td><code>BQS</code></td><td>工作季度开始频率</td></tr><tr><td><code>D</code></td><td>日历日频率</td><td><code>A</code></td><td>年终频率</td></tr><tr><td><code>W</code></td><td>每周频率</td><td><code>BA</code></td><td>工作年度结束频率</td></tr><tr><td><code>M</code></td><td>月末频率</td><td><code>BAS</code></td><td>工作年度开始频率</td></tr><tr><td><code>SM</code></td><td>半月结束频率</td><td><code>BH</code></td><td>营业时间频率</td></tr><tr><td><code>BM</code></td><td>工作月结束频率</td><td><code>H</code></td><td>小时频率</td></tr><tr><td><code>MS</code></td><td>月开始频率</td><td><code>T,min</code></td><td>每分钟频率</td></tr><tr><td><code>SMS</code></td><td>半月开始频率</td><td><code>S</code></td><td>每秒钟频率</td></tr><tr><td><code>BMS</code></td><td>工作月开始频率</td><td><code>L,ms</code></td><td>毫秒</td></tr><tr><td><code>Q</code></td><td>季末频率</td><td><code>U,us</code></td><td>微秒</td></tr><tr><td><code>BQ</code></td><td>工作季度结束频率</td><td><code>N</code></td><td>纳秒</td></tr><tr><td><code>QS</code></td><td>季度开始频率</td><td></td><td></td></tr></tbody></table><p>周期计算：指的是对时间周期进行算术运算，所有的操作将在“频率”的基础上执行。</p><p>创建时间周期：可以使用<code>period_range()</code>方法来创建时间周期范围。</p><p>时间序列转换：如果想要把字符串日期转换为<code>Period</code>，首先需要将字符串转换为日期格式，然后再将日期转换为<code>Period</code>。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd </span><br><span class="line"><span class="comment"># S表示秒</span></span><br><span class="line">x = pd.Period(<span class="string">&#x27;2014&#x27;</span>, freq=<span class="string">&#x27;S&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line"><span class="comment"># 加1s的时间</span></span><br><span class="line"><span class="built_in">print</span>(x+<span class="number">1</span>)</span><br><span class="line"><span class="comment"># 使用period_range()方法来创建时间周期范围</span></span><br><span class="line">p = pd.period_range(<span class="string">&#x27;2016&#x27;</span>,<span class="string">&#x27;2018&#x27;</span>, freq=<span class="string">&#x27;Y&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(p)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="number">2014</span>-01-01 <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span></span><br><span class="line"><span class="number">2014</span>-01-01 <span class="number">00</span>:<span class="number">00</span>:01</span><br><span class="line">PeriodIndex([<span class="string">&#x27;2016&#x27;</span>, <span class="string">&#x27;2017&#x27;</span>, <span class="string">&#x27;2018&#x27;</span>], dtype=<span class="string">&#x27;period[A-DEC]&#x27;</span>, freq=<span class="string">&#x27;A-DEC&#x27;</span>)</span><br></pre></td></tr></table></figure><h4 id="👁日期时间格式化"><a href="#👁日期时间格式化" class="headerlink" title="👁日期时间格式化"></a>👁日期时间格式化</h4><p>当进行数据分析时，我们会遇到很多带有日期、时间格式的数据集，在处理这些数据集时，可能会遇到日期格式不统一的问题，此时就需要对日期时间做统一的格式化处理。比如”<code>Wednesday, June 6, 2020</code>“可以写成”<code>6/6/20</code>“，或者写成”<code>06-06-2020</code>“。</p><p>（1）日期格式化符号</p><p>在对时间进行格式化处理时，它们都有固定的表示格式，比如小时的格式化符号为<code>%H</code> ,分钟简写为<code>%M</code> ，秒简写为<code>%S</code>。</p><table><thead><tr><th>符号</th><th>说明</th><th>符号</th><th>说明</th></tr></thead><tbody><tr><td><code>%y</code></td><td>两位数的年份表示（00-99）</td><td><code>%Y</code></td><td>四位数的年份表示（000-9999）</td></tr><tr><td><code>%m</code></td><td>月份（01-12）</td><td><code>%d</code></td><td>月内中的一天（0-31）</td></tr><tr><td><code>%H</code></td><td>24小时制小时数（0-23）</td><td><code>%I</code></td><td>12小时制小时数（01-12）</td></tr><tr><td><code>%M</code></td><td>分钟数（00&#x3D;59）</td><td><code>%S</code></td><td>秒（00-59）</td></tr><tr><td><code>%a</code></td><td>本地英文缩写星期名称</td><td><code>%A</code></td><td>本地英文完整星期名称</td></tr><tr><td><code>%b</code></td><td>本地缩写英文的月份名称</td><td><code>%B</code></td><td>本地完整英文的月份名称</td></tr><tr><td><code>%w</code></td><td>星期（0-6），星期天为星期的开始</td><td><code>%W</code></td><td>一年中的星期数（00-53）星期一为星期的开始</td></tr><tr><td><code>%x</code></td><td>本地相应的日期表示</td><td><code>%X</code></td><td>本地相应的时间表示</td></tr><tr><td><code>%Z</code></td><td>当前时区的名称</td><td><code>%U</code></td><td>一年中的星期数（00-53）星期天为星期的开始</td></tr><tr><td><code>%j</code></td><td>年内的一天（001-366）</td><td><code>%c</code></td><td>本地相应的日期表示和时间表示</td></tr></tbody></table><p>（2）日期格式化处理函数</p><p><code>Python</code>内置的<code>strptime()</code>方法能够将字符串日期转换为<code>datetime</code>类型。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="comment"># 将日期定义为字符串    </span></span><br><span class="line">date_str1 = <span class="string">&#x27;Wednesday,July 18,2020&#x27;</span> </span><br><span class="line">date_str2 = <span class="string">&#x27;18/7/20&#x27;</span> </span><br><span class="line">date_str3 = <span class="string">&#x27;18-07-2020&#x27;</span>  </span><br><span class="line"><span class="comment"># 将日期转化为datetime对象 </span></span><br><span class="line">dmy_dt1 = datetime.strptime(date_str1, <span class="string">&#x27;%A,%B %d,%Y&#x27;</span>) </span><br><span class="line">dmy_dt2 = datetime.strptime(date_str2, <span class="string">&#x27;%d/%m/%y&#x27;</span>) </span><br><span class="line">dmy_dt3 = datetime.strptime(date_str3, <span class="string">&#x27;%d-%m-%Y&#x27;</span>)  </span><br><span class="line"><span class="comment"># 处理为相同格式，并打印输出</span></span><br><span class="line"><span class="built_in">print</span>(dmy_dt1) </span><br><span class="line"><span class="built_in">print</span>(dmy_dt2) </span><br><span class="line"><span class="built_in">print</span>(dmy_dt3) </span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="number">2020</span>-07-<span class="number">18</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span></span><br><span class="line"><span class="number">2020</span>-07-<span class="number">18</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span></span><br><span class="line"><span class="number">2020</span>-07-<span class="number">18</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span></span><br></pre></td></tr></table></figure><p>除了使用<code>Python</code>内置的<code>strptime()</code>方法外，你还可以使用<code>Pandas</code>模块的<code>pd.to_datetime()</code>和<code>pd.DatetimeIndex()</code>进行转换。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment"># 通过to_datetime()直接转换为 datetime 类型</span></span><br><span class="line">date1 = [<span class="string">&#x27;2012-05-06 11:00:00&#x27;</span>,<span class="string">&#x27;2012-05-16 11:00:00&#x27;</span>]</span><br><span class="line">pd_date1 = pd.to_datetime(date1)</span><br><span class="line">df1 = pd.Series(np.random.randn(<span class="number">2</span>),index=pd_date1)</span><br><span class="line"><span class="built_in">print</span>(pd_date1)</span><br><span class="line"><span class="built_in">print</span>(df1)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 使用Datetimeindex()函数设置时间序</span></span><br><span class="line">date2 = pd.DatetimeIndex([<span class="string">&#x27;1/1/2008&#x27;</span>, <span class="string">&#x27;1/2/2008&#x27;</span>, <span class="string">&#x27;1/3/2008&#x27;</span>, <span class="string">&#x27;1/4/2008&#x27;</span>, <span class="string">&#x27;1/5/2008&#x27;</span>])</span><br><span class="line">dt2 = pd.DataFrame(np.random.randn(<span class="number">5</span>),index=date2, columns=[<span class="string">&#x27;value&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(date2)</span><br><span class="line"><span class="built_in">print</span>(dt2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">DatetimeIndex([<span class="string">&#x27;2012-05-06 11:00:00&#x27;</span>, <span class="string">&#x27;2012-05-16 11:00:00&#x27;</span>], dtype=<span class="string">&#x27;datetime64[ns]&#x27;</span>, freq=<span class="literal">None</span>)</span><br><span class="line"><span class="number">2012</span>-05-06 <span class="number">11</span>:<span class="number">00</span>:<span class="number">00</span>    <span class="number">2.115566</span></span><br><span class="line"><span class="number">2012</span>-05-<span class="number">16</span> <span class="number">11</span>:<span class="number">00</span>:<span class="number">00</span>   -<span class="number">0.145139</span></span><br><span class="line">dtype: float64</span><br><span class="line">********************</span><br><span class="line">DatetimeIndex([<span class="string">&#x27;2008-01-01&#x27;</span>, <span class="string">&#x27;2008-01-02&#x27;</span>, <span class="string">&#x27;2008-01-03&#x27;</span>, <span class="string">&#x27;2008-01-04&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2008-01-05&#x27;</span>],</span><br><span class="line">              dtype=<span class="string">&#x27;datetime64[ns]&#x27;</span>, freq=<span class="literal">None</span>)</span><br><span class="line">               value</span><br><span class="line"><span class="number">2008</span>-01-01  <span class="number">0.828022</span></span><br><span class="line"><span class="number">2008</span>-01-02 -<span class="number">1.873516</span></span><br><span class="line"><span class="number">2008</span>-01-03  <span class="number">1.940921</span></span><br><span class="line"><span class="number">2008</span>-01-04  <span class="number">1.563612</span></span><br><span class="line"><span class="number">2008</span>-01-05  <span class="number">0.964914</span></span><br></pre></td></tr></table></figure><h4 id="👁Timedelta时间差"><a href="#👁Timedelta时间差" class="headerlink" title="👁Timedelta时间差"></a>👁Timedelta时间差</h4><p><code>Timedelta</code>表示时间差（或者时间增量），我们可以使用不同的时间单位来表示它，比如，天、小时、分、秒。时间差的最终的结果可以是正时间差，也可以是负时间差。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment"># 通过传递字符串可以创建Timedelta对象</span></span><br><span class="line"><span class="built_in">print</span>(pd.Timedelta(<span class="string">&#x27;5 days 8 hours 6 minutes 59 seconds&#x27;</span>))</span><br><span class="line"><span class="comment"># 通过传递整数值和unit参数也可以创建一个Timedelta对象。</span></span><br><span class="line"><span class="built_in">print</span>(pd.Timedelta(<span class="number">19</span>,unit=<span class="string">&#x27;h&#x27;</span>))</span><br><span class="line"><span class="comment"># 数据偏移量， 比如，周(weeks)、天(days)、小时(hours)、分钟(minutes)、秒(milliseconds)、毫秒、微秒、纳秒都可以使用。</span></span><br><span class="line"><span class="built_in">print</span>(pd.Timedelta(days=<span class="number">2</span>,hours=<span class="number">6</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 您可以使用pd.to_timedelta()方法，将具有timedelta格式的值 (标量、数组、列表或Series）转换为Timedelta类型。如果输入是Series，则返回Series；如果输入是标量，则返回值也为标量，其他情况输出TimedeltaIndex。</span></span><br><span class="line"><span class="built_in">print</span>(pd.to_timedelta([<span class="string">&#x27;1 days 06:05:01.00003&#x27;</span>, <span class="string">&#x27;15.5us&#x27;</span>, <span class="string">&#x27;nan&#x27;</span>]))</span><br><span class="line"><span class="built_in">print</span>(pd.to_timedelta(np.arange(<span class="number">5</span>), unit=<span class="string">&#x27;s&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="number">5</span> days 08:06:<span class="number">59</span></span><br><span class="line"><span class="number">0</span> days <span class="number">19</span>:<span class="number">00</span>:<span class="number">00</span></span><br><span class="line"><span class="number">2</span> days 06:<span class="number">00</span>:<span class="number">00</span></span><br><span class="line">********************</span><br><span class="line">TimedeltaIndex([<span class="string">&#x27;1 days 06:05:01.000030&#x27;</span>, <span class="string">&#x27;0 days 00:00:00.000015&#x27;</span>, NaT], dtype=<span class="string">&#x27;timedelta64[ns]&#x27;</span>, freq=<span class="literal">None</span>)</span><br><span class="line">TimedeltaIndex([<span class="string">&#x27;00:00:00&#x27;</span>, <span class="string">&#x27;00:00:01&#x27;</span>, <span class="string">&#x27;00:00:02&#x27;</span>, <span class="string">&#x27;00:00:03&#x27;</span>, <span class="string">&#x27;00:00:04&#x27;</span>], dtype=<span class="string">&#x27;timedelta64[ns]&#x27;</span>, freq=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure><p>通过对<code>datetime64[ns]</code>类型的时间序列或时间戳做算术运算，其运算结果依然是<code>datetime64[ns]</code>数据类型。接下来，我们创建一个带有<code>Timedelta</code>与<code>datetime</code>的<code>DataFrame</code>对象，并对其做一些算术运算。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">s = pd.Series(pd.date_range(<span class="string">&#x27;2020-1-1&#x27;</span>, periods=<span class="number">5</span>, freq=<span class="string">&#x27;D&#x27;</span>))</span><br><span class="line"><span class="comment"># 推导式用法</span></span><br><span class="line">td = pd.Series([ pd.Timedelta(days=i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>)])</span><br><span class="line">df = pd.DataFrame(<span class="built_in">dict</span>(A = s, B = td))</span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 加法运算</span></span><br><span class="line">df[<span class="string">&#x27;C&#x27;</span>]=df[<span class="string">&#x27;A&#x27;</span>]+df[<span class="string">&#x27;B&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 减法运算</span></span><br><span class="line">df[<span class="string">&#x27;D&#x27;</span>]=df[<span class="string">&#x27;C&#x27;</span>]-df[<span class="string">&#x27;B&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">           A      B</span><br><span class="line"><span class="number">0</span> <span class="number">2020</span>-01-01 <span class="number">0</span> days</span><br><span class="line"><span class="number">1</span> <span class="number">2020</span>-01-02 <span class="number">1</span> days</span><br><span class="line"><span class="number">2</span> <span class="number">2020</span>-01-03 <span class="number">2</span> days</span><br><span class="line"><span class="number">3</span> <span class="number">2020</span>-01-04 <span class="number">3</span> days</span><br><span class="line"><span class="number">4</span> <span class="number">2020</span>-01-05 <span class="number">4</span> days</span><br><span class="line">********************</span><br><span class="line">           A      B          C</span><br><span class="line"><span class="number">0</span> <span class="number">2020</span>-01-01 <span class="number">0</span> days <span class="number">2020</span>-01-01</span><br><span class="line"><span class="number">1</span> <span class="number">2020</span>-01-02 <span class="number">1</span> days <span class="number">2020</span>-01-03</span><br><span class="line"><span class="number">2</span> <span class="number">2020</span>-01-03 <span class="number">2</span> days <span class="number">2020</span>-01-05</span><br><span class="line"><span class="number">3</span> <span class="number">2020</span>-01-04 <span class="number">3</span> days <span class="number">2020</span>-01-07</span><br><span class="line"><span class="number">4</span> <span class="number">2020</span>-01-05 <span class="number">4</span> days <span class="number">2020</span>-01-09</span><br><span class="line">********************</span><br><span class="line">           A      B          C          D</span><br><span class="line"><span class="number">0</span> <span class="number">2020</span>-01-01 <span class="number">0</span> days <span class="number">2020</span>-01-01 <span class="number">2020</span>-01-01</span><br><span class="line"><span class="number">1</span> <span class="number">2020</span>-01-02 <span class="number">1</span> days <span class="number">2020</span>-01-03 <span class="number">2020</span>-01-02</span><br><span class="line"><span class="number">2</span> <span class="number">2020</span>-01-03 <span class="number">2</span> days <span class="number">2020</span>-01-05 <span class="number">2020</span>-01-03</span><br><span class="line"><span class="number">3</span> <span class="number">2020</span>-01-04 <span class="number">3</span> days <span class="number">2020</span>-01-07 <span class="number">2020</span>-01-04</span><br><span class="line"><span class="number">4</span> <span class="number">2020</span>-01-05 <span class="number">4</span> days <span class="number">2020</span>-01-09 <span class="number">2020</span>-01-05</span><br></pre></td></tr></table></figure><h3 id="👀数据样本处理"><a href="#👀数据样本处理" class="headerlink" title="👀数据样本处理"></a>👀数据样本处理</h3><h4 id="👁Pandas缺失值处理"><a href="#👁Pandas缺失值处理" class="headerlink" title="👁Pandas缺失值处理"></a>👁Pandas缺失值处理</h4><p>稀疏数据，指的是在数据库或者数据集中存在大量缺失数据或者空值，我们把这样的数据集称为稀疏数据集。稀疏数据不是无效数据，只不过是信息不全而已，只要通过适当的方法就可以“变废为宝”。</p><p><strong>检查缺失值</strong>：<code>Pandas</code>提供了<code>isnull()</code>和<code>notnull()</code>两个函数，它们同时适用于<code>Series</code>和<code>DataFrame</code>对象。</p><p><strong>缺失数据计算</strong>：计算缺失数据时，需要注意两点：首先数据求和时，将NA值视为0，其次，如果要计算的数据为NA，那么结果就是NA。</p><p><strong>清理并填充缺失值</strong>：<code>Pandas</code>提供了多种方法来清除缺失值。<code>fillna()</code>函数可以实现用非空数据“填充”<code>NaN</code>值；<code>ffill()</code>向前填充和<code>bfill()</code>向后填充，使用这两个函数也可以处理NA值。<code>replace()</code>将<code>DataFrame</code>中的通用值替换成特定值。</p><p><strong>删除缺失值</strong>：使用<code>dropna()</code>函数与参数<code>axis</code>可以实现删除缺失值。在默认情况下，按照<code>axis=0</code>来按行处理，这意味着如果某一行中存在<code>NaN</code>值将会删除整行数据。</p><h4 id="👁Pandas随机样本选择"><a href="#👁Pandas随机样本选择" class="headerlink" title="👁Pandas随机样本选择"></a>👁Pandas随机样本选择</h4><p>随机抽样，是统计学中常用的一种方法，它可以帮助我们从大量的数据中快速地构建出一组数据分析模型。在<code>Pandas</code>中，如果想要对数据集进行随机抽样，需要使用<code>sample()</code>函数。该函数返回与数据集类型相同的新对象，相当于<code>numpy.random.choice()</code>。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">DataFrame.sample(n=<span class="literal">None</span>,frac=<span class="literal">None</span>,replace=<span class="literal">False</span>,weights=<span class="literal">None</span>,random_state=<span class="literal">None</span>,axis=<span class="literal">None</span>)</span><br><span class="line">参数说明</span><br><span class="line">n表示要抽取的行数。</span><br><span class="line">frac表示抽取的比例，比如frac=<span class="number">0.5</span>，代表抽取总体数据的<span class="number">50</span>%。</span><br><span class="line">replace布尔值参数，表示是否以有放回抽样的方式进行选择，默认为<span class="literal">False</span>，取出数据后不再放回。</span><br><span class="line">weights可选参数，代表每个样本的权重值，参数值是字符串或者数组。</span><br><span class="line">random_state 可选参数，控制随机状态，默认为<span class="literal">None</span>，表示随机数据不会重复；若为<span class="number">1</span>表示会取得重复数据。</span><br><span class="line">axis表示在哪个方向上抽取数据(axis=<span class="number">1</span>表示列/axis=<span class="number">0</span>表示行)。</span><br></pre></td></tr></table></figure><h4 id="👁Pandas数据重采样"><a href="#👁Pandas数据重采样" class="headerlink" title="👁Pandas数据重采样"></a>👁Pandas数据重采样</h4><p>数据重采样是将时间序列从一个频率转换至另一个频率的过程，它主要有两种实现方式，分别是降采样和升采样，降采样指将高频率的数据转换为低频率，升采样则与其恰好相反，说明如下：</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>降采样</td><td>将高频率(间隔短)数据转换为低频率(间隔长)。</td></tr><tr><td>升采样</td><td>将低频率数据转换为高频率。</td></tr></tbody></table><p><code>Pandas</code>提供了<code>resample()</code>函数来实现数据的重采样。</p><p><code>asfreq()</code>方法不仅能够实现频率转换，还可以保留原频率对应的数值，同时它也可以单独使用。</p><p>插值处理，升采样的结果会产生缺失值，那么就需要对缺失值进行处理，一般有以下几种处理方式：</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>pad/ffill</code></td><td>用前一个非缺失值去填充缺失值。</td></tr><tr><td><code>backfill/bfill</code></td><td>用后一个非缺失值去填充缺失值。</td></tr><tr><td><code>interpolater(&#39;linear&#39;)</code></td><td>线性插值方法。</td></tr><tr><td><code>fillna(value)</code></td><td>指定一个值去替换缺失值。</td></tr></tbody></table><h4 id="👁Pandas分类对象"><a href="#👁Pandas分类对象" class="headerlink" title="👁Pandas分类对象"></a>👁Pandas分类对象</h4><p>通常情况下，数据集中会存在许多同一类别的信息，比如相同国家、相同行政编码、相同性别等，当这些相同类别的数据多次出现时，就会给数据处理增添许多麻烦，导致数据集变得臃肿，不能直观、清晰地展示数据。</p><p><code>Pandas</code>提供了分类对象（<code>Categorical Object</code>），该对象能够实现有序排列、自动去重的功能，但是它不能执行运算。通过<code>Category</code>的构造函数，您可以创建一个类别对象。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pandas.Categorical(values, categories, ordered)</span><br><span class="line">参数说明</span><br><span class="line">    values：以列表的形式传参，表示要分类的值。</span><br><span class="line">    ordered：布尔值，默认为<span class="literal">False</span>，若为Ture，表示对分类的数据进行排序。</span><br><span class="line">    dtype：返回一个category类型，表示分类对象。</span><br></pre></td></tr></table></figure><p><code>describe()</code>：对已经分类的数据使用<code>describe()</code>方法，得到和数据统计相关的摘要信息。</p><p><code>categories</code>：使用<code>obj.categories</code>命令可以获取对象的类别信息。</p><p><code>Series.cat.categories</code>：对类别实现重命名。</p><p><code>Series.cat.add_categories()</code>：追加新类别。</p><p><code>Series.cat.remove_categories()</code>：删除不需要的类别。</p><h3 id="👀其它函数"><a href="#👀其它函数" class="headerlink" title="👀其它函数"></a>👀其它函数</h3><h4 id="👁Pandas统计函数"><a href="#👁Pandas统计函数" class="headerlink" title="👁Pandas统计函数"></a>👁Pandas统计函数</h4><p><code>Pandas</code>的本质是统计学原理在计算机领域的一种应用实现，通过编程的方式达到分析、描述数据的目的。而统计函数则是统计学中用于计算和分析数据的一种工具。在数据分析的过程中，使用统计函数有助于我们理解和分析数据。常见的统计函数，比如百分比函数、协方差函数、相关系数等。</p><ul><li><code>pct_change()</code> ：<code>Series</code>和<code>DatFrames</code>都可以使用<code>pct_change()</code>函数。该函数将每个元素与其前一个元素进行比较，并计算前后数值的百分比变化。默认情况下，<code>pct_change()</code>对列进行操作，如果想要操作行，则需要传递参数<code>axis=1</code>参数。</li><li><code>cov()</code>：<code>Series</code>对象提供了一个<code>cov</code>方法用来计算Series对象之间的协方差。同时，该方法也会将缺失值(<code>NAN</code>)自动排除。当应用于<code>DataFrame</code>时，协方差（<code>cov</code>）将计算所有列之间的协方差。</li><li><code>corr()</code>：相关系数显示任意两个<code>Series</code>之间的线性关系。<code>Pandas</code>提供了计算相关性的三种方法，分别是<code>pearson(default)</code>、<code>spearman()</code>和<code>kendall()</code>。注意：如果<code>DataFrame</code>存在非数值（<code>NAN</code>），该方法会自动将其删除。</li><li><code>rank()</code> ：按照某种规则（升序或者降序）对序列中的元素值排名，该函数的返回值的也是一个序列，包含了原序列中每个元素值的名次。如果序列中包含两个相同的的元素值，那么会为其分配两者的平均排名。</li></ul><h4 id="👁Pandas窗口函数"><a href="#👁Pandas窗口函数" class="headerlink" title="👁Pandas窗口函数"></a>👁Pandas窗口函数</h4><p>为了能更好地处理数值型数据，<code>Pandas</code>提供了几种窗口函数：</p><ul><li>移动函数（<code>rolling</code>）</li><li>扩展函数（<code>expanding</code>）</li><li>指数加权函数（<code>ewm</code>）</li></ul><blockquote><p>窗口是一种形象化的叫法，这些函数在执行操作时，就如同窗口一样在数据区间上移动。</p></blockquote><p>如何在<code>DataFrame</code>和<code>Series</code>对象上应用窗口函数：</p><ul><li><p><code>rolling()</code> ：移动窗口函数，它可以与<code>mean</code>、<code>count</code>、<code>sum</code>、<code>median</code>、<code>std</code>等聚合函数一起使用。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">rolling(window=n, min_periods=<span class="literal">None</span>, center=<span class="literal">False</span>)</span><br><span class="line">参数说明</span><br><span class="line">    window默认值为<span class="number">1</span>，表示窗口的大小，也就是观测值的数量，</span><br><span class="line">    min_periods表示窗口的最小观察值，默认与window的参数值相等。</span><br><span class="line">    center是否把中间值做为窗口标准，默认值为<span class="literal">False</span>。</span><br></pre></td></tr></table></figure></li><li><p><code>expanding()</code> ：扩展窗口函数，扩展是指由序列的第一个元素开始，逐个向后计算元素的聚合值。</p></li><li><p><code>ewm()</code>：（全称 Exponentially Weighted Moving）表示指数加权移动。<code>ewn()</code>函数先会对序列元素做指数加权运算，其次计算加权后的均值。该函数通过指定<code>com</code>、<code>span</code>或者<code>halflife</code>参数来实现指数加权移动。</p></li></ul><p>在数据分析的过程中，使用窗口函数能够提升数据的准确性，并且使数据曲线的变化趋势更加平滑，从而让数据分析变得更加准确、可靠。</p><h4 id="👁Pandas聚合函数"><a href="#👁Pandas聚合函数" class="headerlink" title="👁Pandas聚合函数"></a>👁Pandas聚合函数</h4><p>窗口函数可以与聚合函数一起使用，聚合函数指的是对一组数据求总和、最大值、最小值以及平均值的操作，本节重点讲解聚合函数的应用。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">data = &#123;<span class="string">&#x27;col1&#x27;</span>:[<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>],<span class="string">&#x27;col2&#x27;</span>:[<span class="number">0</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">0</span>],<span class="string">&#x27;col3&#x27;</span>:[<span class="number">4</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">4</span>],<span class="string">&#x27;col4&#x27;</span>:[<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>]&#125;</span><br><span class="line">df = pd.DataFrame(data)</span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 窗口大小为3，min_periods最小观测值为1</span></span><br><span class="line">r1 = df.rolling(window=<span class="number">3</span>,min_periods=<span class="number">1</span>)</span><br><span class="line"><span class="comment"># min_periods默认与window的参数值相等</span></span><br><span class="line">r2 = df.rolling(window=<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(r1.<span class="built_in">sum</span>())</span><br><span class="line"><span class="built_in">print</span>(r2.<span class="built_in">sum</span>())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 把一个聚合函数传递给DataFrame</span></span><br><span class="line"><span class="comment"># 对整体聚合,使用aggregate()聚合操作</span></span><br><span class="line"><span class="built_in">print</span>(r1.aggregate(np.<span class="built_in">sum</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 对任意某一列聚合</span></span><br><span class="line"><span class="built_in">print</span>(r1[<span class="string">&#x27;col1&#x27;</span>].aggregate(np.<span class="built_in">sum</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 对多列数据聚合</span></span><br><span class="line"><span class="built_in">print</span>(r1[<span class="string">&#x27;col1&#x27;</span>,<span class="string">&#x27;col2&#x27;</span>].aggregate(np.<span class="built_in">sum</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 对单列应用多个函数</span></span><br><span class="line"><span class="built_in">print</span>(r1[<span class="string">&#x27;col1&#x27;</span>].aggregate([np.<span class="built_in">sum</span>,np.mean]))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 对不同列应用多个函数</span></span><br><span class="line"><span class="built_in">print</span>(r1[<span class="string">&#x27;col1&#x27;</span>,<span class="string">&#x27;col2&#x27;</span>].aggregate([np.<span class="built_in">sum</span>,np.mean]))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 对不同列应用不同函数</span></span><br><span class="line"><span class="built_in">print</span>(r1.aggregate(&#123;<span class="string">&#x27;col1&#x27;</span>:np.<span class="built_in">sum</span>,<span class="string">&#x27;col2&#x27;</span>:np.mean&#125;))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"> col1  col2  col3  col4</span><br><span class="line"><span class="number">0</span>     <span class="number">1</span>     <span class="number">0</span>     <span class="number">4</span>     <span class="number">1</span></span><br><span class="line"><span class="number">1</span>     <span class="number">0</span>     <span class="number">2</span>     <span class="number">0</span>     <span class="number">0</span></span><br><span class="line"><span class="number">2</span>     <span class="number">1</span>     <span class="number">5</span>     <span class="number">4</span>     <span class="number">1</span></span><br><span class="line"><span class="number">3</span>     <span class="number">1</span>     <span class="number">0</span>     <span class="number">4</span>     <span class="number">1</span></span><br><span class="line">********************</span><br><span class="line">   col1  col2  col3  col4</span><br><span class="line"><span class="number">0</span>   <span class="number">1.0</span>   <span class="number">0.0</span>   <span class="number">4.0</span>   <span class="number">1.0</span></span><br><span class="line"><span class="number">1</span>   <span class="number">1.0</span>   <span class="number">2.0</span>   <span class="number">4.0</span>   <span class="number">1.0</span></span><br><span class="line"><span class="number">2</span>   <span class="number">2.0</span>   <span class="number">7.0</span>   <span class="number">8.0</span>   <span class="number">2.0</span></span><br><span class="line"><span class="number">3</span>   <span class="number">2.0</span>   <span class="number">7.0</span>   <span class="number">8.0</span>   <span class="number">2.0</span></span><br><span class="line">   col1  col2  col3  col4</span><br><span class="line"><span class="number">0</span>   NaN   NaN   NaN   NaN</span><br><span class="line"><span class="number">1</span>   NaN   NaN   NaN   NaN</span><br><span class="line"><span class="number">2</span>   <span class="number">2.0</span>   <span class="number">7.0</span>   <span class="number">8.0</span>   <span class="number">2.0</span></span><br><span class="line"><span class="number">3</span>   <span class="number">2.0</span>   <span class="number">7.0</span>   <span class="number">8.0</span>   <span class="number">2.0</span></span><br><span class="line">********************</span><br><span class="line">   col1  col2  col3  col4</span><br><span class="line"><span class="number">0</span>   <span class="number">1.0</span>   <span class="number">0.0</span>   <span class="number">4.0</span>   <span class="number">1.0</span></span><br><span class="line"><span class="number">1</span>   <span class="number">1.0</span>   <span class="number">2.0</span>   <span class="number">4.0</span>   <span class="number">1.0</span></span><br><span class="line"><span class="number">2</span>   <span class="number">2.0</span>   <span class="number">7.0</span>   <span class="number">8.0</span>   <span class="number">2.0</span></span><br><span class="line"><span class="number">3</span>   <span class="number">2.0</span>   <span class="number">7.0</span>   <span class="number">8.0</span>   <span class="number">2.0</span></span><br><span class="line">********************</span><br><span class="line"><span class="number">0</span>    <span class="number">1.0</span></span><br><span class="line"><span class="number">1</span>    <span class="number">1.0</span></span><br><span class="line"><span class="number">2</span>    <span class="number">2.0</span></span><br><span class="line"><span class="number">3</span>    <span class="number">2.0</span></span><br><span class="line">Name: col1, dtype: float64</span><br><span class="line">********************</span><br><span class="line">   col1  col2</span><br><span class="line"><span class="number">0</span>   <span class="number">1.0</span>   <span class="number">0.0</span></span><br><span class="line"><span class="number">1</span>   <span class="number">1.0</span>   <span class="number">2.0</span></span><br><span class="line"><span class="number">2</span>   <span class="number">2.0</span>   <span class="number">7.0</span></span><br><span class="line"><span class="number">3</span>   <span class="number">2.0</span>   <span class="number">7.0</span></span><br><span class="line">********************</span><br><span class="line">   <span class="built_in">sum</span>      mean</span><br><span class="line"><span class="number">0</span>  <span class="number">1.0</span>  <span class="number">1.000000</span></span><br><span class="line"><span class="number">1</span>  <span class="number">1.0</span>  <span class="number">0.500000</span></span><br><span class="line"><span class="number">2</span>  <span class="number">2.0</span>  <span class="number">0.666667</span></span><br><span class="line"><span class="number">3</span>  <span class="number">2.0</span>  <span class="number">0.666667</span></span><br><span class="line">********************</span><br><span class="line">  col1           col2          </span><br><span class="line">   <span class="built_in">sum</span>      mean  <span class="built_in">sum</span>      mean</span><br><span class="line"><span class="number">0</span>  <span class="number">1.0</span>  <span class="number">1.000000</span>  <span class="number">0.0</span>  <span class="number">0.000000</span></span><br><span class="line"><span class="number">1</span>  <span class="number">1.0</span>  <span class="number">0.500000</span>  <span class="number">2.0</span>  <span class="number">1.000000</span></span><br><span class="line"><span class="number">2</span>  <span class="number">2.0</span>  <span class="number">0.666667</span>  <span class="number">7.0</span>  <span class="number">2.333333</span></span><br><span class="line"><span class="number">3</span>  <span class="number">2.0</span>  <span class="number">0.666667</span>  <span class="number">7.0</span>  <span class="number">2.333333</span></span><br><span class="line">********************</span><br><span class="line">   col1      col2</span><br><span class="line"><span class="number">0</span>   <span class="number">1.0</span>  <span class="number">0.000000</span></span><br><span class="line"><span class="number">1</span>   <span class="number">1.0</span>  <span class="number">1.000000</span></span><br><span class="line"><span class="number">2</span>   <span class="number">2.0</span>  <span class="number">2.333333</span></span><br><span class="line"><span class="number">3</span>   <span class="number">2.0</span>  <span class="number">2.333333</span></span><br></pre></td></tr></table></figure><h4 id="👁groupby分组操作"><a href="#👁groupby分组操作" class="headerlink" title="👁groupby分组操作"></a>👁groupby分组操作</h4><p>在数据分析中，经常会遇到这样的情况：根据某一列（或多列）标签把数据划分为不同的组别，然后再对其进行数据分析。比如，某网站对注册用户的性别或者年龄等进行分组，从而研究出网站用户的画像（特点）。在<code>Pandas</code> 中，要完成数据的分组操作，需要使用<code>groupby()</code>函数，它和<code>SQL</code>的<code>GROUP BY</code>操作非常相似。 在划分出来的组（<code>group</code>）上应用一些统计函数，从而达到数据分析的目的，比如对分组数据进行聚合、转换，或者过滤。这个过程主要包含以下三步：</p><ul><li>拆分（<code>Spliting</code>）：表示对数据进行分组；</li><li>应用（<code>Applying</code>）：对分组数据应用聚合函数，进行相应计算；</li><li>合并（<code>Combining</code>）：最后汇总计算结果。</li></ul><p>使用<code>groupby()</code>可以沿着任意轴分组。您可以把分组时指定的键（<code>key</code>）作为每组的组名，方法如下所示：</p><ul><li><code>df.groupby(&quot;key&quot;)</code></li><li><code>df.groupby(&quot;key&quot;,axis=1)</code></li><li><code>df.groupby([&quot;key1&quot;,&quot;key2&quot;])</code></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">data = &#123;<span class="string">&#x27;name&#x27;</span>: [<span class="string">&#x27;John&#x27;</span>, <span class="string">&#x27;Helen&#x27;</span>, <span class="string">&#x27;John&#x27;</span>, <span class="string">&#x27;Ella&#x27;</span>],</span><br><span class="line">   <span class="string">&#x27;score&#x27;</span>: [<span class="number">82</span>, <span class="number">98</span>, <span class="number">91</span>, <span class="number">87</span>],</span><br><span class="line">   <span class="string">&#x27;option_course&#x27;</span>: [<span class="string">&#x27;C#&#x27;</span>,<span class="string">&#x27;Python&#x27;</span>,<span class="string">&#x27;Java&#x27;</span>,<span class="string">&#x27;C&#x27;</span>]&#125;</span><br><span class="line">df = pd.DataFrame(data)</span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 生成分组groupby对象</span></span><br><span class="line"><span class="built_in">print</span>(df.groupby(<span class="string">&#x27;score&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 查看分组,通过调用groups属性查看分组结果</span></span><br><span class="line"><span class="built_in">print</span>(df.groupby(<span class="string">&#x27;score&#x27;</span>).groups)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 多个列标签分组</span></span><br><span class="line"><span class="built_in">print</span>(df.groupby([<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;score&#x27;</span>]).groups)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 通过 get_group()方法可以选择组内的具体数据项</span></span><br><span class="line"><span class="built_in">print</span>(df.groupby(<span class="string">&#x27;score&#x27;</span>).get_group(<span class="number">91</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 遍历分组数据</span></span><br><span class="line">grouped=df.groupby(<span class="string">&#x27;score&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> label, option_course <span class="keyword">in</span> grouped:</span><br><span class="line"><span class="comment"># 其中key代表分组后字典的键，也就是score</span></span><br><span class="line">    <span class="built_in">print</span>(label)</span><br><span class="line"><span class="comment"># 字典对应的值选修的科目</span></span><br><span class="line">    <span class="built_in">print</span>(option_course)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 通过agg()函数可以对分组对象应用多个聚合函数</span></span><br><span class="line">grouped_name = df.groupby(<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line"><span class="comment"># 应用一个聚合函数求均值</span></span><br><span class="line"><span class="built_in">print</span>(grouped_name[<span class="string">&#x27;score&#x27;</span>].agg(np.mean))</span><br><span class="line"><span class="comment"># 应用多个聚合函数求均值</span></span><br><span class="line"><span class="built_in">print</span>(grouped_name[<span class="string">&#x27;score&#x27;</span>].agg([np.size,np.mean,np.std]))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 组的数据过滤操作,筛选出名字出现超过两次的人名</span></span><br><span class="line"><span class="built_in">print</span>(grouped_name.<span class="built_in">filter</span>(<span class="keyword">lambda</span> x: <span class="built_in">len</span>(x) &gt;= <span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">  name  score option_course</span><br><span class="line"><span class="number">0</span>   John     <span class="number">82</span>            C<span class="comment">#</span></span><br><span class="line"><span class="number">1</span>  Helen     <span class="number">98</span>        Python</span><br><span class="line"><span class="number">2</span>   John     <span class="number">91</span>          Java</span><br><span class="line"><span class="number">3</span>   Ella     <span class="number">87</span>             C</span><br><span class="line">********************</span><br><span class="line">&lt;pandas.core.groupby.generic.DataFrameGroupBy <span class="built_in">object</span> at <span class="number">0x000001CB3F4CD948</span>&gt;</span><br><span class="line">********************</span><br><span class="line">&#123;<span class="number">82</span>: Int64Index([<span class="number">0</span>], dtype=<span class="string">&#x27;int64&#x27;</span>), <span class="number">87</span>: Int64Index([<span class="number">3</span>], dtype=<span class="string">&#x27;int64&#x27;</span>), <span class="number">91</span>: Int64Index([<span class="number">2</span>], dtype=<span class="string">&#x27;int64&#x27;</span>), <span class="number">98</span>: Int64Index([<span class="number">1</span>], dtype=<span class="string">&#x27;int64&#x27;</span>)&#125;</span><br><span class="line">********************</span><br><span class="line">&#123;(<span class="string">&#x27;Ella&#x27;</span>, <span class="number">87</span>): Int64Index([<span class="number">3</span>], dtype=<span class="string">&#x27;int64&#x27;</span>), (<span class="string">&#x27;Helen&#x27;</span>, <span class="number">98</span>): Int64Index([<span class="number">1</span>], dtype=<span class="string">&#x27;int64&#x27;</span>), (<span class="string">&#x27;John&#x27;</span>, <span class="number">82</span>): Int64Index([<span class="number">0</span>], dtype=<span class="string">&#x27;int64&#x27;</span>), (<span class="string">&#x27;John&#x27;</span>, <span class="number">91</span>): Int64Index([<span class="number">2</span>], dtype=<span class="string">&#x27;int64&#x27;</span>)&#125;</span><br><span class="line">********************</span><br><span class="line">   name  score option_course</span><br><span class="line"><span class="number">2</span>  John     <span class="number">91</span>          Java</span><br><span class="line">********************</span><br><span class="line"><span class="number">82</span></span><br><span class="line">   name  score option_course</span><br><span class="line"><span class="number">0</span>  John     <span class="number">82</span>            C<span class="comment">#</span></span><br><span class="line"><span class="number">87</span></span><br><span class="line">   name  score option_course</span><br><span class="line"><span class="number">3</span>  Ella     <span class="number">87</span>             C</span><br><span class="line"><span class="number">91</span></span><br><span class="line">   name  score option_course</span><br><span class="line"><span class="number">2</span>  John     <span class="number">91</span>          Java</span><br><span class="line"><span class="number">98</span></span><br><span class="line">    name  score option_course</span><br><span class="line"><span class="number">1</span>  Helen     <span class="number">98</span>        Python</span><br><span class="line">********************</span><br><span class="line">name</span><br><span class="line">Ella     <span class="number">87.0</span></span><br><span class="line">Helen    <span class="number">98.0</span></span><br><span class="line">John     <span class="number">86.5</span></span><br><span class="line">Name: score, dtype: float64</span><br><span class="line">       size  mean       std</span><br><span class="line">name                       </span><br><span class="line">Ella      <span class="number">1</span>  <span class="number">87.0</span>       NaN</span><br><span class="line">Helen     <span class="number">1</span>  <span class="number">98.0</span>       NaN</span><br><span class="line">John      <span class="number">2</span>  <span class="number">86.5</span>  <span class="number">6.363961</span></span><br><span class="line">********************</span><br><span class="line">   name  score option_course</span><br><span class="line"><span class="number">0</span>  John     <span class="number">82</span>            C<span class="comment">#</span></span><br><span class="line"><span class="number">2</span>  John     <span class="number">91</span>          Java</span><br></pre></td></tr></table></figure><p>组的转换操作：通过<code>transform()</code>函数可以实现组的转换，在组的行或列上可以执行转换操作，最终会返回一个与组大小相同的索引对象。</p><p>组的数据过滤操作：通过<code>filter()</code>函数可以实现数据的筛选，该函数根据定义的条件过滤数据并返回一个新的数据集。</p><h4 id="👁merge合并操作"><a href="#👁merge合并操作" class="headerlink" title="👁merge合并操作"></a>👁merge合并操作</h4><p><code>Pandas</code>提供的<code>merge()</code>函数能够进行高效的合并操作，这与<code>SQL</code>关系型数据库的<code>MERGE</code>用法非常相似。从字面意思上不难理解，<code>merge</code>翻译为“合并”，指的是将两个<code>DataFrame</code>数据表按照指定的规则进行连接，最后拼接成一个新的<code>DataFrame</code>数据表。<code>merge()</code>函数的法格式如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pd.merge(left, right, how=<span class="string">&#x27;inner&#x27;</span>, on=<span class="literal">None</span>, left_on=<span class="literal">None</span>, right_on=<span class="literal">None</span>, left_index=<span class="literal">False</span>, right_index=<span class="literal">False</span>, sort=<span class="literal">True</span>,suffixes=(<span class="string">&#x27;_x&#x27;</span>, <span class="string">&#x27;_y&#x27;</span>), copy=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">参数说明</span><br><span class="line">left/right: 两个不同的DataFrame对象。</span><br><span class="line">on: 指定用于连接的键（即列标签的名字），该键必须同时存在于左右两个DataFrame中，如果没有指定，并且其他参数也未指定， 那么将会以两个DataFrame的列名交集做为连接键。</span><br><span class="line">left_on: 指定左侧DataFrame中作连接键的列名。该参数在左、右列标签名不相同，但表达的含义相同时非常有用。</span><br><span class="line">right_on: 指定左侧DataFrame中作连接键的列名。</span><br><span class="line">left_index: 布尔参数，默认为<span class="literal">False</span>。如果为<span class="literal">True</span> 则使用左侧DataFrame的行索引作为连接键，若DataFrame具有多层索引(MultiIndex)，则层的数量必须与连接键的数量相等。</span><br><span class="line">right_index: 布尔参数，默认为<span class="literal">False</span>。如果为<span class="literal">True</span> 则使用左侧DataFrame的行索引作为连接键。</span><br><span class="line">how: 要执行的合并类型，从&#123;<span class="string">&#x27;left&#x27;</span>,<span class="string">&#x27;right&#x27;</span>,<span class="string">&#x27;outer&#x27;</span>,<span class="string">&#x27;inner&#x27;</span>&#125; 中取值，默认为“inner”内连接。</span><br><span class="line">sort: 布尔值参数，默认为<span class="literal">True</span>，它会将合并后的数据进行排序；若设置为<span class="literal">False</span>，则按照how给定的参数值进行排序。</span><br><span class="line">suffixes: 字符串组成的元组。当左右DataFrame存在相同列名时，通过该参数可以在相同的列名后附加后缀名，默认为(<span class="string">&#x27;_x&#x27;</span>,<span class="string">&#x27;_y&#x27;</span>)。</span><br><span class="line">copy: 默认为<span class="literal">True</span>，表示对数据进行复制。</span><br></pre></td></tr></table></figure><blockquote><p>注意：<code>Pandas</code>库的<code>merge()</code>支持各种内外连接，与其相似的还有<code>join()</code>函数（默认为左连接）。</p></blockquote><h4 id="👁concat连接操作"><a href="#👁concat连接操作" class="headerlink" title="👁concat连接操作"></a>👁concat连接操作</h4><p><code>Pandas</code>通过<code>concat()</code>函数能够轻松地将<code>Series</code>与<code>DataFrame</code>对象组合在一起，函数的语法格式如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pd.concat(objs, axis=<span class="number">0</span>, join=<span class="string">&#x27;outer&#x27;</span>, join_axes=<span class="literal">None</span>, ignore_index=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">参数说明</span><br><span class="line">objs: 一个序列或者是Series、DataFrame对象。</span><br><span class="line">axis: 表示在哪个轴方向上（行或者列）进行连接操作，默认axis=<span class="number">0</span>表示行方向。</span><br><span class="line">join: 指定连接方式，取值为&#123;<span class="string">&quot;inner&quot;</span>,<span class="string">&quot;outer&quot;</span>&#125;，默认为outer表示取并集，inner代表取交集。</span><br><span class="line">ignore_index: 布尔值参数，默认为<span class="literal">False</span>，如果为<span class="literal">True</span>，表示不在连接的轴上使用索引。</span><br><span class="line">join_axes: 表示索引对象的列表。</span><br></pre></td></tr></table></figure><p><code>append()</code>: 如果要连接<code>Series</code>和<code>DataFrame</code>对象，有一个最方便、快捷的方法，就是<code>append()</code>方法。该方法沿着<code>axis=0</code>（行方向）进行操作；<code>append()</code>函数也可接收多个对象。</p><h3 id="👀Pandas绘图"><a href="#👀Pandas绘图" class="headerlink" title="👀Pandas绘图"></a>👀Pandas绘图</h3><p><code>Pandas</code>对<code>Matplotlib</code>绘图软件包的基础上单独封装了一个<code>plot()</code>接口，通过调用该接口可以实现常用的绘图操作。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment"># 创建包含时间序列的数据</span></span><br><span class="line">df = pd.DataFrame(np.random.randn(<span class="number">8</span>,<span class="number">4</span>),index=pd.date_range(<span class="string">&#x27;2/1/2020&#x27;</span>,periods=<span class="number">8</span>), columns=<span class="built_in">list</span>(<span class="string">&#x27;ABCD&#x27;</span>))</span><br><span class="line">df.plot()</span><br><span class="line"><span class="comment"># 如果行索引中包含日期，Pandas会自动调用gct().autofmt_xdate()来格式化x轴。</span></span><br></pre></td></tr></table></figure><p>除了使用默认的线条绘图外，您还可以使用其他绘图方式，如下所示：</p><ul><li>柱状图：<code>bar()</code> 或 <code>barh()</code></li><li>直方图：<code>hist()</code></li><li>箱状箱：<code>box()</code></li><li>区域图：<code>area()</code></li><li>散点图：<code>scatter()</code></li></ul><p>通过关键字参数<code>kind</code>可以把上述方法传递给<code>plot()</code>。</p><p>（1）柱状图</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">df = pd.DataFrame(np.random.rand(<span class="number">10</span>,<span class="number">4</span>),columns=[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>])</span><br><span class="line"><span class="comment"># 或使用df.plot(kind=&quot;bar&quot;)</span></span><br><span class="line">df.plot.bar()</span><br><span class="line"><span class="comment"># 通过设置参数stacked=True可以生成柱状堆叠图</span></span><br><span class="line"><span class="comment"># 或者使用df.plot.bar(stacked=&quot;True&quot;)</span></span><br><span class="line">df.plot(kind=<span class="string">&quot;bar&quot;</span>,stacked=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># 如果要绘制水平柱状图</span></span><br><span class="line">df.plot.barh(stacked=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p>（2）直方图</p><p><code>plot.hist()</code>可以实现绘制直方图，并且它还可以指定<code>bins</code>（构成直方图的箱数）。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">df = pd.DataFrame(&#123;<span class="string">&#x27;A&#x27;</span>:np.random.randn(<span class="number">100</span>)+<span class="number">2</span>,<span class="string">&#x27;B&#x27;</span>:np.random.randn(<span class="number">100</span>),<span class="string">&#x27;C&#x27;</span>:np.random.randn(<span class="number">100</span>)-<span class="number">2</span>,<span class="string">&#x27;D&#x27;</span>:np.random.randn(<span class="number">100</span>)+<span class="number">3</span>&#125;,columns=[<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;D&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line"><span class="comment"># 指定箱数为15</span></span><br><span class="line">df.plot.hist(bins=<span class="number">15</span>)</span><br><span class="line"><span class="comment"># 给每一列数据都绘制一个直方图</span></span><br><span class="line">df.diff().hist(color=<span class="string">&quot;r&quot;</span>,alpha=<span class="number">0.5</span>,bins=<span class="number">15</span>)</span><br></pre></td></tr></table></figure><p>（3）箱线图</p><p>通过调用<code>Series.box.plot()</code> 、<code>DataFrame.box.plot()</code>或者<code>DataFrame.boxplot()</code>方法来绘制箱型图，它将每一列数据的分布情况，以可视化的图像展现出来。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">df = pd.DataFrame(np.random.rand(<span class="number">10</span>, <span class="number">4</span>), columns=[<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>])</span><br><span class="line">df.plot.box()</span><br></pre></td></tr></table></figure><p>（4）区域图</p><p>使用<code>Series.plot.area()</code>或<code>DataFrame.plot.area()</code>方法来绘制区域图。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">df = pd.DataFrame(np.random.rand(<span class="number">5</span>, <span class="number">4</span>), columns=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>])</span><br><span class="line">df.plot.area()</span><br></pre></td></tr></table></figure><p>（5）散点图</p><p>使用<code>DataFrame.plot.scatter()</code>方法来绘制散点图。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">df = pd.DataFrame(np.random.rand(<span class="number">30</span>, <span class="number">4</span>), columns=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>])</span><br><span class="line">df.plot.scatter(x=<span class="string">&#x27;a&#x27;</span>,y=<span class="string">&#x27;b&#x27;</span>)</span><br></pre></td></tr></table></figure><p>（6）饼状图</p><p>通过<code>DataFrame.plot.pie()</code>方法来绘制。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">df = pd.DataFrame(<span class="number">3</span> * np.random.rand(<span class="number">4</span>), index=[<span class="string">&#x27;go&#x27;</span>, <span class="string">&#x27;java&#x27;</span>, <span class="string">&#x27;c++&#x27;</span>, <span class="string">&#x27;c&#x27;</span>], columns=[<span class="string">&#x27;L&#x27;</span>])</span><br><span class="line">df.plot.pie(subplots=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><h2 id="⛄Pandas和NumPy的比较"><a href="#⛄Pandas和NumPy的比较" class="headerlink" title="⛄Pandas和NumPy的比较"></a>⛄Pandas和NumPy的比较</h2><p><code>Pandas</code>和<code>NumPy</code>被认为是科学计算与机器学习中必不可少的库，因为它们具有直观的语法和高性能的矩阵计算能力。</p><table><thead><tr><th>比较项</th><th>Pandas</th><th>NumPy</th></tr></thead><tbody><tr><td>适应性</td><td><code>Pandas</code>主要用来处理类表格数据。</td><td><code>NumPy</code>主要用来处理数值数据。</td></tr><tr><td>工具</td><td><code>Pandas</code>提供了<code>Series</code>和<code>DataFrame</code>数据结构。</td><td><code>NumPy</code>构建了<code>ndarray array</code>来容纳数据。</td></tr><tr><td>性能</td><td><code>Pandas</code>对于处理50万行以上的数据更具优势。</td><td><code>NumPy</code>则对于50万以下或者更少的数据，性能更佳。</td></tr><tr><td>内存利用率</td><td>与<code>NumPy</code>相比，<code>Pandas</code>会消耗大量的内存。</td><td><code>NumPy</code>会消耗较少的内存。</td></tr><tr><td>对象</td><td><code>Pandas</code>提供了<code>DataFrame 2D</code>数据表对象。</td><td><code>NumPy</code>则提供了一个多维数组<code>ndarray</code>对象</td></tr></tbody></table><p>在某些情况下，需要执行一些<code>NumPy</code>数值计算的高级函数，这个时候您可以使用<code>to_numpy()</code>函数，将<code>DataFrame</code>对象转换为<code>NumPy ndarray</code>数组，并将其返回。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">DataFrame.to_numpy(dtype=<span class="literal">None</span>, copy=<span class="literal">False</span>)   </span><br><span class="line">参数说明如下：</span><br><span class="line">    dtype：可选参数，表示数据类型；</span><br><span class="line">    copy：布尔值参数，默认值为 Fales，表示返回值不是其他数组的视图。</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd </span><br><span class="line"><span class="comment">#创建DataFrame对象</span></span><br><span class="line">info = pd.DataFrame([[<span class="number">17</span>,<span class="number">62</span>,<span class="number">35</span>],[<span class="number">25</span>,<span class="number">36</span>,<span class="number">54</span>],[<span class="number">42</span>,<span class="number">20</span>,<span class="number">15</span>],[<span class="number">48</span>,<span class="number">62</span>,<span class="number">76</span>]], columns=[<span class="string">&#x27;x&#x27;</span>,<span class="string">&#x27;y&#x27;</span>,<span class="string">&#x27;z&#x27;</span>]) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;DataFrame\n----------\n&#x27;</span>, info) </span><br><span class="line"><span class="comment">#转换DataFrame为数组array</span></span><br><span class="line">arr = info.to_numpy() </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\nNumpy Array\n----------\n&#x27;</span>, arr)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">DataFrame</span><br><span class="line">----------</span><br><span class="line">     x   y   z</span><br><span class="line"><span class="number">0</span>  <span class="number">17</span>  <span class="number">62</span>  <span class="number">35</span></span><br><span class="line"><span class="number">1</span>  <span class="number">25</span>  <span class="number">36</span>  <span class="number">54</span></span><br><span class="line"><span class="number">2</span>  <span class="number">42</span>  <span class="number">20</span>  <span class="number">15</span></span><br><span class="line"><span class="number">3</span>  <span class="number">48</span>  <span class="number">62</span>  <span class="number">76</span></span><br><span class="line"></span><br><span class="line">Numpy Array</span><br><span class="line">----------</span><br><span class="line"> [[<span class="number">17</span> <span class="number">62</span> <span class="number">35</span>]</span><br><span class="line"> [<span class="number">25</span> <span class="number">36</span> <span class="number">54</span>]</span><br><span class="line"> [<span class="number">42</span> <span class="number">20</span> <span class="number">15</span>]</span><br><span class="line"> [<span class="number">48</span> <span class="number">62</span> <span class="number">76</span>]]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 科学计算 </tag>
            
            <tag> 数据分析 </tag>
            
            <tag> Pandas </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python之NumPy详解</title>
      <link href="/2023/02/13/Python-Numpy/"/>
      <url>/2023/02/13/Python-Numpy/</url>
      
        <content type="html"><![CDATA[<p><code>NumPy</code>(Numerical Python) 是<code>Python</code>语言的一个数值计算扩展程序库，支持大量的维度数组与矩阵运算，此外也针对数组运算提供大量的数学函数库。</p><p><code>NumPy</code>的前身<code>Numeric</code>最早是由Jim Hugunin与其它协作者共同开发，2005年，Travis Oliphant在<code>Numeric</code>中结合了另一个同性质的程序库<code>Numarray</code>的特色，并加入了其它扩展而开发了<code>NumPy</code>。<code>NumPy</code>为开放源代码并且由许多协作者共同维护开发。</p><p><code>NumPy</code>是一个运行速度非常快的数学库，主要用于数组计算，包含：</p><ul><li>一个强大的N维数组对象<code>ndarray</code>，对数组进行函数运算；</li><li>数值积分；</li><li>广播功能函数；</li><li>整合<code>C/C++/Fortran</code>代码的工具；</li><li>线性代数、傅里叶变换、随机数生成等功能。</li></ul><p><code>NumPy</code>通常与<code>SciPy</code>（Scientific Python）和<code>Matplotlib</code>（绘图库）一起使用， 这种组合广泛用于替代<code>MatLab</code>，是一个强大的科学计算环境，有助于我们通过<code>Python</code>学习数据科学或者机器学习。</p><p><code>SciPy</code>是一个开源的<code>Python</code>算法库和数学工具包。<code>SciPy</code>包含的模块有<strong>最优化</strong>、<strong>线性代数</strong>、<strong>积分</strong>、<strong>插值</strong>、<strong>特殊函数</strong>、<strong>快速傅里叶变换</strong>、<strong>信号处理和图像处理</strong>、<strong>常微分方程求解</strong>和其他科学与工程中常用的计算。</p><p><code>Matplotlib</code>是<code>Python</code>编程语言及其数值数学扩展包<code>NumPy</code>的可视化操作界面。它为利用通用的图形用户界面工具包，如<code>Tkinter</code>, <code>wxPython</code>, <code>Qt</code>或<code>GTK+</code>向应用程序嵌入式绘图提供了应用程序接（<code>API</code>）。</p><p>标准的<code>Python</code>中用<code>list</code>（列表）保存值，可以当做数组使用，但因为列表中的元素可以是任何对象，所以浪费了<code>CPU</code>运算时间和内存。NumPy诞生为了弥补这些缺陷，它提供了两种基本的对象。</p><ul><li><code>ndarray</code>：全称（n-dimensional array object）是储存<strong>单一数据类型</strong>的多维数组；</li><li><code>ufunc</code>：全称（universal function object）它是一种能够对数组进行处理的函数。</li></ul><p><code>NumPy</code>官网（<a href="https://numpy.org/%EF%BC%89">https://numpy.org/）</a></p><p><code>SciPy</code>官网（<a href="https://scipy.org/%EF%BC%89">https://scipy.org/）</a></p><p><code>Matplotlib</code>官网（<a href="https://matplotlib.org/%EF%BC%89">https://matplotlib.org/）</a></p><h2 id="⛄ndarray对象"><a href="#⛄ndarray对象" class="headerlink" title="⛄ndarray对象"></a>⛄ndarray对象</h2><p><code>NumPy</code>最重要的一个特点是其<code>N</code>维数组对象<code>ndarray</code>，它是一系列同类型数据的集合，以<code>0</code>下标为开始进行集合中元素的索引。<code>NumPy</code>里面所有的函数都是围绕<code>ndarray</code>展开的。</p><p><code>ndarray</code>对象是用于存放同类型元素的多维数组。</p><p><code>ndarray</code>中的每个元素在内存中都有相同存储大小的区域。</p><p><code>ndarray</code>内部由以下内容组成：</p><ul><li>一个指向数据（内存或内存映射文件中的一块数据）的指针；</li><li>数据类型或<code>dtype</code>，描述在数组中的固定大小值的格子；</li><li>一个表示数组形状（<code>shape</code>）的元组，表示各维度大小的元组；</li><li>一个跨度元组（<code>stride</code>），其中的整数指的是为了前进到当前维度下一个元素需要”跨过”的字节数。跨度可以是负数，这样会使数组在内存中后向移动，切片中 <strong>obj[::-1]</strong> 或 <strong>obj[:,::-1]</strong> 就是如此</li></ul><h3 id="👀ndarray的创建"><a href="#👀ndarray的创建" class="headerlink" title="👀ndarray的创建"></a>👀ndarray的创建</h3><h4 id="👁numpy-array-函数创建"><a href="#👁numpy-array-函数创建" class="headerlink" title="👁numpy.array()函数创建"></a>👁<code>numpy.array()</code>函数创建</h4><p>创建一个<code>ndarray</code>只需调用<code>NumPy</code>的<code>array</code>函数即可：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numpy.array(<span class="built_in">object</span>, dtype = <span class="literal">None</span>, copy = <span class="literal">True</span>, order = <span class="literal">None</span>, subok = <span class="literal">False</span>, ndmin = <span class="number">0</span>)</span><br><span class="line"><span class="comment"># 参数说明</span></span><br><span class="line"><span class="built_in">object</span>数组或嵌套的数列</span><br><span class="line">dtype数组元素的数据类型，可选</span><br><span class="line">copy对象是否需要复制，可选</span><br><span class="line">order创建数组的样式，C为行方向，F为列方向，A为任意方向（默认）</span><br><span class="line">subok默认返回一个与基类类型一致的数组</span><br><span class="line">ndmin指定生成数组的最小维度</span><br><span class="line"></span><br><span class="line"><span class="comment"># 例子</span></span><br><span class="line"><span class="comment"># dtype参数  </span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line">a = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], dtype = <span class="built_in">complex</span>)  </span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[<span class="number">1.</span>+<span class="number">0.j</span> <span class="number">2.</span>+<span class="number">0.j</span> <span class="number">3.</span>+<span class="number">0.j</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 最小维度  </span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line">a = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>], ndmin = <span class="number">2</span>)  </span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span>]]</span><br></pre></td></tr></table></figure><p><code>ndarray</code>对象由计算机内存的连续一维部分组成，并结合索引模式，将每个元素映射到内存块中的一个位置。内存块以行顺序(<code>C</code>样式)或列顺序(<code>FORTRAN</code>或<code>MatLab</code>风格，即前述的<code>F</code>样式)来保存元素。</p><h4 id="👁特殊函数创建"><a href="#👁特殊函数创建" class="headerlink" title="👁特殊函数创建"></a>👁特殊函数创建</h4><ul><li><code>numpy.empty()</code></li><li><code>numpy.zeros()</code></li><li><code>numpy.ones()</code></li><li><code>numpy.full()</code></li><li><code>numpy.random.*</code></li><li><code>numpy.eye()</code></li><li>……</li></ul><p>（1）<code>numpy.empty()</code>方法用来创建一个指定形状（<code>shape</code>）、数据类型（<code>dtype</code>）且未初始化的数组：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numpy.empty(shape, dtype = <span class="built_in">float</span>, order = <span class="string">&#x27;C&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 参数说明</span></span><br><span class="line">shape数组形状，可以是<span class="built_in">int</span>或是元组，也可以是列表，如：（<span class="number">3</span>，<span class="number">4</span>）<span class="keyword">or</span> <span class="number">3</span> <span class="keyword">or</span> [<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">dtype数据类型，可选</span><br><span class="line">order有<span class="string">&quot;C&quot;</span>和<span class="string">&quot;F&quot;</span>两个选项,分别代表，行优先和列优先，在计算机内存中的存储元素的顺序。</span><br><span class="line"></span><br><span class="line"><span class="comment"># 例子</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line">x = np.empty([<span class="number">3</span>,<span class="number">2</span>], dtype = <span class="built_in">int</span>) </span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[[ <span class="number">6917529027641081856</span>  <span class="number">5764616291768666155</span>]</span><br><span class="line"> [ <span class="number">6917529027641081859</span> -<span class="number">5764598754299804209</span>]</span><br><span class="line"> [          <span class="number">4497473538</span>      <span class="number">844429428932120</span>]]</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>：数组元素为随机值，因为它们未初始化。</p></blockquote><p>（2）<code>numpy.zeros()</code>创建指定大小的数组，数组元素以0来填充：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numpy.zeros(shape, dtype = <span class="built_in">float</span>, order = <span class="string">&#x27;C&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 参数说明</span></span><br><span class="line">shape数组形状</span><br><span class="line">dtype数据类型，可选</span><br><span class="line">order<span class="string">&#x27;C&#x27;</span>用于C的行数组，或者<span class="string">&#x27;F&#x27;</span>用于FORTRAN的列数组</span><br><span class="line"></span><br><span class="line"><span class="comment"># 例子</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment"># 默认为浮点数</span></span><br><span class="line">x = np.zeros(<span class="number">5</span>) </span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line"><span class="comment"># 设置类型为整数</span></span><br><span class="line">y = np.zeros((<span class="number">5</span>,), dtype = <span class="built_in">int</span>) </span><br><span class="line"><span class="built_in">print</span>(y)</span><br><span class="line"><span class="comment"># 自定义类型</span></span><br><span class="line">z = np.zeros((<span class="number">2</span>,<span class="number">2</span>), dtype = [(<span class="string">&#x27;x&#x27;</span>,<span class="string">&#x27;i4&#x27;</span>), (<span class="string">&#x27;y&#x27;</span>,<span class="string">&#x27;i4&#x27;</span>)])  </span><br><span class="line"><span class="built_in">print</span>(z)</span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[<span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span>]</span><br><span class="line">[<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br><span class="line">[[(<span class="number">0</span>, <span class="number">0</span>) (<span class="number">0</span>, <span class="number">0</span>)]</span><br><span class="line"> [(<span class="number">0</span>, <span class="number">0</span>) (<span class="number">0</span>, <span class="number">0</span>)]]</span><br></pre></td></tr></table></figure><p>（3）<code>numpy.ones()</code>创建指定形状的数组，数组元素以1来填充：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numpy.ones(shape, dtype = <span class="literal">None</span>, order = <span class="string">&#x27;C&#x27;</span>)</span><br><span class="line"><span class="comment"># 参数说明</span></span><br><span class="line">shape数组形状</span><br><span class="line">dtype数据类型，可选</span><br><span class="line">order<span class="string">&#x27;C&#x27;</span> 用于C的行数组，或者<span class="string">&#x27;F&#x27;</span>用于 FORTRAN 的列数组</span><br><span class="line"></span><br><span class="line"><span class="comment"># 例子</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment"># 默认为浮点数</span></span><br><span class="line">x = np.ones(<span class="number">5</span>) </span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line"><span class="comment"># 自定义类型</span></span><br><span class="line">x = np.ones([<span class="number">2</span>,<span class="number">2</span>], dtype = <span class="built_in">int</span>)</span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[<span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span>]</span><br><span class="line">[[<span class="number">1</span> <span class="number">1</span>]</span><br><span class="line"> [<span class="number">1</span> <span class="number">1</span>]]</span><br></pre></td></tr></table></figure><p>（4）<code>numpy.full()</code>创建指定形状的数组，数组元素以<code>fill_value</code>来填充：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numpy.full(shape, fill_value, dtype=<span class="literal">None</span>, order=<span class="string">&#x27;C&#x27;</span>)</span><br><span class="line"><span class="comment"># 参数说明</span></span><br><span class="line">shape数组形状</span><br><span class="line">fill_value填充值（标量或类似数组）</span><br><span class="line">dtype数据类型，可选</span><br><span class="line">order<span class="string">&#x27;C&#x27;</span> 用于C的行数组，或者<span class="string">&#x27;F&#x27;</span>用于 FORTRAN 的列数组</span><br><span class="line"></span><br><span class="line"><span class="comment"># 例子</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = np.full((<span class="number">2</span>,<span class="number">2</span>),np.pi)</span><br><span class="line">b = np.full((<span class="number">2</span>,<span class="number">2</span>),<span class="number">1</span>)</span><br><span class="line">c = np.full((<span class="number">2</span>,<span class="number">2</span>),[<span class="number">1</span>,<span class="number">2</span>])</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[[<span class="number">3.14159265</span> <span class="number">3.14159265</span>]</span><br><span class="line"> [<span class="number">3.14159265</span> <span class="number">3.14159265</span>]]</span><br><span class="line">[[<span class="number">1</span> <span class="number">1</span>]</span><br><span class="line"> [<span class="number">1</span> <span class="number">1</span>]]</span><br><span class="line">[[<span class="number">1</span> <span class="number">2</span>]</span><br><span class="line"> [<span class="number">1</span> <span class="number">2</span>]]</span><br></pre></td></tr></table></figure><p>（5）<code>numpy.random.*</code></p><p>在<code>Python</code>中，有两个模块可以产生随机数：</p><ul><li>python自带<code>random</code>包： 提供一些基本的随机数产生函数，可满足基本需要；</li><li><code>numpy.random</code>：提供一些产生随机数的高级函数，满足高级需求。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> random</span><br><span class="line"><span class="comment"># 例子1 Numpy创建标准正态分布数组</span></span><br><span class="line"><span class="comment"># 创建randn(size)服从X~N(0,1)的正态分布随机数组</span></span><br><span class="line">a = random.randn(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[[-<span class="number">0.75827863</span> -<span class="number">0.0696867</span>  -<span class="number">2.23015832</span>]</span><br><span class="line"> [-<span class="number">0.57744225</span> -<span class="number">0.20939873</span> -<span class="number">1.2368758</span> ]]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 例子2 Numpy创建随机分布整数型数组</span></span><br><span class="line"><span class="comment"># 利用randint([low,high],size)创建一个整数型指定范围在[low.high]之间的数组</span></span><br><span class="line">b=random.randint(<span class="number">100</span>,<span class="number">300</span>,(<span class="number">4</span>,<span class="number">4</span>))</span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[[<span class="number">130</span> <span class="number">136</span> <span class="number">156</span> <span class="number">208</span>]</span><br><span class="line"> [<span class="number">221</span> <span class="number">241</span> <span class="number">124</span> <span class="number">244</span>]</span><br><span class="line"> [<span class="number">203</span> <span class="number">266</span> <span class="number">160</span> <span class="number">222</span>]</span><br><span class="line"> [<span class="number">142</span> <span class="number">183</span> <span class="number">203</span> <span class="number">215</span>]]</span><br></pre></td></tr></table></figure><p>（6）<code>numpy.eye()</code></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment"># 创建对角矩阵数组</span></span><br><span class="line">a = np.eye(<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[[<span class="number">1.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span>]</span><br><span class="line"> [<span class="number">0.</span> <span class="number">1.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span>]</span><br><span class="line"> [<span class="number">0.</span> <span class="number">0.</span> <span class="number">1.</span> <span class="number">0.</span> <span class="number">0.</span>]</span><br><span class="line"> [<span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">1.</span> <span class="number">0.</span>]</span><br><span class="line"> [<span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">1.</span>]]</span><br></pre></td></tr></table></figure><h4 id="👁NumPy从已有的数组创建数组"><a href="#👁NumPy从已有的数组创建数组" class="headerlink" title="👁NumPy从已有的数组创建数组"></a>👁<code>NumPy</code>从已有的数组创建数组</h4><ul><li><code>numpy.asarray()</code></li><li><code>numpy.frombuffer()</code></li><li><code>numpy.fromiter()</code></li></ul><p>（1）<code>numpy.asarray()</code></p><p><code>numpy.asarray()</code>类似<code>numpy.array()</code>，但<code>numpy.asarray()</code>参数只有三个。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numpy.asarray(a, dtype = <span class="literal">None</span>, order = <span class="literal">None</span>)</span><br><span class="line"><span class="comment"># 参数说明</span></span><br><span class="line">a任意形式的输入参数，可以是：列表、列表的元组、元组、元组的元组、元组的列表、多维数组</span><br><span class="line">dtype数据类型，可选</span><br><span class="line">order可选，有<span class="string">&quot;C&quot;</span>和<span class="string">&quot;F&quot;</span>两个选项,分别代表，行优先和列优先，在计算机内存中的存储元素的顺序。</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment"># 将列表转换为ndarray</span></span><br><span class="line">x = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">a1 = np.asarray(x)  </span><br><span class="line">a2 = np.asarray(x, dtype = <span class="built_in">float</span>)  </span><br><span class="line"><span class="built_in">print</span>(a1)</span><br><span class="line"><span class="built_in">print</span>(a2)</span><br><span class="line"><span class="comment"># 将元组转换为ndarray</span></span><br><span class="line">y = (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>) </span><br><span class="line">b = np.asarray(y)  </span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="comment"># 将元组列表转换为ndarray</span></span><br><span class="line">z = [(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>),(<span class="number">4</span>,<span class="number">5</span>)] </span><br><span class="line">c = np.asarray(z)  </span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]</span><br><span class="line">[<span class="number">1.</span> <span class="number">2.</span> <span class="number">3.</span>]</span><br><span class="line">[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]</span><br><span class="line">[(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) (<span class="number">4</span>, <span class="number">5</span>)]</span><br></pre></td></tr></table></figure><p>（2）<code>numpy.frombuffer()</code></p><p><code>numpy.frombuffer()</code>用于实现动态数组。</p><p><code>numpy.frombuffer()</code>接受buffer输入参数，以流的形式读入转化成ndarray对象。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numpy.frombuffer(buffer, dtype = <span class="built_in">float</span>, count = -<span class="number">1</span>, offset = <span class="number">0</span>)</span><br><span class="line"><span class="comment"># 注意：buffer是字符串的时候，Python3默认str是Unicode类型，所以要转成bytestring在原str前加上b。</span></span><br><span class="line">buffer可以是任意对象，会以流的形式读入。</span><br><span class="line">dtype返回数组的数据类型，可选</span><br><span class="line">count读取的数据数量，默认为-<span class="number">1</span>，读取所有数据。</span><br><span class="line">offset读取的起始位置，默认为<span class="number">0</span>。</span><br><span class="line"></span><br><span class="line"><span class="comment"># Python3例子</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"><span class="built_in">str</span> = <span class="string">b&#x27;Hello World9527&#x27;</span> </span><br><span class="line">a = np.frombuffer(<span class="built_in">str</span>, dtype = <span class="string">&#x27;S1&#x27;</span>)  </span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[<span class="string">b&#x27;H&#x27;</span> <span class="string">b&#x27;e&#x27;</span> <span class="string">b&#x27;l&#x27;</span> <span class="string">b&#x27;l&#x27;</span> <span class="string">b&#x27;o&#x27;</span> <span class="string">b&#x27; &#x27;</span> <span class="string">b&#x27;W&#x27;</span> <span class="string">b&#x27;o&#x27;</span> <span class="string">b&#x27;r&#x27;</span> <span class="string">b&#x27;l&#x27;</span> <span class="string">b&#x27;d&#x27;</span> <span class="string">b&#x27;9&#x27;</span> <span class="string">b&#x27;5&#x27;</span> <span class="string">b&#x27;2&#x27;</span> <span class="string">b&#x27;7&#x27;</span>]</span><br></pre></td></tr></table></figure><p>（3）<code>numpy.fromiter()</code></p><p><code>numpy.fromiter()</code>方法从可迭代对象中建立ndarray对象，返回一维数组。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numpy.fromiter(iterable, dtype, count=-<span class="number">1</span>)</span><br><span class="line"><span class="comment"># 参数说明</span></span><br><span class="line">iterable可迭代对象</span><br><span class="line">dtype返回数组的数据类型</span><br><span class="line">count读取的数据数量，默认为-<span class="number">1</span>，读取所有数据</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"><span class="comment"># 使用range函数创建列表对象  </span></span><br><span class="line"><span class="built_in">list</span>=<span class="built_in">range</span>(<span class="number">5</span>)</span><br><span class="line">it=<span class="built_in">iter</span>(<span class="built_in">list</span>)</span><br><span class="line"><span class="built_in">print</span>(it)</span><br><span class="line"><span class="comment"># 使用迭代器创建 ndarray </span></span><br><span class="line">x=np.fromiter(it, dtype = <span class="built_in">float</span>)</span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">&lt;range_iterator <span class="built_in">object</span> at <span class="number">0x0000023512CA7E70</span>&gt;</span><br><span class="line">[<span class="number">0.</span> <span class="number">1.</span> <span class="number">2.</span> <span class="number">3.</span> <span class="number">4.</span>]</span><br></pre></td></tr></table></figure><h4 id="👁NumPy从数值范围创建数组"><a href="#👁NumPy从数值范围创建数组" class="headerlink" title="👁NumPy从数值范围创建数组"></a>👁<code>NumPy</code>从数值范围创建数组</h4><ul><li><code>numpy.arange()</code></li><li><code>numpy.linspace()</code></li><li><code>numpy.logspace()</code></li></ul><p>（1）<code>numpy.arange()</code></p><p><code>numpy</code>包中的使用<code>arange</code>函数创建数值范围并返回ndarray对象，函数格式如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numpy.arange(start, stop, step, dtype)</span><br><span class="line"><span class="comment"># 根据start与stop指定的范围以及step设定的步长，生成一个ndarray</span></span><br><span class="line"><span class="comment"># 参数说明</span></span><br><span class="line">start起始值，默认为<span class="number">0</span></span><br><span class="line">stop终止值（不包含）</span><br><span class="line">step步长，默认为<span class="number">1</span></span><br><span class="line">dtype返回ndarray的数据类型，如果没有提供，则会使用输入数据的类型。</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a1 = np.arange(<span class="number">10</span>)</span><br><span class="line">a2 = np.arange(<span class="number">10</span>, dtype = <span class="built_in">float</span>)</span><br><span class="line">b = np.arange(<span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line">c = np.arange(<span class="number">10</span>, <span class="number">20</span>, <span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(a1)</span><br><span class="line"><span class="built_in">print</span>(a2)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span>]</span><br><span class="line">[<span class="number">0.</span> <span class="number">1.</span> <span class="number">2.</span> <span class="number">3.</span> <span class="number">4.</span> <span class="number">5.</span> <span class="number">6.</span> <span class="number">7.</span> <span class="number">8.</span> <span class="number">9.</span>]</span><br><span class="line">[<span class="number">10</span> <span class="number">11</span> <span class="number">12</span> <span class="number">13</span> <span class="number">14</span> <span class="number">15</span> <span class="number">16</span> <span class="number">17</span> <span class="number">18</span> <span class="number">19</span>]</span><br><span class="line">[<span class="number">10</span> <span class="number">12</span> <span class="number">14</span> <span class="number">16</span> <span class="number">18</span>]</span><br></pre></td></tr></table></figure><p>（2）<code>numpy.linspace()</code></p><p><code>numpy.linspace</code>函数用于创建一个一维数组，数组是一个等差数列构成的，格式如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.linspace(start, stop, num=<span class="number">50</span>, endpoint=<span class="literal">True</span>, retstep=<span class="literal">False</span>, dtype=<span class="literal">None</span>)</span><br><span class="line"><span class="comment"># 参数说明</span></span><br><span class="line">start序列的起始值</span><br><span class="line">stop序列的终止值，如果endpoint为true，该值包含于数列中</span><br><span class="line">num要生成的等步长的样本数量，默认为<span class="number">50</span></span><br><span class="line">endpoint该值为true时，数列中包含stop值，反之不包含，默认是<span class="literal">True</span>。</span><br><span class="line">retstep如果为<span class="literal">True</span>时，生成的数组中会显示间距，反之不显示。</span><br><span class="line">dtypendarray的数据类型</span><br><span class="line"></span><br><span class="line"><span class="comment"># 例子1</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = np.linspace(<span class="number">1</span>,<span class="number">10</span>,<span class="number">10</span>)</span><br><span class="line">b = np.linspace(<span class="number">1</span>,<span class="number">1</span>,<span class="number">10</span>)</span><br><span class="line">c = np.linspace(<span class="number">10</span>, <span class="number">20</span>, <span class="number">5</span>, endpoint = <span class="literal">False</span>) </span><br><span class="line">d = np.linspace(<span class="number">10</span>, <span class="number">20</span>, <span class="number">5</span>)  </span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line"><span class="built_in">print</span>(d)</span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[<span class="number">1.</span> <span class="number">2.</span> <span class="number">3.</span> <span class="number">4.</span> <span class="number">5.</span> <span class="number">6.</span> <span class="number">7.</span> <span class="number">8.</span> <span class="number">9.</span> <span class="number">10.</span>]</span><br><span class="line">[<span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span>]</span><br><span class="line">[<span class="number">10.</span> <span class="number">12.</span> <span class="number">14.</span> <span class="number">16.</span> <span class="number">18.</span>]</span><br><span class="line">[<span class="number">10.</span> <span class="number">12.5</span> <span class="number">15.</span> <span class="number">17.5</span> <span class="number">20.</span> ]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 例子2</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">e1 = np.linspace(<span class="number">1</span>,<span class="number">10</span>,<span class="number">10</span>,retstep= <span class="literal">True</span>)</span><br><span class="line">e2 = np.linspace(<span class="number">1</span>,<span class="number">10</span>,<span class="number">5</span>,retstep= <span class="literal">True</span>) </span><br><span class="line"><span class="built_in">print</span>(e1)</span><br><span class="line"><span class="built_in">print</span>(e2)</span><br><span class="line"><span class="comment"># 拓展例子</span></span><br><span class="line">f = np.linspace(<span class="number">1</span>,<span class="number">10</span>,<span class="number">10</span>).reshape([<span class="number">10</span>,<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(f)</span><br><span class="line"><span class="comment">#输出结果</span></span><br><span class="line">(array([ <span class="number">1.</span>,  <span class="number">2.</span>,  <span class="number">3.</span>,  <span class="number">4.</span>,  <span class="number">5.</span>,  <span class="number">6.</span>,  <span class="number">7.</span>,  <span class="number">8.</span>,  <span class="number">9.</span>, <span class="number">10.</span>]), <span class="number">1.0</span>)</span><br><span class="line">(array([ <span class="number">1.</span>,  <span class="number">3.25</span>,  <span class="number">5.5</span>,  <span class="number">7.75</span>, <span class="number">10.</span>]), <span class="number">2.25</span>)</span><br><span class="line">[[ <span class="number">1.</span>]</span><br><span class="line"> [ <span class="number">2.</span>]</span><br><span class="line"> [ <span class="number">3.</span>]</span><br><span class="line"> [ <span class="number">4.</span>]</span><br><span class="line"> [ <span class="number">5.</span>]</span><br><span class="line"> [ <span class="number">6.</span>]</span><br><span class="line"> [ <span class="number">7.</span>]</span><br><span class="line"> [ <span class="number">8.</span>]</span><br><span class="line"> [ <span class="number">9.</span>]</span><br><span class="line"> [<span class="number">10.</span>]]</span><br></pre></td></tr></table></figure><p>（3）<code>numpy.logspace()</code></p><p><code>numpy.logspace</code>函数用于创建一个于等比数列。格式如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.logspace(start, stop, num=<span class="number">50</span>, endpoint=<span class="literal">True</span>, base=<span class="number">10.0</span>, dtype=<span class="literal">None</span>)</span><br><span class="line"><span class="comment"># 参数说明</span></span><br><span class="line">start序列的起始值为：base ** start</span><br><span class="line">stop序列的终止值为：base ** stop。如果endpoint为true，该值包含于数列中</span><br><span class="line">num要生成的等步长的样本数量，默认为<span class="number">50</span></span><br><span class="line">endpoint该值为 true 时，数列中中包含stop值，反之不包含，默认是<span class="literal">True</span>。</span><br><span class="line">base对数 log 的底数。</span><br><span class="line">dtypendarray 的数据类型</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment"># 默认底数是10</span></span><br><span class="line">a = np.logspace(<span class="number">1.0</span>, <span class="number">2.0</span>, num = <span class="number">10</span>)</span><br><span class="line"><span class="comment"># 将对数的底数设置为 2 </span></span><br><span class="line">b = np.logspace(<span class="number">0</span>, <span class="number">9</span>, <span class="number">10</span>,base = <span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[ <span class="number">10.</span>          <span class="number">12.91549665</span>  <span class="number">16.68100537</span>  <span class="number">21.5443469</span>   <span class="number">27.82559402</span></span><br><span class="line">  <span class="number">35.93813664</span>  <span class="number">46.41588834</span>  <span class="number">59.94842503</span>  <span class="number">77.42636827</span> <span class="number">100.</span>        ]</span><br><span class="line">[  <span class="number">1.</span>   <span class="number">2.</span>   <span class="number">4.</span>   <span class="number">8.</span>  <span class="number">16.</span>  <span class="number">32.</span>  <span class="number">64.</span> <span class="number">128.</span> <span class="number">256.</span> <span class="number">512.</span>]</span><br></pre></td></tr></table></figure><h4 id="👁结构数组"><a href="#👁结构数组" class="headerlink" title="👁结构数组"></a>👁结构数组</h4><p>C语言中可以通过struct关键字定义结构类型。NumPy中也有类似的结构数组。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment"># 例子1</span></span><br><span class="line">student = np.dtype([(<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;S20&#x27;</span>), (<span class="string">&#x27;age&#x27;</span>, <span class="string">&#x27;i1&#x27;</span>), (<span class="string">&#x27;marks&#x27;</span>, <span class="string">&#x27;f4&#x27;</span>)]) </span><br><span class="line">a = np.array([(<span class="string">&#x27;abc&#x27;</span>, <span class="number">21</span>, <span class="number">50</span>),(<span class="string">&#x27;xyz&#x27;</span>, <span class="number">18</span>, <span class="number">75</span>)], dtype = student) </span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">0</span>])</span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[(<span class="string">b&#x27;abc&#x27;</span>, <span class="number">21</span>, <span class="number">50.</span>) (<span class="string">b&#x27;xyz&#x27;</span>, <span class="number">18</span>, <span class="number">75.</span>)]</span><br><span class="line">(<span class="string">b&#x27;abc&#x27;</span>, <span class="number">21</span>, <span class="number">50.</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 例子2</span></span><br><span class="line">persontype = np.dtype(&#123;</span><br><span class="line">    <span class="string">&#x27;names&#x27;</span>:[<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;age&#x27;</span>,<span class="string">&#x27;weight&#x27;</span>],</span><br><span class="line">    <span class="string">&#x27;formats&#x27;</span>:[<span class="string">&#x27;S30&#x27;</span>,<span class="string">&#x27;i&#x27;</span>,<span class="string">&#x27;f&#x27;</span>]&#125;)</span><br><span class="line">b = np.array([(<span class="string">&#x27;Zhang&#x27;</span>,<span class="number">32</span>,<span class="number">75.5</span>),(<span class="string">&#x27;Wang&#x27;</span>,<span class="number">24</span>,<span class="number">65.2</span>)],dtype = persontype)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="built_in">print</span>(b[<span class="number">0</span>])</span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[(<span class="string">b&#x27;Zhang&#x27;</span>, <span class="number">32</span>, <span class="number">75.5</span>) (<span class="string">b&#x27;Wang&#x27;</span>, <span class="number">24</span>, <span class="number">65.2</span>)]</span><br><span class="line">(<span class="string">b&#x27;Zhang&#x27;</span>, <span class="number">32</span>, <span class="number">75.5</span>)</span><br></pre></td></tr></table></figure><blockquote><p>Python打印字符串，前面出现<code>b</code>:</p><ul><li>b: bytes </li><li>python3.x里默认的str是(py2.x里的)unicode, bytes是(py2.x)的str, b”“前缀代表的就是bytes ;</li><li>python2.x里, b前缀没什么具体意义， 只是为了兼容python3.x的这种写法.</li></ul></blockquote><h3 id="👀NumPy数据类型对象-dtype"><a href="#👀NumPy数据类型对象-dtype" class="headerlink" title="👀NumPy数据类型对象(dtype)"></a>👀NumPy数据类型对象(dtype)</h3><p><code>NumPy</code>支持的数据类型比<code>Python</code>内置的类型要多很多，基本上可以和<code>C</code>语言的数据类型对应上，其中部分类型对应为<code>Python</code>内置的类型。</p><table><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td><code>bool_</code></td><td>布尔型数据类型（True 或者 False）</td></tr><tr><td><code>int8</code></td><td>字节（-128 to 127）</td></tr><tr><td><code>int16</code></td><td>整数（-32768 to 32767）</td></tr><tr><td><code>int32</code></td><td>整数（-2147483648 to 2147483647）</td></tr><tr><td><code>int64</code></td><td>整数（-9223372036854775808 to 9223372036854775807）</td></tr><tr><td><code>uint8</code></td><td>无符号整数（0 to 255）</td></tr><tr><td><code>uint16</code></td><td>无符号整数（0 to 65535）</td></tr><tr><td><code>uint32</code></td><td>无符号整数（0 to 4294967295）</td></tr><tr><td><code>uint64</code></td><td>无符号整数（0 to 18446744073709551615）</td></tr><tr><td><code>float_</code></td><td>float64 类型的简写</td></tr><tr><td><code>float16</code></td><td>半精度浮点数，包括：1 个符号位，5 个指数位，10 个尾数位</td></tr><tr><td><code>float32</code></td><td>单精度浮点数，包括：1 个符号位，8 个指数位，23 个尾数位</td></tr><tr><td><code>float64</code></td><td>双精度浮点数，包括：1 个符号位，11 个指数位，52 个尾数位</td></tr></tbody></table><p>数据类型对象（<code>numpy.dtype</code>类的实例）用来描述与数组对应的内存区域是如何使用，它描述了数据的以下几个方面：</p><ul><li>数据的类型（整数，浮点数或者<code>Python</code>对象）</li><li>数据的大小（例如， 整数使用多少个字节存储）</li><li>数据的字节顺序（小端法或大端法）</li><li>在结构化类型的情况下，字段的名称、每个字段的数据类型和每个字段所取的内存块的部分</li><li>如果数据类型是子数组，那么它的形状和数据类型是什么。</li></ul><p>字节顺序是通过对数据类型预先设定 <code>&lt;</code>或 <code>&gt;</code> 来决定的。 <code>&lt;</code>意味着小端法(最小值存储在最小的地址，即低位组放在最前面)。<code>&gt;</code>意味着大端法(最重要的字节存储在最小的地址，即高位组放在最前面)。</p><p><code>dtype</code>对象是使用以下语法构造的：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numpy.dtype(<span class="built_in">object</span>, align, copy)</span><br><span class="line"><span class="comment"># 参数说明</span></span><br><span class="line"><span class="built_in">object</span> - 要转换为的数据类型对象</span><br><span class="line">align - 如果为true，填充字段使其类似C的结构体。</span><br><span class="line">copy - 复制dtype对象，如果为false，则是对内置数据类型对象的引用</span><br><span class="line"></span><br><span class="line"><span class="comment"># 例子1</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment"># 使用标量类型</span></span><br><span class="line">dt1 = np.dtype(np.int32)</span><br><span class="line"><span class="comment"># int8, int16, int32, int64四种数据类型可以使用字符串&#x27;i1&#x27;, &#x27;i2&#x27;,&#x27;i4&#x27;,&#x27;i8&#x27;代替</span></span><br><span class="line">dt2 = np.dtype(<span class="string">&#x27;i4&#x27;</span>)</span><br><span class="line"><span class="comment"># 字节顺序标注</span></span><br><span class="line">dt3 = np.dtype(<span class="string">&#x27;&lt;i4&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(dt1)</span><br><span class="line"><span class="built_in">print</span>(dt2)</span><br><span class="line"><span class="built_in">print</span>(dt4)</span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">int32</span><br><span class="line">int32</span><br><span class="line">int32</span><br></pre></td></tr></table></figure><p>下面实例展示结构化数据类型的使用，类型字段和对应的实际类型将被创建。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment"># 例子1</span></span><br><span class="line"><span class="comment"># 首先创建结构化数据类型</span></span><br><span class="line">dt = np.dtype([(<span class="string">&#x27;age&#x27;</span>,np.int8)]) </span><br><span class="line"><span class="built_in">print</span>(dt)</span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[(<span class="string">&#x27;age&#x27;</span>, <span class="string">&#x27;i1&#x27;</span>)]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 例子2</span></span><br><span class="line"><span class="comment"># 将数据类型应用于ndarray对象</span></span><br><span class="line">dt = np.dtype([(<span class="string">&#x27;age&#x27;</span>,np.int8)]) </span><br><span class="line">a = np.array([(<span class="number">10</span>,),(<span class="number">20</span>,),(<span class="number">30</span>,)], dtype = dt) </span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[(<span class="number">10</span>,) (<span class="number">20</span>,) (<span class="number">30</span>,)]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 例子3</span></span><br><span class="line"><span class="comment"># 类型字段名可以用于存取实际的age列</span></span><br><span class="line">dt = np.dtype([(<span class="string">&#x27;age&#x27;</span>,np.int8)]) </span><br><span class="line">a = np.array([(<span class="number">10</span>,),(<span class="number">20</span>,),(<span class="number">30</span>,)], dtype = dt) </span><br><span class="line"><span class="built_in">print</span>(a[<span class="string">&#x27;age&#x27;</span>])</span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[<span class="number">10</span> <span class="number">20</span> <span class="number">30</span>]</span><br></pre></td></tr></table></figure><p>下面的示例定义一个结构化数据类型student，包含字符串字段name，整数字段age，及浮点字段marks，并将这个dtype应用到ndarray对象。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment"># 例子1</span></span><br><span class="line">student = np.dtype([(<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;S20&#x27;</span>), (<span class="string">&#x27;age&#x27;</span>, <span class="string">&#x27;i1&#x27;</span>), (<span class="string">&#x27;marks&#x27;</span>, <span class="string">&#x27;f4&#x27;</span>)]) </span><br><span class="line"><span class="built_in">print</span>(student)</span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;S20&#x27;</span>), (<span class="string">&#x27;age&#x27;</span>, <span class="string">&#x27;i1&#x27;</span>), (<span class="string">&#x27;marks&#x27;</span>, <span class="string">&#x27;f4&#x27;</span>)]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 例子2</span></span><br><span class="line">a = np.array([(<span class="string">&#x27;abc&#x27;</span>, <span class="number">21</span>, <span class="number">50</span>),(<span class="string">&#x27;xyz&#x27;</span>, <span class="number">18</span>, <span class="number">75</span>)], dtype = student) </span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">0</span>])</span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[(<span class="string">b&#x27;abc&#x27;</span>, <span class="number">21</span>, <span class="number">50.</span>) (<span class="string">b&#x27;xyz&#x27;</span>, <span class="number">18</span>, <span class="number">75.</span>)]</span><br><span class="line">(<span class="string">b&#x27;abc&#x27;</span>, <span class="number">21</span>, <span class="number">50.</span>)</span><br></pre></td></tr></table></figure><p>每个内建类型都有一个唯一定义它的字符代码，如下：</p><table><thead><tr><th>字符</th><th>对应类型</th></tr></thead><tbody><tr><td>b</td><td>布尔型</td></tr><tr><td>i</td><td>(有符号) 整型</td></tr><tr><td>u</td><td>无符号整型 integer</td></tr><tr><td>f</td><td>浮点型</td></tr><tr><td>c</td><td>复数浮点型</td></tr><tr><td>m</td><td>timedelta（时间间隔）</td></tr><tr><td>M</td><td>datetime（日期时间）</td></tr><tr><td>O</td><td>(Python) 对象</td></tr><tr><td>S,a</td><td>(byte-)字符串</td></tr><tr><td>U</td><td>Unicode</td></tr><tr><td>V</td><td>原始数据 (void)</td></tr></tbody></table><h3 id="👀NumPy数组属性"><a href="#👀NumPy数组属性" class="headerlink" title="👀NumPy数组属性"></a>👀NumPy数组属性</h3><p><code>NumPy</code>数组的维数称为秩（rank），秩就是轴的数量，即数组的维度，一维数组的秩为 1，二维数组的秩为 2，以此类推。在<code>NumPy</code>中，每一个线性的数组称为是一个轴（<code>axis</code>），也就是维度（<code>dimensions</code>）。比如说，二维数组相当于是两个一维数组，其中第一个一维数组中每个元素又是一个一维数组。所以一维数组就是<code>NumPy</code>中的轴（<code>axis</code>），第一个轴相当于是底层数组，第二个轴是底层数组里的数组。而轴的数量——秩，就是数组的维数。</p><p>很多时候可以声明<code>axis</code>。axis&#x3D;0，表示沿着第0轴进行操作，即对每一列进行操作；axis&#x3D;1，表示沿着第1轴进行操作，即对每一行进行操作。<code>NumPy</code>的数组中比较重要<code>ndarray</code>对象属性有：</p><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td><code>ndarray.ndim</code></td><td>秩，即轴的数量或维度的数量</td></tr><tr><td><code>ndarray.shape</code></td><td>数组的维度，对于矩阵，n行m列</td></tr><tr><td><code>ndarray.size</code></td><td>数组元素的总个数，相当于 .shape中n*m的值</td></tr><tr><td><code>ndarray.dtype</code></td><td>ndarray对象的元素类型</td></tr><tr><td><code>ndarray.itemsize</code></td><td>ndarray对象中每个元素的大小，以字节为单位</td></tr><tr><td><code>ndarray.flags</code></td><td>ndarray对象的内存信息</td></tr><tr><td><code>ndarray.real</code></td><td>ndarray元素的实部</td></tr><tr><td><code>ndarray.imag</code></td><td>ndarray元素的虚部</td></tr><tr><td><code>ndarray.data</code></td><td>包含实际数组元素的缓冲区，由于一般通过数组的索引获取元素，所以通常不需要使用这个属性</td></tr></tbody></table><p><code>ndarray.ndim</code>用于返回数组的维数，等于秩。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"><span class="comment"># ndarray.ndim用于返回数组的维数，等于秩。</span></span><br><span class="line">a = np.arange(<span class="number">24</span>)  </span><br><span class="line"><span class="built_in">print</span>(a.ndim)             <span class="comment"># a 现只有一个维度</span></span><br><span class="line"><span class="comment"># 现在调整其大小</span></span><br><span class="line">b = a.reshape(<span class="number">2</span>,<span class="number">4</span>,<span class="number">3</span>)       <span class="comment"># b 现在拥有三个维度</span></span><br><span class="line"><span class="built_in">print</span>(b.ndim)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><p><code>ndarray.shape</code>表示数组的维度，返回一个元组，这个元组的长度就是维度的数目，即<code>ndim</code>属性(秩)。比如，一个二维数组，其维度表示”行数”和”列数”。</p><p><code>ndarray.shape</code>也可以用于调整数组大小。<code>NumPy</code>也提供了<code>reshape()</code>函数来调整数组大小。</p><p><code>ndarray.size</code>数组元素的总个数，相当于 <code>.shape</code>中n*m的值。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 例子1</span></span><br><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]])  </span><br><span class="line"><span class="built_in">print</span>(a.shape)</span><br><span class="line">b = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]]) </span><br><span class="line">b.shape = (<span class="number">3</span>,<span class="number">2</span>)  </span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">[[<span class="number">1</span> <span class="number">2</span>]</span><br><span class="line"> [<span class="number">3</span> <span class="number">4</span>]</span><br><span class="line"> [<span class="number">5</span> <span class="number">6</span>]]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 例子2</span></span><br><span class="line">c = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]]) </span><br><span class="line">d = c.reshape(<span class="number">3</span>,<span class="number">2</span>)  </span><br><span class="line">e = np.size(c)</span><br><span class="line"><span class="built_in">print</span>(d)</span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[[<span class="number">1</span> <span class="number">2</span>]</span><br><span class="line"> [<span class="number">3</span> <span class="number">4</span>]</span><br><span class="line"> [<span class="number">5</span> <span class="number">6</span>]]</span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure><p><code>ndarray.itemsize</code>以字节的形式返回数组中每一个元素的大小。</p><p>例如，一个元素类型为<code>float64</code>的数组<code>itemsize</code>属性值为 8(<code>float64</code>占用64个bits（位），每个字节（Byte）长度为8，所以64&#x2F;8，占用8个字节），又如，一个元素类型为<code>complex32</code>的数组item属性为4（32&#x2F;8）。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"> </span><br><span class="line"><span class="comment"># 数组的dtype为int8（一个字节）  </span></span><br><span class="line">x = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>], dtype = np.int8)  </span><br><span class="line"><span class="built_in">print</span>(x.itemsize)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 数组的dtype现在为float64（八个字节） </span></span><br><span class="line">y = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>], dtype = np.float64)  </span><br><span class="line"><span class="built_in">print</span>(y.itemsize)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">8</span></span><br></pre></td></tr></table></figure><p><code>ndarray.flags</code>返回ndarray对象的内存信息，包含以下属性：</p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td><code>C_CONTIGUOUS (C)</code></td><td>数据是在一个单一的<code>C</code>风格的连续段中</td></tr><tr><td><code>F_CONTIGUOUS (F)</code></td><td>数据是在一个单一的<code>Fortran</code>风格的连续段中</td></tr><tr><td><code>OWNDATA (O)</code></td><td>数组拥有它所使用的内存或从另一个对象中借用它</td></tr><tr><td><code>WRITEABLE (W)</code></td><td>数据区域可以被写入，将该值设置为<code>False</code>，则数据为只读</td></tr><tr><td><code>ALIGNED (A)</code></td><td>数据和所有元素都适当地对齐到硬件上</td></tr><tr><td><code>UPDATEIFCOPY (U)</code></td><td>这个数组是其它数组的一个副本，当这个数组被释放时，原数组的内容将被更新</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"> </span><br><span class="line">x = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])  </span><br><span class="line"><span class="built_in">print</span>(x.flags)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">C_CONTIGUOUS : <span class="literal">True</span></span><br><span class="line">F_CONTIGUOUS : <span class="literal">True</span></span><br><span class="line">OWNDATA : <span class="literal">True</span></span><br><span class="line">WRITEABLE : <span class="literal">True</span></span><br><span class="line">ALIGNED : <span class="literal">True</span></span><br><span class="line">WRITEBACKIFCOPY : <span class="literal">False</span></span><br><span class="line">UPDATEIFCOPY : <span class="literal">False</span></span><br></pre></td></tr></table></figure><blockquote><p><code>ndarray.reshape()</code>通常返回的是非拷贝副本，即改变返回后数组的元素，原数组对应元素的值也会改变。</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]])</span><br><span class="line">b = a.reshape((<span class="number">6</span>,))</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">20</span>)</span><br><span class="line">b[<span class="number">0</span>] = <span class="number">168</span></span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]</span><br><span class="line"> [<span class="number">4</span> <span class="number">5</span> <span class="number">6</span>]]</span><br><span class="line">[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span>]</span><br><span class="line">********************</span><br><span class="line">[<span class="number">168</span>   <span class="number">2</span>   <span class="number">3</span>   <span class="number">4</span>   <span class="number">5</span>   <span class="number">6</span>]</span><br><span class="line">[[<span class="number">168</span>   <span class="number">2</span>   <span class="number">3</span>]</span><br><span class="line"> [  <span class="number">4</span>   <span class="number">5</span>   <span class="number">6</span>]]</span><br></pre></td></tr></table></figure><h3 id="👀NumPy切片和索引"><a href="#👀NumPy切片和索引" class="headerlink" title="👀NumPy切片和索引"></a>👀NumPy切片和索引</h3><p>（1）整数和切片索引</p><p><code>ndarray</code>对象的内容可以通过索引或切片来访问和修改，与<code>Python</code>中<code>list</code>的切片操作一样。</p><p><code>ndarray</code>数组可以基于<code>0-n</code>的下标进行索引，切片对象可以通过内置的<code>slice</code>函数，并设置start, stop及step参数进行，从原数组中切割出一个新数组。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = np.arange(<span class="number">10</span>)</span><br><span class="line"><span class="comment"># 内置的slice函数</span></span><br><span class="line"><span class="comment"># 从索引2开始到索引7停止，间隔为2</span></span><br><span class="line">s = <span class="built_in">slice</span>(<span class="number">2</span>,<span class="number">7</span>,<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(a[s])</span><br><span class="line"><span class="comment"># 从索引2开始到索引7停止，间隔为2</span></span><br><span class="line">b = a[<span class="number">2</span>:<span class="number">7</span>:<span class="number">2</span>]</span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[<span class="number">2</span> <span class="number">4</span> <span class="number">6</span>]</span><br><span class="line">[<span class="number">2</span> <span class="number">4</span> <span class="number">6</span>]</span><br></pre></td></tr></table></figure><p>冒号<code>:</code>的解释：如果只放置一个参数，如<code>[2]</code>，将返回与该索引相对应的单个元素。如果为<code>[2:]</code>，表示从该索引开始以后的所有项都将被提取。如果使用了两个参数，如<code>[2:7]</code>，那么则提取两个索引(不包括停止索引)之间的项。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = np.arange(<span class="number">10</span>)  <span class="comment"># [0 1 2 3 4 5 6 7 8 9]</span></span><br><span class="line">b = a[<span class="number">5</span>]</span><br><span class="line">c = a[<span class="number">2</span>:]</span><br><span class="line">d = a[<span class="number">2</span>:<span class="number">5</span>]</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line"><span class="built_in">print</span>(d)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span>]</span><br><span class="line"><span class="number">5</span></span><br><span class="line">[<span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span>]</span><br><span class="line">[<span class="number">2</span> <span class="number">3</span> <span class="number">4</span>]</span><br></pre></td></tr></table></figure><p>多维数组同样适用上述索引提取方法。</p><p>切片还可以包括省略号<code>…</code>，来使选择元组的长度与数组的维度相同。 如果在行位置使用省略号，它将返回包含行中元素的ndarray。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]])</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="comment"># 从某个索引处开始切割</span></span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">1</span>:])</span><br><span class="line"><span class="built_in">print</span>(a[...,<span class="number">1</span>])   <span class="comment"># 第2列元素</span></span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">1</span>,...])   <span class="comment"># 第2行元素</span></span><br><span class="line"><span class="built_in">print</span>(a[...,<span class="number">1</span>:])  <span class="comment"># 第2列及剩下的所有元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]</span><br><span class="line"> [<span class="number">3</span> <span class="number">4</span> <span class="number">5</span>]</span><br><span class="line"> [<span class="number">4</span> <span class="number">5</span> <span class="number">6</span>]]</span><br><span class="line">[[<span class="number">3</span> <span class="number">4</span> <span class="number">5</span>]</span><br><span class="line"> [<span class="number">4</span> <span class="number">5</span> <span class="number">6</span>]]</span><br><span class="line">[<span class="number">2</span> <span class="number">4</span> <span class="number">5</span>]</span><br><span class="line">[<span class="number">3</span> <span class="number">4</span> <span class="number">5</span>]</span><br><span class="line">[[<span class="number">2</span> <span class="number">3</span>]</span><br><span class="line"> [<span class="number">4</span> <span class="number">5</span>]</span><br><span class="line"> [<span class="number">5</span> <span class="number">6</span>]]</span><br></pre></td></tr></table></figure><blockquote><p><code>np.s_[:]</code>的用法，可以参考Python中内置的 <code>slice</code> 函数，并设置start, stop及step参数。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Out[<span class="number">23</span>]:np.s_[:]</span><br><span class="line">Out[<span class="number">23</span>]:<span class="built_in">slice</span>(<span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>)</span><br></pre></td></tr></table></figure></blockquote><p>（2）高级索引</p><ul><li>整数数组索引</li><li>布尔索引</li><li>花式索引</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 整数数组索引</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"><span class="comment"># 获取数组中(0,0)，(1,1)和(2,0)位置处的元素。</span></span><br><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>], [<span class="number">3</span>,<span class="number">4</span>], [<span class="number">5</span>,<span class="number">6</span>]]) </span><br><span class="line">b = a[[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>],[<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>]]  </span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[<span class="number">1</span> <span class="number">4</span> <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#**********************************</span></span><br><span class="line">c = np.array([[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],[<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>],[<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>]])  </span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line">rows = np.array([[<span class="number">0</span>,<span class="number">0</span>],[<span class="number">3</span>,<span class="number">3</span>]])</span><br><span class="line">cols = np.array([[<span class="number">0</span>,<span class="number">2</span>],[<span class="number">0</span>,<span class="number">2</span>]])</span><br><span class="line">d = c[rows,cols]</span><br><span class="line"><span class="built_in">print</span>(d)</span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[[ <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>]</span><br><span class="line"> [ <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>]</span><br><span class="line"> [ <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>]</span><br><span class="line"> [ <span class="number">9</span> <span class="number">10</span> <span class="number">11</span>]]</span><br><span class="line">[[ <span class="number">0</span>  <span class="number">2</span>]</span><br><span class="line"> [ <span class="number">9</span> <span class="number">11</span>]]</span><br><span class="line"></span><br><span class="line"><span class="comment">#**********************************</span></span><br><span class="line"><span class="comment"># 借助切片:或…与索引数组组合。如下面例子：</span></span><br><span class="line">e = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]])</span><br><span class="line">f = e[<span class="number">1</span>:<span class="number">3</span>,<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line">g = e[<span class="number">1</span>:<span class="number">3</span>,[<span class="number">1</span>,<span class="number">2</span>]]</span><br><span class="line">h = e[...,<span class="number">1</span>:]</span><br><span class="line"><span class="built_in">print</span>(e)</span><br><span class="line"><span class="built_in">print</span>(f)</span><br><span class="line"><span class="built_in">print</span>(g)</span><br><span class="line"><span class="built_in">print</span>(h)</span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]</span><br><span class="line"> [<span class="number">4</span> <span class="number">5</span> <span class="number">6</span>]</span><br><span class="line"> [<span class="number">7</span> <span class="number">8</span> <span class="number">9</span>]]</span><br><span class="line">[[<span class="number">5</span> <span class="number">6</span>]</span><br><span class="line"> [<span class="number">8</span> <span class="number">9</span>]]</span><br><span class="line">[[<span class="number">5</span> <span class="number">6</span>]</span><br><span class="line"> [<span class="number">8</span> <span class="number">9</span>]]</span><br><span class="line">[[<span class="number">2</span> <span class="number">3</span>]</span><br><span class="line"> [<span class="number">5</span> <span class="number">6</span>]</span><br><span class="line"> [<span class="number">8</span> <span class="number">9</span>]]</span><br></pre></td></tr></table></figure><p><strong>布尔索引</strong>通过布尔运算（如：比较运算符）来获取符合指定条件的元素的数组。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"></span><br><span class="line">x = np.array([[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],[<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>],[<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>]])  </span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line"><span class="comment"># 现在我们会打印出大于5的元素  </span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;大于5的元素是：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(x[x&gt;<span class="number">5</span>])</span><br><span class="line"><span class="comment">#输出结果</span></span><br><span class="line">[[ <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>]</span><br><span class="line"> [ <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>]</span><br><span class="line"> [ <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>]</span><br><span class="line"> [ <span class="number">9</span> <span class="number">10</span> <span class="number">11</span>]]</span><br><span class="line">大于<span class="number">5</span>的元素是：</span><br><span class="line">[ <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span> <span class="number">10</span> <span class="number">11</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#**********************************</span></span><br><span class="line"><span class="comment"># 使用了~（取补运算符）来过滤NaN</span></span><br><span class="line">a = np.array([np.nan,<span class="number">1</span>,<span class="number">2</span>,np.nan,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])  </span><br><span class="line"><span class="built_in">print</span>(a[np.isnan(a)])</span><br><span class="line"><span class="built_in">print</span>(a[~np.isnan(a)])</span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[<span class="number">1.</span> <span class="number">2.</span> <span class="number">3.</span> <span class="number">4.</span> <span class="number">5.</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#**********************************</span></span><br><span class="line"><span class="comment"># 从数组中过滤掉非复数元素</span></span><br><span class="line">a = np.array([<span class="number">1</span>,<span class="number">2</span>+<span class="number">6j</span>,<span class="number">5</span>,<span class="number">3.5</span>+<span class="number">5j</span>])  </span><br><span class="line"><span class="built_in">print</span>(a[np.iscomplex(a)])</span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[<span class="number">2.</span>+<span class="number">6.j</span> <span class="number">3.5</span>+<span class="number">5.j</span>]</span><br></pre></td></tr></table></figure><p><strong>花式索引</strong>指的是利用整数数组进行索引。花式索引根据索引数组的值作为目标数组的某个轴的下标来取值。</p><ul><li><p>对于使用一维整型数组作为索引，如果目标是一维数组，那么索引的结果就是对应位置的元素；如果目标是二维数组，那么就是对应下标的行。</p></li><li><p>花式索引跟切片不一样，它总是将数据复制到新数组中；</p></li><li><p>传入多个索引数组（要使用<code>np.ix_</code>）。<code>np.ix_</code> 函数就是输入两个数组，产生笛卡尔积的映射关系。</p><p>笛卡尔乘积是指在数学中，两个集合 X 和 Y 的<strong>笛卡尔积</strong>（Cartesian product），又称直积，表示为 <strong>X×Y</strong>，第一个对象是X的成员而第二个对象是 Y 的所有可能有序对的其中一个成员。</p></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 一维数组只有一个轴 axis = 0，所以一维数组就在 axis = 0 这个轴上取值：</span></span><br><span class="line">a = np.arange(<span class="number">1</span>,<span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="comment"># 一维数组读取指定下标对应的元素</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;-------读取下标对应的元素-------&quot;</span>)</span><br><span class="line">b = a[[<span class="number">0</span>,<span class="number">6</span>]] <span class="comment"># 使用花式索引</span></span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="built_in">print</span>(b[<span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span>(b[<span class="number">1</span>])</span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span>]</span><br><span class="line">-------读取下标对应的元素-------</span><br><span class="line">[<span class="number">1</span> <span class="number">7</span>]</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#**********************************</span></span><br><span class="line"><span class="comment"># 二维数组</span></span><br><span class="line">c = np.arange(<span class="number">32</span>).reshape((<span class="number">8</span>,<span class="number">4</span>))</span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line"><span class="comment"># 二维数组读取指定下标对应的行,输出下表为4,2,1,7对应的行</span></span><br><span class="line"><span class="built_in">print</span>(c[[<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">7</span>]])</span><br><span class="line"><span class="comment"># 传入倒序索引数组</span></span><br><span class="line"><span class="built_in">print</span>(c[[-<span class="number">4</span>,-<span class="number">2</span>,-<span class="number">1</span>,-<span class="number">7</span>]])</span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[[ <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>]</span><br><span class="line"> [ <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>]</span><br><span class="line"> [ <span class="number">8</span>  <span class="number">9</span> <span class="number">10</span> <span class="number">11</span>]</span><br><span class="line"> [<span class="number">12</span> <span class="number">13</span> <span class="number">14</span> <span class="number">15</span>]</span><br><span class="line"> [<span class="number">16</span> <span class="number">17</span> <span class="number">18</span> <span class="number">19</span>]</span><br><span class="line"> [<span class="number">20</span> <span class="number">21</span> <span class="number">22</span> <span class="number">23</span>]</span><br><span class="line"> [<span class="number">24</span> <span class="number">25</span> <span class="number">26</span> <span class="number">27</span>]</span><br><span class="line"> [<span class="number">28</span> <span class="number">29</span> <span class="number">30</span> <span class="number">31</span>]]</span><br><span class="line">[[<span class="number">16</span> <span class="number">17</span> <span class="number">18</span> <span class="number">19</span>]</span><br><span class="line"> [ <span class="number">8</span>  <span class="number">9</span> <span class="number">10</span> <span class="number">11</span>]</span><br><span class="line"> [ <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>]</span><br><span class="line"> [<span class="number">28</span> <span class="number">29</span> <span class="number">30</span> <span class="number">31</span>]]</span><br><span class="line">[[<span class="number">16</span> <span class="number">17</span> <span class="number">18</span> <span class="number">19</span>]</span><br><span class="line"> [<span class="number">24</span> <span class="number">25</span> <span class="number">26</span> <span class="number">27</span>]</span><br><span class="line"> [<span class="number">28</span> <span class="number">29</span> <span class="number">30</span> <span class="number">31</span>]</span><br><span class="line"> [ <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>]]</span><br><span class="line"></span><br><span class="line"><span class="comment">#**********************************</span></span><br><span class="line"><span class="comment"># 传入多个索引数组（要使用np.ix_），笛卡尔积</span></span><br><span class="line"><span class="comment"># 例如 A=&#123;a,b&#125;, B=&#123;0,1,2&#125;，则：</span></span><br><span class="line"><span class="comment"># A×B=&#123;(a,0),(a,1),(a,2),(b,0),(b,1),(b,2)&#125;</span></span><br><span class="line"><span class="comment"># B×A=&#123;(0,a),(0,b),(1,a),(1,b),(2,a),(2,b)&#125;</span></span><br><span class="line">d = np.arange(<span class="number">32</span>).reshape((<span class="number">8</span>,<span class="number">4</span>))</span><br><span class="line"><span class="built_in">print</span>(d)</span><br><span class="line"><span class="built_in">print</span>(d[np.ix_([<span class="number">1</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">2</span>],[<span class="number">0</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>])])</span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[[ <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>]</span><br><span class="line"> [ <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>]</span><br><span class="line"> [ <span class="number">8</span>  <span class="number">9</span> <span class="number">10</span> <span class="number">11</span>]</span><br><span class="line"> [<span class="number">12</span> <span class="number">13</span> <span class="number">14</span> <span class="number">15</span>]</span><br><span class="line"> [<span class="number">16</span> <span class="number">17</span> <span class="number">18</span> <span class="number">19</span>]</span><br><span class="line"> [<span class="number">20</span> <span class="number">21</span> <span class="number">22</span> <span class="number">23</span>]</span><br><span class="line"> [<span class="number">24</span> <span class="number">25</span> <span class="number">26</span> <span class="number">27</span>]</span><br><span class="line"> [<span class="number">28</span> <span class="number">29</span> <span class="number">30</span> <span class="number">31</span>]]</span><br><span class="line">[[ <span class="number">4</span>  <span class="number">7</span>  <span class="number">5</span>  <span class="number">6</span>]</span><br><span class="line"> [<span class="number">20</span> <span class="number">23</span> <span class="number">21</span> <span class="number">22</span>]</span><br><span class="line"> [<span class="number">28</span> <span class="number">31</span> <span class="number">29</span> <span class="number">30</span>]</span><br><span class="line"> [ <span class="number">8</span> <span class="number">11</span>  <span class="number">9</span> <span class="number">10</span>]]</span><br></pre></td></tr></table></figure><h2 id="⛄ufunc函数"><a href="#⛄ufunc函数" class="headerlink" title="⛄ufunc函数"></a>⛄ufunc函数</h2><h3 id="👀NumPy广播（Broadcast）"><a href="#👀NumPy广播（Broadcast）" class="headerlink" title="👀NumPy广播（Broadcast）"></a>👀NumPy广播（Broadcast）</h3><p>广播(Broadcast)是numpy对不同形状(shape)的数组进行数值计算的方式， 对数组的算术运算通常在相应的元素上进行。如果两个数组a和b形状相同，即满足<strong>a.shape &#x3D;&#x3D; b.shape</strong>，那么a*b的结果就是a与b数组对应位相乘。这要求维数相同，且各维度的长度相同。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]) </span><br><span class="line">b = np.array([<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>]) </span><br><span class="line">c = a * b </span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line"><span class="comment"># 当运算中的2个数组的形状不同时，numpy将自动触发广播机制</span></span><br><span class="line">d = np.array([[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line">           [<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>],</span><br><span class="line">           [<span class="number">20</span>,<span class="number">20</span>,<span class="number">20</span>],</span><br><span class="line">           [<span class="number">30</span>,<span class="number">30</span>,<span class="number">30</span>]])</span><br><span class="line">e = np.array([<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>])</span><br><span class="line"><span class="built_in">print</span>(d + e)</span><br><span class="line"><span class="comment"># 4x3的二维数组与长为3的一维数组相加，等效于把数组b在二维上重复4次再运算：</span></span><br><span class="line">f = np.array([[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line">           [<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>],</span><br><span class="line">           [<span class="number">20</span>,<span class="number">20</span>,<span class="number">20</span>],</span><br><span class="line">           [<span class="number">30</span>,<span class="number">30</span>,<span class="number">30</span>]])</span><br><span class="line">g = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">gg = np.tile(g,(<span class="number">4</span>,<span class="number">1</span>))  <span class="comment">#重复b的各个维度</span></span><br><span class="line"><span class="built_in">print</span>(gg)</span><br><span class="line"><span class="built_in">print</span>(f+gg)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[<span class="number">10</span> <span class="number">40</span> <span class="number">90</span> <span class="number">160</span>]</span><br><span class="line">[[ <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>]</span><br><span class="line"> [<span class="number">10</span> <span class="number">11</span> <span class="number">12</span>]</span><br><span class="line"> [<span class="number">20</span> <span class="number">21</span> <span class="number">22</span>]</span><br><span class="line"> [<span class="number">30</span> <span class="number">31</span> <span class="number">32</span>]]</span><br><span class="line">[[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]</span><br><span class="line"> [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]</span><br><span class="line"> [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]</span><br><span class="line"> [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]]</span><br><span class="line">[[ <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>]</span><br><span class="line"> [<span class="number">11</span> <span class="number">12</span> <span class="number">13</span>]</span><br><span class="line"> [<span class="number">21</span> <span class="number">22</span> <span class="number">23</span>]</span><br><span class="line"> [<span class="number">31</span> <span class="number">32</span> <span class="number">33</span>]]</span><br></pre></td></tr></table></figure><p>广播的规则：</p><ul><li>让所有输入数组都向其中形状最长的数组看齐，形状中不足的部分都通过在前面加1补齐。</li><li>输出数组的形状是输入数组形状的各个维度上的最大值。</li><li>如果输入数组的某个维度和输出数组的对应维度的长度相同或者其长度为1时，这个数组能够用来计算，否则出错。</li><li>当输入数组的某个维度的长度为1时，沿着此维度运算时都用此维度上的第一组值。</li></ul><p><strong>简单理解：</strong>对两个数组，分别比较他们的每一个维度（若其中一个数组没有当前维度则忽略），满足：</p><ul><li>数组拥有相同形状。</li><li>当前维度的值相等。</li><li>当前维度的值有一个是1。</li></ul><p>若条件不满足，抛出 <strong>“ValueError: frames are not aligned”</strong> 异常。</p><h3 id="👀NumPy迭代数组"><a href="#👀NumPy迭代数组" class="headerlink" title="👀NumPy迭代数组"></a>👀NumPy迭代数组</h3><p><code>NumPy</code>迭代器对象<code>numpy.nditer</code>提供了一种灵活访问一个或者多个数组元素的方式。</p><p>迭代器最基本的任务的可以完成对数组元素的访问。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = np.arange(<span class="number">6</span>).reshape(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;原始数组是：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;迭代输出元素：&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> np.nditer(a):</span><br><span class="line">    <span class="built_in">print</span>(x, end=<span class="string">&quot;, &quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">原始数组是：</span><br><span class="line">[[<span class="number">0</span> <span class="number">1</span> <span class="number">2</span>]</span><br><span class="line"> [<span class="number">3</span> <span class="number">4</span> <span class="number">5</span>]]</span><br><span class="line"></span><br><span class="line">迭代输出元素：</span><br><span class="line"><span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, </span><br></pre></td></tr></table></figure><p>以上实例不是使用标准C或者Fortran顺序，选择的顺序是和数组内存布局一致的，这样做是为了提升访问的效率，<strong>默认是行序优先</strong>（row-major order，或者说是 C-order）。这反映了默认情况下只需访问每个元素，而无需考虑其特定顺序。<code>a</code>和<code>a.T</code>的遍历顺序是一样的，也就是他们在内存中的存储顺序也是一样的，但是<code>a.T.copy(order = &#39;C&#39;)</code>的遍历结果是不同的，那是因为它和前两种的存储方式是不一样的，默认是按行访问。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"> </span><br><span class="line">a = np.arange(<span class="number">6</span>).reshape(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> np.nditer(a.T):</span><br><span class="line">    <span class="built_in">print</span>(x, end=<span class="string">&quot;, &quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> np.nditer(a.T.copy(order=<span class="string">&#x27;C&#x27;</span>)):</span><br><span class="line">    <span class="built_in">print</span>(x, end=<span class="string">&quot;, &quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, </span><br><span class="line"></span><br><span class="line"><span class="number">0</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">5</span>,</span><br></pre></td></tr></table></figure><p>（1）控制遍历顺序</p><ul><li><code>for x in np.nditer(a, order=&#39;F&#39;):</code>Fortran order，即是列序优先；</li><li><code>for x in np.nditer(a.T, order=&#39;C&#39;):</code>C order，即是行序优先；</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"> </span><br><span class="line">a = np.arange(<span class="number">0</span>,<span class="number">60</span>,<span class="number">5</span>) </span><br><span class="line">a = a.reshape(<span class="number">3</span>,<span class="number">4</span>)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;原始数组是：&#x27;</span>) </span><br><span class="line"><span class="built_in">print</span>(a) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;原始数组的转置是：&#x27;</span>) </span><br><span class="line">b = a.T </span><br><span class="line"><span class="built_in">print</span>(b) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;以 C 风格顺序排序：&#x27;</span>) </span><br><span class="line">c = b.copy(order=<span class="string">&#x27;C&#x27;</span>)  </span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> np.nditer(c):  </span><br><span class="line">    <span class="built_in">print</span> (x, end=<span class="string">&quot;, &quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;以 F 风格顺序排序：&#x27;</span>)</span><br><span class="line">c = b.copy(order=<span class="string">&#x27;F&#x27;</span>)  </span><br><span class="line"><span class="built_in">print</span> (c)</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> np.nditer(c):  </span><br><span class="line">    <span class="built_in">print</span>(x, end=<span class="string">&quot;, &quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">原始数组是：</span><br><span class="line">[[ <span class="number">0</span>  <span class="number">5</span> <span class="number">10</span> <span class="number">15</span>]</span><br><span class="line"> [<span class="number">20</span> <span class="number">25</span> <span class="number">30</span> <span class="number">35</span>]</span><br><span class="line"> [<span class="number">40</span> <span class="number">45</span> <span class="number">50</span> <span class="number">55</span>]]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">原始数组的转置是：</span><br><span class="line">[[ <span class="number">0</span> <span class="number">20</span> <span class="number">40</span>]</span><br><span class="line"> [ <span class="number">5</span> <span class="number">25</span> <span class="number">45</span>]</span><br><span class="line"> [<span class="number">10</span> <span class="number">30</span> <span class="number">50</span>]</span><br><span class="line"> [<span class="number">15</span> <span class="number">35</span> <span class="number">55</span>]]</span><br><span class="line"></span><br><span class="line">以 C 风格顺序排序：</span><br><span class="line">[[ <span class="number">0</span> <span class="number">20</span> <span class="number">40</span>]</span><br><span class="line"> [ <span class="number">5</span> <span class="number">25</span> <span class="number">45</span>]</span><br><span class="line"> [<span class="number">10</span> <span class="number">30</span> <span class="number">50</span>]</span><br><span class="line"> [<span class="number">15</span> <span class="number">35</span> <span class="number">55</span>]]</span><br><span class="line"><span class="number">0</span>, <span class="number">20</span>, <span class="number">40</span>, <span class="number">5</span>, <span class="number">25</span>, <span class="number">45</span>, <span class="number">10</span>, <span class="number">30</span>, <span class="number">50</span>, <span class="number">15</span>, <span class="number">35</span>, <span class="number">55</span>, </span><br><span class="line"></span><br><span class="line">以 F 风格顺序排序：</span><br><span class="line">[[ <span class="number">0</span> <span class="number">20</span> <span class="number">40</span>]</span><br><span class="line"> [ <span class="number">5</span> <span class="number">25</span> <span class="number">45</span>]</span><br><span class="line"> [<span class="number">10</span> <span class="number">30</span> <span class="number">50</span>]</span><br><span class="line"> [<span class="number">15</span> <span class="number">35</span> <span class="number">55</span>]]</span><br><span class="line"><span class="number">0</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>, <span class="number">20</span>, <span class="number">25</span>, <span class="number">30</span>, <span class="number">35</span>, <span class="number">40</span>, <span class="number">45</span>, <span class="number">50</span>, <span class="number">55</span>, </span><br></pre></td></tr></table></figure><p>可以通过显式设置，来强制nditer对象使用某种顺序：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"> </span><br><span class="line">a = np.arange(<span class="number">0</span>,<span class="number">60</span>,<span class="number">5</span>) </span><br><span class="line">a = a.reshape(<span class="number">3</span>,<span class="number">4</span>)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;原始数组是：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;以 C 风格顺序排序：&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> np.nditer(a, order = <span class="string">&#x27;C&#x27;</span>):  </span><br><span class="line">    <span class="built_in">print</span>(x, end=<span class="string">&quot;, &quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;以 F 风格顺序排序：&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> np.nditer(a, order = <span class="string">&#x27;F&#x27;</span>):  </span><br><span class="line">    <span class="built_in">print</span>(x, end=<span class="string">&quot;, &quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">原始数组是：</span><br><span class="line">[[ <span class="number">0</span>  <span class="number">5</span> <span class="number">10</span> <span class="number">15</span>]</span><br><span class="line"> [<span class="number">20</span> <span class="number">25</span> <span class="number">30</span> <span class="number">35</span>]</span><br><span class="line"> [<span class="number">40</span> <span class="number">45</span> <span class="number">50</span> <span class="number">55</span>]]</span><br><span class="line"></span><br><span class="line">以 C 风格顺序排序：</span><br><span class="line"><span class="number">0</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>, <span class="number">20</span>, <span class="number">25</span>, <span class="number">30</span>, <span class="number">35</span>, <span class="number">40</span>, <span class="number">45</span>, <span class="number">50</span>, <span class="number">55</span>, </span><br><span class="line"></span><br><span class="line">以 F 风格顺序排序：</span><br><span class="line"><span class="number">0</span>, <span class="number">20</span>, <span class="number">40</span>, <span class="number">5</span>, <span class="number">25</span>, <span class="number">45</span>, <span class="number">10</span>, <span class="number">30</span>, <span class="number">50</span>, <span class="number">15</span>, <span class="number">35</span>, <span class="number">55</span>, </span><br></pre></td></tr></table></figure><p>（2）修改数组中元素的值</p><p><code>nditer</code>对象有另一个可选参数<code>op_flags</code>。 默认情况下，<code>nditer</code>将视待迭代遍历的数组为只读对象（read-only），为了在遍历数组的同时，实现对数组元素值得修改，必须指定<code>readwrite</code>或者<code>writeonly</code>的模式。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"> </span><br><span class="line">a = np.arange(<span class="number">0</span>,<span class="number">60</span>,<span class="number">5</span>) </span><br><span class="line">a = a.reshape(<span class="number">3</span>,<span class="number">4</span>)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;原始数组是：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> np.nditer(a, op_flags=[<span class="string">&#x27;readwrite&#x27;</span>]): </span><br><span class="line">    <span class="comment"># x[...]是修改原numpy元素，x只是个拷贝。</span></span><br><span class="line">    x[...]=<span class="number">2</span>*x </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;修改后的数组是：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">原始数组是：</span><br><span class="line">[[ <span class="number">0</span>  <span class="number">5</span> <span class="number">10</span> <span class="number">15</span>]</span><br><span class="line"> [<span class="number">20</span> <span class="number">25</span> <span class="number">30</span> <span class="number">35</span>]</span><br><span class="line"> [<span class="number">40</span> <span class="number">45</span> <span class="number">50</span> <span class="number">55</span>]]</span><br><span class="line"></span><br><span class="line">修改后的数组是：</span><br><span class="line">[[  <span class="number">0</span>  <span class="number">10</span>  <span class="number">20</span>  <span class="number">30</span>]</span><br><span class="line"> [ <span class="number">40</span>  <span class="number">50</span>  <span class="number">60</span>  <span class="number">70</span>]</span><br><span class="line"> [ <span class="number">80</span>  <span class="number">90</span> <span class="number">100</span> <span class="number">110</span>]]</span><br></pre></td></tr></table></figure><p>（3）使用外部循环</p><p><code>nditer</code>类的构造器拥有flags参数，它可以接受下列值：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>c_index</code></td><td>可以跟踪C顺序的索引</td></tr><tr><td><code>f_index</code></td><td>可以跟踪Fortran顺序的索引</td></tr><tr><td><code>multi_index</code></td><td>每次迭代可以跟踪一种索引类型</td></tr><tr><td><code>external_loop</code></td><td>给出的值是具有多个值的一维数组，而不是零维数组</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 迭代器遍历对应于每列，并组合为一维数组</span></span><br><span class="line"><span class="comment"># 当数组的order与在循环中指定的order顺序不同时，打印为多个一维数组，当相同时，是整个一个一维数组。</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line">a = np.arange(<span class="number">0</span>,<span class="number">60</span>,<span class="number">5</span>) </span><br><span class="line">a = a.reshape(<span class="number">3</span>,<span class="number">4</span>)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;原始数组是：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;修改后的数组(F风格)是：&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> np.nditer(a, flags = [<span class="string">&#x27;external_loop&#x27;</span>], order = <span class="string">&#x27;F&#x27;</span>):  </span><br><span class="line">   <span class="built_in">print</span>(x, end=<span class="string">&quot;, &quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;修改后的数组(C风格)是：&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> y <span class="keyword">in</span> np.nditer(a, flags = [<span class="string">&#x27;external_loop&#x27;</span>], order = <span class="string">&#x27;C&#x27;</span>):  </span><br><span class="line">   <span class="built_in">print</span>(y, end=<span class="string">&quot;, &quot;</span>)</span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">原始数组是：</span><br><span class="line">[[ <span class="number">0</span>  <span class="number">5</span> <span class="number">10</span> <span class="number">15</span>]</span><br><span class="line"> [<span class="number">20</span> <span class="number">25</span> <span class="number">30</span> <span class="number">35</span>]</span><br><span class="line"> [<span class="number">40</span> <span class="number">45</span> <span class="number">50</span> <span class="number">55</span>]]</span><br><span class="line"></span><br><span class="line">修改后的数组(F风格)是：</span><br><span class="line">[ <span class="number">0</span> <span class="number">20</span> <span class="number">40</span>], [ <span class="number">5</span> <span class="number">25</span> <span class="number">45</span>], [<span class="number">10</span> <span class="number">30</span> <span class="number">50</span>], [<span class="number">15</span> <span class="number">35</span> <span class="number">55</span>], </span><br><span class="line"></span><br><span class="line">修改后的数组(C风格)是：</span><br><span class="line">[ <span class="number">0</span>  <span class="number">5</span> <span class="number">10</span> <span class="number">15</span> <span class="number">20</span> <span class="number">25</span> <span class="number">30</span> <span class="number">35</span> <span class="number">40</span> <span class="number">45</span> <span class="number">50</span> <span class="number">55</span>], </span><br></pre></td></tr></table></figure><p>（4）广播迭代</p><p>如果两个数组是可广播的，<code>nditer</code>组合对象能够同时迭代它们。 假设数组a的维度为3X4，数组b的维度为1X4 ，则使用以下迭代器（数组b被广播到a的大小）。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"> </span><br><span class="line">a = np.arange(<span class="number">0</span>,<span class="number">60</span>,<span class="number">5</span>) </span><br><span class="line">a = a.reshape(<span class="number">3</span>,<span class="number">4</span>)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;第一个数组为：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;第二个数组为：&#x27;</span>)</span><br><span class="line">b = np.array([<span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>,  <span class="number">4</span>], dtype = <span class="built_in">int</span>)  </span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;修改后的数组为：&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> x,y <span class="keyword">in</span> np.nditer([a,b]):  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;%d:%d&quot;</span>%(x,y), end=<span class="string">&quot;, &quot;</span>)</span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">第一个数组为：</span><br><span class="line">[[ <span class="number">0</span>  <span class="number">5</span> <span class="number">10</span> <span class="number">15</span>]</span><br><span class="line"> [<span class="number">20</span> <span class="number">25</span> <span class="number">30</span> <span class="number">35</span>]</span><br><span class="line"> [<span class="number">40</span> <span class="number">45</span> <span class="number">50</span> <span class="number">55</span>]]</span><br><span class="line"></span><br><span class="line">第二个数组为：</span><br><span class="line">[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">修改后的数组为：</span><br><span class="line"><span class="number">0</span>:<span class="number">1</span>, <span class="number">5</span>:<span class="number">2</span>, <span class="number">10</span>:<span class="number">3</span>, <span class="number">15</span>:<span class="number">4</span>, <span class="number">20</span>:<span class="number">1</span>, <span class="number">25</span>:<span class="number">2</span>, <span class="number">30</span>:<span class="number">3</span>, <span class="number">35</span>:<span class="number">4</span>, <span class="number">40</span>:<span class="number">1</span>, <span class="number">45</span>:<span class="number">2</span>, <span class="number">50</span>:<span class="number">3</span>, <span class="number">55</span>:<span class="number">4</span>, </span><br></pre></td></tr></table></figure><h3 id="👀NumPy数组操作"><a href="#👀NumPy数组操作" class="headerlink" title="👀NumPy数组操作"></a>👀NumPy数组操作</h3><p><code>Numpy</code>中包含了一些函数用于处理数组，大概可分为以下几类：</p><h4 id="👁修改数组形状"><a href="#👁修改数组形状" class="headerlink" title="👁修改数组形状"></a>👁修改数组形状</h4><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td><code>reshape</code></td><td>不改变数据的条件下修改形状</td></tr><tr><td><code>flat</code></td><td>数组元素迭代器</td></tr><tr><td><code>flatten</code></td><td>返回一份数组拷贝，对拷贝所做的修改不会影响原始数组</td></tr><tr><td><code>ravel</code></td><td>返回展开数组</td></tr></tbody></table><h4 id="👁翻转数组"><a href="#👁翻转数组" class="headerlink" title="👁翻转数组"></a>👁翻转数组</h4><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td><code>transpose</code></td><td>对换数组的维度</td></tr><tr><td><code>ndarray.T</code></td><td>和 <code>self.transpose()</code> 相同</td></tr><tr><td><code>rollaxis</code></td><td>向后滚动指定的轴</td></tr><tr><td><code>swapaxes</code></td><td>对换数组的两个轴</td></tr></tbody></table><h4 id="👁修改数组维度"><a href="#👁修改数组维度" class="headerlink" title="👁修改数组维度"></a>👁修改数组维度</h4><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td><code>broadcast</code></td><td>产生模仿广播的对象</td></tr><tr><td><code>broadcast_to</code></td><td>将数组广播到新形状</td></tr><tr><td><code>expand_dims</code></td><td>扩展数组的形状</td></tr><tr><td><code>squeeze</code></td><td>从数组的形状中删除一维条目</td></tr></tbody></table><h4 id="👁连接数组"><a href="#👁连接数组" class="headerlink" title="👁连接数组"></a>👁连接数组</h4><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td><code>concatenate</code></td><td>连接沿现有轴的数组序列</td></tr><tr><td><code>stack</code></td><td>沿着新的轴加入一系列数组。</td></tr><tr><td><code>hstack</code></td><td>水平堆叠序列中的数组（列方向）</td></tr><tr><td><code>vstack</code></td><td>竖直堆叠序列中的数组（行方向）</td></tr></tbody></table><h4 id="👁分割数组"><a href="#👁分割数组" class="headerlink" title="👁分割数组"></a>👁分割数组</h4><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td><code>split</code></td><td>将一个数组分割为多个子数组</td></tr><tr><td><code>hsplit</code></td><td>将一个数组水平分割为多个子数组（按列）</td></tr><tr><td><code>vsplit</code></td><td>将一个数组垂直分割为多个子数组（按行）</td></tr></tbody></table><h4 id="👁数组元素的添加与删除"><a href="#👁数组元素的添加与删除" class="headerlink" title="👁数组元素的添加与删除"></a>👁数组元素的添加与删除</h4><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td><code>resize</code></td><td>返回指定形状的新数组</td></tr><tr><td><code>append</code></td><td>将值添加到数组末尾</td></tr><tr><td><code>insert</code></td><td>沿指定轴将值插入到指定下标之前</td></tr><tr><td><code>delete</code></td><td>删掉某个轴的子数组，并返回删除后的新数组</td></tr><tr><td><code>unique</code></td><td>查找数组内的唯一元素</td></tr></tbody></table><h3 id="👀NumPy位运算"><a href="#👀NumPy位运算" class="headerlink" title="👀NumPy位运算"></a>👀NumPy位运算</h3><p><code>NumPy</code><strong>“bitwise_”</strong> 开头的函数是位运算函数。<code>NumPy</code>位运算包括以下几个函数：</p><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td><code>bitwise_and</code></td><td>对数组元素执行位与操作</td></tr><tr><td><code>bitwise_or</code></td><td>对数组元素执行位或操作</td></tr><tr><td><code>invert</code></td><td>按位取反</td></tr><tr><td><code>left_shift</code></td><td>向左移动二进制表示的位，相当于右侧附加相等数量的0</td></tr><tr><td><code>right_shift</code></td><td>向右移动二进制表示的位，相当于左侧附加相等数量的0</td></tr></tbody></table><p><code>bitwise_and()</code>函数对数组中整数的二进制形式执行位与运算。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;13和17的二进制形式：&#x27;</span>)</span><br><span class="line">a,b = <span class="number">13</span>,<span class="number">17</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">bin</span>(a), <span class="built_in">bin</span>(b))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;13和17的位与：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.bitwise_and(<span class="number">13</span>, <span class="number">17</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="number">13</span>和<span class="number">17</span>的二进制形式：</span><br><span class="line"><span class="number">0b1101</span> <span class="number">0b10001</span></span><br><span class="line"></span><br><span class="line"><span class="number">13</span>和<span class="number">17</span>的位与：</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p><code>bitwise_or()</code>函数对数组中整数的二进制形式执行位或运算。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"> </span><br><span class="line">a,b = <span class="number">13</span>,<span class="number">17</span> </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;13和17的二进制形式：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">bin</span>(a), <span class="built_in">bin</span>(b))</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;13和17的位或：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.bitwise_or(<span class="number">13</span>, <span class="number">17</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="number">13</span>和<span class="number">17</span>的二进制形式：</span><br><span class="line"><span class="number">0b1101</span> <span class="number">0b10001</span></span><br><span class="line"><span class="number">13</span>和<span class="number">17</span>的位或：</span><br><span class="line"><span class="number">29</span></span><br></pre></td></tr></table></figure><p><code>invert()</code>函数对数组中整数进行位取反运算，即0变成1，1变成0。对于有符号整数，取该二进制数的补码，然后 +1。二进制数，最高位为0表示正数，最高位为1表示负数。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;13的位反转，其中ndarray的dtype是uint8：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.invert(np.array([<span class="number">13</span>], dtype = np.uint8)))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="comment"># 比较13和242的二进制表示，我们发现了位的反转</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;13的二进制表示：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.binary_repr(<span class="number">13</span>, width = <span class="number">8</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;242的二进制表示：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.binary_repr(<span class="number">242</span>, width = <span class="number">8</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="number">13</span>的位反转，其中ndarray的dtype是uint8：</span><br><span class="line">[<span class="number">242</span>]</span><br><span class="line"></span><br><span class="line"><span class="number">13</span>的二进制表示：</span><br><span class="line">00001101</span><br><span class="line"></span><br><span class="line"><span class="number">242</span>的二进制表示：</span><br><span class="line"><span class="number">11110010</span></span><br></pre></td></tr></table></figure><p><code>left_shift()</code>函数将数组元素的二进制形式向左移动到指定位置，右侧附加相等数量的0。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;将10左移两位：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.left_shift(<span class="number">10</span>,<span class="number">2</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;10的二进制表示：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.binary_repr(<span class="number">10</span>, width = <span class="number">8</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;40的二进制表示：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.binary_repr(<span class="number">40</span>, width = <span class="number">8</span>))</span><br><span class="line"><span class="comment"># &#x27;00001010&#x27; 中的两位移动到了左边，并在右边添加了两个0。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">将<span class="number">10</span>左移两位：</span><br><span class="line"><span class="number">40</span></span><br><span class="line"></span><br><span class="line"><span class="number">10</span>的二进制表示：</span><br><span class="line"><span class="number">0000</span>1010</span><br><span class="line"></span><br><span class="line"><span class="number">40</span>的二进制表示：</span><br><span class="line"><span class="number">00</span>101000</span><br></pre></td></tr></table></figure><p><code>right_shift()</code>函数将数组元素的二进制形式向右移动到指定位置，左侧附加相等数量的0。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;将40右移两位：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.right_shift(<span class="number">40</span>,<span class="number">2</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;40的二进制表示：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.binary_repr(<span class="number">40</span>, width = <span class="number">8</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;10的二进制表示：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.binary_repr(<span class="number">10</span>, width = <span class="number">8</span>))</span><br><span class="line"><span class="comment"># &#x27;00001010&#x27;中的两位移动到了右边，并在左边添加了两个0。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">将<span class="number">40</span>右移两位：</span><br><span class="line"><span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="number">40</span>的二进制表示：</span><br><span class="line"><span class="number">00</span>101000</span><br><span class="line"></span><br><span class="line"><span class="number">10</span>的二进制表示：</span><br><span class="line"><span class="number">0000</span>1010</span><br></pre></td></tr></table></figure><h3 id="👀NumPy字符串函数"><a href="#👀NumPy字符串函数" class="headerlink" title="👀NumPy字符串函数"></a>👀NumPy字符串函数</h3><p>以下函数用于对<code>dtype</code>为<code>numpy.string_</code>或<code>numpy.unicode_</code>的数组执行向量化字符串操作。 它们基于Python 内置库中的标准字符串函数。这些函数在字符数组类（<code>numpy.char</code>）中定义。</p><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td><code>add()</code></td><td>对两个数组的逐个字符串元素进行连接</td></tr><tr><td><code>multiply()</code></td><td>返回按元素多重连接后的字符串</td></tr><tr><td><code>center()</code></td><td>居中字符串</td></tr><tr><td><code>capitalize()</code></td><td>将字符串第一个字母转换为大写</td></tr><tr><td><code>title()</code></td><td>将字符串的每个单词的第一个字母转换为大写</td></tr><tr><td><code>lower()</code></td><td>数组元素转换为小写</td></tr><tr><td><code>upper()</code></td><td>数组元素转换为大写</td></tr><tr><td><code>split()</code></td><td>指定分隔符对字符串进行分割，并返回数组列表</td></tr><tr><td><code>splitlines()</code></td><td>返回元素中的行列表，以换行符分割</td></tr><tr><td><code>strip()</code></td><td>移除元素开头或者结尾处的特定字符</td></tr><tr><td><code>join()</code></td><td>通过指定分隔符来连接数组中的元素</td></tr><tr><td><code>replace()</code></td><td>使用新字符串替换字符串中的所有子字符串</td></tr><tr><td><code>decode()</code></td><td>数组元素依次调用<code>str.decode</code></td></tr><tr><td><code>encode()</code></td><td>数组元素依次调用<code>str.encode</code></td></tr></tbody></table><p><code>numpy.char.add()</code>函数依次对两个数组的元素进行字符串连接。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;连接两个字符串：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.char.add([<span class="string">&#x27;hello&#x27;</span>],[<span class="string">&#x27; xyz&#x27;</span>]))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;连接示例：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.char.add([<span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27;hi&#x27;</span>],[<span class="string">&#x27; abc&#x27;</span>, <span class="string">&#x27; xyz&#x27;</span>]))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">连接两个字符串：</span><br><span class="line">[<span class="string">&#x27;hello xyz&#x27;</span>]</span><br><span class="line"></span><br><span class="line">连接示例：</span><br><span class="line">[<span class="string">&#x27;hello abc&#x27;</span> <span class="string">&#x27;hi xyz&#x27;</span>]</span><br></pre></td></tr></table></figure><p><code>numpy.char.multiply()</code>函数执行多重连接。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(np.char.multiply(<span class="string">&#x27;Runoob &#x27;</span>,<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">Runoob Runoob Runoob </span><br></pre></td></tr></table></figure><p><code>numpy.char.center()</code>函数用于将字符串居中，并使用指定字符在左侧和右侧进行填充。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"> </span><br><span class="line"><span class="comment"># np.char.center(str , width,fillchar) ：</span></span><br><span class="line"><span class="comment"># str: 字符串，width: 长度，fillchar: 填充字符</span></span><br><span class="line"><span class="built_in">print</span>(np.char.center(<span class="string">&#x27;Runoob&#x27;</span>, <span class="number">20</span>,fillchar = <span class="string">&#x27;*&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">*******Runoob*******</span><br></pre></td></tr></table></figure><p><code>numpy.char.capitalize()</code>函数将字符串的第一个字母转换为大写。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(np.char.capitalize(<span class="string">&#x27;runoob&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">Runoob</span><br></pre></td></tr></table></figure><p><code>numpy.char.title()</code>函数将字符串的每个单词的第一个字母转换为大写。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(np.char.title(<span class="string">&#x27;i like runoob&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">I Like Runoob</span><br></pre></td></tr></table></figure><p><code>numpy.char.lower()</code>函数对数组的每个元素转换为小写。它对每个元素调用str.lower。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"> </span><br><span class="line"><span class="comment">#操作数组</span></span><br><span class="line"><span class="built_in">print</span>(np.char.lower([<span class="string">&#x27;RUNOOB&#x27;</span>,<span class="string">&#x27;GOOGLE&#x27;</span>]))</span><br><span class="line"><span class="comment"># 操作字符串</span></span><br><span class="line"><span class="built_in">print</span>(np.char.lower(<span class="string">&#x27;RUNOOB&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[<span class="string">&#x27;runoob&#x27;</span> <span class="string">&#x27;google&#x27;</span>]</span><br><span class="line">runoob</span><br></pre></td></tr></table></figure><p><code>numpy.char.upper()</code>函数对数组的每个元素转换为大写。它对每个元素调用 str.upper。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"> </span><br><span class="line"><span class="comment">#操作数组</span></span><br><span class="line"><span class="built_in">print</span>(np.char.upper([<span class="string">&#x27;runoob&#x27;</span>,<span class="string">&#x27;google&#x27;</span>]))</span><br><span class="line"><span class="comment"># 操作字符串</span></span><br><span class="line"><span class="built_in">print</span>(np.char.upper(<span class="string">&#x27;runoob&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[<span class="string">&#x27;RUNOOB&#x27;</span> <span class="string">&#x27;GOOGLE&#x27;</span>]</span><br><span class="line">RUNOOB</span><br></pre></td></tr></table></figure><p><code>numpy.char.split()</code>通过指定分隔符对字符串进行分割，并返回数组。默认情况下，分隔符为空格。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"> </span><br><span class="line"><span class="comment"># 分隔符默认为空格</span></span><br><span class="line"><span class="built_in">print</span>(np.char.split(<span class="string">&#x27;i like runoob?&#x27;</span>))</span><br><span class="line"><span class="comment"># 分隔符为.</span></span><br><span class="line"><span class="built_in">print</span>(np.char.split(<span class="string">&#x27;www.runoob.com&#x27;</span>, sep = <span class="string">&#x27;.&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[<span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;like&#x27;</span>, <span class="string">&#x27;runoob?&#x27;</span>]</span><br><span class="line">[<span class="string">&#x27;www&#x27;</span>, <span class="string">&#x27;runoob&#x27;</span>, <span class="string">&#x27;com&#x27;</span>]</span><br></pre></td></tr></table></figure><p><code>numpy.char.splitlines()</code>函数以换行符作为分隔符来分割字符串，并返回数组。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"><span class="comment"># \n，\r，\r\n 都可用作换行符。</span></span><br><span class="line"><span class="comment"># 换行符\n</span></span><br><span class="line"><span class="built_in">print</span>(np.char.splitlines(<span class="string">&#x27;i\nlike runoob?&#x27;</span>)) </span><br><span class="line"><span class="built_in">print</span>(np.char.splitlines(<span class="string">&#x27;i\rlike runoob?&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[<span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;like runoob?&#x27;</span>]</span><br><span class="line">[<span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;like runoob?&#x27;</span>]</span><br></pre></td></tr></table></figure><p><code>numpy.char.strip()</code>函数用于移除开头或结尾处的特定字符。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"> </span><br><span class="line"><span class="comment"># 移除字符串头尾的a字符</span></span><br><span class="line"><span class="built_in">print</span>(np.char.strip(<span class="string">&#x27;ashok arunooba&#x27;</span>,<span class="string">&#x27;a&#x27;</span>))</span><br><span class="line"><span class="comment"># 移除数组元素头尾的a字符</span></span><br><span class="line"><span class="built_in">print</span>(np.char.strip([<span class="string">&#x27;arunooba&#x27;</span>,<span class="string">&#x27;admin&#x27;</span>,<span class="string">&#x27;java&#x27;</span>],<span class="string">&#x27;a&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">shok arunoob</span><br><span class="line">[<span class="string">&#x27;runoob&#x27;</span> <span class="string">&#x27;dmin&#x27;</span> <span class="string">&#x27;jav&#x27;</span>]</span><br></pre></td></tr></table></figure><p><code>numpy.char.join()</code>函数通过指定分隔符来连接数组中的元素或字符串</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"> </span><br><span class="line"><span class="comment"># 操作字符串</span></span><br><span class="line"><span class="built_in">print</span>(np.char.join(<span class="string">&#x27;:&#x27;</span>,<span class="string">&#x27;runoob&#x27;</span>))</span><br><span class="line"><span class="comment"># 指定多个分隔符操作数组元素</span></span><br><span class="line"><span class="built_in">print</span>(np.char.join([<span class="string">&#x27;:&#x27;</span>,<span class="string">&#x27;-&#x27;</span>],[<span class="string">&#x27;runoob&#x27;</span>,<span class="string">&#x27;google&#x27;</span>]))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">r:u:n:o:o:b</span><br><span class="line">[<span class="string">&#x27;r:u:n:o:o:b&#x27;</span> <span class="string">&#x27;g-o-o-g-l-e&#x27;</span>]</span><br></pre></td></tr></table></figure><p><code>numpy.char.replace()</code>函数使用新字符串替换字符串中的所有子字符串。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(np.char.replace(<span class="string">&#x27;i like runoob&#x27;</span>, <span class="string">&#x27;oo&#x27;</span>, <span class="string">&#x27;cc&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">i like runccb</span><br></pre></td></tr></table></figure><p><code>numpy.char.encode()</code>函数对数组中的每个元素调用<code>str.encode</code>函数。 默认编码是utf-8，可以使用标准Python库中的编解码器。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"> </span><br><span class="line">a = np.char.encode(<span class="string">&#x27;runoob&#x27;</span>, <span class="string">&#x27;cp500&#x27;</span>) </span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="string">b&#x27;\x99\xa4\x95\x96\x96\x82&#x27;</span></span><br></pre></td></tr></table></figure><p><code>numpy.char.decode()</code>函数对编码的元素进行<code>str.decode()</code>解码。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"> </span><br><span class="line">a = np.char.encode(<span class="string">&#x27;runoob&#x27;</span>, <span class="string">&#x27;cp500&#x27;</span>) </span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(np.char.decode(a,<span class="string">&#x27;cp500&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="string">b&#x27;\x99\xa4\x95\x96\x96\x82&#x27;</span></span><br><span class="line">runoob</span><br></pre></td></tr></table></figure><h3 id="👀NumPy数学函数"><a href="#👀NumPy数学函数" class="headerlink" title="👀NumPy数学函数"></a>👀NumPy数学函数</h3><p><code>NumPy</code>包含大量的各种数学运算的函数，包括三角函数，算术运算的函数，复数处理函数等。</p><p>（1）三角函数</p><p>NumPy提供了标准的三角函数：sin()、cos()、tan()。arcsin，arccos，和arctan函数返回给定角度的sin，cos和tan的反三角函数。这些函数的结果可以通过<code>numpy.degrees()</code>函数将弧度转换为角度。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"> </span><br><span class="line">a = np.array([<span class="number">0</span>,<span class="number">30</span>,<span class="number">45</span>,<span class="number">60</span>,<span class="number">90</span>])  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;含有正弦值的数组：&#x27;</span>)</span><br><span class="line">sin = np.sin(a*np.pi/<span class="number">180</span>)  </span><br><span class="line"><span class="built_in">print</span>(sin)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;计算角度的反正弦，返回值以弧度为单位：&#x27;</span>)</span><br><span class="line">inv = np.arcsin(sin)  </span><br><span class="line"><span class="built_in">print</span>(inv)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;通过转化为角度制来检查结果：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.degrees(inv))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">含有正弦值的数组：</span><br><span class="line">[<span class="number">0.</span>         <span class="number">0.5</span>        <span class="number">0.70710678</span> <span class="number">0.8660254</span>  <span class="number">1.</span>        ]</span><br><span class="line"></span><br><span class="line">计算角度的反正弦，返回值以弧度为单位：</span><br><span class="line">[<span class="number">0.</span>         <span class="number">0.52359878</span> <span class="number">0.78539816</span> <span class="number">1.04719755</span> <span class="number">1.57079633</span>]</span><br><span class="line"></span><br><span class="line">通过转化为角度制来检查结果：</span><br><span class="line">[ <span class="number">0.</span> <span class="number">30.</span> <span class="number">45.</span> <span class="number">60.</span> <span class="number">90.</span>]</span><br></pre></td></tr></table></figure><p>（2）舍入函数</p><p><code>numpy.around()</code>函数返回指定数字的四舍五入值。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numpy.around(a,decimals)</span><br><span class="line">参数说明：</span><br><span class="line">    a: 数组</span><br><span class="line">    decimals: 舍入的小数位数。默认值为<span class="number">0</span>。如果为负，整数将四舍五入到小数点左侧的位置。例如decimals为-<span class="number">1</span>，代表舍入到十位，<span class="number">13</span>舍入为<span class="number">10</span>,<span class="number">16</span>舍入为<span class="number">20</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"> </span><br><span class="line">a = np.array([<span class="number">1.0</span>,<span class="number">5.55</span>,<span class="number">123</span>,<span class="number">0.567</span>,<span class="number">25.532</span>])  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;原数组：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;舍入后：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.around(a))</span><br><span class="line"><span class="built_in">print</span>(np.around(a, decimals = <span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(np.around(a, decimals = -<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">原数组：</span><br><span class="line">[<span class="number">1.</span><span class="number">5.55</span>  <span class="number">123.</span><span class="number">0.567</span>  <span class="number">25.532</span>]</span><br><span class="line"></span><br><span class="line">舍入后：</span><br><span class="line">[<span class="number">1.</span>  <span class="number">6.</span> <span class="number">123.</span>   <span class="number">1.</span>  <span class="number">26.</span>]</span><br><span class="line">[<span class="number">1.</span>  <span class="number">5.6</span> <span class="number">123.</span>    <span class="number">0.6</span>  <span class="number">25.5</span>]</span><br><span class="line">[<span class="number">0.</span>  <span class="number">10.</span> <span class="number">120.</span>   <span class="number">0.</span>  <span class="number">30.</span>]</span><br></pre></td></tr></table></figure><p><code>numpy.floor()</code>返回小于或者等于指定表达式的最大整数，即向下取整。</p><p><code>numpy.ceil()</code>返回大于或者等于指定表达式的最小整数，即向上取整。</p><h3 id="👀NumPy算术函数"><a href="#👀NumPy算术函数" class="headerlink" title="👀NumPy算术函数"></a>👀NumPy算术函数</h3><p><code>NumPy</code>算术函数包含简单的加减乘除: add()，subtract()，multiply()和divide()。需要注意的是数组必须具有相同的形状或符合数组广播规则。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"> </span><br><span class="line">a = np.arange(<span class="number">9</span>, dtype = np.float_).reshape(<span class="number">3</span>,<span class="number">3</span>)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;第一个数组：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;第二个数组：&#x27;</span>)</span><br><span class="line">b = np.array([<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>])  </span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;两个数组相加：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.add(a,b))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;两个数组相减：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.subtract(a,b))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;两个数组相乘：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.multiply(a,b))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;两个数组相除：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.divide(a,b))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">第一个数组：</span><br><span class="line">[[<span class="number">0.</span> <span class="number">1.</span> <span class="number">2.</span>]</span><br><span class="line"> [<span class="number">3.</span> <span class="number">4.</span> <span class="number">5.</span>]</span><br><span class="line"> [<span class="number">6.</span> <span class="number">7.</span> <span class="number">8.</span>]]</span><br><span class="line"></span><br><span class="line">第二个数组：</span><br><span class="line">[<span class="number">10</span> <span class="number">10</span> <span class="number">10</span>]</span><br><span class="line"></span><br><span class="line">两个数组相加：</span><br><span class="line">[[<span class="number">10.</span> <span class="number">11.</span> <span class="number">12.</span>]</span><br><span class="line"> [<span class="number">13.</span> <span class="number">14.</span> <span class="number">15.</span>]</span><br><span class="line"> [<span class="number">16.</span> <span class="number">17.</span> <span class="number">18.</span>]]</span><br><span class="line"></span><br><span class="line">两个数组相减：</span><br><span class="line">[[-<span class="number">10.</span>  -<span class="number">9.</span>  -<span class="number">8.</span>]</span><br><span class="line"> [ -<span class="number">7.</span>  -<span class="number">6.</span>  -<span class="number">5.</span>]</span><br><span class="line"> [ -<span class="number">4.</span>  -<span class="number">3.</span>  -<span class="number">2.</span>]]</span><br><span class="line"></span><br><span class="line">两个数组相乘：</span><br><span class="line">[[ <span class="number">0.</span> <span class="number">10.</span> <span class="number">20.</span>]</span><br><span class="line"> [<span class="number">30.</span> <span class="number">40.</span> <span class="number">50.</span>]</span><br><span class="line"> [<span class="number">60.</span> <span class="number">70.</span> <span class="number">80.</span>]]</span><br><span class="line"></span><br><span class="line">两个数组相除：</span><br><span class="line">[[<span class="number">0.</span>  <span class="number">0.1</span> <span class="number">0.2</span>]</span><br><span class="line"> [<span class="number">0.3</span> <span class="number">0.4</span> <span class="number">0.5</span>]</span><br><span class="line"> [<span class="number">0.6</span> <span class="number">0.7</span> <span class="number">0.8</span>]]</span><br></pre></td></tr></table></figure><p><code>numpy.reciprocal()</code>函数返回参数逐元素的倒数。如 <strong>1&#x2F;4</strong> 倒数为 <strong>4&#x2F;1</strong>。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"> </span><br><span class="line">a = np.array([<span class="number">0.25</span>,  <span class="number">1.33</span>,  <span class="number">1</span>,  <span class="number">100</span>])  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;我们的数组是：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;调用 reciprocal 函数：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.reciprocal(a))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">我们的数组是：</span><br><span class="line">[<span class="number">0.25</span>  <span class="number">1.33</span>  <span class="number">1.</span>  <span class="number">100.</span>]</span><br><span class="line"></span><br><span class="line">调用 reciprocal 函数：</span><br><span class="line">[<span class="number">4.</span><span class="number">0.7518797</span><span class="number">1.</span><span class="number">0.01</span>]</span><br></pre></td></tr></table></figure><p><code>numpy.power()</code>函数将第一个输入数组中的元素作为底数，计算它与第二个输入数组中相应元素的幂。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"> </span><br><span class="line">a = np.array([<span class="number">10</span>,<span class="number">100</span>,<span class="number">1000</span>])  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;我们的数组是；&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;调用 power 函数：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.power(a,<span class="number">2</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;第二个数组：&#x27;</span>)</span><br><span class="line">b = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])  </span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;再次调用 power 函数：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.power(a,b))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">我们的数组是；</span><br><span class="line">[<span class="number">10</span><span class="number">100</span> <span class="number">1000</span>]</span><br><span class="line"></span><br><span class="line">调用power函数：</span><br><span class="line">[<span class="number">100</span><span class="number">10000</span><span class="number">1000000</span>]</span><br><span class="line"></span><br><span class="line">第二个数组：</span><br><span class="line">[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">再次调用 power 函数：</span><br><span class="line">[<span class="number">10</span><span class="number">10000</span> <span class="number">1000000000</span>]</span><br></pre></td></tr></table></figure><p><code>numpy.mod()</code>计算输入数组中相应元素的相除后的余数。 函数<code>numpy.remainder()</code>也产生相同的结果。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"> </span><br><span class="line">a = np.array([<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>]) </span><br><span class="line">b = np.array([<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>])  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;第一个数组：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;第二个数组：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;调用 mod() 函数：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.mod(a,b))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;调用 remainder() 函数：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.remainder(a,b))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">第一个数组：</span><br><span class="line">[<span class="number">10</span> <span class="number">20</span> <span class="number">30</span>]</span><br><span class="line"></span><br><span class="line">第二个数组：</span><br><span class="line">[<span class="number">3</span> <span class="number">5</span> <span class="number">7</span>]</span><br><span class="line"></span><br><span class="line">调用mod()函数：</span><br><span class="line">[<span class="number">1</span> <span class="number">0</span> <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">调用remainder()函数：</span><br><span class="line">[<span class="number">1</span> <span class="number">0</span> <span class="number">2</span>]</span><br></pre></td></tr></table></figure><h3 id="👀NumPy统计函数"><a href="#👀NumPy统计函数" class="headerlink" title="👀NumPy统计函数"></a>👀NumPy统计函数</h3><p><code>NumPy</code>提供了很多统计函数，用于从数组中查找<strong>最小元素</strong>，<strong>最大元素</strong>，<strong>百分位标准差</strong>和<strong>方差</strong>等。 函数说明如下：</p><p><code>numpy.amin()</code>用于计算数组中的元素沿指定轴的最小值。</p><p><code>numpy.amax()</code>用于计算数组中的元素沿指定轴的最大值。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"> </span><br><span class="line">a = np.array([[<span class="number">3</span>,<span class="number">7</span>,<span class="number">5</span>],[<span class="number">8</span>,<span class="number">4</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">4</span>,<span class="number">9</span>]])  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;我们的数组是：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;调用amin()函数：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.amin(a,<span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;再次调用amin()函数：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.amin(a,<span class="number">0</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;调用amax()函数：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.amax(a))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;再次调用amax()函数：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.amax(a, axis = <span class="number">0</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">我们的数组是：</span><br><span class="line">[[<span class="number">3</span> <span class="number">7</span> <span class="number">5</span>]</span><br><span class="line"> [<span class="number">8</span> <span class="number">4</span> <span class="number">3</span>]</span><br><span class="line"> [<span class="number">2</span> <span class="number">4</span> <span class="number">9</span>]]</span><br><span class="line"></span><br><span class="line">调用amin()函数：</span><br><span class="line">[<span class="number">3</span> <span class="number">3</span> <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">再次调用amin()函数：</span><br><span class="line">[<span class="number">2</span> <span class="number">4</span> <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">调用amax()函数：</span><br><span class="line"><span class="number">9</span></span><br><span class="line"></span><br><span class="line">再次调用amax()函数：</span><br><span class="line">[<span class="number">8</span> <span class="number">7</span> <span class="number">9</span>]</span><br></pre></td></tr></table></figure><p><code>numpy.ptp()</code>函数计算数组中元素最大值与最小值的差（最大值 - 最小值）。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"> </span><br><span class="line">a = np.array([[<span class="number">3</span>,<span class="number">7</span>,<span class="number">5</span>],[<span class="number">8</span>,<span class="number">4</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">4</span>,<span class="number">9</span>]])  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;我们的数组是：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;调用ptp()函数：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.ptp(a))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;沿轴1调用ptp()函数：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.ptp(a, axis = <span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;沿轴0调用ptp()函数：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.ptp(a, axis = <span class="number">0</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">我们的数组是：</span><br><span class="line">[[<span class="number">3</span> <span class="number">7</span> <span class="number">5</span>]</span><br><span class="line"> [<span class="number">8</span> <span class="number">4</span> <span class="number">3</span>]</span><br><span class="line"> [<span class="number">2</span> <span class="number">4</span> <span class="number">9</span>]]</span><br><span class="line"></span><br><span class="line">调用ptp()函数：</span><br><span class="line"><span class="number">7</span></span><br><span class="line"></span><br><span class="line">沿轴<span class="number">1</span>调用ptp()函数：</span><br><span class="line">[<span class="number">4</span> <span class="number">5</span> <span class="number">7</span>]</span><br><span class="line"></span><br><span class="line">沿轴<span class="number">0</span>调用ptp()函数：</span><br><span class="line">[<span class="number">6</span> <span class="number">3</span> <span class="number">6</span>]</span><br></pre></td></tr></table></figure><p>百分位数是统计中使用的度量，表示小于这个值的观察值的百分比。 函数<code>numpy.percentile()</code>接受以下参数。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numpy.percentile(a, q, axis)</span><br><span class="line">参数说明：</span><br><span class="line">    a: 输入数组</span><br><span class="line">    q: 要计算的百分位数，在<span class="number">0</span>~<span class="number">100</span>之间</span><br><span class="line">    axis: 沿着它计算百分位数的轴</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"> </span><br><span class="line">a = np.array([[<span class="number">10</span>, <span class="number">7</span>, <span class="number">4</span>], [<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;我们的数组是：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;调用percentile()函数：&#x27;</span>)</span><br><span class="line"><span class="comment"># 50%的分位数，就是a里排序之后的中位数</span></span><br><span class="line"><span class="built_in">print</span>(np.percentile(a,<span class="number">50</span>)) </span><br><span class="line"><span class="comment"># axis为0，在纵列上求</span></span><br><span class="line"><span class="built_in">print</span>(np.percentile(a,<span class="number">50</span>,axis=<span class="number">0</span>)) </span><br><span class="line"><span class="comment"># axis为1，在横行上求</span></span><br><span class="line"><span class="built_in">print</span>(np.percentile(a,<span class="number">50</span>,axis=<span class="number">1</span>)) </span><br><span class="line"><span class="comment"># 保持维度不变</span></span><br><span class="line"><span class="built_in">print</span>(np.percentile(a,<span class="number">50</span>,axis=<span class="number">1</span>,keepdims=<span class="literal">True</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">我们的数组是：</span><br><span class="line">[[<span class="number">10</span>  <span class="number">7</span>  <span class="number">4</span>]</span><br><span class="line"> [ <span class="number">3</span>  <span class="number">2</span>  <span class="number">1</span>]]</span><br><span class="line">调用percentile()函数：</span><br><span class="line"><span class="number">3.5</span></span><br><span class="line">[<span class="number">6.5</span> <span class="number">4.5</span> <span class="number">2.5</span>]</span><br><span class="line">[<span class="number">7.</span> <span class="number">2.</span>]</span><br><span class="line">[[<span class="number">7.</span>]</span><br><span class="line"> [<span class="number">2.</span>]]</span><br></pre></td></tr></table></figure><p><code>numpy.median()</code>函数用于计算数组a中元素的中位数（中值）</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"> </span><br><span class="line">a = np.array([[<span class="number">30</span>,<span class="number">65</span>,<span class="number">70</span>],[<span class="number">80</span>,<span class="number">95</span>,<span class="number">10</span>],[<span class="number">50</span>,<span class="number">90</span>,<span class="number">60</span>]])  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;我们的数组是：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;调用median()函数：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.median(a))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;沿轴0调用median()函数：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.median(a, axis = <span class="number">0</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;沿轴1调用median()函数：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.median(a, axis = <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">我们的数组是：</span><br><span class="line">[[<span class="number">30</span> <span class="number">65</span> <span class="number">70</span>]</span><br><span class="line"> [<span class="number">80</span> <span class="number">95</span> <span class="number">10</span>]</span><br><span class="line"> [<span class="number">50</span> <span class="number">90</span> <span class="number">60</span>]]</span><br><span class="line"></span><br><span class="line">调用median()函数：</span><br><span class="line"><span class="number">65.0</span></span><br><span class="line"></span><br><span class="line">沿轴<span class="number">0</span>调用median()函数：</span><br><span class="line">[<span class="number">50.</span> <span class="number">90.</span> <span class="number">60.</span>]</span><br><span class="line"></span><br><span class="line">沿轴<span class="number">1</span>调用median()函数：</span><br><span class="line">[<span class="number">65.</span> <span class="number">80.</span> <span class="number">60.</span>]</span><br></pre></td></tr></table></figure><p><code>numpy.mean()</code>函数返回数组中元素的算术平均值。 如果提供了轴，则沿其计算。算术平均值是沿轴的元素的总和除以元素的数量。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"> </span><br><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]])  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;我们的数组是：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;调用mean()函数：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.mean(a))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;沿轴0调用mean()函数：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.mean(a, axis = <span class="number">0</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;沿轴1调用mean()函数：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.mean(a, axis = <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">我们的数组是：</span><br><span class="line">[[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]</span><br><span class="line"> [<span class="number">3</span> <span class="number">4</span> <span class="number">5</span>]</span><br><span class="line"> [<span class="number">4</span> <span class="number">5</span> <span class="number">6</span>]]</span><br><span class="line"></span><br><span class="line">调用mean()函数：</span><br><span class="line"><span class="number">3.6666666666666665</span></span><br><span class="line"></span><br><span class="line">沿轴<span class="number">0</span>调用mean()函数：</span><br><span class="line">[<span class="number">2.66666667</span> <span class="number">3.66666667</span> <span class="number">4.66666667</span>]</span><br><span class="line"></span><br><span class="line">沿轴<span class="number">1</span>调用mean()函数：</span><br><span class="line">[<span class="number">2.</span> <span class="number">4.</span> <span class="number">5.</span>]</span><br></pre></td></tr></table></figure><p><code>numpy.average()</code>函数根据在另一个数组中给出的各自的权重计算数组中元素的加权平均值。该函数可以接受一个轴参数。 如果没有指定轴，则数组会被展开。加权平均值即将各数值乘以相应的权数，然后加总求和得到总体值，再除以总的单位数。考虑数组[1,2,3,4]和相应的权重[4,3,2,1]，通过将相应元素的乘积相加，并将和除以权重的和，来计算加权平均值。</p><blockquote><p>加权平均值 &#x3D; (1*4+2*3+3*2+4*1)&#x2F;(4+3+2+1)</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"> </span><br><span class="line">a = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;我们的数组是：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;调用average()函数：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.average(a))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="comment"># 不指定权重时相当于mean函数</span></span><br><span class="line">wts = np.array([<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>])  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;再次调用average()函数：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.average(a,weights = wts))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="comment"># 如果returned参数设为true，则返回权重的和  </span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;权重的和：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.average([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],weights = [<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>], returned = <span class="literal">True</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">我们的数组是：</span><br><span class="line">[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">调用average()函数：</span><br><span class="line"><span class="number">2.5</span></span><br><span class="line"></span><br><span class="line">再次调用average()函数：</span><br><span class="line"><span class="number">2.0</span></span><br><span class="line"></span><br><span class="line">权重的和：</span><br><span class="line">(<span class="number">2.0</span>, <span class="number">10.0</span>)</span><br></pre></td></tr></table></figure><p>在多维数组中，可以指定用于计算的轴。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"> </span><br><span class="line">a = np.arange(<span class="number">6</span>).reshape(<span class="number">3</span>,<span class="number">2</span>)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;我们的数组是：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;修改后的数组：&#x27;</span>)</span><br><span class="line">wt = np.array([<span class="number">3</span>,<span class="number">5</span>])  </span><br><span class="line"><span class="built_in">print</span>(np.average(a, axis = <span class="number">1</span>, weights = wt))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;修改后的数组：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.average(a, axis = <span class="number">1</span>, weights = wt, returned = <span class="literal">True</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">我们的数组是：</span><br><span class="line">[[<span class="number">0</span> <span class="number">1</span>]</span><br><span class="line"> [<span class="number">2</span> <span class="number">3</span>]</span><br><span class="line"> [<span class="number">4</span> <span class="number">5</span>]]</span><br><span class="line"></span><br><span class="line">修改后的数组：</span><br><span class="line">[<span class="number">0.625</span> <span class="number">2.625</span> <span class="number">4.625</span>]</span><br><span class="line"></span><br><span class="line">修改后的数组：</span><br><span class="line">(array([<span class="number">0.625</span>, <span class="number">2.625</span>, <span class="number">4.625</span>]), array([<span class="number">8.</span>, <span class="number">8.</span>, <span class="number">8.</span>]))</span><br></pre></td></tr></table></figure><p>标准差是一组数据平均值分散程度的一种度量。标准差是方差的算术平方根。标准差公式如下：</p><blockquote><p><code>std = sqrt(mean((x-x.mean())**2))</code></p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(np.std([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="number">1.118033988749895</span></span><br></pre></td></tr></table></figure><p>统计中的方差（样本方差）是每个样本值与全体样本值的平均数之差的平方值的平均数，即<code>mean((x-x.mean())**2)</code>。换句话说，标准差是方差的平方根。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(np.var([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="number">1.25</span></span><br></pre></td></tr></table></figure><h3 id="👀NumPy排序、条件筛选函数"><a href="#👀NumPy排序、条件筛选函数" class="headerlink" title="👀NumPy排序、条件筛选函数"></a>👀NumPy排序、条件筛选函数</h3><p><code>NumPy</code>提供了多种排序的方法。 这些排序函数实现不同的排序算法，每个排序算法的特征在于执行速度，最坏情况性能，所需的工作空间和算法的稳定性。 下表显示了三种排序算法的比较。</p><table><thead><tr><th>种类</th><th>速度</th><th>最坏情况</th><th>工作空间</th><th>稳定性</th></tr></thead><tbody><tr><td><code>&#39;quicksort&#39;</code>（快速排序）</td><td>1</td><td>O(n^2)</td><td>0</td><td>否</td></tr><tr><td><code>&#39;mergesort&#39;</code>（归并排序）</td><td>2</td><td>O(n*log(n))</td><td>~n&#x2F;2</td><td>是</td></tr><tr><td><code>&#39;heapsort&#39;</code>（堆排序）</td><td>3</td><td>O(n*log(n))</td><td>0</td><td>否</td></tr></tbody></table><p><code>numpy.sort()</code>函数返回输入数组的排序副本。函数格式如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numpy.sort(a, axis, kind, order)</span><br><span class="line">参数说明：</span><br><span class="line">    a: 要排序的数组</span><br><span class="line">    axis: 沿着它排序数组的轴，如果没有数组会被展开，沿着最后的轴排序， axis=<span class="number">0</span>按列排序，axis=<span class="number">1</span>按行排序</span><br><span class="line">    kind: 默认为<span class="string">&#x27;quicksort&#x27;</span>（快速排序）</span><br><span class="line">    order: 如果数组包含字段，则是要排序的字段</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np  </span><br><span class="line"> </span><br><span class="line">a = np.array([[<span class="number">3</span>,<span class="number">7</span>],[<span class="number">9</span>,<span class="number">1</span>]])  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;我们的数组是：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;调用sort()函数：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.sort(a))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;按列排序：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.sort(a, axis =  <span class="number">0</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="comment"># 在sort函数中排序字段 </span></span><br><span class="line">dt = np.dtype([(<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;S10&#x27;</span>),(<span class="string">&#x27;age&#x27;</span>,<span class="built_in">int</span>)]) </span><br><span class="line">a = np.array([(<span class="string">&quot;raju&quot;</span>,<span class="number">21</span>),(<span class="string">&quot;anil&quot;</span>,<span class="number">25</span>),(<span class="string">&quot;ravi&quot;</span>, <span class="number">17</span>), (<span class="string">&quot;amar&quot;</span>,<span class="number">27</span>)], dtype = dt)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;我们的数组是：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;按name排序：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.sort(a, order = <span class="string">&#x27;name&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">我们的数组是：</span><br><span class="line">[[<span class="number">3</span> <span class="number">7</span>]</span><br><span class="line"> [<span class="number">9</span> <span class="number">1</span>]]</span><br><span class="line"></span><br><span class="line">调用sort()函数：</span><br><span class="line">[[<span class="number">3</span> <span class="number">7</span>]</span><br><span class="line"> [<span class="number">1</span> <span class="number">9</span>]]</span><br><span class="line"></span><br><span class="line">按列排序：</span><br><span class="line">[[<span class="number">3</span> <span class="number">1</span>]</span><br><span class="line"> [<span class="number">9</span> <span class="number">7</span>]]</span><br><span class="line"></span><br><span class="line">我们的数组是：</span><br><span class="line">[(<span class="string">b&#x27;raju&#x27;</span>, <span class="number">21</span>) (<span class="string">b&#x27;anil&#x27;</span>, <span class="number">25</span>) (<span class="string">b&#x27;ravi&#x27;</span>, <span class="number">17</span>) (<span class="string">b&#x27;amar&#x27;</span>, <span class="number">27</span>)]</span><br><span class="line"></span><br><span class="line">按 name 排序：</span><br><span class="line">[(<span class="string">b&#x27;amar&#x27;</span>, <span class="number">27</span>) (<span class="string">b&#x27;anil&#x27;</span>, <span class="number">25</span>) (<span class="string">b&#x27;raju&#x27;</span>, <span class="number">21</span>) (<span class="string">b&#x27;ravi&#x27;</span>, <span class="number">17</span>)]</span><br></pre></td></tr></table></figure><p><code>numpy.argsort()</code>函数返回的是数组值从小到大的索引值。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"> </span><br><span class="line">x = np.array([<span class="number">3</span>,  <span class="number">1</span>,  <span class="number">2</span>])  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;我们的数组是：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;对x调用argsort()函数：&#x27;</span>)</span><br><span class="line">y = np.argsort(x)  </span><br><span class="line"><span class="built_in">print</span>(y)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;以排序后的顺序重构原数组：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(x[y])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;使用循环重构原数组：&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> y:  </span><br><span class="line">    <span class="built_in">print</span> (x[i], end=<span class="string">&quot; &quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">我们的数组是：</span><br><span class="line">[<span class="number">3</span> <span class="number">1</span> <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">对x调用argsort()函数：</span><br><span class="line">[<span class="number">1</span> <span class="number">2</span> <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">以排序后的顺序重构原数组：</span><br><span class="line">[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">使用循环重构原数组：</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><p><code>numpy.lexsort()</code>用于对多个序列进行排序。把它想象成对电子表格进行排序，每一列代表一个序列，排序时优先照顾靠后的列。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"></span><br><span class="line"><span class="comment"># 传入np.lexsort的是一个tuple，排序时首先排nm，顺序为：amar、anil、raju、ravi。综上排序结果为[3 1 0 2]。</span></span><br><span class="line">nm = (<span class="string">&#x27;raju&#x27;</span>,<span class="string">&#x27;anil&#x27;</span>,<span class="string">&#x27;ravi&#x27;</span>,<span class="string">&#x27;amar&#x27;</span>) </span><br><span class="line">dv = (<span class="string">&#x27;f.y.&#x27;</span>, <span class="string">&#x27;s.y.&#x27;</span>, <span class="string">&#x27;s.y.&#x27;</span>, <span class="string">&#x27;f.y.&#x27;</span>) </span><br><span class="line">ind = np.lexsort((dv,nm))  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;调用lexsort()函数：&#x27;</span>) </span><br><span class="line"><span class="built_in">print</span>(ind) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;使用这个索引来获取排序后的数据：&#x27;</span>) </span><br><span class="line"><span class="built_in">print</span>([nm[i]+<span class="string">&quot;, &quot;</span> + dv[i] <span class="keyword">for</span> i <span class="keyword">in</span> ind])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">调用lexsort()函数：</span><br><span class="line">[<span class="number">3</span> <span class="number">1</span> <span class="number">0</span> <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">使用这个索引来获取排序后的数据：</span><br><span class="line">[<span class="string">&#x27;amar, f.y.&#x27;</span>, <span class="string">&#x27;anil, s.y.&#x27;</span>, <span class="string">&#x27;raju, f.y.&#x27;</span>, <span class="string">&#x27;ravi, s.y.&#x27;</span>]</span><br></pre></td></tr></table></figure><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td><code>msort(a)</code></td><td>数组按第一个轴排序，返回排序后的数组副本。<code>np.msort(a)</code>相等于<code>np.sort(a, axis=0)</code>。</td></tr><tr><td><code>sort_complex(a)</code></td><td>对复数按照先实部后虚部的顺序进行排序。</td></tr><tr><td><code>partition(a, kth[, axis, kind, order])</code></td><td>指定一个数，对数组进行分区</td></tr><tr><td><code>argpartition(a, kth[, axis, kind, order])</code></td><td>可以通过关键字<code>kind</code>指定算法沿着指定轴对数组进行分区</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 复数排序</span></span><br><span class="line"><span class="built_in">print</span>(np.sort_complex([<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">1</span>]))</span><br><span class="line"><span class="built_in">print</span>(np.sort_complex([<span class="number">1</span>+<span class="number">2j</span>, <span class="number">2</span>-<span class="number">1j</span>, <span class="number">3</span>-<span class="number">2j</span>, <span class="number">3</span>-<span class="number">3j</span>, <span class="number">3</span>+<span class="number">5j</span>]))</span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[<span class="number">1.</span>+<span class="number">0.j</span> <span class="number">2.</span>+<span class="number">0.j</span> <span class="number">3.</span>+<span class="number">0.j</span> <span class="number">5.</span>+<span class="number">0.j</span> <span class="number">6.</span>+<span class="number">0.j</span>]</span><br><span class="line">[<span class="number">1.</span>+<span class="number">2.j</span> <span class="number">2.</span>-<span class="number">1.j</span> <span class="number">3.</span>-<span class="number">3.j</span> <span class="number">3.</span>-<span class="number">2.j</span> <span class="number">3.</span>+<span class="number">5.j</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># partition()分区排序：</span></span><br><span class="line">a = np.array([<span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>])</span><br><span class="line"><span class="comment"># 将数组a中所有元素（包括重复元素）从小到大排列，3表示的是排序数组索引为3的数字，比该数字小的排在该数字前面，比该数字大的排在该数字的后面</span></span><br><span class="line"><span class="built_in">print</span>(np.partition(a, <span class="number">3</span>))</span><br><span class="line"><span class="comment"># 小于1的在前面，大于3的在后面，1和3之间的在中间</span></span><br><span class="line"><span class="built_in">print</span>(np.partition(a,(<span class="number">1</span>,<span class="number">3</span>)))</span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[<span class="number">2</span> <span class="number">1</span> <span class="number">3</span> <span class="number">4</span>]</span><br><span class="line">[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">arr = np.array([<span class="number">46</span>, <span class="number">57</span>, <span class="number">23</span>, <span class="number">39</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">0</span>, <span class="number">120</span>])</span><br><span class="line"><span class="comment"># 找到数组的第3小（index=2）的值和第2大（index=-2）的值</span></span><br><span class="line"><span class="built_in">print</span>(arr[np.argpartition(arr, <span class="number">2</span>)[<span class="number">2</span>]])</span><br><span class="line"><span class="built_in">print</span>(arr[np.argpartition(arr, -<span class="number">2</span>)[-<span class="number">2</span>]])</span><br><span class="line"><span class="comment"># 同时找到第3和第4小的值。注意这里，用[2,3]同时将第3和第4小的排序好，然后可以分别通过下标[2]和[3]取得。</span></span><br><span class="line"><span class="built_in">print</span>(arr[np.argpartition(arr,[<span class="number">2</span>,<span class="number">3</span>])[<span class="number">2</span>]])</span><br><span class="line"><span class="built_in">print</span>(arr[np.argpartition(arr,[<span class="number">2</span>,<span class="number">3</span>])[<span class="number">3</span>]])</span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">57</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">23</span></span><br></pre></td></tr></table></figure><p><code>numpy.argmax()</code>和<code>numpy.argmin()</code>函数分别沿给定轴返回最大和最小元素的索引。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"> </span><br><span class="line">a = np.array([[<span class="number">30</span>,<span class="number">40</span>,<span class="number">70</span>],[<span class="number">80</span>,<span class="number">20</span>,<span class="number">10</span>],[<span class="number">50</span>,<span class="number">90</span>,<span class="number">60</span>]])  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;我们的数组是：&#x27;</span>) </span><br><span class="line"><span class="built_in">print</span>(a) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;调用argmax()函数：&#x27;</span>) </span><br><span class="line"><span class="built_in">print</span>(np.argmax(a)) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;展开数组：&#x27;</span>) </span><br><span class="line"><span class="built_in">print</span>(a.flatten()) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;沿轴0的最大值索引：&#x27;</span>) </span><br><span class="line">maxindex = np.argmax(a, axis = <span class="number">0</span>)  </span><br><span class="line"><span class="built_in">print</span>(maxindex) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;沿轴1的最大值索引：&#x27;</span>) </span><br><span class="line">maxindex = np.argmax(a, axis = <span class="number">1</span>)  </span><br><span class="line"><span class="built_in">print</span>(maxindex) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;调用argmin()函数：&#x27;</span>) </span><br><span class="line">minindex = np.argmin(a)  </span><br><span class="line"><span class="built_in">print</span>(minindex) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;展开数组中的最小值：&#x27;</span>) </span><br><span class="line"><span class="built_in">print</span>(a.flatten()[minindex]) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;沿轴0的最小值索引：&#x27;</span>) </span><br><span class="line">minindex = np.argmin(a, axis = <span class="number">0</span>)  </span><br><span class="line"><span class="built_in">print</span>(minindex) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;沿轴1的最小值索引：&#x27;</span>) </span><br><span class="line">minindex = np.argmin(a, axis = <span class="number">1</span>)  </span><br><span class="line"><span class="built_in">print</span>(minindex)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">我们的数组是：</span><br><span class="line">[[<span class="number">30</span> <span class="number">40</span> <span class="number">70</span>]</span><br><span class="line"> [<span class="number">80</span> <span class="number">20</span> <span class="number">10</span>]</span><br><span class="line"> [<span class="number">50</span> <span class="number">90</span> <span class="number">60</span>]]</span><br><span class="line"></span><br><span class="line">调用argmax()函数：</span><br><span class="line"><span class="number">7</span></span><br><span class="line"></span><br><span class="line">展开数组：</span><br><span class="line">[<span class="number">30</span> <span class="number">40</span> <span class="number">70</span> <span class="number">80</span> <span class="number">20</span> <span class="number">10</span> <span class="number">50</span> <span class="number">90</span> <span class="number">60</span>]</span><br><span class="line"></span><br><span class="line">沿轴<span class="number">0</span>的最大值索引：</span><br><span class="line">[<span class="number">1</span> <span class="number">2</span> <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">沿轴<span class="number">1</span>的最大值索引：</span><br><span class="line">[<span class="number">2</span> <span class="number">0</span> <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">调用argmin()函数：</span><br><span class="line"><span class="number">5</span></span><br><span class="line"></span><br><span class="line">展开数组中的最小值：</span><br><span class="line"><span class="number">10</span></span><br><span class="line"></span><br><span class="line">沿轴<span class="number">0</span>的最小值索引：</span><br><span class="line">[<span class="number">0</span> <span class="number">1</span> <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">沿轴<span class="number">1</span>的最小值索引：</span><br><span class="line">[<span class="number">0</span> <span class="number">2</span> <span class="number">0</span>]</span><br></pre></td></tr></table></figure><p><code>numpy.nonzero()</code>函数返回输入数组中非零元素的索引。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"> </span><br><span class="line">a = np.array([[<span class="number">30</span>,<span class="number">40</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">20</span>,<span class="number">10</span>],[<span class="number">50</span>,<span class="number">0</span>,<span class="number">60</span>]])  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;我们的数组是：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;调用nonzero()函数：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.nonzero(a))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">我们的数组是：</span><br><span class="line">[[<span class="number">30</span> <span class="number">40</span>  <span class="number">0</span>]</span><br><span class="line"> [ <span class="number">0</span> <span class="number">20</span> <span class="number">10</span>]</span><br><span class="line"> [<span class="number">50</span>  <span class="number">0</span> <span class="number">60</span>]]</span><br><span class="line"></span><br><span class="line">调用nonzero()函数：</span><br><span class="line">(array([<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>], dtype=int64), array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">2</span>], dtype=int64))</span><br></pre></td></tr></table></figure><p><code>numpy.where()</code>函数返回输入数组中满足给定条件的元素的索引。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"> </span><br><span class="line">x = np.arange(<span class="number">9.</span>).reshape(<span class="number">3</span>, <span class="number">3</span>)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;我们的数组是：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;大于3的元素的索引：&#x27;</span>)</span><br><span class="line">y = np.where(x &gt; <span class="number">3</span>)  </span><br><span class="line"><span class="built_in">print</span>(y)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;使用这些索引来获取满足条件的元素：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(x[y])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">我们的数组是：</span><br><span class="line">[[<span class="number">0.</span> <span class="number">1.</span> <span class="number">2.</span>]</span><br><span class="line"> [<span class="number">3.</span> <span class="number">4.</span> <span class="number">5.</span>]</span><br><span class="line"> [<span class="number">6.</span> <span class="number">7.</span> <span class="number">8.</span>]]</span><br><span class="line">大于<span class="number">3</span>的元素的索引：</span><br><span class="line">(array([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>], dtype=int64), array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>], dtype=int64))</span><br><span class="line">使用这些索引来获取满足条件的元素：</span><br><span class="line">[<span class="number">4.</span> <span class="number">5.</span> <span class="number">6.</span> <span class="number">7.</span> <span class="number">8.</span>]</span><br></pre></td></tr></table></figure><p><code>numpy.extract()</code>函数根据某个条件从数组中抽取元素，返回满条件的元素。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"> </span><br><span class="line">x = np.arange(<span class="number">9.</span>).reshape(<span class="number">3</span>, <span class="number">3</span>)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;我们的数组是：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line"><span class="comment"># 定义条件,选择偶数元素</span></span><br><span class="line">condition = np.mod(x,<span class="number">2</span>) == <span class="number">0</span>  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;按元素的条件值：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(condition)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;使用条件提取元素：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.extract(condition, x))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">我们的数组是：</span><br><span class="line">[[<span class="number">0.</span> <span class="number">1.</span> <span class="number">2.</span>]</span><br><span class="line"> [<span class="number">3.</span> <span class="number">4.</span> <span class="number">5.</span>]</span><br><span class="line"> [<span class="number">6.</span> <span class="number">7.</span> <span class="number">8.</span>]]</span><br><span class="line">按元素的条件值：</span><br><span class="line">[[<span class="literal">True</span> <span class="literal">False</span> <span class="literal">True</span>]</span><br><span class="line"> [<span class="literal">False</span> <span class="literal">True</span> <span class="literal">False</span>]</span><br><span class="line"> [<span class="literal">True</span> <span class="literal">False</span> <span class="literal">True</span>]]</span><br><span class="line">使用条件提取元素：</span><br><span class="line">[<span class="number">0.</span> <span class="number">2.</span> <span class="number">4.</span> <span class="number">6.</span> <span class="number">8.</span>]</span><br></pre></td></tr></table></figure><h3 id="👀NumPy字节交换"><a href="#👀NumPy字节交换" class="headerlink" title="👀NumPy字节交换"></a>👀NumPy字节交换</h3><p>在几乎所有的机器上，多字节对象都被存储为连续的字节序列。字节顺序，是跨越多字节的程序对象的存储规则。</p><ul><li><strong>大端模式：</strong>指数据的高字节保存在内存的低地址中，而数据的低字节保存在内存的高地址中，这样的存储模式有点儿类似于把数据当作字符串顺序处理：地址由小向大增加，而数据从高位往低位放；这和我们的阅读习惯一致。</li><li><strong>小端模式：</strong>指数据的高字节保存在内存的高地址中，而数据的低字节保存在内存的低地址中，这种存储模式将地址的高低和数据位权有效地结合起来，高地址部分权值高，低地址部分权值低。</li></ul><p><code>numpy.ndarray.byteswap()</code>函数将<code>ndarray</code>中每个元素中的字节进行大小端转换。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"> </span><br><span class="line">a = np.array([<span class="number">1</span>, <span class="number">256</span>, <span class="number">8755</span>], dtype = np.int16)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;我们的数组是：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;以十六进制表示内存中的数据：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">map</span>(<span class="built_in">hex</span>,a))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">hex</span>, a)))</span><br><span class="line"><span class="comment"># byteswap()函数通过传入true来原地交换 </span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;调用 byteswap() 函数：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a.byteswap(<span class="literal">True</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;十六进制形式：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">map</span>(<span class="built_in">hex</span>,a))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">hex</span>, a)))</span><br><span class="line"><span class="comment"># 我们可以看到字节已经交换了</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">我们的数组是：</span><br><span class="line">[   <span class="number">1</span>  <span class="number">256</span> <span class="number">8755</span>]</span><br><span class="line">以十六进制表示内存中的数据：</span><br><span class="line">&lt;<span class="built_in">map</span> <span class="built_in">object</span> at <span class="number">0x00000229347A3D88</span>&gt;</span><br><span class="line">[<span class="string">&#x27;0x1&#x27;</span>, <span class="string">&#x27;0x100&#x27;</span>, <span class="string">&#x27;0x2233&#x27;</span>]</span><br><span class="line">调用 byteswap() 函数：</span><br><span class="line">[  <span class="number">256</span>     <span class="number">1</span> <span class="number">13090</span>]</span><br><span class="line">十六进制形式：</span><br><span class="line">&lt;<span class="built_in">map</span> <span class="built_in">object</span> at <span class="number">0x00000229347A3608</span>&gt;</span><br><span class="line">[<span class="string">&#x27;0x100&#x27;</span>, <span class="string">&#x27;0x1&#x27;</span>, <span class="string">&#x27;0x3322&#x27;</span>]</span><br></pre></td></tr></table></figure><h3 id="👀NumPy副本和视图"><a href="#👀NumPy副本和视图" class="headerlink" title="👀NumPy副本和视图"></a>👀NumPy副本和视图</h3><p>副本是一个数据的完整的拷贝，如果我们对副本进行修改，它不会影响到原始数据，物理内存不在同一位置。</p><p>视图是数据的一个别称或引用，通过该别称或引用亦便可访问、操作原有数据，但原有数据不会产生拷贝。如果我们对视图进行修改，它会影响到原始数据，物理内存在同一位置。</p><p><strong>副本一般发生在：</strong></p><ul><li>Python序列的切片操作，调用deepCopy()函数。</li><li>调用ndarray的copy()函数产生一个副本。</li></ul><p><strong>视图一般发生在：</strong></p><ul><li>numpy的切片操作返回原数据的视图。</li><li>调用ndarray的view()函数产生一个视图。</li></ul><p>（1）无复制</p><p>简单的赋值不会创建数组对象的副本。 相反，它使用<strong>原始数组的相同</strong><code>id()</code>来访问它。 <code>id()</code>返回<code>Python</code>对象的通用标识符，类似于C中的指针。此外，一个数组的任何变化都反映在另一个数组上。 例如，一个数组的形状改变也会改变另一个数组的形状。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"> </span><br><span class="line">a = np.arange(<span class="number">6</span>)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;我们的数组是：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;调用id()函数：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(a))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;a赋值给b：&#x27;</span>)</span><br><span class="line">b = a </span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;b拥有相同id()：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(b))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;修改b的形状：&#x27;</span>)</span><br><span class="line">b.shape = <span class="number">3</span>,<span class="number">2</span>  </span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;a的形状也修改了：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">我们的数组是：</span><br><span class="line">[<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span>]</span><br><span class="line">调用<span class="built_in">id</span>()函数：</span><br><span class="line"><span class="number">2375996889168</span></span><br><span class="line">a赋值给b：</span><br><span class="line">[<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span>]</span><br><span class="line">b拥有相同<span class="built_in">id</span>()：</span><br><span class="line"><span class="number">2375996889168</span></span><br><span class="line">修改 b 的形状：</span><br><span class="line">[[<span class="number">0</span> <span class="number">1</span>]</span><br><span class="line"> [<span class="number">2</span> <span class="number">3</span>]</span><br><span class="line"> [<span class="number">4</span> <span class="number">5</span>]]</span><br><span class="line">a的形状也修改了：</span><br><span class="line">[[<span class="number">0</span> <span class="number">1</span>]</span><br><span class="line"> [<span class="number">2</span> <span class="number">3</span>]</span><br><span class="line"> [<span class="number">4</span> <span class="number">5</span>]]</span><br></pre></td></tr></table></figure><p>（2）视图或浅拷贝</p><p><code>ndarray.view()</code>方会创建一个新的数组对象，该方法创建的新数组的维数变化不会改变原始数据的维数。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"> </span><br><span class="line"><span class="comment"># 最开始 a 是个 3X2 的数组</span></span><br><span class="line">a = np.arange(<span class="number">6</span>).reshape(<span class="number">3</span>,<span class="number">2</span>)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;数组a：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;创建a的视图：&#x27;</span>)</span><br><span class="line">b = a.view()  </span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;两个数组的id()不同：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;a的id()：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(a))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;b的id()：&#x27;</span> )</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(b))</span><br><span class="line"><span class="comment"># 修改b的形状，并不会修改a</span></span><br><span class="line">b.shape =  <span class="number">2</span>,<span class="number">3</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;b的形状：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;a的形状：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">数组a：</span><br><span class="line">[[<span class="number">0</span> <span class="number">1</span>]</span><br><span class="line"> [<span class="number">2</span> <span class="number">3</span>]</span><br><span class="line"> [<span class="number">4</span> <span class="number">5</span>]]</span><br><span class="line">创建a的视图：</span><br><span class="line">[[<span class="number">0</span> <span class="number">1</span>]</span><br><span class="line"> [<span class="number">2</span> <span class="number">3</span>]</span><br><span class="line"> [<span class="number">4</span> <span class="number">5</span>]]</span><br><span class="line">两个数组的<span class="built_in">id</span>()不同：</span><br><span class="line">a的<span class="built_in">id</span>()：</span><br><span class="line"><span class="number">2375996990448</span></span><br><span class="line">b的<span class="built_in">id</span>()：</span><br><span class="line"><span class="number">2375996617872</span></span><br><span class="line">b的形状：</span><br><span class="line">[[<span class="number">0</span> <span class="number">1</span> <span class="number">2</span>]</span><br><span class="line"> [<span class="number">3</span> <span class="number">4</span> <span class="number">5</span>]]</span><br><span class="line">a的形状：</span><br><span class="line">[[<span class="number">0</span> <span class="number">1</span>]</span><br><span class="line"> [<span class="number">2</span> <span class="number">3</span>]</span><br><span class="line"> [<span class="number">4</span> <span class="number">5</span>]]</span><br></pre></td></tr></table></figure><p>使用切片创建视图修改数据会影响到原始数组，变量a，b都是arr的一部分视图，对视图的修改会直接反映到原数据中。但是我们观察a，b的id，他们是不同的，也就是说，视图虽然指向原数据，但是他们和赋值引用还是有区别的。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"> </span><br><span class="line">arr = np.arange(<span class="number">12</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;我们的数组：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(arr)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;创建切片：&#x27;</span>)</span><br><span class="line">a=arr[<span class="number">3</span>:]</span><br><span class="line">b=arr[<span class="number">3</span>:]</span><br><span class="line">a[<span class="number">1</span>]=<span class="number">123</span></span><br><span class="line">b[<span class="number">2</span>]=<span class="number">234</span></span><br><span class="line"><span class="built_in">print</span>(arr)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(a),<span class="built_in">id</span>(b),<span class="built_in">id</span>(arr[<span class="number">3</span>:]))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">我们的数组：</span><br><span class="line">[ <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span> <span class="number">10</span> <span class="number">11</span>]</span><br><span class="line">创建切片：</span><br><span class="line">[  <span class="number">0</span>   <span class="number">1</span>   <span class="number">2</span>   <span class="number">3</span> <span class="number">123</span> <span class="number">234</span>   <span class="number">6</span>   <span class="number">7</span>   <span class="number">8</span>   <span class="number">9</span>  <span class="number">10</span>  <span class="number">11</span>]</span><br><span class="line"><span class="number">2375996635536</span> <span class="number">2375996634816</span> <span class="number">2375996921616</span></span><br></pre></td></tr></table></figure><p>（3）副本或深拷贝</p><p><code>ndarray.copy()</code>函数创建一个副本。 对副本数据进行修改，不会影响到原始数据，它们物理内存不在同一位置。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"> </span><br><span class="line">a = np.array([[<span class="number">10</span>,<span class="number">10</span>],  [<span class="number">2</span>,<span class="number">3</span>],  [<span class="number">4</span>,<span class="number">5</span>]])  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;数组a：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;创建a的深层副本：&#x27;</span>)</span><br><span class="line">b = a.copy()  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;数组 b：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="comment"># b与a不共享任何内容  </span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;我们能够写入b来写入a吗？&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(b <span class="keyword">is</span> a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;修改b的内容：&#x27;</span>)</span><br><span class="line">b[<span class="number">0</span>,<span class="number">0</span>] = <span class="number">100</span>  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;修改后的数组b：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;a保持不变：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">数组a：</span><br><span class="line">[[<span class="number">10</span> <span class="number">10</span>]</span><br><span class="line"> [ <span class="number">2</span>  <span class="number">3</span>]</span><br><span class="line"> [ <span class="number">4</span>  <span class="number">5</span>]]</span><br><span class="line">创建a的深层副本：</span><br><span class="line">数组 b：</span><br><span class="line">[[<span class="number">10</span> <span class="number">10</span>]</span><br><span class="line"> [ <span class="number">2</span>  <span class="number">3</span>]</span><br><span class="line"> [ <span class="number">4</span>  <span class="number">5</span>]]</span><br><span class="line">我们能够写入b来写入a吗？</span><br><span class="line"><span class="literal">False</span></span><br><span class="line">修改b的内容：</span><br><span class="line">修改后的数组b：</span><br><span class="line">[[<span class="number">100</span>  <span class="number">10</span>]</span><br><span class="line"> [  <span class="number">2</span>   <span class="number">3</span>]</span><br><span class="line"> [  <span class="number">4</span>   <span class="number">5</span>]]</span><br><span class="line">a保持不变：</span><br><span class="line">[[<span class="number">10</span> <span class="number">10</span>]</span><br><span class="line"> [ <span class="number">2</span>  <span class="number">3</span>]</span><br><span class="line"> [ <span class="number">4</span>  <span class="number">5</span>]]</span><br></pre></td></tr></table></figure><h3 id="👀NumPy矩阵库（Matrix）"><a href="#👀NumPy矩阵库（Matrix）" class="headerlink" title="👀NumPy矩阵库（Matrix）"></a>👀NumPy矩阵库（Matrix）</h3><p><code>NumPy</code>中包含了一个矩阵库<code>numpy.matlib</code>，该模块中的函数返回一个矩阵，而不是<code>ndarray</code>对象。一个<code>m×n</code>的矩阵是一个由m行（row）n列（column）元素排列成的矩形阵列。矩阵里的元素可以是数字、符号或数学式。</p><p>（1）转置矩阵</p><p><code>NumPy</code>中除了可以使用<code>numpy.transpose</code>函数来对换数组的维度，还可以使用 <strong>T</strong> 属性。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"> </span><br><span class="line">a = np.arange(<span class="number">12</span>).reshape(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;原数组：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;转置数组：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a.T)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">原数组：</span><br><span class="line">[[ <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>]</span><br><span class="line"> [ <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>]</span><br><span class="line"> [ <span class="number">8</span>  <span class="number">9</span> <span class="number">10</span> <span class="number">11</span>]]</span><br><span class="line"></span><br><span class="line">转置数组：</span><br><span class="line">[[ <span class="number">0</span>  <span class="number">4</span>  <span class="number">8</span>]</span><br><span class="line"> [ <span class="number">1</span>  <span class="number">5</span>  <span class="number">9</span>]</span><br><span class="line"> [ <span class="number">2</span>  <span class="number">6</span> <span class="number">10</span>]</span><br><span class="line"> [ <span class="number">3</span>  <span class="number">7</span> <span class="number">11</span>]]</span><br></pre></td></tr></table></figure><p>（2）matlib.empty()</p><p><code>matlib.empty()</code>函数返回一个新的矩阵，语法格式为：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numpy.matlib.empty(shape, dtype, order)</span><br><span class="line">参数说明：</span><br><span class="line">    shape: 定义新矩阵形状的整数或整数元组</span><br><span class="line">    Dtype: 可选，数据类型</span><br><span class="line">    order: C（行序优先） 或者 F（列序优先）</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(np.matlib.empty((<span class="number">2</span>,<span class="number">2</span>)))</span><br><span class="line"><span class="comment"># 填充为随机数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[[<span class="number">1.36008890e-311</span> <span class="number">1.69168361e-301</span>]</span><br><span class="line"> [<span class="number">3.42821614e-210</span> <span class="number">7.46699190e-301</span>]]</span><br></pre></td></tr></table></figure><p>（3）numpy.matlib.zeros()</p><p><code>numpy.matlib.zeros()</code>函数创建一个以0填充的矩阵。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(np.matlib.zeros((<span class="number">2</span>,<span class="number">2</span>)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[[<span class="number">0.</span> <span class="number">0.</span>]</span><br><span class="line"> [<span class="number">0.</span> <span class="number">0.</span>]]</span><br></pre></td></tr></table></figure><p>（4）numpy.matlib.ones()</p><p><code>numpy.matlib.ones()</code>函数创建一个以1填充的矩阵。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(np.matlib.ones((<span class="number">2</span>,<span class="number">2</span>)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[[<span class="number">1.</span> <span class="number">1.</span>]</span><br><span class="line"> [<span class="number">1.</span> <span class="number">1.</span>]]</span><br></pre></td></tr></table></figure><p>（5）numpy.matlib.eye()</p><p><code>numpy.matlib.eye()</code>函数返回一个矩阵，对角线元素为1，其他位置为零。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numpy.matlib.eye(n, M,k, dtype)</span><br><span class="line">参数说明：</span><br><span class="line">    n: 返回矩阵的行数</span><br><span class="line">    M: 返回矩阵的列数，默认为n</span><br><span class="line">    k: 对角线的索引</span><br><span class="line">    dtype: 数据类型</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(np.matlib.eye(n=<span class="number">3</span>, M=<span class="number">4</span>, k=<span class="number">0</span>, dtype=<span class="built_in">float</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[[<span class="number">1.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span>]</span><br><span class="line"> [<span class="number">0.</span> <span class="number">1.</span> <span class="number">0.</span> <span class="number">0.</span>]</span><br><span class="line"> [<span class="number">0.</span> <span class="number">0.</span> <span class="number">1.</span> <span class="number">0.</span>]]</span><br></pre></td></tr></table></figure><p>（6）numpy.matlib.identity()</p><p><code>numpy.matlib.identity()</code>函数返回给定大小的单位矩阵。单位矩阵是个方阵，从左上角到右下角的对角线（称为主对角线）上的元素均为1，除此以外全都为0。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"> </span><br><span class="line"><span class="comment"># 大小为 5，类型位浮点型</span></span><br><span class="line"><span class="built_in">print</span>(np.matlib.identity(<span class="number">5</span>, dtype=<span class="built_in">float</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[[<span class="number">1.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span>]</span><br><span class="line"> [<span class="number">0.</span> <span class="number">1.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span>]</span><br><span class="line"> [<span class="number">0.</span> <span class="number">0.</span> <span class="number">1.</span> <span class="number">0.</span> <span class="number">0.</span>]</span><br><span class="line"> [<span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">1.</span> <span class="number">0.</span>]</span><br><span class="line"> [<span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">1.</span>]]</span><br></pre></td></tr></table></figure><p>（7）numpy.matlib.rand()</p><p><code>numpy.matlib.rand()</code>函数创建一个给定大小的矩阵，数据是随机填充的。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(np.matlib.rand(<span class="number">3</span>,<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[[<span class="number">0.85907694</span> <span class="number">0.10033233</span> <span class="number">0.90102019</span>]</span><br><span class="line"> [<span class="number">0.60724393</span> <span class="number">0.67443377</span> <span class="number">0.19654135</span>]</span><br><span class="line"> [<span class="number">0.1626346</span>  <span class="number">0.4910893</span>  <span class="number">0.11768052</span>]]</span><br></pre></td></tr></table></figure><p>矩阵总是二维的，而ndarray是一个n维数组。 两个对象都是可互换的。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np  </span><br><span class="line"> </span><br><span class="line">i = np.matrix(<span class="string">&#x27;1,2;3,4&#x27;</span>)  </span><br><span class="line"><span class="built_in">print</span>(i)</span><br><span class="line">j = np.asarray(i)  </span><br><span class="line"><span class="built_in">print</span>(j)</span><br><span class="line">k = np.asmatrix(j)  </span><br><span class="line"><span class="built_in">print</span>(k)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[[<span class="number">1</span> <span class="number">2</span>]</span><br><span class="line"> [<span class="number">3</span> <span class="number">4</span>]]</span><br><span class="line">[[<span class="number">1</span> <span class="number">2</span>]</span><br><span class="line"> [<span class="number">3</span> <span class="number">4</span>]]</span><br><span class="line">[[<span class="number">1</span> <span class="number">2</span>]</span><br><span class="line"> [<span class="number">3</span> <span class="number">4</span>]]</span><br></pre></td></tr></table></figure><h3 id="👀NumPy线性代数"><a href="#👀NumPy线性代数" class="headerlink" title="👀NumPy线性代数"></a>👀NumPy线性代数</h3><p><code>NumPy</code>提供了线性代数函数库<strong>linalg</strong>，该库包含了线性代数所需的所有功能，可以看看下面的说明：</p><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td><code>dot</code></td><td>两个数组的点积，即元素对应相乘</td></tr><tr><td><code>vdot</code></td><td>两个向量的点积</td></tr><tr><td><code>inner</code></td><td>两个数组的内积</td></tr><tr><td><code>matmul</code></td><td>两个数组的矩阵积</td></tr><tr><td><code>determinant</code></td><td>数组的行列式</td></tr><tr><td><code>solve</code></td><td>求解线性矩阵方程</td></tr><tr><td><code>inv</code></td><td>计算矩阵的乘法逆矩阵</td></tr></tbody></table><h3 id="👀NumPy-IO"><a href="#👀NumPy-IO" class="headerlink" title="👀NumPy IO"></a>👀NumPy IO</h3><p><code>Numpy</code>可以读写磁盘上的文本数据或二进制数据。</p><p><code>NumPy</code>为<code>ndarray</code>对象引入了一个简单的文件格式：<code>npy</code>。</p><p><code>npy</code>文件用于存储重建<code>ndarray</code>所需的数据、图形、dtype和其他信息。</p><p>常用的<code>IO</code>函数有：</p><ul><li><code>load()</code>和<code>save()</code>函数是读写文件数组数据的两个主要函数，默认情况下，数组是以未压缩的原始二进制格式保存在扩展名为<code>.npy</code>的文件中。</li><li><code>savez()</code>函数用于将多个数组写入文件，默认情况，数组是以未压缩的原始二进制格式保存在扩展名为<code>.npz</code>的文件中。</li><li><code>loadtxt()</code>和<code>savetxt()</code>函数处理正常的文本文件(<code>.txt</code>等)</li></ul><p>（1）numpy.save()</p><p><code>numpy.save()</code>函数将数组保存到以<code>.npy</code>为扩展名的文件中。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numpy.save(file, arr, allow_pickle=<span class="literal">True</span>, fix_imports=<span class="literal">True</span>)</span><br><span class="line">参数说明：</span><br><span class="line">    file：要保存的文件，扩展名为.npy，如果文件路径末尾没有扩展名.npy，该扩展名会被自动加上。</span><br><span class="line">    arr: 要保存的数组</span><br><span class="line">    allow_pickle: 可选，布尔值，允许使用Python pickles保存对象数组，Python中的pickle用于在保存到磁盘文件或从磁盘文件读取之前，对对象进行序列化和反序列化。</span><br><span class="line">    fix_imports: 可选，为了方便Pyhton2中读取Python3保存的数据。</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"> </span><br><span class="line">a = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]) </span><br><span class="line"><span class="comment"># 保存到outfile.npy文件上</span></span><br><span class="line">np.save(<span class="string">&#x27;outfile.npy&#x27;</span>,a) </span><br><span class="line"><span class="comment"># 保存到outfile2.npy文件上，如果文件路径末尾没有扩展名.npy，该扩展名会被自动加上</span></span><br><span class="line">np.save(<span class="string">&#x27;outfile2&#x27;</span>,a)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以看出文件是乱码的，因为它们是Numpy专用的二进制格式后的数据。</span></span><br><span class="line"><span class="comment"># 我们可以使用load()函数来读取数据就可以正常显示了</span></span><br><span class="line">b = np.load(<span class="string">&#x27;outfile.npy&#x27;</span>)  </span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span>]</span><br></pre></td></tr></table></figure><p>（2）np.savez()</p><p><code>numpy.savez()</code>函数将多个数组保存到以<code>.npz</code>为扩展名的文件中。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numpy.savez(file, *args, **kwds)</span><br><span class="line">参数说明：</span><br><span class="line">    file：要保存的文件，扩展名为.npz，如果文件路径末尾没有扩展名.npz，该扩展名会被自动加上。</span><br><span class="line">args: 要保存的数组，可以使用关键字参数为数组起一个名字，非关键字参数传递的数组会自动起名为arr_0, arr_1, …　。</span><br><span class="line">    kwds: 要保存的数组使用关键字名称。</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"> </span><br><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]])</span><br><span class="line">b = np.arange(<span class="number">0</span>, <span class="number">1.0</span>, <span class="number">0.1</span>)</span><br><span class="line">c = np.sin(b)</span><br><span class="line"><span class="comment"># c使用了关键字参数sin_array</span></span><br><span class="line">np.savez(<span class="string">&quot;runoob.npz&quot;</span>, a, b, sin_array = c)</span><br><span class="line">r = np.load(<span class="string">&quot;runoob.npz&quot;</span>)  </span><br><span class="line"><span class="built_in">print</span>(r.files) <span class="comment"># 查看各个数组名称</span></span><br><span class="line"><span class="built_in">print</span>(r[<span class="string">&quot;arr_0&quot;</span>]) <span class="comment"># 数组 a</span></span><br><span class="line"><span class="built_in">print</span>(r[<span class="string">&quot;arr_1&quot;</span>]) <span class="comment"># 数组 b</span></span><br><span class="line"><span class="built_in">print</span>(r[<span class="string">&quot;sin_array&quot;</span>]) <span class="comment"># 数组 c</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[<span class="string">&#x27;sin_array&#x27;</span>, <span class="string">&#x27;arr_0&#x27;</span>, <span class="string">&#x27;arr_1&#x27;</span>]</span><br><span class="line">[[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]</span><br><span class="line"> [<span class="number">4</span> <span class="number">5</span> <span class="number">6</span>]]</span><br><span class="line">[<span class="number">0.</span>  <span class="number">0.1</span> <span class="number">0.2</span> <span class="number">0.3</span> <span class="number">0.4</span> <span class="number">0.5</span> <span class="number">0.6</span> <span class="number">0.7</span> <span class="number">0.8</span> <span class="number">0.9</span>]</span><br><span class="line">[<span class="number">0.</span>         <span class="number">0.09983342</span> <span class="number">0.19866933</span> <span class="number">0.29552021</span> <span class="number">0.38941834</span> <span class="number">0.47942554</span></span><br><span class="line"> <span class="number">0.56464247</span> <span class="number">0.64421769</span> <span class="number">0.71735609</span> <span class="number">0.78332691</span>]</span><br></pre></td></tr></table></figure><p>（3）np.savetxt()</p><p><code>savetxt()</code>函数是以简单的文本文件格式存储数据，对应的使用<code>loadtxt()</code>函数来获取数据。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.loadtxt(FILENAME, dtype=<span class="built_in">int</span>, delimiter=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">np.savetxt(FILENAME, a, fmt=<span class="string">&quot;%d&quot;</span>, delimiter=<span class="string">&quot;,&quot;</span>)</span><br><span class="line"><span class="comment"># 参数delimiter可以指定各种分隔符、针对特定列的转换器函数、需要跳过的行数等。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"> </span><br><span class="line">a = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]) </span><br><span class="line">np.savetxt(<span class="string">&#x27;out.txt&#x27;</span>,a) </span><br><span class="line">b = np.loadtxt(<span class="string">&#x27;out.txt&#x27;</span>)  </span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[<span class="number">1.</span> <span class="number">2.</span> <span class="number">3.</span> <span class="number">4.</span> <span class="number">5.</span>]</span><br></pre></td></tr></table></figure><p>使用delimiter参数：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"></span><br><span class="line"><span class="comment"># arr.shape    # (a,b)</span></span><br><span class="line"><span class="comment"># arr.reshape(m,-1) # 改变维度为m行、d列（-1表示列数自动计算，d=a*b/m）</span></span><br><span class="line"><span class="comment"># arr.reshape(-1,m) # 改变维度为d行、m列（-1表示行数自动计算，d=a*b/m）</span></span><br><span class="line">a = np.arange(<span class="number">0</span>,<span class="number">10</span>,<span class="number">0.5</span>).reshape(<span class="number">4</span>,-<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line">np.savetxt(<span class="string">&quot;out.txt&quot;</span>,a,fmt=<span class="string">&quot;%d&quot;</span>,delimiter=<span class="string">&quot;,&quot;</span>) <span class="comment"># 改为保存为整数，以逗号分隔</span></span><br><span class="line">b = np.loadtxt(<span class="string">&quot;out.txt&quot;</span>,delimiter=<span class="string">&quot;,&quot;</span>) <span class="comment"># load 时也要指定为逗号分隔</span></span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[[<span class="number">0.</span>  <span class="number">0.5</span> <span class="number">1.</span>  <span class="number">1.5</span> <span class="number">2.</span> ]</span><br><span class="line"> [<span class="number">2.5</span> <span class="number">3.</span>  <span class="number">3.5</span> <span class="number">4.</span>  <span class="number">4.5</span>]</span><br><span class="line"> [<span class="number">5.</span>  <span class="number">5.5</span> <span class="number">6.</span>  <span class="number">6.5</span> <span class="number">7.</span> ]</span><br><span class="line"> [<span class="number">7.5</span> <span class="number">8.</span>  <span class="number">8.5</span> <span class="number">9.</span>  <span class="number">9.5</span>]]</span><br><span class="line">[[<span class="number">0.</span> <span class="number">0.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">2.</span>]</span><br><span class="line"> [<span class="number">2.</span> <span class="number">3.</span> <span class="number">3.</span> <span class="number">4.</span> <span class="number">4.</span>]</span><br><span class="line"> [<span class="number">5.</span> <span class="number">5.</span> <span class="number">6.</span> <span class="number">6.</span> <span class="number">7.</span>]</span><br><span class="line"> [<span class="number">7.</span> <span class="number">8.</span> <span class="number">8.</span> <span class="number">9.</span> <span class="number">9.</span>]]</span><br></pre></td></tr></table></figure><h3 id="👀NumPy-Matplotlib"><a href="#👀NumPy-Matplotlib" class="headerlink" title="👀NumPy Matplotlib"></a>👀NumPy Matplotlib</h3><p><code>Matplotlib</code>是<code>Python</code>的绘图库。 它可与<code>NumPy</code>一起使用，提供了一种有效的<code>MatLab</code>开源替代方案。它也可以和图形工具包一起使用，如<code>PyQt</code>和<code>wxPython</code>。</p><p>参考资料：菜鸟教程</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 科学计算 </tag>
            
            <tag> Numpy </tag>
            
            <tag> 数据分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Matlab语法基础（01）</title>
      <link href="/2022/12/17/Matlab-Basic01/"/>
      <url>/2022/12/17/Matlab-Basic01/</url>
      
        <content type="html"><![CDATA[<p><code>MathWorks</code>公司创立于 1984 年，是领先的为工程师和科学家提供数学计算软件的供应商，旗下产品包括<code>MATLAB</code>产品家族、<code>Simulink</code>产品家族及 <code>PolySpace</code>产品家族。</p><p><code>MATLAB</code>是矩阵实验室（<code>Matrix Laboratory</code>）的简称，是一种用于算法开发、数据可视化、数据分析及数值计算的高级技术计算语言和交互式环境。<code>MATLAB</code>的应用范围非常广，包括信号和图像处理、通信、控制系统设计、测试和测量、财务建模和分析，以及计算生物学等众多应用领域。附加的工具箱（单独提供的专用 <code>MATLAB</code> 函数集）扩展了<code>MATLAB</code>的使用环境，以解决这些应用领域内特定类型的问题。</p><p><code>Simulink</code>是一个用于对动态系统进行多域建模和模型设计的平台。它提供了一个交互式图形环境，以及一个自定义模块库，并可针对特定应用加以扩展，可应用于控制系统设计、信号处理和通信及图像处理等众多领域。</p><p><code>PolySpace</code>提供代码验证，可确保消除源代码中的溢出、除零、数组访问越界及其他运行错误。此类产品可以证明源代码中不存在某些运行错误，使工程师能够选择并跟踪嵌入式软件质量的指标和阈值，帮助软件团队更好地定义质量目标，并更快地实施。该软件已经在汽车、航空、国防及工业自动化和机械行业中得到广泛应用。</p><p>目前，经常使用的<code>MATLAB</code>软件集成了<code>MATLAB</code>和<code>Simulink</code>两大模块；而<code>PolySpace</code> 是独立于<code>MATLAB</code> 软件之外的，需要单独安装。</p><table><thead><tr><th>数学软件</th><th>备注</th></tr></thead><tbody><tr><td><code>Mathematica</code></td><td><code>Mathematica</code>是一个综合的数学软件环境，具有数值计算、符号推导、数据可视化和编程等多种功能，在符号计算领域有很高的知名度。<code>Mathematica</code>软件分为两大部分：<code>Kemel</code>和<code>FrontEnd</code>。<code>Kemel</code>是软件的计算中心，而<code>FrontEnd</code>负责与用户的交流，两者有一定的独立性。<code>Mathematica</code>的表达式含义十分丰富，几乎包含了一切要处理的对象。</td></tr><tr><td><code>Maple</code></td><td><code>Maple</code>是世界上较优秀的几款数学软件之一。它以友善的使用环境、强大的符号处理、精确的数值计算、灵活的图形显示、高效的编程功能为越来越多的教师、学生和科研人员所喜爱，并成为数学处理的首选工具。由于<code>Maple</code>软件原是为符号计算而设计的，因此在数值计算与绘图方面的运算速度要比<code>MATLAB</code>慢。<code>Maple</code>的帮助系统是用英语写的，这给英文差的人们带来了不便。</td></tr></tbody></table><p><code>MATLAB</code>作为和<code>Mathematica</code>、<code>Maple</code>并列的三大数学软件之一，强项就是其强大的矩阵计算及仿真能力。每次 <code>MathWorks</code>公司发布<code>MATLAB</code>的同时，也会发布仿真工具<code>Simulink</code>。<code>MATLAB</code>以其良好的开放性和运行的可靠性，已经成为国际控制界公认的标准计算软件，<code>MATLAB</code>在数值计算方面独占鳌头。</p><ul><li>计算功能强大；</li><li>绘图方便：它包括强力的二维及三维图形函数、图像处理和动画显示等函数；</li><li>功能强大的工具箱（应用程序）：功能性工具箱和学科性工具；</li><li>帮助功能完整。</li></ul><blockquote><p><strong>clc</strong>：清除命令窗口的内容，对工作环境中的全部变量无影响；</p><p><strong>close</strong>：关闭当前的Figure窗口；</p><p><strong>close all</strong>：关闭所有的Figure窗口；</p><p><strong>clear</strong>：清除工作空间的所有变量；</p><p><strong>clear all</strong>：清除工作空间所有变量、函数、MEX文件；</p><p><strong>disp</strong>：用来展示变量的内容，可以是字符串、元胞、矩阵、结构体；</p><p><strong>调用帮助</strong>：help ~；或demos；或doc；</p><p><strong>whos函数</strong>：用来列出当前工作区中的变量名及它们的详细信息，如 size（大小）、bytes（字节）及class（数据类型）等；</p><p><strong>数组&#x2F;矩阵索引</strong>：从1开始；</p><p><strong>命令行小细节</strong>：当命令后面有分号（半角符号格式）时，按Enter键后，命令行窗口中不显示运算结果；如果无分号，则在命令行窗口中显示运算结果。当希望先输入多条语句，然后再同时执行它们时，则在输入下一条命令时，要在按住Shift键的同时按Enter键进行换行输入。</p></blockquote><h2 id="⛄数据类型"><a href="#⛄数据类型" class="headerlink" title="⛄数据类型"></a>⛄数据类型</h2><p><code>MATLAB</code>中的数据类型主要包括数值类型、逻辑类型、字符串、函数句柄、结构体和单元数组类型。这 6 种基本的数据类型都是按照数组形式存储和操作的。</p><h3 id="👀数值类型"><a href="#👀数值类型" class="headerlink" title="👀数值类型"></a>👀数值类型</h3><p>基本的数值类型主要有整数、单精度浮点数和双精度浮点数。<code>MATLAB</code>中数值类型的数据包括有符号和无符号整数、单精度浮点数和双精度浮点数。在未加说明与特殊定义时，<code>MATLAB</code>对所有数值按照<strong>双精度浮点数</strong>类型进行存储和操作，相对于双精度浮点数格式，整数型与单精度浮点型的优点在于节省变量占用的内存空间，当然首先要在满足精度要求的前提下。</p><h4 id="👁整数类型"><a href="#👁整数类型" class="headerlink" title="👁整数类型"></a>👁整数类型</h4><p><code>MATLAB</code>中提供了8种内置的整数类型，这8种类型的存储占用位数、能表示的数值范围和转换函数均不相同。不同的整数类型所占用的位数不同，因此能够表示的数值范围也不同。在实际应用中，应根据实际需要合理选择合适的整数类型。</p><table><thead><tr><th align="center">整数类型</th><th align="center">数值范围</th><th align="center">转换函数</th></tr></thead><tbody><tr><td align="center">有符号 8 位整数</td><td align="center">-2^7^~2^7^-1</td><td align="center">int8</td></tr><tr><td align="center">无符号 8 位整数</td><td align="center">0~2^8^-1</td><td align="center">uint8</td></tr><tr><td align="center">有符号 16 位整数</td><td align="center">-2^15^~2^15^-1</td><td align="center">int16</td></tr><tr><td align="center">无符号 16 位整数</td><td align="center">0~2^16^-1</td><td align="center">uint16</td></tr><tr><td align="center">有符号 32 位整数</td><td align="center">-2^31^~2^31^-1</td><td align="center">int32</td></tr><tr><td align="center">无符号 32 位整数</td><td align="center">0~2^32^-1</td><td align="center">uint32</td></tr><tr><td align="center">有符号 64 位整数</td><td align="center">-2^63^~2^63^-1</td><td align="center">int64</td></tr><tr><td align="center">无符号 64 位整数</td><td align="center">0~2^64^-1</td><td align="center">uint64</td></tr></tbody></table><p>由于 <code>MATLAB</code>中数值的默认存储类型是<strong>双精度浮点类型</strong>，因此将变量设置为整数类型时，需要使用相应的转换函数，将双精度浮点数转换为指定的整数类型。<code>MATLAB</code>中还包含了几类不同运算法则的取整函数，也可以把浮点数转换成整数。在不超出数值范围的情况下，任意两个整数类型之间也可以通过转换函数进行相互转换。同时，由于不同的整数类型能够表示的数值范围不同，因此当运算结果超出相应的整数类型能够表示的范围时，就会出现一处错误，运算结果被置为该整数类型能够表示的最大值或最小值。</p><table><thead><tr><th align="center">函数</th><th align="center">运算法则</th><th align="center">示例</th></tr></thead><tbody><tr><td align="center"><code>floor</code>(x)</td><td align="center">向下取整</td><td align="center">floor(1.2)&#x3D;1；floor(2.5)&#x3D;2；floor(－2.5)&#x3D; －3</td></tr><tr><td align="center"><code>ceil</code>(x)</td><td align="center">向上取整</td><td align="center">ceil(1.2)&#x3D;2；ceil(2.5)&#x3D;3；ceil(－2.5)&#x3D;－2</td></tr><tr><td align="center"><code>round</code>(x)</td><td align="center">四舍五入</td><td align="center">round(1.2)&#x3D;1；round(2.5)&#x3D;3；round(－2.5)&#x3D;－3</td></tr><tr><td align="center"><code>fix</code>(x)</td><td align="center">向0取整</td><td align="center">fix(1.2)&#x3D;1；fix(2.5)&#x3D;2；fix(－2.5)&#x3D;－2</td></tr></tbody></table><h4 id="👁浮点数类型"><a href="#👁浮点数类型" class="headerlink" title="👁浮点数类型"></a>👁浮点数类型</h4><p><code>MATLAB</code>中提供了单精度浮点数类型和双精度浮点数类型，其存储位宽、能够表示的数值范围、数值精度各方面均不相同，单精度浮点类型的占用位数少，因此占用内存小，但能够表示的数值范围和数值的精度都比双精度浮点类型小。</p><table><thead><tr><th align="center">浮点类型</th><th align="center">存储位宽</th><th>数值范围</th><th align="center">转换函数</th></tr></thead><tbody><tr><td align="center">单精度</td><td align="center">32</td><td>－3.40282e+038 ~－1.17549e-038 <br/>1.17549e-038 ~ 3.40282e+038</td><td align="center">single</td></tr><tr><td align="center">双精度</td><td align="center">64</td><td>－1.79769e+308 ~－2.22507e-308 <br/>2.22507e－308 ~ 1.79769e+308</td><td align="center">double</td></tr></tbody></table><p>双精度浮点数参与运算时，返回值的类型依赖于参与运算的其他数据类型。参与运算的其他数据为逻辑型、字符型时，返回结果为双精度浮点型；参与运算的其他数据为整数型时，返回结果为相应的整数类型；参与运算的其他数据为单精度浮点型时，返回结果为相应的单精度浮点型。</p><blockquote><p>在 <code>MATLAB</code>中，单精度浮点类型不能与整数类型进行算术运算。</p></blockquote><h4 id="👁复数"><a href="#👁复数" class="headerlink" title="👁复数"></a>👁复数</h4><p>复数包括实部和虚部两部分。<code>MATLAB</code>中默认使用字符<code>i</code>或<code>j</code>作为虚部标志。创建复数时，可以直接按照复数形式进行输入或者利用 <code>complex</code>函数。</p><table><thead><tr><th>函数</th><th>说明</th><th>函数</th><th>说明</th></tr></thead><tbody><tr><td><code>real</code>(z)</td><td>返回复数 z 的实部</td><td><code>imag</code>(z)</td><td>返回复数 z 的虚部</td></tr><tr><td><code>abs</code>(z)</td><td>返回复数 z 的模</td><td><code>angle</code>(z)</td><td>返回复数 z 的辐角</td></tr><tr><td><code>conj</code>(z)</td><td>返回复数 z 的共轭复数</td><td><code>complex</code>(a,b)</td><td>以 a 为实部、b 为虚部创建复数</td></tr></tbody></table><h4 id="👁无穷量（Inf）和非数值量（NaN）"><a href="#👁无穷量（Inf）和非数值量（NaN）" class="headerlink" title="👁无穷量（Inf）和非数值量（NaN）"></a>👁无穷量（<code>Inf</code>）和非数值量（<code>NaN</code>）</h4><p><code>MATLAB</code>中使用<code>Inf</code>和<code>-Inf</code>分别代表正无穷量和负无穷量，<code>NaN</code>表示非数值量。正负无穷量的产生一般是由于运算溢出，产生了超出双精度浮点数数值范围的结果，非数值量则是由于<code>0/0</code>或<code>Inf/Inf</code>类型的非正常运算而产生的，这两个<code>NaN</code>彼此是不相等的。</p><h3 id="👀逻辑类型"><a href="#👀逻辑类型" class="headerlink" title="👀逻辑类型"></a>👀逻辑类型</h3><p>逻辑类型的数据是指布尔类型的数据及数据之间的逻辑关系。作为所有关系和逻辑表达式的输入，<code>MATLAB</code>把任何非零数值当作真，把零当作假。所有关系和逻辑表达式的输出：对于真，输出为1；对于假，输出为0。逻辑类型数据进行运算时需要用到关系操作符和逻辑运算符。</p><table><thead><tr><th align="center">关系操作符</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">&lt;</td><td align="center">小于</td></tr><tr><td align="center">&lt;&#x3D;</td><td align="center">小于或等于</td></tr><tr><td align="center">&gt;</td><td align="center">大于</td></tr><tr><td align="center">&gt;&#x3D;</td><td align="center">大于或等于</td></tr><tr><td align="center">&#x3D;&#x3D;</td><td align="center">等于</td></tr><tr><td align="center">~&#x3D;</td><td align="center">不等于</td></tr></tbody></table><p><code>MATLAB</code>关系操作符能用来比较两个同样大小的数组，或用来比较一个数组和一个标量。在后一种情况中，标量和数组中的每一个元素相比较，结果与数组大小一样。</p><table><thead><tr><th align="center">逻辑运算符</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">&amp;</td><td align="center">与</td></tr><tr><td align="center">|</td><td align="center">或</td></tr><tr><td align="center">~</td><td align="center">非</td></tr></tbody></table><blockquote><p><code>xor</code>(x , y )指令的功能为异或运算，x和y同为零（假）或非零（真）时返回0，否则返回1。<br><code>any</code>(x)指令的功能为判断是否为零向量或零矩阵（即向量或矩阵中的元素全部为零），如果是零向量或零矩阵，则返回1，否则返回0。</p></blockquote><p><code>MATLAB</code> 还提供了大量的函数，在运算过程中用来测试特殊值或条件是否存在，并返回相应的表示结果的逻辑值。</p><table><thead><tr><th>函数名称</th><th>函数功能</th></tr></thead><tbody><tr><td><code>finite</code></td><td>元素有限，返回真值</td></tr><tr><td><code>Isempty</code></td><td>参量为空，返回真值</td></tr><tr><td><code>isglobal</code></td><td>参量是一个全局变量，返回真值</td></tr><tr><td><code>ishold</code></td><td>当前绘图保持状态是“ON”，返回真值</td></tr><tr><td><code>isieee</code></td><td>计算机执行 IEEE 算术运算，返回真值</td></tr><tr><td><code>isinf</code></td><td>元素无穷大，返回真值</td></tr><tr><td><code>isletter</code></td><td>元素为字母，返回真值</td></tr><tr><td><code>isnan</code></td><td>元素为不定值，返回真值</td></tr><tr><td><code>isreal</code></td><td>参量无虚部，返回真值</td></tr><tr><td><code>isspace</code></td><td>元素为空格字符，返回真值</td></tr><tr><td><code>isstr</code></td><td>参量为一个字符串，返回真值</td></tr><tr><td><code>isstudent</code></td><td>MATLAB 为学生版，返回真值</td></tr><tr><td><code>isunix</code></td><td>计算机为 UNIX 系统，返回真值</td></tr></tbody></table><h3 id="👀字符和字符串"><a href="#👀字符和字符串" class="headerlink" title="👀字符和字符串"></a>👀字符和字符串</h3><p>一个字符串是存储在一个行向量中的文本，这个行向量中的每一个元素代表一个字符。实际上，元素中存放的是字符的内部代码，即<code>ASCII</code>码。由于字符串是以向量的形式来存储的，因此可以通过它的下标对字符串中的任何一个元素进行访问。字符矩阵也可以通过下标索引进行访问，但是矩阵的每行字符数必须相同。</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">String =</span><br><span class="line">    <span class="string">&#x27;Every good boy does fun.&#x27;</span></span><br><span class="line">&gt;&gt; <span class="built_in">size</span>(String)</span><br><span class="line"></span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line">     <span class="number">1</span>    <span class="number">24</span></span><br><span class="line">&gt;&gt; whos </span><br><span class="line">  Name        Size            Bytes  Class     Attributes</span><br><span class="line"></span><br><span class="line">  String      <span class="number">1</span>x24               <span class="number">48</span>  char                </span><br><span class="line">  <span class="built_in">ans</span>         <span class="number">1</span>x2                <span class="number">16</span>  double   </span><br></pre></td></tr></table></figure><p>一个字符串是由<strong>单引号</strong>括起来的简单文本。在字符串里的每个字符是数组里的一个元素，字符串的存储要求每个字符8字节，如同<code>MATLAB</code>的其他变量。</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">&gt;&gt; String =<span class="string">&#x27;Every good boy does fun.&#x27;</span></span><br><span class="line">String =</span><br><span class="line">    <span class="string">&#x27;Every good boy does fun.&#x27;</span></span><br><span class="line">&gt;&gt; a = String(<span class="number">7</span>:<span class="number">10</span>) </span><br><span class="line">a =</span><br><span class="line">    <span class="string">&#x27;good&#x27;</span></span><br><span class="line">&gt;&gt; b = String(<span class="number">10</span>:<span class="number">-1</span>:<span class="number">7</span>) </span><br><span class="line">b =</span><br><span class="line">    <span class="string">&#x27;doog&#x27;</span></span><br></pre></td></tr></table></figure><p>字符串内的单引号是由两个连续的单引号来表示的。字符串的连接可以直接将字符串数组连接来实现。</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">&gt;&gt; String =<span class="string">&#x27;It&#x27;&#x27;s not the manual!&#x27;</span></span><br><span class="line">String =</span><br><span class="line">    <span class="string">&#x27;It&#x27;</span>s not the manual!<span class="string">&#x27;</span></span><br><span class="line"><span class="string">&gt;&gt; U =&#x27;</span>Hello,<span class="string">&#x27;; </span></span><br><span class="line"><span class="string">&gt;&gt; V =&#x27;</span> world!<span class="string">&#x27;; </span></span><br><span class="line"><span class="string">&gt;&gt; W = [U V] </span></span><br><span class="line"><span class="string">W =</span></span><br><span class="line"><span class="string">    &#x27;</span>Hello, world!<span class="string">&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="👀函数句柄"><a href="#👀函数句柄" class="headerlink" title="👀函数句柄"></a>👀函数句柄</h3><p>在<code>MATLAB</code>平台中，对函数的调用方法分为直接调用法和间接调用法。</p><ul><li>直接调用函数，被调用的函数通常被称为子函数。但是子函数只能被与其<code>M</code>文件同名的主函数或在<code>M</code>文件中的其他函数所调用，同时在一个文件中只能有一个主函数。</li><li>而使用函数句柄对函数进行调用则避免了上述问题。函数句柄实际上提供了一种间接调用函数的方法。创建函数句柄需要用到操作符<code>@</code>。对<code>MATLAB</code>库函数中提供的各种<code>M</code>文件中的函数和使用者自主编写的程序中的内部函数，都可以创建函数句柄，从而可以通过函数句柄来实现对这些函数的间接调用。</li></ul><p>创建函数句柄的一般句法格式为：</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">Function_Handle = @Function_Filename; </span><br><span class="line"><span class="comment">% Function_Filename是函数所对应的M文件的名称或MATLAB内部函数的名称。</span></span><br><span class="line"><span class="comment">% @是句柄创建操作符。</span></span><br><span class="line"><span class="comment">% Function_Handle变量保存了这一函数句柄，并在后续的运算中作为数据流进行传递。</span></span><br></pre></td></tr></table></figure><p>例如，<code>F_Handle=@cos</code>就创建了<code>MATLAB</code>内部函数<code>cos</code>的句柄，并将其保存在<code>F_Handle</code>变量中，后续的运算过程中就可以通过<code>F_Handle(x)</code>来实现<code>cos(x)</code>的功能。</p><h3 id="👀结构体类型"><a href="#👀结构体类型" class="headerlink" title="👀结构体类型"></a>👀结构体类型</h3><p><code>MATLAB</code>中的结构体与<code>C</code>语言中的结构体类似，一个结构体可以通过字段存储多个不同类型的数据。因此，结构体相当于一个数据容器，把多个相关联的不同类型的数据封装在一个结构体对象中。</p><p>一个结构体中可以具有多个字段，每个字段又可以存储不同类型的数据，通过这种方式就把多个不同类型的数据组织在一个结构体对象中。创建结构体对象的方法有两种，可以直接通过赋值语句给结构体的字段赋值，也可以使用结构体创建函数<code>struct</code>。</p><p>（1）直接赋值创建</p><p>通过字段赋值创建结构体。在对结构体的字段进行赋值时，赋值表达式的变量名使用“<code>结构体名称.字段名称</code>”的形式书写，对同一个结构体可以进行多个字段的赋值。</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">Student.Name=<span class="string">&#x27;Sam&#x27;</span>; </span><br><span class="line">Student.Grade=<span class="number">6</span>; </span><br><span class="line">Student.Subject=&#123;<span class="string">&#x27;Chinese&#x27;</span>,<span class="string">&#x27;Math&#x27;</span>,<span class="string">&#x27;English&#x27;</span>&#125;; </span><br><span class="line">Student.Result=&#123;<span class="number">99</span>,<span class="number">99</span>,<span class="number">99</span>&#125;; </span><br><span class="line"></span><br><span class="line"><span class="comment">% 输出结果</span></span><br><span class="line">&gt;&gt; Student</span><br><span class="line">Student = </span><br><span class="line">  包含以下字段的 struct:</span><br><span class="line">       Name: <span class="string">&#x27;Sam&#x27;</span></span><br><span class="line">      Grade: <span class="number">6</span></span><br><span class="line">    Subject: &#123;<span class="string">&#x27;Chinese&#x27;</span>  <span class="string">&#x27;Math&#x27;</span>  <span class="string">&#x27;English&#x27;</span>&#125;</span><br><span class="line">     Result: &#123;[<span class="number">99</span>]  [<span class="number">99</span>]  [<span class="number">99</span>]&#125;</span><br><span class="line"><span class="comment">% Student 是一个 1×1 的结构体数组</span></span><br><span class="line">&gt;&gt; whos</span><br><span class="line">  Name         SizeBytes  Class     Attributes</span><br><span class="line"></span><br><span class="line">  Student      <span class="number">1</span>x1<span class="number">1450</span>     struct  </span><br></pre></td></tr></table></figure><p>（2）函数<code>struct</code>创建</p><p><code>struct</code>函数的句法形式为：<code>StrArray = struct(&#39;field1&#39;, var1, &#39;field2&#39;, var2,…,&#39;fieldn&#39;, varn)</code> </p><blockquote><p>在进行字段赋值操作时，没有明确赋值的字段，<code>MATLAB</code>默认赋值为空数组。通过<strong>圆括号</strong>索引进行字段赋值，还可以创建<strong>任意尺寸的结构体数组</strong>。需要注意的是，同一个结构体数组中的所有结构体对象具有<strong>相同</strong>的字段组合。</p></blockquote><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">Schedule(<span class="number">2</span>)=struct(<span class="string">&#x27;Day&#x27;</span>,<span class="string">&#x27;Thursday&#x27;</span>,<span class="string">&#x27;Time&#x27;</span>,<span class="string">&#x27;15:00&#x27;</span>,<span class="string">&#x27;Number&#x27;</span>,<span class="number">18</span>) </span><br><span class="line">ScheduleArray=<span class="built_in">repmat</span>(struct(<span class="string">&#x27;Day&#x27;</span>,<span class="string">&#x27;Thursday&#x27;</span>,<span class="string">&#x27;Time&#x27;</span>,<span class="string">&#x27;15:00&#x27;</span>,<span class="string">&#x27;Number&#x27;</span>,<span class="number">18</span>),<span class="number">1</span>,<span class="number">2</span>) </span><br><span class="line">newArray=struct(<span class="string">&#x27;Day&#x27;</span>,&#123;<span class="string">&#x27;Thursday&#x27;</span>,<span class="string">&#x27;Friday&#x27;</span>&#125;,<span class="string">&#x27;Time&#x27;</span>,&#123;<span class="string">&#x27;15:00&#x27;</span>,<span class="string">&#x27;9:00&#x27;</span>&#125;, <span class="string">&#x27;Number&#x27;</span>,&#123;<span class="number">18</span>,<span class="number">6</span>&#125;) </span><br><span class="line"></span><br><span class="line"><span class="comment">% 输出结果</span></span><br><span class="line">Schedule = </span><br><span class="line">  包含以下字段的 <span class="number">1</span>×<span class="number">2</span> struct 数组:</span><br><span class="line">    Day</span><br><span class="line">    Time</span><br><span class="line">    Number</span><br><span class="line">ScheduleArray = </span><br><span class="line">  包含以下字段的 <span class="number">1</span>×<span class="number">2</span> struct 数组:</span><br><span class="line">    Day</span><br><span class="line">    Time</span><br><span class="line">    Number</span><br><span class="line">newArray = </span><br><span class="line">  包含以下字段的 <span class="number">1</span>×<span class="number">2</span> struct 数组:</span><br><span class="line">    Day</span><br><span class="line">    Time</span><br><span class="line">    Number</span><br><span class="line"><span class="comment">% 获取结构体某个元素</span></span><br><span class="line"><span class="comment">% 结构体第一个元素没有赋值，因此所有字段均为空数组</span></span><br><span class="line">&gt;&gt; Schedule(<span class="number">1</span>) </span><br><span class="line"><span class="built_in">ans</span> = </span><br><span class="line">  包含以下字段的 struct:</span><br><span class="line">       Day: []</span><br><span class="line">      Time: []</span><br><span class="line">    Number: []</span><br><span class="line"><span class="comment">% 1×2 的结构体数组ScheduleArray的两个元素完全相同</span></span><br><span class="line">&gt;&gt; ScheduleArray(<span class="number">1</span>) </span><br><span class="line"><span class="built_in">ans</span> = </span><br><span class="line">  包含以下字段的 struct:</span><br><span class="line">       Day: <span class="string">&#x27;Thursday&#x27;</span></span><br><span class="line">      Time: <span class="string">&#x27;15:00&#x27;</span></span><br><span class="line">    Number: <span class="number">18</span></span><br><span class="line">&gt;&gt; ScheduleArray(<span class="number">2</span>) </span><br><span class="line"><span class="built_in">ans</span> = </span><br><span class="line">  包含以下字段的 struct:</span><br><span class="line"></span><br><span class="line">       Day: <span class="string">&#x27;Thursday&#x27;</span></span><br><span class="line">      Time: <span class="string">&#x27;15:00&#x27;</span></span><br><span class="line">    Number: <span class="number">18</span></span><br><span class="line"><span class="comment">% newArray结构体中包含的结构体对象具有相同的字段组合</span></span><br><span class="line">&gt;&gt; newArray(<span class="number">1</span>) </span><br><span class="line"><span class="built_in">ans</span> = </span><br><span class="line">  包含以下字段的 struct:</span><br><span class="line">       Day: <span class="string">&#x27;Thursday&#x27;</span></span><br><span class="line">      Time: <span class="string">&#x27;15:00&#x27;</span></span><br><span class="line">    Number: <span class="number">18</span></span><br><span class="line">&gt;&gt; newArray(<span class="number">2</span>) </span><br><span class="line"><span class="built_in">ans</span> = </span><br><span class="line">  包含以下字段的 struct:</span><br><span class="line">       Day: <span class="string">&#x27;Friday&#x27;</span></span><br><span class="line">      Time: <span class="string">&#x27;9:00&#x27;</span></span><br><span class="line">    Number: <span class="number">6</span></span><br></pre></td></tr></table></figure><h3 id="👀数组类型"><a href="#👀数组类型" class="headerlink" title="👀数组类型"></a>👀数组类型</h3><p>在<code>MATLAB</code>中进行运算的所有数据类型，都是按照数组及矩阵的形式进行存储和运算的，而二者在<code>MATLAB</code>中的基本运算性质不同，阵列强调元素对元素的运算，而矩阵则采用线性代数的运算方式。数组的属性及数组之间的逻辑关系，是编写程序时非常重要的两个方面。在<code>MATLAB</code>平台上，数组的定义是广义的，数组的元素可以是<strong>任意</strong>的数据类型，例如可以是数值、字符串、指针等。</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">Array = [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span>]</span><br><span class="line"><span class="comment">% 在MATLAB中可以使用冒号“:”来代表一系列数值，有时也使用它来定义数组。</span></span><br><span class="line"><span class="comment">% 创建从i开始、步长为1、到k结束的数字序列</span></span><br><span class="line"><span class="comment">% 如果i&gt;k，MATLAB则返回一个空矩阵。数字i和k不必是整数，该序列的最后一个数小于或等于k。</span></span><br><span class="line">Array = <span class="built_in">i</span>:k </span><br><span class="line"><span class="comment">% 创建从i开始、步长为j、到k结束的数字序列</span></span><br><span class="line"><span class="comment">% 如果j=0，则返回一个空矩阵。数字i、j和k不必是整数，该序列的最后一个数小于或等于k。</span></span><br><span class="line">Array = <span class="built_in">i</span>:<span class="built_in">j</span>:k</span><br><span class="line"></span><br><span class="line"><span class="comment">% 预定义函数也可以用来创建线性序列和逻辑序列</span></span><br><span class="line"><span class="comment">% 在区间[a,b]上创建一个有n个元素的向量，这n个数把整个区间线性分隔。</span></span><br><span class="line"><span class="comment">% 当数组的元素个数为0时，就称数组为空。空数组是特殊的数组，它不含有任何元素。空数组主要用于逻辑运算、数组声明、数组的清空等。</span></span><br><span class="line">Array = <span class="built_in">linspace</span>(a,b,n) </span><br><span class="line"></span><br><span class="line"><span class="comment">% 创建空数组</span></span><br><span class="line">Array_Empty=[] </span><br></pre></td></tr></table></figure><h3 id="👀单元数组类型"><a href="#👀单元数组类型" class="headerlink" title="👀单元数组类型"></a>👀单元数组类型</h3><p>单元（<code>Cell</code>）数组是一种无所不包的广义矩阵。组成单元数组的每一个元素称为一个单元。每一个单元可以包括一个任意数组，如数值数组、字符串数组、结构体数组或另外一个单元数组，因而每一个单元可以具有不同的尺寸和内存占用空间。<code>MATLAB</code>中使用单元数组的目的在于，它可以把不同类型的数据归并到一个数组中。</p><blockquote><p>和一般的数值数组一样，单元数组的维数不受限制，可以是一维、二维或多维。</p></blockquote><h4 id="👁单元数组的创建"><a href="#👁单元数组的创建" class="headerlink" title="👁单元数组的创建"></a>👁单元数组的创建</h4><p>单元数组的创建有两种方法：使用<strong>赋值语句创建</strong>单元数组和利用<code>cell</code><strong>函数创建</strong>数组。</p><p>（1）赋值语句创建单元数组 </p><p>与一般数组有所不同的是，单元数组使用花括号“<code>&#123;&#125;</code>”来创建，使用逗号“<code>,</code>”或空格来分隔每一个单元，使用分号“<code>;</code>”来分行。</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">&gt;&gt; C = &#123;<span class="string">&#x27;x&#x27;</span>,[<span class="number">1</span>;<span class="number">3</span>;<span class="number">6</span>];<span class="number">10</span>,<span class="built_in">pi</span>&#125; </span><br><span class="line">C =</span><br><span class="line">  <span class="number">2</span>×<span class="number">2</span> cell 数组</span><br><span class="line">    &#123;<span class="string">&#x27;x&#x27;</span> &#125;    &#123;<span class="number">3</span>×<span class="number">1</span> double&#125;</span><br><span class="line">    &#123;[<span class="number">10</span>]&#125;    &#123;[  <span class="number">3.1416</span>]&#125;</span><br><span class="line">&gt;&gt; whos</span><br><span class="line">  Name      Size    Bytes  Class    Attributes</span><br><span class="line">  C         <span class="number">2</span>x2          <span class="number">490</span>           cell     </span><br></pre></td></tr></table></figure><p>（2）<code>cell</code>函数创建单元数组</p><p><code>cell</code>函数的调用格式如下：</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% cell函数创建一个 m×n 的空单元数组，其每一个单元均为空矩阵。</span></span><br><span class="line">cellName = cell(m，n)</span><br></pre></td></tr></table></figure><p>同一般的数值数组一样，单元数组的内存空间也是动态分配的。因此，使用<code>cell</code>函数创建空单元数组的主要目的是为该单元数组预先分配连续的存储空间，以节约内存占用，提高执行效率。</p><h4 id="👁单元数组的寻访"><a href="#👁单元数组的寻访" class="headerlink" title="👁单元数组的寻访"></a>👁单元数组的寻访</h4><p>在单元数组中，单元和单元中的内容是两个不同范畴的东西，因此，寻访单元和单元中的内容是两个不同的操作。<code>MATLAB</code>为两种操作设计了相对应的操作对象：单元外标识（<code>Cell Indexing</code>）和单元内编址（<code>Content Addressing</code>）。</p><p>对于单元数组<code>C</code>，<code>C(m,n)</code>指的是单元数组中第<code>m</code>行第<code>n</code>列的<strong>单元</strong>，而 <code>C&#123;m,n&#125;</code>指的是单元数组中第<code>m</code>行第<code>n</code>列<strong>单元中的内容</strong>。</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">&gt;&gt; C = &#123;<span class="number">3</span>,[<span class="number">4</span> <span class="number">7</span>;<span class="number">6</span> <span class="number">6</span>;<span class="number">80</span> <span class="number">9</span>],<span class="string">&#x27;string&#x27;</span>;<span class="built_in">sin</span>(<span class="built_in">pi</span>/<span class="number">8</span>),<span class="number">3</span>&gt;<span class="number">10</span>,<span class="string">&#x27;code&#x27;</span>&#125;</span><br><span class="line">C =</span><br><span class="line">  <span class="number">2</span>×<span class="number">3</span> cell 数组</span><br><span class="line">    &#123;[     <span class="number">3</span>]&#125;    &#123;<span class="number">3</span>×<span class="number">2</span> double&#125;    &#123;<span class="string">&#x27;string&#x27;</span>&#125;</span><br><span class="line">    &#123;[<span class="number">0.3827</span>]&#125;    &#123;[       <span class="number">0</span>]&#125;    &#123;<span class="string">&#x27;code&#x27;</span>  &#125;</span><br><span class="line"></span><br><span class="line">&gt;&gt; unitVal_1 = C(<span class="number">2</span>,<span class="number">2</span>) </span><br><span class="line">unitVal_1 =</span><br><span class="line">  <span class="number">1</span>×<span class="number">1</span> cell 数组</span><br><span class="line">    &#123;[<span class="number">0</span>]&#125;</span><br><span class="line">&gt;&gt; class(unitVal_1) </span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line">    <span class="string">&#x27;cell&#x27;</span></span><br><span class="line">&gt;&gt; unitVal_2 = C&#123;<span class="number">2</span>,<span class="number">2</span>&#125; </span><br><span class="line">unitVal_2 =</span><br><span class="line">  logical</span><br><span class="line">   <span class="number">0</span></span><br><span class="line">&gt;&gt; class(unitVal_2) </span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line">    <span class="string">&#x27;logical&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="👁单元数组的操作"><a href="#👁单元数组的操作" class="headerlink" title="👁单元数组的操作"></a>👁单元数组的操作</h4><p>单元数组的操作包括合并、删除单元数组中的指定单元、改变单元数组的形状等。</p><p>（1）单元数组的合并</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">a&#123;<span class="number">1</span>,<span class="number">1</span>&#125;=<span class="string">&#x27;cellclass&#x27;</span>; </span><br><span class="line">a&#123;<span class="number">1</span>,<span class="number">2</span>&#125;=[<span class="number">1</span> <span class="number">2</span> <span class="number">2</span>];</span><br><span class="line">a&#123;<span class="number">2</span>,<span class="number">1</span>&#125;=[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>]; </span><br><span class="line">a&#123;<span class="number">2</span>,<span class="number">2</span>&#125;=[<span class="number">9</span> <span class="number">5</span> <span class="number">6</span>];</span><br><span class="line">a</span><br><span class="line">b = &#123;<span class="string">&#x27;Jan&#x27;</span>&#125; </span><br><span class="line">c = &#123;a b&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">% 输出结果</span></span><br><span class="line">a = </span><br><span class="line"> <span class="string">&#x27;cellclass&#x27;</span> [<span class="number">1</span>x3 double] </span><br><span class="line"> <span class="string">&#x27;abc&#x27;</span> [<span class="number">1</span>x3 double] </span><br><span class="line">b = <span class="string">&#x27;Jan&#x27;</span> </span><br><span class="line">c = &#123;<span class="number">2</span>x2 cell&#125; &#123;<span class="number">1</span>x1 cell&#125; </span><br></pre></td></tr></table></figure><p>（2）单元数组中指定单元的删除</p><p>如果要删除单元数组中指定的某个单元，只需要将空矩阵赋给该单元，即：</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">C&#123;m,n&#125; = [] </span><br></pre></td></tr></table></figure><p>（3）单元数组的形状修改</p><p>使用<code>reshape</code>函数改变单元数组的形状。<code>reshape</code>函数的调用格式为：</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% reshape函数将单元数组C改变成一个具有M行N列的新单元数组。</span></span><br><span class="line">trimC = <span class="built_in">reshape</span>（C, M, N）</span><br></pre></td></tr></table></figure><h3 id="👀map容器类型"><a href="#👀map容器类型" class="headerlink" title="👀map容器类型"></a>👀map容器类型</h3><p><code>map</code>的本意是映射，是可以将一个量映射到另一个量。比如将一个字符串映射为一个数值，那个字符串就是 <code>map</code>的键（<code>key</code>），那个值就是<code>map</code>的数据（<code>value</code>）。因此，可以将map容器理解为一种快速查找数据结构的键。</p><blockquote><p>对一个<code>map</code>元素进行寻访的索引称为“<code>键</code>”。一个“<code>键</code>”可以是以下任何一种数据类型：</p><ul><li>1×N 字符串；</li><li>单精度或双精度实数标量；</li><li>有符号或无符号标量整数。</li></ul></blockquote><p>这些键和其对应的数据存储在<code>map</code>中。一个<code>map</code>的每一个条目都包括唯一的键和相对应的数据。<code>map</code>中存储的数据可以是任何类型，包括数值类型、字符或字符串类型、结构体类型、单元类型或其他<code>map</code>。一个<code>map</code>是<code>MATLAB</code>类的一个对象。<code>map</code>类的所有对象具有3种属性。用户不能直接对这些属性进行修改，但可以通过作用于<code>map</code>类的函数进行修改。</p><table><thead><tr><th>属性</th><th>说明</th><th>默认值</th></tr></thead><tbody><tr><td><code>Count</code></td><td>无符号 64 位整数，表示 map 对象中存储的 key&#x2F;value 对的总数</td><td>0</td></tr><tr><td><code>KeyType</code></td><td>字符串，表示 map 对象中包括的 key 的类型</td><td>char</td></tr><tr><td><code>ValueType</code></td><td>字符串，表示 map 对象中包括的数据类型</td><td>any</td></tr></tbody></table><blockquote><p><code>map</code>属性的查看方法为<code>map名＋小数点“.”＋map的属性名</code>。例如，为了查看<code>mapW</code>对象包括的数据类型，需要使用 <code>mapW.ValueType</code>。</p></blockquote><h4 id="👁创建map对象"><a href="#👁创建map对象" class="headerlink" title="👁创建map对象"></a>👁创建<code>map</code>对象</h4><p><code>map</code>是一个<code>map</code>类中的对象，由<code>MATLAB</code>中名为“容器”的一个包来定义，通过构造函数来创建，其创建方法如下：</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">mapObj = containers.Map(&#123;key1,key2,…&#125;,&#123;val1,val2,…&#125;) </span><br><span class="line"><span class="comment">% 当键和值是字符串时，需要对上述语法稍作变更，即：</span></span><br><span class="line">mapObj = containers.Map(&#123;<span class="string">&#x27;key1&#x27;</span>,<span class="string">&#x27;key2&#x27;</span>,…&#125;,&#123;val1,val2,…&#125;) </span><br></pre></td></tr></table></figure><p><code>map</code>对象的创建可以分为两个步骤：首先创建一个空<code>map</code>对象；然后使用<code>keys</code>和<code>values</code>方法对其内容进行补充。空<code>map</code>对象的创建方法如下：</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">&gt;&gt; newMap = containers.Map() </span><br><span class="line">&gt;&gt; newMap</span><br><span class="line">newMap = </span><br><span class="line"> Map (带属性): </span><br><span class="line"> Count: <span class="number">0</span> </span><br><span class="line"> KeyType: char </span><br><span class="line"> ValueType: any </span><br></pre></td></tr></table></figure><h4 id="👁查看-x2F-读取-map-对象"><a href="#👁查看-x2F-读取-map-对象" class="headerlink" title="👁查看&#x2F;读取 map 对象"></a>👁查看&#x2F;读取 <code>map</code> 对象</h4><p>（1）查看<code>map</code>对象</p><p><code>map</code>对象中的每个条目包括两个部分：一个唯一的键及其对应的值。可以通过使用<code>keys</code>函数查看<code>map</code>对象中包含的所有键；通过<code>values</code>函数查看所有的值。</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">&gt;&gt; schedulemap = containers.Map(&#123;<span class="string">&#x27;Monday&#x27;</span>,<span class="string">&#x27;Tuesday&#x27;</span>,<span class="string">&#x27;Wednesday&#x27;</span>,<span class="string">&#x27;Thursday&#x27;</span>,<span class="string">&#x27;Friday&#x27;</span>&#125;, &#123;<span class="string">&#x27;Maths&#x27;</span>,<span class="string">&#x27;Chinese&#x27;</span>,<span class="string">&#x27;History&#x27;</span>,<span class="string">&#x27;Geography&#x27;</span>,<span class="string">&#x27;Biology&#x27;</span>&#125;) </span><br><span class="line">schedulemap = </span><br><span class="line">  Map - 属性:</span><br><span class="line">        Count: <span class="number">5</span></span><br><span class="line">      KeyType: char</span><br><span class="line">    ValueType: char</span><br><span class="line">&gt;&gt; keys(schedulemap) </span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line">  <span class="number">1</span>×<span class="number">5</span> cell 数组</span><br><span class="line">    &#123;<span class="string">&#x27;Friday&#x27;</span>&#125;    &#123;<span class="string">&#x27;Monday&#x27;</span>&#125;    &#123;<span class="string">&#x27;Thursday&#x27;</span>&#125;    &#123;<span class="string">&#x27;Tuesday&#x27;</span>&#125;    &#123;<span class="string">&#x27;Wednesday&#x27;</span>&#125;</span><br><span class="line">&gt;&gt; values(schedulemap) </span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line">  <span class="number">1</span>×<span class="number">5</span> cell 数组</span><br><span class="line">    &#123;<span class="string">&#x27;Biology&#x27;</span>&#125;    &#123;<span class="string">&#x27;Maths&#x27;</span>&#125;    &#123;<span class="string">&#x27;Geography&#x27;</span>&#125;    &#123;<span class="string">&#x27;Chinese&#x27;</span>&#125;    &#123;<span class="string">&#x27;History&#x27;</span>&#125;</span><br></pre></td></tr></table></figure><p>（2）读取<code>map</code>对象</p><p>在创建好一个<code>map</code>对象后，用户可以对其进行数据的寻访。寻访指定键（<code>keyName</code>）所对应的值（<code>valueName</code>）使用的格式如下：</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">valueName = mapName（keyName）</span><br><span class="line"><span class="comment">% 当键名是一个字符串时，需使用单引号将键名括起来。</span></span><br><span class="line"></span><br><span class="line">&gt;&gt; course = schedulemap(<span class="string">&#x27;Wednesday&#x27;</span>) </span><br><span class="line">course =</span><br><span class="line">    <span class="string">&#x27;History&#x27;</span></span><br><span class="line"><span class="comment">% 如果需要对多个键进行访问，可以使用 values 函数，如：</span></span><br><span class="line">&gt;&gt; values(schedulemap,&#123;<span class="string">&#x27;Monday&#x27;</span>,<span class="string">&#x27;Thursday&#x27;</span>&#125;) </span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line">  <span class="number">1</span>×<span class="number">2</span> cell 数组</span><br><span class="line">    &#123;<span class="string">&#x27;Maths&#x27;</span>&#125;    &#123;<span class="string">&#x27;Geography&#x27;</span>&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在对多个键进行访问时，不能像在其他数据类型中那样使用冒号“<code>:</code>”，这将导致错误产生。例如输入：<br><code>schedulemap(&#39;Monday&#39;:&#39;Thursday&#39;) </code><br>结果弹出如下错误信息：<br>警告: 冒号操作数必须为实数标量。</p></blockquote><h4 id="👁编辑map对象"><a href="#👁编辑map对象" class="headerlink" title="👁编辑map对象"></a>👁编辑<code>map</code>对象</h4><p>（1）从<code>map</code>对象中删除<code>keys/values</code>对</p><p>用户可以使用<code>remove</code>函数从<code>map</code>对象中删除<code>keys/values</code>对，该函数的调用格式为：</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% mapName和keyName分别为map对象名称及需要删除的键名。</span></span><br><span class="line"><span class="comment">% 执行该命令后，MATLAB 系统删除指定的键名及其相对应的值。</span></span><br><span class="line">remove(<span class="string">&#x27;mapName&#x27;</span>, <span class="string">&#x27;keyName&#x27;</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment">% 删除schedulemap中的“星期四”及其对应的科目。</span></span><br><span class="line">&gt;&gt; remove(schedulemap,<span class="string">&#x27;Thursday&#x27;</span>) </span><br><span class="line"><span class="built_in">ans</span> = </span><br><span class="line">  Map - 属性:</span><br><span class="line">        Count: <span class="number">4</span></span><br><span class="line">      KeyType: char</span><br><span class="line">    ValueType: char</span><br><span class="line">&gt;&gt; keys(schedulemap) </span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line">  <span class="number">1</span>×<span class="number">4</span> cell 数组</span><br><span class="line">    &#123;<span class="string">&#x27;Friday&#x27;</span>&#125;    &#123;<span class="string">&#x27;Monday&#x27;</span>&#125;    &#123;<span class="string">&#x27;Tuesday&#x27;</span>&#125;    &#123;<span class="string">&#x27;Wednesday&#x27;</span>&#125;</span><br><span class="line">&gt;&gt; values(schedulemap) </span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line">  <span class="number">1</span>×<span class="number">4</span> cell 数组</span><br><span class="line">    &#123;<span class="string">&#x27;Biology&#x27;</span>&#125;    &#123;<span class="string">&#x27;Maths&#x27;</span>&#125;    &#123;<span class="string">&#x27;Chinese&#x27;</span>&#125;    &#123;<span class="string">&#x27;History&#x27;</span>&#125;</span><br></pre></td></tr></table></figure><p>（2）添加<code>keys/values</code>对象</p><p>当用户向一个<code>map</code>对象中写入新元素的值时，需要提供键名，而且该键的类型必须和<code>map</code>中的其他键一致。该操作的调用格式为：</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">existingMapObj(newKeyName)= newValue </span><br><span class="line"></span><br><span class="line"><span class="comment">% 为schedulemap添加“星期六”及其对应的科目“public elective course”</span></span><br><span class="line">&gt;&gt; schedulemap(<span class="string">&#x27;Saturday&#x27;</span>) = <span class="string">&#x27;public elective course&#x27;</span> </span><br><span class="line">schedulemap = </span><br><span class="line">  Map - 属性:</span><br><span class="line">        Count: <span class="number">5</span></span><br><span class="line">      KeyType: char</span><br><span class="line">    ValueType: char</span><br><span class="line">&gt;&gt; keys(schedulemap) </span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line">  <span class="number">1</span>×<span class="number">5</span> cell 数组</span><br><span class="line">    &#123;<span class="string">&#x27;Friday&#x27;</span>&#125;    &#123;<span class="string">&#x27;Monday&#x27;</span>&#125;    &#123;<span class="string">&#x27;Saturday&#x27;</span>&#125;    &#123;<span class="string">&#x27;Tuesday&#x27;</span>&#125;    &#123;<span class="string">&#x27;Wednesday&#x27;</span>&#125;</span><br><span class="line">&gt;&gt; values(schedulemap) </span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line">  <span class="number">1</span>×<span class="number">5</span> cell 数组</span><br><span class="line">    &#123;<span class="string">&#x27;Biology&#x27;</span>&#125;    &#123;<span class="string">&#x27;Maths&#x27;</span>&#125;    &#123;<span class="string">&#x27;public elective…&#x27;</span>&#125;    &#123;<span class="string">&#x27;Chinese&#x27;</span>&#125;    &#123;<span class="string">&#x27;History&#x27;</span>&#125;</span><br></pre></td></tr></table></figure><p>（3）修改<code>keys</code></p><p>如果需要在保持值不变的情况下对键名进行更改，首先要删除键名和对应的值，然后再添加一个有正确键名的新条目。</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% 修改“星期六”及其对应的科目“公共选修课”为“星期天”及其对应的科目“MBA”</span></span><br><span class="line">&gt;&gt; remove(schedulemap,<span class="string">&#x27;Saturday&#x27;</span>);</span><br><span class="line">&gt;&gt; schedulemap(<span class="string">&#x27;Sunday&#x27;</span>) = <span class="string">&#x27;MBA&#x27;</span>; </span><br><span class="line">&gt;&gt; keys(schedulemap) </span><br><span class="line"></span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line">  <span class="number">1</span>×<span class="number">5</span> cell 数组</span><br><span class="line">    &#123;<span class="string">&#x27;Friday&#x27;</span>&#125;    &#123;<span class="string">&#x27;Monday&#x27;</span>&#125;    &#123;<span class="string">&#x27;Sunday&#x27;</span>&#125;    &#123;<span class="string">&#x27;Tuesday&#x27;</span>&#125;    &#123;<span class="string">&#x27;Wednesday&#x27;</span>&#125;</span><br><span class="line">&gt;&gt; values(schedulemap) </span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line">  <span class="number">1</span>×<span class="number">5</span> cell 数组</span><br><span class="line">    &#123;<span class="string">&#x27;Biology&#x27;</span>&#125;    &#123;<span class="string">&#x27;Maths&#x27;</span>&#125;    &#123;<span class="string">&#x27;MBA&#x27;</span>&#125;    &#123;<span class="string">&#x27;Chinese&#x27;</span>&#125;    &#123;<span class="string">&#x27;History&#x27;</span>&#125;</span><br></pre></td></tr></table></figure><p>（4）修改<code>values</code></p><p>通过赋值操作，覆盖原有的值，即可对<code>map</code>对象中的值进行修改。</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% 修改“星期一”的科目为“英语”</span></span><br><span class="line">&gt;&gt; schedulemap(<span class="string">&#x27;Monday&#x27;</span>)</span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line">    <span class="string">&#x27;Maths&#x27;</span></span><br><span class="line">&gt;&gt; schedulemap(<span class="string">&#x27;Monday&#x27;</span>) = <span class="string">&#x27;english&#x27;</span>; </span><br><span class="line">&gt;&gt; keys(schedulemap) </span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line">  <span class="number">1</span>×<span class="number">5</span> cell 数组</span><br><span class="line">    &#123;<span class="string">&#x27;Friday&#x27;</span>&#125;    &#123;<span class="string">&#x27;Monday&#x27;</span>&#125;    &#123;<span class="string">&#x27;Sunday&#x27;</span>&#125;    &#123;<span class="string">&#x27;Tuesday&#x27;</span>&#125;    &#123;<span class="string">&#x27;Wednesday&#x27;</span>&#125;</span><br><span class="line">&gt;&gt; values(schedulemap) </span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line">  <span class="number">1</span>×<span class="number">5</span> cell 数组</span><br><span class="line">    &#123;<span class="string">&#x27;Biology&#x27;</span>&#125;    &#123;<span class="string">&#x27;english&#x27;</span>&#125;    &#123;<span class="string">&#x27;MBA&#x27;</span>&#125;    &#123;<span class="string">&#x27;Chinese&#x27;</span>&#125;    &#123;<span class="string">&#x27;History&#x27;</span>&#125;</span><br></pre></td></tr></table></figure><h2 id="⛄基本矩阵操作"><a href="#⛄基本矩阵操作" class="headerlink" title="⛄基本矩阵操作"></a>⛄基本矩阵操作</h2><p>对矩阵的基本操作，主要有矩阵的构建、矩阵维度与矩阵大小的改变、矩阵的索引、矩阵属性信息的获取、矩阵结构的改变等。对于这些操作，<code>MATLAB</code>中都有固定指令或相应的库函数与之相对应。</p><p>矩阵最早来自于方程组的系数及常数所构成的方阵，这一概念由19世纪英国数学家凯利首先提出。数组是在程序设计中，为了处理方便，把具有相同类型的若干变量按有序的形式组织起来的一种形式。这些按序排列的同类数据元素的集合称为数组。</p><p>在<code>MATLAB</code>中，一个数组可以分解为多个数组元素，这些数组元素可以是基本数据类型或构造类型。因此按数组元素的类型不同，数组又可分为数值数组、字符数组、单元数组、结构数组等各种类别。</p><p>由此可见，矩阵和数组在<code>MATLAB</code>中存在很多方面的区别，主要有以下几个方面：</p><ul><li>矩阵是数学上的概念，而数组是计算机程序设计领域的概念。</li><li>作为一种变换或者映射算符的体现，矩阵运算有着明确而严格的数学规则。而数组运算是 MATLAB 软件定义的规则，其目的是为了使数据管理方便，操作简单，命令形式自然，执行计算有效。</li></ul><p>两者间的联系主要体现在：在<code>MATLAB</code>中，矩阵是以数组的形式存在的。因此，一维数组相当于向量，二维数组相当于矩阵，所以矩阵是数组的子集。</p><h3 id="👀矩阵的构造"><a href="#👀矩阵的构造" class="headerlink" title="👀矩阵的构造"></a>👀矩阵的构造</h3><p>矩阵的构建方式有两种，一种与单元数组相似，可以对变量直接进行赋值；另一种是<code>MATLAB</code>中提供构建特殊矩阵的指令。特殊矩阵的构建函数：</p><p><strong>1矩阵</strong>：<code>ones()</code>；</p><p><strong>0矩阵</strong>：<code>zeros()</code>；</p><p><strong>单位矩阵</strong>：<code>eyes()</code>；</p><p><strong>行&#x2F;列和相等的矩阵</strong>：<code>magic()</code>；</p><p><strong>随机矩阵</strong>：<code>rand()</code>和<code>randn()</code>；</p><p><strong>其它矩阵（对角线、上三角形、下三角形）</strong>：<code>diag()</code>、<code>triu()</code>、<code>tril()</code>。</p><p>（1）建立简单矩阵</p><p>简单矩阵采用矩阵构造符号——方括号“<code>[]</code>”，将矩阵元素置于方括号内，同行元素之间用<code>空格</code>或<code>逗号</code>隔开，行与行之间用分号“<code>;</code>”隔开，格式如下：</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">matrixName = [element11,element12,element13;element21,element22,element23] </span><br><span class="line">matrixName = [element11 element12 element13;element21 element22 element23] </span><br></pre></td></tr></table></figure><p>（2）建立特殊矩阵</p><p>特殊矩阵是指非零元素或零元素的分布有一定规律的矩阵，常见的有对称矩阵、三角矩阵和对角矩阵等。</p><p>（3）向量、标量和空矩阵</p><p>通常情况下，矩阵包含m行和n列，即m×n。当m和n取一些特殊值时，得到的矩阵具有一些特殊的性质。</p><p><strong>向量</strong>：当m&#x3D;1或n&#x3D;1，即1×n或m×1时，建立的矩阵称为向量。</p><p><strong>标量</strong>：当m&#x3D;n&#x3D;1时，建立的矩阵称为标量。任意以1×1的矩阵形式表示的<strong>单个实数</strong>、<strong>复数</strong>都是标量。单个实数或者复数在<code>MATLAB</code>中都是以矩阵的形式存储的；在<code>MATLAB</code>中，单个数据或由单个数据构造的矩阵都是标量。</p><p><strong>空矩阵</strong>：当m&#x3D;n&#x3D;0，或者m&#x3D;0，或者n&#x3D;0，即0×0、0×n、m×0 时，创建的矩阵称为空矩阵。空矩阵可以通过赋值语句建立。<strong>空矩阵</strong>和<strong>0矩阵</strong>的本质区别在于：空矩阵内没有任何元素，因此不占用任何存储空间；而 0 矩阵表示该矩阵中的所有元素全部为0，需要占用一定的存储空间。</p><h3 id="👀矩阵大小及结构的改变"><a href="#👀矩阵大小及结构的改变" class="headerlink" title="👀矩阵大小及结构的改变"></a>👀矩阵大小及结构的改变</h3><p>根据运算时的不同情况和需要，矩阵大小和结构的改变，主要的方式有旋转矩阵、改变矩阵维度、删除矩阵元素等。</p><table><thead><tr><th>函数名称</th><th>函数功能</th></tr></thead><tbody><tr><td><code>fliplr(A)</code></td><td>矩阵每一行均进行逆序排列</td></tr><tr><td><code>flipud(A)</code></td><td>矩阵每一列均进行逆序排列</td></tr><tr><td><code>flipdim(A,dim)</code></td><td>生成一个在dim维矩阵A内的元素交换位置的多维矩阵</td></tr><tr><td><code>rot90(A)</code></td><td>生成一个由矩阵A逆时针旋转90°而得到的新矩阵</td></tr><tr><td><code>rot90(A,k)</code></td><td>生成一个由矩阵A逆时针旋转k×90°而得到的新矩阵</td></tr><tr><td><code>reshape(A,m,n)</code></td><td>生成一个m×n×…×p维的矩阵，其元素以线性索引的顺序从矩阵A中取得<br/>如果矩阵A中没有m×n×…×p个元素，将返回一个错误信息</td></tr><tr><td><code>repmat(A,[m n…p])</code></td><td>创建一个和矩阵A有相同元素的m×n×…×p块的多维矩阵</td></tr><tr><td><code>shiftdim(A,n)</code></td><td>矩阵的列移动n步。n为正数，矩阵向左移；n为负数，矩阵向右移</td></tr><tr><td><code>squeeze(A)</code></td><td>返回没有空维的矩阵A</td></tr><tr><td><code>cat(dim,A,B)</code></td><td>将矩阵A和B组合成一个dim维的多维矩阵</td></tr><tr><td><code>permute(A,order)</code></td><td>根据向量order来改变矩阵A中的维数顺序</td></tr><tr><td><code>ipermute(A,order)</code></td><td>进行命令permute的逆变换</td></tr><tr><td><code>sort(A)</code></td><td>对一维或二维矩阵进行升序排序，并返回排序后的矩阵；<br/>当A为二维矩阵时，对矩阵的每一列分别进行排序</td></tr><tr><td><code>sort(A,dim)</code></td><td>对矩阵按指定的方向进行升序排序，并返回排序后的矩阵。<br />当dim&#x3D;1时，对矩阵的每一列排序；dim&#x3D;2时，对矩阵的每一行排序</td></tr><tr><td><code>sort(A,dim,mode)</code></td><td>mode为’ascend’时，进行升序排序；mode为’descend’时，进行降序排序</td></tr><tr><td><code>[B,IX] = sort(A,…)</code></td><td>IX为排序后备元素在原矩阵中的行位置或列位置的索引</td></tr></tbody></table><h3 id="👀矩阵下标引用"><a href="#👀矩阵下标引用" class="headerlink" title="👀矩阵下标引用"></a>👀矩阵下标引用</h3><p>在<code>MATLAB</code>中，普通二维数组元素的数字索引分为<strong>双下标索引</strong>和<strong>单下标索引</strong>。<strong>双下标索引</strong>是通过一个二元数组对来对应元素在矩阵中的行列位置，例如A(2,3)表示矩阵A中第2行第3列的元素。<strong>单下标索引</strong>的方式是采用列元素优先的原则，对m行n列的矩阵按列排序进行重组，成为一维数组，再取新的一维数组中的元素位置对应的值作为元素在原矩阵中的单下标，例如对于4×4的矩阵，A(7)表示矩阵A中第3行第2列的元素，而 A(13)表示矩阵A中第1行第4列的元素。</p><p>（1）矩阵下标访问单个矩阵元素</p><table><thead><tr><th>索引表达式</th><th>函数功能</th></tr></thead><tbody><tr><td><code>A(1)</code></td><td>将二维矩阵<code>A</code>重组为一维数组，返回数组中第一个元素</td></tr><tr><td><code>A(:,j)</code></td><td>返回二维矩阵<code>A</code>中第<code>j</code>列列向量</td></tr><tr><td><code>A(i,:)</code></td><td>返回二维矩阵<code>A</code>中第<code>i</code>行行向量</td></tr><tr><td><code>A(:,j:k)</code></td><td>返回由二维矩阵<code>A</code>中的第<code>j</code>列到第<code>k</code>列列向量组成的子矩阵</td></tr><tr><td><code>A(i:k,:)</code></td><td>返回由二维矩阵<code>A</code>中的第<code>i</code>行到第<code>k</code>行行向量组成的子矩阵</td></tr><tr><td><code>A(i:k,j:l)</code></td><td>返回由二维矩阵<code>A</code>中的第<code>i</code>行到第<code>k</code>行行向量<br />和第<code>j</code>列到第<code>l</code>列列向量的交集组成的子矩阵</td></tr><tr><td><code>A(:)</code></td><td>将矩阵<code>A</code>中的每列合并成一个长的列向量</td></tr><tr><td><code>A(j:k)</code></td><td>返回一个行向量，其元素为<code>A(:)</code>中的第<code>j</code>个元素到第<code>k</code>个元素</td></tr><tr><td><code>A([j1 j2 …])</code></td><td>返回一个行向量，其元素为<code>A(:)</code>中的第<code>j1</code>、<code>j2</code>元素</td></tr><tr><td><code>A(:,[j1 j2…])</code></td><td>返回矩阵<code>A</code>的第<code>j1</code>列、第<code>j2</code>列等的列向量</td></tr><tr><td><code>A([i1 i2 …],:)</code></td><td>返回矩阵<code>A</code>的第<code>i1</code>行、第<code>i2</code>行等的行向量</td></tr><tr><td><code>A([i1 i2…],[j1 j2…])</code></td><td>返回矩阵第<code>i1</code>行、第<code>i2</code>行等和第<code>j1</code>列、第<code>j2</code>列等的元素</td></tr></tbody></table><p>（2）线性应用矩阵元素</p><p>矩阵中某一元素的单下标索引值和双下标索引值之间，可以通过<code>MATLAB</code>内部函数进行转换。</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% 将双下标索引值转换为单下标索引值</span></span><br><span class="line"><span class="comment">% siz是一个包含两个元素的数组，代表了转换矩阵的行列数，一般可以直接用size(A)表示;</span></span><br><span class="line"><span class="comment">% i与j分别是双下表索引中的行、列值，IND是转换后的单下标索引值。</span></span><br><span class="line">IND = <span class="built_in">sub2ind</span>(siz, <span class="built_in">i</span>, <span class="built_in">j</span>) </span><br><span class="line"><span class="comment">% 将单下标索引值转换为双下标索引值，各变量意义同上</span></span><br><span class="line">[I J] = <span class="built_in">ind2sub</span>(siz, ind) </span><br></pre></td></tr></table></figure><p>（3）访问多个矩阵元素</p><p>在下标表达式里，可以用冒号来表示矩阵的多个元素。例如，<code>A(1:k,j)</code>表示矩阵第<code>j</code>列的前<code>k</code>个元素。在 <code>MATLAB</code>中提供了一个关键字<code>end</code>，用于表示该维中的最后一个元素。</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">A=<span class="built_in">magic</span>(<span class="number">4</span>)，</span><br><span class="line"><span class="comment">% 利用冒号，第4列元素的和可以用更为简洁的式子</span></span><br><span class="line">sum(A(<span class="number">1</span>:<span class="number">4</span>,<span class="number">4</span>)) </span><br><span class="line"><span class="comment">% 冒号本身可以表示一列或者一行的所有元素，上式还可写为：</span></span><br><span class="line">sum(A(:,<span class="number">4</span>)) </span><br><span class="line"><span class="comment">% 关键字end，用于表示该维中的最后一个元素，上式还可写为：</span></span><br><span class="line">sum(A(:,<span class="keyword">end</span>)) </span><br><span class="line"></span><br><span class="line"><span class="comment">% 还可以用冒号来表示非相邻的多个元素</span></span><br><span class="line">B=<span class="number">1</span>:<span class="number">10</span> </span><br><span class="line">C=B(<span class="number">1</span>:<span class="number">3</span>:<span class="number">10</span>) </span><br></pre></td></tr></table></figure><h3 id="👀矩阵信息的获取"><a href="#👀矩阵信息的获取" class="headerlink" title="👀矩阵信息的获取"></a>👀矩阵信息的获取</h3><p>矩阵的信息主要包括矩阵结构、矩阵大小、矩阵维度、矩阵的数据类型及内存占用等。</p><p>（1）矩阵结构</p><p>矩阵的结构是指矩阵子元素的排列方式。这类函数的返回值是逻辑类型的数据。返回值为“<code>1</code>”表示该矩阵是某一特定类型的矩阵；返回值为“<code>0</code>”表示该矩阵不是该特定类型的矩阵。</p><table><thead><tr><th>函数名称</th><th>函数功能</th></tr></thead><tbody><tr><td><code>isempty(A)</code></td><td>检测矩阵是否为空</td></tr><tr><td><code>isscalar(A)</code></td><td>检测矩阵是否是单元素的标量矩阵</td></tr><tr><td><code>isvector(A)</code></td><td>检测矩阵是否是只具有一行或一列元素的一维向量</td></tr><tr><td><code>issparse(A)</code></td><td>检测数组是否是稀疏矩阵</td></tr></tbody></table><p>（2）矩阵大小</p><p>矩阵的形状信息反映了矩阵的大小，通常又包括以下几个方面的内容：</p><ul><li>矩阵的维数。</li><li>矩阵各维（例如最长维、用户指定的维）的长度。</li><li>矩阵元素的个数。</li></ul><table><thead><tr><th>函 数</th><th></th><th>描 述</th></tr></thead><tbody><tr><td><code>ndims</code></td><td>n&#x3D;ndims(X)</td><td>获取矩阵的维数</td></tr><tr><td><code>size</code></td><td>[m,n]&#x3D;size(X)</td><td>获取矩阵在各维上的长度</td></tr><tr><td><code>length</code></td><td>n&#x3D;length(X)</td><td>获取矩阵最长维的长度</td></tr><tr><td><code>numel</code></td><td>n&#x3D;numel(X)</td><td>获取矩阵元素的个数</td></tr></tbody></table><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">A = <span class="built_in">eye</span>(<span class="number">5</span>,<span class="number">3</span>) </span><br><span class="line">[m,n] = <span class="built_in">size</span>(A) </span><br><span class="line">m = <span class="number">5</span> </span><br><span class="line">n = <span class="number">3</span> </span><br><span class="line">d = <span class="built_in">size</span>(A) </span><br><span class="line">d = <span class="number">5</span> <span class="number">3</span> </span><br><span class="line">e1 = <span class="built_in">size</span>(A,<span class="number">1</span>) </span><br><span class="line">e1 = <span class="number">5</span> </span><br><span class="line">e2 = <span class="built_in">size</span>(A,<span class="number">2</span>) </span><br><span class="line">e2 = <span class="number">3</span> </span><br></pre></td></tr></table></figure><blockquote><p><code>size</code>函数的应用可知：①<code>size</code>函数的返回值可以是分开显示的单个实数变量，也可以是一个行向量；②在<code>size</code>函数的输入参数中增加维度参数可以获取指定维度的长度，其中“<code>1</code>”表示行，“<code>2</code>”表示列。</p></blockquote><p>（3）矩阵维度</p><p>对于空矩阵、标量矩阵、一维矩阵和二维矩阵，<code>MATLAB</code>都将其作为普通二维数组对待。特别需要注意的是，用[]产生的空矩阵是作为二维矩阵的，但是在高维矩阵中也有空矩阵的概念，此时空矩阵则具有多个维度。</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">A = []; B = <span class="number">5</span>; C = <span class="number">1</span>:<span class="number">3</span>; D = <span class="built_in">magic</span>(<span class="number">2</span>); E(:,:,<span class="number">2</span>) = [<span class="number">1</span> <span class="number">2</span>; <span class="number">3</span> <span class="number">4</span>]; </span><br><span class="line">Ndims = [<span class="built_in">ndims</span>(A) <span class="built_in">ndims</span>(B) <span class="built_in">ndims</span>(C) <span class="built_in">ndims</span>(D) <span class="built_in">ndims</span>(E)] </span><br><span class="line"><span class="comment">% 输出结果</span></span><br><span class="line">Ndims = <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">3</span> </span><br></pre></td></tr></table></figure><p>（4）矩阵的数据类型</p><p>矩阵作为<code>MATLAB</code>的内部数据存储和运算结构，其元素可以是各种各样的数据类型，对应不同数据类型的元素，可以是数值、字符串、元胞、结构体等。这类函数的返回值也是逻辑类型的数据。返回值为“<code>1</code>”表示是某一特定的数据类型；返回值为“<code>0</code>”表示不是该特定的数据类型。</p><table><thead><tr><th>函数名称</th><th>函数功能</th></tr></thead><tbody><tr><td><code>isnumeric</code></td><td>检测矩阵元素是否为数值型变量</td></tr><tr><td><code>isreal</code></td><td>检测矩阵元素是否为实数数值型变量</td></tr><tr><td><code>isfloat</code></td><td>检测矩阵元素是否为浮点数值型变量</td></tr><tr><td><code>isinteger</code></td><td>检测矩阵元素是否为整数型变量</td></tr><tr><td><code>islogical</code></td><td>检测矩阵元素是否为逻辑型变量</td></tr><tr><td><code>ischar</code></td><td>检测矩阵元素是否为字符型变量</td></tr><tr><td><code>isstruct</code></td><td>检测矩阵元素是否为结构体型变量</td></tr><tr><td><code>iscell</code></td><td>检测矩阵元素是否为元胞型变量</td></tr><tr><td><code>iscellstr</code></td><td>检测矩阵元素是否为结构体的元胞型变量</td></tr></tbody></table><p>（5）矩阵占用的内存</p><p>了解矩阵的内存占用情况，对于优化<code>MATLAB</code>代码性能是十分重要的。使用者可以通过<code>whos</code>命令查看当前工作区中指定变量的所有信息，包括变量名、矩阵大小、内存占用和数据类型等。</p><h3 id="👀矩阵的保存和加载"><a href="#👀矩阵的保存和加载" class="headerlink" title="👀矩阵的保存和加载"></a>👀矩阵的保存和加载</h3><p>矩阵在MATLAB中的存储方式、矩阵元素的寻址方法、矩阵元素的赋值及扩展。<code>MATLAB</code>就是将矩阵元素按<code>列优先</code>排列的原则依次放置在相应的格子内。因此，可以看成是一个长列向量。<code>MATLAB</code>采用了两种元素寻址方式：①矩阵下标寻址；②线性寻址。</p><h4 id="👁矩阵元素的寻址"><a href="#👁矩阵元素的寻址" class="headerlink" title="👁矩阵元素的寻址"></a>👁矩阵元素的寻址</h4><p>（1）矩阵下标寻址方法</p><p>在<code>MATLAB</code>中，使用<code>A(i,j)</code>来表示一个矩阵<code>A</code>从左上角数起的第i行、第j列上的元素，这就是矩阵下标寻址方法。这种方法和线性代数中矩阵元素的引用方法一致，通俗易懂。</p><p><strong>单元素的寻访</strong>：当使用双下标访问一个二维矩阵中的某个元素时，必须同时指定该元素所在的行号和列号，访问格式为：<code>A(numRow,numColumn)</code> ，其中，<code>numRow</code>和<code>numColumn</code>分别代表行号和列号。</p><p><strong>矩阵元素区域的寻访</strong>：访问矩阵的多个元素，可以是某一行、某一列或者其中的部分元素，也可以是矩阵中的某一块区域。在<code>MATLAB</code>中，元素区域的访问需要用到冒号“<code>:</code>”来表示矩阵中的多个元素，具体的访问格式如下：</p><ul><li><code>A(1:m,n)</code>：表示访问第n列的第一个元素至第m个元素。</li><li><code>A(m,:)</code>：表示访问第m行的所有元素。</li><li><code>A(i:j,m:n)</code> ：表示访问从第i 行至第j行、从第m列至第n列的矩阵区域。</li><li><code>A(i:inc1:j,m:inc2:n)</code> ：表示访问从第i行至第j行，行间隔为inc1行；从第m列至第n列，列间隔为inc2的非相邻的多个矩阵元素。</li></ul><p>（2）线性寻址</p><p>线性寻址的原理来自于<code>MATLAB</code>将矩阵元素存储在内存空间的存储方法。与矩阵下标寻址相比，只需要单一下标即可实现矩阵中任意位置元素的寻访。线性寻址的下标是通过矩阵的双下标换算得到的。</p><p>一般，设A是一个m×n的矩阵，位于第i行、第j列上的元素A(i,j)的单一下标为<code>A((j-1)·m+i)</code>。</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">A = <span class="built_in">hilb</span>(<span class="number">3</span>) </span><br><span class="line">A(<span class="number">2</span>,<span class="number">3</span>) <span class="comment">% 采用矩阵下标寻址的方法访问第 2 行第 3 列的元素</span></span><br><span class="line">A(<span class="number">8</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment">% 输出结果</span></span><br><span class="line">A = </span><br><span class="line"> <span class="number">1.0000</span> <span class="number">0.5000</span> <span class="number">0.3333</span> </span><br><span class="line"> <span class="number">0.5000</span> <span class="number">0.3333</span> <span class="number">0.2500</span> </span><br><span class="line"><span class="number">0.3333</span> <span class="number">0.2500</span> <span class="number">0.2000</span> </span><br><span class="line"><span class="built_in">ans</span> = <span class="number">0.2500</span> </span><br><span class="line"><span class="built_in">ans</span> = <span class="number">0.2500</span> </span><br></pre></td></tr></table></figure><h4 id="👁矩阵元素的赋值及扩展"><a href="#👁矩阵元素的赋值及扩展" class="headerlink" title="👁矩阵元素的赋值及扩展"></a>👁矩阵元素的赋值及扩展</h4><p>（1）矩阵元素的赋值</p><p><code>MATLAB</code>使用赋值语句对矩阵元素进行赋值，基本语法如下：</p><ul><li><code>A(i,j) = value</code>：等号左侧为矩阵中的某个元素；等号右侧为值。</li><li><code>A = []</code>：删除矩阵中的所有元素。</li></ul><p>（2）矩阵元素的扩展与删除</p><p>增加或删除矩阵元素最常用的办法是使用赋值语句。此外，<code>MATLAB</code>提供了多个函数进行矩阵合并操作，从而实现将多个矩阵合并成一个矩阵。</p><table><thead><tr><th>函数</th><th>调用格式</th><th>描述</th></tr></thead><tbody><tr><td><code>cat</code></td><td><code>cat(DIM,A,B)</code></td><td>在DIM指定的维度上合并矩阵 A 和 B。<br />DIM&#x3D;1表示按行（竖直方向）合并；DIM&#x3D;2表示按列（水平方向）合并</td></tr><tr><td><code>horzcat</code></td><td><code>horzcat(A,B)</code></td><td>在水平方向上合并矩阵A和B</td></tr><tr><td><code>vertcat</code></td><td><code>vertcat(A,B)</code></td><td>在竖直方向上合并矩阵A和B</td></tr><tr><td><code>repmat</code></td><td><code>B=repmat(A,M,N)</code></td><td>通过复制M×N个矩阵A来构造新的矩阵B</td></tr><tr><td><code>blkdiag</code></td><td><code>Y=blkdiag(A,B,...)</code></td><td>用已知的A、B等多个矩阵构造块对角化矩阵Y</td></tr></tbody></table><blockquote><p>cat及其相关的函数在将两个矩阵按某个维度进行合并操作时，原始的两个矩阵要在某一个维度上具有相同的长度，否则 MATLAB 在进行计算时就会发生错误。</p></blockquote><h2 id="⛄运算符"><a href="#⛄运算符" class="headerlink" title="⛄运算符"></a>⛄运算符</h2><p><code>MATLAB</code>中的运算符分为算术运算符、关系运算符和逻辑运算符。这三种运算符可以分别使用，也可以在同一运算式中出现。当在同一运算式中同时出现两种或两种以上运算符时，运算的优先级排列如下：算术运算符优先级最高，其次是关系运算符，最低级别是逻辑运算符。</p><h3 id="👀算术运算符"><a href="#👀算术运算符" class="headerlink" title="👀算术运算符"></a>👀算术运算符</h3><p><code>MATLAB</code>中的算术运算符有加、减、乘、除、点乘、点除等。</p><table><thead><tr><th>算术运算符</th><th>运算法则</th><th>算术运算符</th><th>运算法则</th></tr></thead><tbody><tr><td><code>A+B</code></td><td>A与B相加<br/>（A、B为数值或矩阵）</td><td><code>A-B</code></td><td>A与B相减<br/>（A、B为数值或矩阵）</td></tr><tr><td><code>A * B</code></td><td>A与B相乘<br/>（A、B为数值或矩阵）</td><td><code>A.* B</code></td><td>A与B相应元素相乘<br/>（A、B为相同维度的矩阵）</td></tr><tr><td><code>A / B</code></td><td>A与B相除<br/>（A、B为数值或矩阵）</td><td><code>A./ B</code></td><td>A与B相应元素相除<br/>（A、B为相同维度的矩阵）</td></tr><tr><td><code>A ^ B</code></td><td>A的B次幂<br/>（A、B为数值或矩阵）</td><td><code>A.^ B</code></td><td>A的每个元素的B次幂<br/>（A 为矩阵，B为数值）</td></tr></tbody></table><p><code>MATLAB</code>平台上还提供了大量的运算函数：<code>exp(x)</code>、<code>log(x)</code>、<code>log10(x)</code>、<code>sqrt(x)</code>、<code>sin(x)</code>、<code>cos(x)</code>、<code>tan(x)</code>、<code>asin(x)</code>、<code>acos(x)</code>、<code>atan(x)</code>、<code>mod(a,b)</code>、<code>min(a,b)</code>、<code>max(a,b)</code>、<code>mean(x)</code>、<code>median(x)</code>、<code>sum(x)</code>、<code>prod(x)</code>、<code>cumsum(x)</code>、<code>cumprod(x)</code>、<code>sign(x)</code>、<code>rem(x,y)</code>、<code>diff(x)</code>、<code>sort(x)</code>、<code>fft(x)</code>、<code>rank(x)</code> 。</p><h3 id="👀关系运算符"><a href="#👀关系运算符" class="headerlink" title="👀关系运算符"></a>👀关系运算符</h3><p><code>MATLAB</code>中的关系运算符有6个。关系运算符可以用来对两个数值、两个数组、两个矩阵或两个字符串等数据类型进行比较，同样也可以进行不同类型两个数据之间的比较。比较的方式根据所比较的两个数据类型的不同而不同。例如对矩阵和一个标量进行比较时，需将矩阵中的每个元素与标量进行比较。关系运算符通过比较对应的元素，产生一个仅包含1和0的数值或矩阵。</p><ul><li>返回值为 1，比较结果是真。</li><li>返回值为 0，比较结果是假。</li></ul><table><thead><tr><th align="center">关系运算符</th><th align="center">关系说明</th><th align="center">关系运算符</th><th align="center">关系说明</th></tr></thead><tbody><tr><td align="center">&lt;</td><td align="center">小于</td><td align="center">&lt;&#x3D;</td><td align="center">小于等于</td></tr><tr><td align="center">&gt;</td><td align="center">大于</td><td align="center">&gt;&#x3D;</td><td align="center">大于等于</td></tr><tr><td align="center">&#x3D;&#x3D;</td><td align="center">等于</td><td align="center">~&#x3D;</td><td align="center">不等于</td></tr></tbody></table><blockquote><p>“<code>=</code>”和“<code>==</code>”的区别：“<code>==</code>”的运算法则是比较两个变量，当它们相等时返回 1，当它们不相等时返回 0；而“<code>=</code>”则是被用来将运算的结果赋给一个变量。</p></blockquote><h3 id="👀逻辑运算符"><a href="#👀逻辑运算符" class="headerlink" title="👀逻辑运算符"></a>👀逻辑运算符</h3><p>逻辑运算符提供了一种组合或否定关系表达式。</p><table><thead><tr><th align="center">逻辑运算符</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">&amp;</td><td align="center">与</td></tr><tr><td align="center">|</td><td align="center">或</td></tr><tr><td align="center">~</td><td align="center">非</td></tr></tbody></table><p>与关系运算符一样，逻辑运算符也可以进行矩阵与数值之间的比较，比较的方式为将矩阵的每一个元素都与数值进行比较，比较结果为一个相同维数的矩阵，新生成矩阵的每一个元素都代表着原来矩阵中相同位置上的元素与该数值的逻辑运算结果。使用逻辑运算符比较两个相同维数的矩阵时，是按元素来进行比较的，其比较结果是一个包含1和0的矩阵。元素0表示逻辑为假，元素1表示逻辑为真。</p><p>除了上面的逻辑运算符，<code>MATLAB</code>还提供了各种逻辑函数：</p><table><thead><tr><th>函数</th><th>运算法则</th></tr></thead><tbody><tr><td><code>xor(x,y)</code></td><td>异或运算。x与y不同时，返回1；x与y相同时，返回0</td></tr><tr><td><code>any(x)</code></td><td>如果在一个向量x中，有任何元素是非零，返回1；否则返回0 <br/>如果矩阵x中的每一列有非零元素，返回1；否则返回0</td></tr><tr><td><code>all(x)</code></td><td>如果在一个向量x中，所有元素非零，返回1；否则返回0 <br/>矩阵x中的每一列所有元素非零，返回1；否则返回0</td></tr></tbody></table><h2 id="⛄字符串处理函数"><a href="#⛄字符串处理函数" class="headerlink" title="⛄字符串处理函数"></a>⛄字符串处理函数</h2><p><code>MATLAB</code>提供了大量的字符串函数：</p><table><thead><tr><th>字符串函数</th><th>函数功能</th></tr></thead><tbody><tr><td><code>eval(string)</code></td><td>作为一个MATLAB命令求字符串的值</td></tr><tr><td><code>blanks(n)</code></td><td>返回一个n个零或空格的字符串</td></tr><tr><td><code>deblank</code></td><td>去掉字符串中后拖的空格</td></tr><tr><td><code>feval</code></td><td>求由字符串给定的函数值</td></tr><tr><td><code>findstr</code></td><td>从一个字符串内找出字符串</td></tr><tr><td><code>isletter</code></td><td>字母存在时返回真值</td></tr><tr><td><code>isspace</code></td><td>空格字符存在时返回真值</td></tr><tr><td><code>Isstr</code></td><td>输入一个字符串，返回真值</td></tr><tr><td><code>iasterr</code></td><td>返回上一个产生 MATLAB 错误的字符串</td></tr><tr><td><code>strcmp</code></td><td>字符串相同，返回真值</td></tr><tr><td><code>strrep</code></td><td>用一个字符串替换另一个字符串</td></tr><tr><td><code>strtok</code></td><td>在一个字符串里找出第一个标记</td></tr></tbody></table><h3 id="👀字符串的构造"><a href="#👀字符串的构造" class="headerlink" title="👀字符串的构造"></a>👀字符串的构造</h3><p>字符串或字符串数组的构造可以通过直接给变量赋值来实现，具体表达式中字符串的内容需要写在<strong>单引号</strong>内。如果字符串的内容包含单引号，那么以两个重复的单引号来表示。</p><p>构造多行字符串时，若字符串内容写在<code>[]</code>内，那么多行字符串的长度必须相同；若字符串内容写在<code>&#123;&#125;</code>内，则这多行字符串的长度可以不同。</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">&gt;&gt; Str_mat = [<span class="string">&#x27;July&#x27;</span>;<span class="string">&#x27;August&#x27;</span>;<span class="string">&#x27;September&#x27;</span>;] </span><br><span class="line">要串联的数组的维度不一致。</span><br><span class="line">&gt;&gt; Str_mat2 = &#123;<span class="string">&#x27;July&#x27;</span>;<span class="string">&#x27;August&#x27;</span>;<span class="string">&#x27;September&#x27;</span>;&#125; </span><br><span class="line">Str_mat2 =</span><br><span class="line">  <span class="number">3</span>×<span class="number">1</span> cell 数组</span><br><span class="line">    &#123;<span class="string">&#x27;July&#x27;</span>     &#125;</span><br><span class="line">    &#123;<span class="string">&#x27;August&#x27;</span>   &#125;</span><br><span class="line">    &#123;<span class="string">&#x27;September&#x27;</span>&#125;</span><br></pre></td></tr></table></figure><p><code>MATLAB</code>中还提供了<code>strvcat</code>和<code>char</code>函数用于纵向连接多个字符串。<code>strvcat</code>函数连接多行字符串时，每行字符串的长度不要求相等，所有非最长字符串的右边会自动补偿空格，使得每行字符串的长度相同。<code>char</code>函数与<code>strvcat</code>函数类似，不过当多行字符串中有空字符串时，<code>strvcat</code>函数会自动进行忽略，而<code>char</code>函数会把空字符串也用空格补偿后再进行连接。</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">A=<span class="string">&#x27;top&#x27;</span>; B=<span class="string">&#x27;&#x27;</span>; C=<span class="string">&#x27;Bottom&#x27;</span>; </span><br><span class="line">sABC=strvcat(A,B,C),cABC=char(A,B,C),<span class="built_in">size</span>=[<span class="built_in">size</span>(sABC);<span class="built_in">size</span>(cABC)] </span><br><span class="line"></span><br><span class="line"><span class="comment">% 输出结果</span></span><br><span class="line">sABC = </span><br><span class="line">top </span><br><span class="line">Bottom </span><br><span class="line">cABC = </span><br><span class="line">top </span><br><span class="line"></span><br><span class="line">Bottom </span><br><span class="line"><span class="built_in">size</span> = </span><br><span class="line"> <span class="number">2</span> <span class="number">6</span> </span><br><span class="line"> <span class="number">3</span> <span class="number">6</span> </span><br></pre></td></tr></table></figure><h3 id="👀字符串比较函数"><a href="#👀字符串比较函数" class="headerlink" title="👀字符串比较函数"></a>👀字符串比较函数</h3><p>两个字符串之间的关系可以通过关系运算符来比较，也可以使用<code>strcmp</code>函数来比较两个字符串是否相同。</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">&gt;&gt; A = (<span class="string">&#x27; Hello &#x27;</span> == <span class="string">&#x27; Word &#x27;</span>) </span><br><span class="line">矩阵维度必须一致。</span><br><span class="line">&gt;&gt; A = (<span class="string">&#x27; Hello &#x27;</span> == <span class="string">&#x27; World &#x27;</span>)</span><br><span class="line">A =</span><br><span class="line">  <span class="number">1</span>×<span class="number">7</span> logical 数组</span><br><span class="line">   <span class="number">1</span>   <span class="number">0</span>   <span class="number">0</span>   <span class="number">0</span>   <span class="number">1</span>   <span class="number">0</span>   <span class="number">1</span></span><br><span class="line">&gt;&gt; C = strcmp(<span class="string">&#x27; Hello &#x27;</span>, <span class="string">&#x27; World &#x27;</span>)</span><br><span class="line">C =</span><br><span class="line">  logical</span><br><span class="line">   <span class="number">0</span></span><br></pre></td></tr></table></figure><blockquote><p>使用<strong>关系运算符</strong>进行比较时，会对字符串的每个字符进行比较，返回值是一个与字符串长度相同大小的数组，因此被比较的两个字符串的长度必须相同；而<strong>strcmp函数</strong>则根据两个字符串相同与否，返回值为数值0或 1。</p></blockquote><h3 id="👀字符串查找和替换函数"><a href="#👀字符串查找和替换函数" class="headerlink" title="👀字符串查找和替换函数"></a>👀字符串查找和替换函数</h3><p>字符串的查找与搜索可以通过<code>findstr</code>函数来实现。<code>findstr</code>函数对字母的大小写是敏感的。另外，<code>findstr</code>函数对字符串矩阵不起作用，因此对字符串矩阵的搜索只能通过循环索引矩阵内的元素进行搜索。</p><p>字符串的替换可以通过对字符串数组中相应的元素直接赋值来实现，也可以使用<code>strrep</code>函数来实现。直接赋值方法并不能使两个不同长度的字符串相互替换，而<code>strrep</code>函数可以替换两个任意长度的字符串。与<code>findstr</code>函数类似，<code>strrep</code>函数也对字符串矩阵不起作用。</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">&gt;&gt; String =<span class="string">&#x27;Peter Piper picked a peck of pickled peppers.&#x27;</span></span><br><span class="line">String =</span><br><span class="line">    <span class="string">&#x27;Peter Piper picked a peck of pickled peppers.&#x27;</span></span><br><span class="line">&gt;&gt; findstr(String,<span class="string">&#x27;pick&#x27;</span>)</span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line">    <span class="number">13</span>    <span class="number">30</span></span><br><span class="line">&gt;&gt; String = strrep(String, <span class="string">&#x27;Peter Piper&#x27;</span>, <span class="string">&#x27;Sabrina Crame&#x27;</span>) </span><br><span class="line">String =</span><br><span class="line">    <span class="string">&#x27;Sabrina Crame picked a peck of pickled peppers.&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="👀数值转换"><a href="#👀数值转换" class="headerlink" title="👀数值转换"></a>👀数值转换</h3><p><code>MATLAB</code>还提供了大量字符串与各种数据类型之间的转换函数：</p><table><thead><tr><th>函数名称</th><th>函数功能</th></tr></thead><tbody><tr><td><code>abs</code></td><td>字符转换成 ASCII</td></tr><tr><td><code>dec2hex</code></td><td>十进制数转换成十六进制字符串</td></tr><tr><td><code>fprintf</code></td><td>把格式化的文本写到文件中或显示屏上</td></tr><tr><td><code>hex2dec</code></td><td>十六进制字符串转换成十进制数</td></tr><tr><td><code>hex2num</code></td><td>十六进制字符串转换成 IEEE 浮点数</td></tr><tr><td><code>int2str</code></td><td>整数转换成字符串</td></tr><tr><td><code>lower</code></td><td>字符串转换成小写</td></tr><tr><td><code>num2str</code></td><td>数字转换成字符串</td></tr><tr><td><code>setstr</code></td><td>ASCII 转换成字符串</td></tr><tr><td><code>sprintf</code></td><td>用格式控制数字转换成字符串</td></tr><tr><td><code>sscanf</code></td><td>用格式控制字符串转换成数字</td></tr><tr><td><code>str2mat</code></td><td>字符串转换成一个文本矩阵</td></tr><tr><td><code>str2num</code></td><td>字符串转换成数字</td></tr><tr><td><code>upper</code></td><td>字符串转换成大写</td></tr></tbody></table><h2 id="⛄数组与矩阵"><a href="#⛄数组与矩阵" class="headerlink" title="⛄数组与矩阵"></a>⛄数组与矩阵</h2><h3 id="👀数组运算"><a href="#👀数组运算" class="headerlink" title="👀数组运算"></a>👀数组运算</h3><p>数组运算是<code>MATLAB</code>计算的基础。由于<code>MATLAB</code>面向对象的特性，这种数值数组成为<code>MATLAB</code>最重要的一种内建数据类型，而数组运算就是定义这种数据结构的方法。</p><h4 id="👁数组的创建和操作"><a href="#👁数组的创建和操作" class="headerlink" title="👁数组的创建和操作"></a>👁数组的创建和操作</h4><p>在<code>MATLAB</code>中一般使用方括号“<code>[ ]</code>”、逗号“<code>,</code>”、空格号和分号“<code>;</code>”来创建数组，数组中同一行的元素使用<strong>逗号或空格</strong>进行分隔，不同行之间用<strong>分号</strong>进行分隔。</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% 空数组</span></span><br><span class="line">A=[]</span><br><span class="line"><span class="comment">% 行向量</span></span><br><span class="line">B=[<span class="number">6</span> <span class="number">5</span> <span class="number">4</span> <span class="number">3</span> <span class="number">2</span> <span class="number">1</span>]</span><br><span class="line">C=[<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line"><span class="comment">% 列向量</span></span><br><span class="line">D=[<span class="number">6</span>;<span class="number">5</span>;<span class="number">4</span>;<span class="number">3</span>;<span class="number">2</span>;<span class="number">1</span>]</span><br><span class="line"><span class="comment">% 转置</span></span><br><span class="line">E=B&#x27;</span><br><span class="line"></span><br><span class="line">F=[<span class="number">6</span> <span class="number">5</span> <span class="number">4</span> <span class="number">3</span> <span class="number">2</span> <span class="number">1</span>]</span><br><span class="line"><span class="comment">% 访问数组第 3 个到最后一个元素</span></span><br><span class="line">a3=F(<span class="number">3</span>:<span class="keyword">end</span>)</span><br><span class="line"><span class="comment">% 数组元素反序输出</span></span><br><span class="line">a4=F(<span class="keyword">end</span>:<span class="number">-1</span>:<span class="number">1</span>) </span><br><span class="line"><span class="comment">% 访问数组第1个及第6个元素</span></span><br><span class="line">a5=F([<span class="number">1</span> <span class="number">6</span>])</span><br></pre></td></tr></table></figure><p>（1）通过冒号创建一维数组</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% A是创建一维数组的第一个变量，step是每次递增或递减的数值，直到最后一个元素和B的差的绝对值小于等于step的绝对值为止。</span></span><br><span class="line">X=A:step:B</span><br><span class="line"></span><br><span class="line">A=<span class="number">2</span>:<span class="number">6</span> </span><br><span class="line">B=<span class="number">2.1</span>:<span class="number">1.5</span>:<span class="number">6</span> </span><br><span class="line">C=<span class="number">2.1</span>:<span class="number">-1.5</span>:<span class="number">-6</span> </span><br><span class="line">D=<span class="number">2.1</span>:<span class="number">-1.5</span>:<span class="number">6</span> </span><br><span class="line"><span class="comment">% 输出结果</span></span><br><span class="line">A = <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> </span><br><span class="line">B = <span class="number">2.1000</span> <span class="number">3.6000</span> <span class="number">5.1000</span> </span><br><span class="line">C = <span class="number">2.1000</span> <span class="number">0.6000</span> <span class="number">-0.9000</span> <span class="number">-2.4000</span> <span class="number">-3.9000</span> <span class="number">-5.4000</span> </span><br><span class="line">D = Empty matrix: <span class="number">1</span>-by<span class="number">-0</span> </span><br></pre></td></tr></table></figure><p>（2）通过函数创建一维数组</p><p><code>logspace()</code>函数创建一维数组；<code>linspace()</code>函数创建一维数组</p><h4 id="👁数组的常见运算"><a href="#👁数组的常见运算" class="headerlink" title="👁数组的常见运算"></a>👁数组的常见运算</h4><p>（1）数组的算术运算</p><p>数组的运算是从数组的单个元素出发，针对每个元素进行的运算。在<code>MATLAB</code>中，一维数组的基本运算包括加、减、乘、左除、右除和乘方。</p><p>数组的加减运算：通过格式A+B或A-B可实现数组的加减运算。但是运算规则要求数组A和B的<strong>维数相同</strong>。</p><p>数组的乘除运算：通过格式“<code>.*</code>”或“<code>./</code>”可实现数组的乘除运算。但是运算规则要求数组A和B的<strong>维数相同</strong>。</p><blockquote><p>乘法：数组A和B的维数相同，运算为数组对应元素相乘，计算结果与A和B是相同维数的数组。<br>除法：数组A和B的维数相同，运算为数组对应元素相除，计算结果与A和B是相同维数的数组。<br>右除和左除的关系：A.&#x2F;B&#x3D;B.\A，其中A是被除数，B是除数。</p></blockquote><p>乘方格式“<code>.^</code>”实现数组的乘方运算。数组的乘方运算包括：数组间的乘方运算、数组与某个具体数值的乘方运算，以及常数与数组的乘方运算。</p><p>函数<code>dot()</code>可实现数组的点积运算，但是运算规则要求数组A和B的维数相同，其调用格式如下</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">C = <span class="built_in">dot</span>(A,B)</span><br><span class="line">C = <span class="built_in">dot</span>(A,B,dim)</span><br><span class="line"></span><br><span class="line">clear all</span><br><span class="line">A=[<span class="number">1</span> <span class="number">5</span> <span class="number">6</span> <span class="number">8</span> <span class="number">9</span> <span class="number">6</span>]</span><br><span class="line">B=[<span class="number">9</span> <span class="number">5</span> <span class="number">6</span> <span class="number">2</span> <span class="number">4</span> <span class="number">0</span>]</span><br><span class="line"><span class="comment">% 数组的点积</span></span><br><span class="line">C=<span class="built_in">dot</span>(A,B)</span><br><span class="line"><span class="comment">% 数组元素的乘积之和</span></span><br><span class="line">D=sum(A.*B)</span><br><span class="line"></span><br><span class="line"><span class="comment">% 输出结果</span></span><br><span class="line">A = <span class="number">1</span> <span class="number">5</span> <span class="number">6</span> <span class="number">8</span> <span class="number">9</span> <span class="number">6</span> </span><br><span class="line">B = <span class="number">9</span> <span class="number">5</span> <span class="number">6</span> <span class="number">2</span> <span class="number">4</span> <span class="number">0</span> </span><br><span class="line">C = <span class="number">122</span> </span><br><span class="line">D = <span class="number">122</span> </span><br></pre></td></tr></table></figure><p>（2）数组的关系运算</p><p>在<code>MATLAB</code>中提供了6种数组关系运算符，即<code>&lt;</code>（小于）、<code>&lt;=</code>（小于等于）、<code>&gt;</code>（大于）、<code>&gt;=</code>（大于等于）、<code>==</code>（恒等于）、<code>~=</code>（不等于）。关系运算的运算法则如下：</p><ul><li>当两个比较量是标量时，直接比较两个数的大小。若关系成立，则返回的结果为1，否则为0。</li><li>当两个比较量是维数相等的数组时，逐一比较两个数组相同位置的元素，并给出比较结果。最终的关系运算结果是一个与参与比较的数组维数相同的数组，其组成元素为0或1。</li></ul><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clear all</span><br><span class="line">A=[<span class="number">1</span> <span class="number">5</span> <span class="number">6</span> <span class="number">8</span> <span class="number">9</span> <span class="number">6</span>]</span><br><span class="line">B=[<span class="number">9</span> <span class="number">5</span> <span class="number">6</span> <span class="number">2</span> <span class="number">4</span> <span class="number">0</span>]</span><br><span class="line"><span class="comment">% 数组与常数比较，小于</span></span><br><span class="line">C=A&lt;<span class="number">6</span></span><br><span class="line"><span class="comment">% 数组与常数比较，大于等于</span></span><br><span class="line">D=A&gt;=<span class="number">6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 输出结果</span></span><br><span class="line">A = <span class="number">1</span> <span class="number">5</span> <span class="number">6</span> <span class="number">8</span> <span class="number">9</span> <span class="number">6</span> </span><br><span class="line">B = <span class="number">9</span> <span class="number">5</span> <span class="number">6</span> <span class="number">2</span> <span class="number">4</span> <span class="number">0</span> </span><br><span class="line">C = <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> </span><br><span class="line">D = <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> </span><br></pre></td></tr></table></figure><p>（3）数组的逻辑运算</p><p>在<code>MATLAB</code>中数组提供了3种数组逻辑运算符，即<code>&amp;</code>（与）、<code>|</code>（或）和<code>~</code>（非）。逻辑运算的运算法则如下：</p><ul><li>如果是非零元素则为真，用1表示；如果是零元素则为假，用0表示。</li><li>当两个比较量是维数相等的数组时，逐一比较两个数组相同位置的元素，并给出比较结果。最终的关系运算结果是一个与参与比较的数组维数相同的数组，其组成元素为0或1。</li><li>与运算（a&amp;b）时，a、b全为非零，则为真，运算结果为1；或运算（a|b）时，只要a、b有一个为非零，则运算结果为1；非运算（~a）时，若a为0，运算结果为1，a为非零，运算结果为0。</li></ul><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clear all</span><br><span class="line">A=[<span class="number">1</span> <span class="number">5</span> <span class="number">6</span> <span class="number">8</span> <span class="number">9</span> <span class="number">6</span>]</span><br><span class="line">B=[<span class="number">9</span> <span class="number">5</span> <span class="number">6</span> <span class="number">2</span> <span class="number">4</span> <span class="number">0</span>]</span><br><span class="line"><span class="comment">% 与、或、非</span></span><br><span class="line">C=A&amp;B</span><br><span class="line">D=A|B</span><br><span class="line">E=~B</span><br><span class="line"></span><br><span class="line"><span class="comment">% 输出结果</span></span><br><span class="line">A = <span class="number">1</span> <span class="number">5</span> <span class="number">6</span> <span class="number">8</span> <span class="number">9</span> <span class="number">6</span> </span><br><span class="line">B = <span class="number">9</span> <span class="number">5</span> <span class="number">6</span> <span class="number">2</span> <span class="number">4</span> <span class="number">0</span> </span><br><span class="line">C = <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> </span><br><span class="line">D = <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> </span><br><span class="line">E = <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> </span><br></pre></td></tr></table></figure><h3 id="👀矩阵操作"><a href="#👀矩阵操作" class="headerlink" title="👀矩阵操作"></a>👀矩阵操作</h3><h4 id="👁创建矩阵"><a href="#👁创建矩阵" class="headerlink" title="👁创建矩阵"></a>👁创建矩阵</h4><p>零矩阵、单位矩阵和全1矩阵等特殊矩阵，<code>MATLAB</code>中提供了函数生成试验矩阵。还有一些其他特殊矩阵的指令集。</p><p>希尔伯特（Hilbert）矩阵，它是一个条件数差的矩阵，所以将它用来作为试验矩阵。</p><blockquote><p><code>hilb(n)</code>、<code>invhilb(n)</code></p></blockquote><p>托普利兹（Toeplitz）矩阵，它由两个向量定义，一个行向量和一个列向量。对称的托普利兹矩阵由单一向量来定义。</p><blockquote><p><code>toeplitz(k,r)</code>、<code>toeplitz(c)</code></p></blockquote><p>0～1间均匀分布的随机矩阵，产生 0～1 间均匀分布的随机矩阵。</p><blockquote><p><code>rand(n)</code>、<code>rand(m,n)</code>、<code>rand(m,n,p,...)</code>、<code>rand(size(A))</code></p></blockquote><p>标准正态分布随机矩阵，产生均值为 0、方差为 1 的随机矩阵。</p><blockquote><p><code>randn(n)</code>、<code>randn(m,n)</code>、<code>randn(m,n,p,...)</code>、<code>randn([m,n,p,...])</code>、<code>randn(size(A))</code></p></blockquote><p>魔方矩阵，每行、列和两条对角线上的元素和相等。</p><blockquote><p><code>magic(n)</code></p></blockquote><p>帕斯卡矩阵。</p><blockquote><p><code>pascal(n)</code>、<code>pascal(n,1)</code>、<code>pascal(n,2)</code></p></blockquote><p>范德蒙（Vandermonde）矩阵。</p><blockquote><p><code>vander(v)</code>，生成范德蒙矩阵，矩阵的列是向量v的幂，输入向量可以使行向量或列向量。</p></blockquote><h4 id="👁改变矩阵大小"><a href="#👁改变矩阵大小" class="headerlink" title="👁改变矩阵大小"></a>👁改变矩阵大小</h4><p>（1）矩阵的合并</p><p>矩阵的合并就是把两个或者两个以上的矩阵数据连接起来得到一个新的矩阵。</p><blockquote><p>矩阵构造符<code>[]</code>不仅可用于构造矩阵，同时还可以作为一个矩阵合并操作符。表达式<code>C=[A B]</code>在水平方向合并矩阵A和B，而表达式<code>C=[A;B]</code>在竖直方向合并矩阵A和B。</p><p>除了使用矩阵合并符“<code>[]</code>”来合并矩阵，还可以使用<strong>矩阵合并函数</strong>来合并矩阵。</p></blockquote><p>可以用矩阵合并符来构造任意大小的矩阵。不过需要注意的是，在矩阵合并的过程中一定要保持矩阵的形状是方形，否则矩阵合并将无法进行。</p><p>（2）矩阵行列的删除</p><p>要删除矩阵的某一行或者某一列，只要把该行或者该列赋予一个空矩阵“<code>[]</code>”即可。</p><h4 id="👁重构矩阵"><a href="#👁重构矩阵" class="headerlink" title="👁重构矩阵"></a>👁重构矩阵</h4><p>矩阵重构的两个比较重要的运算是转置和共轭转置，在<code>MATLAB</code>中，用在函数后面加撇号“<code>&#39;</code>”来表示。在线性代数的专业书籍中，这种运算经常用<code>*</code>和<code>H</code>表示。</p><p>如果A是一个实数矩阵，那么它被转置时，第1行变成第1列，第2行变成第2列……以此类推，一个m×n矩阵变为一个n×m矩阵。如果矩阵是方阵，那么这个矩阵在主对角线上反映出来。如果矩阵A的元素a<del>ij</del>是复数，那么所有元素也是共轭的。如果仅希望转置，在撇号“<code>&#39;</code>”之前输入一点，即成为“<code>.&#39;</code>”，A.’表示转置，其结果与conj(A’)相同。如果A是实数矩阵，那么A’与A.’相同。</p><h3 id="👀矩阵元素的运算"><a href="#👀矩阵元素的运算" class="headerlink" title="👀矩阵元素的运算"></a>👀矩阵元素的运算</h3><p>矩阵的加、减、乘、除、比较运算和逻辑运算等代数运算是<code>MATLAB</code>数值计算最基础的部分。</p><p><strong>矩阵的加减运算</strong>。进行矩阵加法、减法运算的前提是参与运算的两个矩阵或多个矩阵必须具有相同的行数和列数，即A、B、C等多个矩阵均为m×n矩阵；或者其中有一个或多个矩阵为标量。</p><p><strong>矩阵的乘法运算</strong>。<code>MATLAB</code>中矩阵的乘法运算包括两种：数与矩阵的乘法；矩阵与矩阵的乘法。</p><ul><li>数与矩阵的乘法：由于单个数在<code>MATLAB</code>中是以标量来存储的，因此数与矩阵的乘法也可以称为标量与矩<br>阵的乘法。</li><li>矩阵与矩阵的乘法：两个矩阵的乘法必须满足被乘矩阵的列数与乘矩阵的行数相等。</li></ul><p><strong>矩阵的除法运算</strong>。矩阵的除法是乘法的逆运算，分为左除和右除两种，分别用运算符号“<code>\</code>”和“<code>/</code>”表示。</p><ul><li>A\B表示矩阵A的逆乘以B，A&#x2F;B表示矩阵A乘以矩阵B的逆。除非矩阵A和矩阵B相同，否则A&#x2F;B和A\B是不等价的。</li><li>对于一般的二维矩阵A和B，当进行A\B运算时，要求A的行数与B的行数相等；当进行A&#x2F;B运算时，要求A的列数与B的列数相等。</li></ul><p><strong>矩阵的幂运算</strong>。当矩阵A为<code>方阵</code>时，可进行矩阵的幂运算，使用运算符号“<code>^</code>”表示幂运算。</p><p><strong>矩阵元素的查找</strong>。函数<code>find()</code>的作用是进行矩阵元素的查找，它通常与关系函数和逻辑运算相结合。其调用格式如下：</p><ul><li><code>ind = find(X)</code>：该函数查找矩阵X中的非零元素，函数返回这些元素的单下标。</li><li><code>[row,col] = find(X, ...)</code>：该函数查找矩阵X中的非零元素，函数返回这些元素的双下标i和j。</li></ul><p><strong>矩阵元素的排序</strong>。函数<code>sort()</code>的作用是按照升序排序，排序后的矩阵和原矩阵的维数相同。其调用格式如下：</p><ul><li><code>B = sort(A)</code>：该函数对矩阵A进行升序排列。A可为矩阵或向量。</li><li><code>B = sort(A,dim)</code>：该函数对矩阵 A 进行升序排列，并将结果返回在给定的维数dim上按照升序排列。当dim&#x3D;1时，按照列进行排序；当dim&#x3D;2时，按照行进行排序。</li><li><code>B = sort(...,mode)</code>：该函数对矩阵 A 进行排序，mode可指定排序的方式。ascend指定按升序排列，为默认值；descend指定按降序排列。</li></ul><p><strong>矩阵元素的求和</strong>。函数<code>sum()</code>和<code>cumsum()</code>的作用是对矩阵的元素求和。函数<code>cumsum()</code>的调用格式与<code>sum()</code>类似，不同的是其返回值为矩阵。其调用格式如下：</p><ul><li><code>B = sum(A)</code>：该函数对矩阵A的元素求和，返回由矩阵A各列元素的和组成的向量。通过<code>sum(sum())</code>可求出矩阵所有元素的和。</li><li><code>B = sum(A,dim)</code>：该函数返回在给定的维数dim上元素的和。当dim&#x3D;1时，计算矩阵A各列元素的和；当dim&#x3D;2时，计算矩阵A各行元素的和。</li><li><code>B = cumsum(A)</code>。</li><li><code>B = cumsum(A,dim)</code>。</li></ul><p><strong>矩阵元素的求积</strong>。函数<code>prod()</code>和<code>cumprod()</code>的作用是对矩阵的元素求积。函数<code>cumprod()</code>的调用格式与<code>prod()</code>类似，不同的是其返回值为矩阵。其调用格式如下：</p><ul><li><code>B = prod(A)</code>：该函数对矩阵A的元素求积，返回由矩阵A各列元素的积组成的向量。</li><li><code>B = prod(A,dim)</code>：该函数返回在给定的维数dim上元素的积。当dim&#x3D;1时，计算矩阵A各列元素的积；当dim&#x3D;2时，计算矩阵A各行元素的积。</li><li><code>B = cumprod(A)</code>。</li><li><code>B = cumprod(A,dim)</code>。</li></ul><p><strong>矩阵元素的差分</strong>。函数<code>diff()</code>的作用是计算矩阵的差分。其调用格式如下：</p><ul><li><code>Y = diff(X)</code>：计算矩阵各列元素的差分。</li><li><code>Y = diff(X,n)</code>：计算矩阵各列元素的n阶差分。</li><li><code>Y = diff(X,n,dim)</code>：计算矩阵在给定的维数dim上元素的n阶差分。当dim&#x3D;1时，计算矩阵各列元素的差分；当dim&#x3D;2时，计算矩阵各行元素的差分。当参数n≥size(x,dim)时，函数的返回值是空矩阵。</li></ul><h3 id="👀矩阵运算"><a href="#👀矩阵运算" class="headerlink" title="👀矩阵运算"></a>👀矩阵运算</h3><p>矩阵运算是线性代数中极其重要的部分，包括矩阵分析、特征值求解和奇异值等。</p><p>（1）矩阵分析</p><table><thead><tr><th>函数名</th><th>功能描述</th></tr></thead><tbody><tr><td><code>norm</code></td><td>求矩阵或者向量的范数</td></tr><tr><td><code>normest</code></td><td>估计矩阵的 2 阶范数</td></tr><tr><td><code>rank</code></td><td>矩阵的秩，即求对角元素的和</td></tr><tr><td><code>det</code></td><td>矩阵的行列式</td></tr><tr><td><code>trace</code></td><td>矩阵的迹</td></tr><tr><td><code>null</code></td><td>0 空间</td></tr><tr><td><code>orth</code></td><td>正交化空间</td></tr><tr><td><code>rref</code></td><td>约化行阶梯形式</td></tr><tr><td><code>subspace</code></td><td>求两个矩阵空间的角度</td></tr></tbody></table><p>（2）矩阵分解</p><p>矩阵分解是把一个矩阵分解成几个“较简单”的矩阵连乘的形式。</p><table><thead><tr><th>函数</th><th>功能描述</th></tr></thead><tbody><tr><td><code>chol</code></td><td>Cholesky分解</td></tr><tr><td><code>cholinc</code></td><td>稀疏矩阵的不完全Cholesky分解</td></tr><tr><td><code>lu</code></td><td>矩阵LU分解（高斯消去法分解）</td></tr><tr><td><code>luinc</code></td><td>稀疏矩阵的不完全LU分解</td></tr><tr><td><code>qr</code></td><td>正交三角分解</td></tr><tr><td><code>svd</code></td><td>奇异值分解</td></tr><tr><td><code>gsvd</code></td><td>一般奇异值分解</td></tr><tr><td><code>schur</code></td><td>舒尔分解</td></tr></tbody></table><p>（3）特征值和特征向量</p><p><code>MATLAB</code>中的命令计算特征值和特征向量十分方便，可以得到不同的子结果和分解，这在线性代数学习中十分有意义。</p><h3 id="👀稀疏矩阵"><a href="#👀稀疏矩阵" class="headerlink" title="👀稀疏矩阵"></a>👀稀疏矩阵</h3><p>在许多问题中提到了含有大量0元素的矩阵，这样的矩阵称为稀疏矩阵。为了节省存储空间和计算时间，<code>MATLAB</code>考虑到矩阵的稀疏性，在对它进行运算时有特殊的命令。稀疏矩阵大部分的元素是0，因此只需存储非零元素的下标和元素值，这种特殊的存储方式可以节省大量的存储空间和不必要的运算。</p><h4 id="👁稀疏矩阵的存储方式"><a href="#👁稀疏矩阵的存储方式" class="headerlink" title="👁稀疏矩阵的存储方式"></a>👁稀疏矩阵的存储方式</h4><p>对于稀疏矩阵，<code>MATLAB</code>仅存储矩阵所有的非零元素的值及其位置（行号和列号）。显然，这对于具有大量0元素的稀疏矩阵来说是十分有效的。</p><h4 id="👁稀疏矩阵的生成"><a href="#👁稀疏矩阵的生成" class="headerlink" title="👁稀疏矩阵的生成"></a>👁稀疏矩阵的生成</h4><p><code>MATLAB</code>提供了多种创建稀疏矩阵的方法。</p><ul><li>利用<code>sparse</code>函数从满矩阵转换得到稀疏矩阵。</li><li>利用一些特定函数创建包括单位稀疏矩阵在内的特殊稀疏矩阵。</li></ul><p>（1）利用<code>sparse</code>函数建立一般的稀疏矩阵</p><table><thead><tr><th>函数名称</th><th>表示意义</th></tr></thead><tbody><tr><td><code>sparse(A)</code></td><td>由非零元素和下标建立稀疏矩阵A。如果A已是一个稀疏矩阵，则返回A本身</td></tr><tr><td><code>sparse(m,n)</code></td><td>生成一个m×n的所有元素都是0的稀疏矩阵</td></tr><tr><td><code>sparse(u,v,a)</code></td><td>生成大小为max(u)×max(v)的稀疏矩阵。其中u和v是整数向量，a为实数或复数向量</td></tr><tr><td><code>sparse(u,v,a,m,n)</code></td><td>生成一个m×n的稀疏矩阵，(ui,vi)对应值 ai。向量u，v和a长度必须相同</td></tr><tr><td><code>spconvert(D)</code></td><td>生成一个稀疏矩阵。D共有3列，第1列为行下标，第2列为列下标，最后一列为元素值</td></tr><tr><td><code>full(S)</code></td><td>将稀疏矩阵S转换成一个满矩阵</td></tr></tbody></table><p><code>MATLAB</code>提供了<code>full()</code>函数把稀疏矩阵转换为满矩阵。<code>full()</code>函数的调用格式如下：</p><ul><li><code>A = full(S)</code>：S为稀疏矩阵。</li></ul><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">A = [<span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>;<span class="number">0</span> <span class="number">5</span> <span class="number">0</span> <span class="number">0</span>;<span class="number">2</span> <span class="number">0</span> <span class="number">0</span> <span class="number">7</span>] </span><br><span class="line">S = sparse(A)</span><br><span class="line">B = full(S) </span><br><span class="line"><span class="comment">% 输出结果</span></span><br><span class="line">S = </span><br><span class="line">     (<span class="number">1</span>,<span class="number">1</span>) <span class="number">1</span> </span><br><span class="line">     (<span class="number">3</span>,<span class="number">1</span>) <span class="number">2</span> </span><br><span class="line">     (<span class="number">2</span>,<span class="number">2</span>) <span class="number">5</span> </span><br><span class="line">     (<span class="number">3</span>,<span class="number">4</span>) <span class="number">7</span> </span><br><span class="line">B = </span><br><span class="line">     <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> </span><br><span class="line">     <span class="number">0</span> <span class="number">5</span> <span class="number">0</span> <span class="number">0</span> </span><br><span class="line">     <span class="number">2</span> <span class="number">0</span> <span class="number">0</span> <span class="number">7</span> </span><br></pre></td></tr></table></figure><p>查看稀疏矩阵中非零的信息示例：</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clear all </span><br><span class="line">a=[<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span>;<span class="number">0</span> <span class="number">0</span> <span class="number">8</span> <span class="number">0</span>;<span class="number">4</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>;<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]; </span><br><span class="line">S=sparse(a); <span class="comment">% 创建稀疏矩阵</span></span><br><span class="line">whos; </span><br><span class="line">n1=nnz(S) <span class="comment">% 查看非零元素的个数</span></span><br><span class="line">n2=nonzeros(S) <span class="comment">% 非零元素的值</span></span><br><span class="line">n3=nzmax(S) <span class="comment">% 查看稀疏矩阵的存储空间</span></span><br><span class="line"><span class="comment">% spy()函数对稀疏矩阵中非零元素的分布进行图形化显示，</span></span><br><span class="line">spy(S) </span><br><span class="line"><span class="comment">% 采用nnz(S)/prod(size(S))计算稀疏矩阵的非零元素密度</span></span><br><span class="line">n4=nnz(S)/prod(<span class="built_in">size</span>(S)) </span><br><span class="line"><span class="comment">% 输出结果</span></span><br><span class="line">Name      Size            Bytes  Class     Attributes</span><br><span class="line"> S         <span class="number">4</span>x4                <span class="number">88</span>  double    sparse    </span><br><span class="line"> a         <span class="number">4</span>x4               <span class="number">128</span>  double </span><br><span class="line">n1 = <span class="number">3</span> </span><br><span class="line">n2 = </span><br><span class="line">     <span class="number">4</span> </span><br><span class="line">     <span class="number">8</span> </span><br><span class="line">     <span class="number">1</span> </span><br><span class="line">n3 = <span class="number">3</span> </span><br><span class="line">n4 = <span class="number">0.1875</span> </span><br></pre></td></tr></table></figure><p>（2）利用特定函数建立稀疏矩阵</p><table><thead><tr><th>函数</th><th>调用格式</th><th>描述</th></tr></thead><tbody><tr><td><code>speye</code></td><td><code>S = speye(m,n)</code></td><td>创建单位稀疏矩阵</td></tr><tr><td><code>spones</code></td><td><code>S = spones(X)</code></td><td>创建非零元素为1的稀疏矩阵</td></tr><tr><td><code>sprand</code></td><td><code>S = sprand(X)</code></td><td>创建非零元素为均匀分布的随机数的稀疏矩阵</td></tr><tr><td><code>sprandn</code></td><td><code>S = sprandn(X)</code></td><td>创建非零元素为高斯分布的随机数的稀疏矩阵</td></tr><tr><td><code>sprandsym</code></td><td><code>S = sprandsym(X)</code></td><td>创建非零元素为高斯分布的随机数的对称稀疏矩阵</td></tr><tr><td><code>spdiags</code></td><td><code>S = spdiags(X)</code></td><td>创建对角稀疏矩阵</td></tr><tr><td><code>spalloc</code></td><td><code>S = spalloc(X)</code></td><td>为稀疏矩阵分配空间</td></tr></tbody></table><h4 id="👁稀疏矩阵的运算"><a href="#👁稀疏矩阵的运算" class="headerlink" title="👁稀疏矩阵的运算"></a>👁稀疏矩阵的运算</h4><ul><li>满矩阵的四则运算对稀疏矩阵同样有效，但是返回结果有可能是稀疏矩阵或者满矩阵。</li><li>对于单个稀疏矩阵的输入，大部分函数输出的结果都是稀疏矩阵，有部分函数输出的结果是满矩阵。对于多个矩阵的输入，如果其中至少有一个矩阵是满矩阵，那么大部分函数的输出结果是满矩阵。</li><li>对于矩阵的加、减、乘、除运算，只要其中有一个是满矩阵，则输出的结果都是满矩阵。</li><li>稀疏矩阵的数乘为稀疏矩阵；稀疏矩阵的幂为稀疏矩阵。</li></ul><p>笔者不才，请多交流！！！</p>]]></content>
      
      
      <categories>
          
          <category> Matlab </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Matlab </tag>
            
            <tag> 科学计算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IDL语法基础（01）</title>
      <link href="/2022/10/30/IDL-Basic01/"/>
      <url>/2022/10/30/IDL-Basic01/</url>
      
        <content type="html"><![CDATA[<h2 id="⛄IDL简介"><a href="#⛄IDL简介" class="headerlink" title="⛄IDL简介"></a>⛄<code>IDL</code>简介</h2><p>交互式数据语言——<code>IDL</code>（<code>Interactive Data Language</code>）是进行应用程序开发、科学数据分析与可视化表达的理想工具。<code>IDL</code>是基于矩阵运算的计算机语言，它语法简单，自带大量的功能函数，用很少的几行代码就能实现其它语言很难实现的功能。利用IDL可以快速地进行科学数据读写、三维数据可视化、数值运算和三维图形建模等。<code>IDL</code>可以应用在地球科学（包括气象、水文、海洋、土壤和地质等），医学影像、图像处理、<code>GIS</code>系统、软件开发、测试、天文、航空航天、信息处理、数学统计与分析以及环境工程等领域。<code>IDL</code>的优势：</p><ul><li>数据访问 —— 灵活的数据输入、输出方式。在科学研究中，将会使用大量不同格式的数据。IDL 基本上支持各种数据格式，并提供了大量的数据读写工具，免除数据读写的烦恼，可以将更多的精力投入到数据分析。</li><li>数据分析 —— 强大的图像处理、信号处理和数据统计分析能力。<code>IDL</code> 集成了完善的数据分析、数据统计、图像处理和信号处理软件包。项目应用 <code>IDL</code> 可以节省大量时间。使用传统的 <code>C</code> 或者 <code>FORTRAN</code> 语言需要数天或数周的项目，使用 <code>IDL</code> 可以在数小时内完成。</li><li>数据可视化 —— 先进的图形技术和强大的可视化能力。从简单的二维绘图、三维绘图、体数据可视化、图像显示、动画显示等，到利用 <code>OpenGL</code>硬件加速功能进行交互式的三维图形浏览，以及支持多处理器快速进行体数据渲染，使用 <code>IDL</code>可以轻松获得丰富的可视化效果。从直接图形法到对象图形法，再到快速可视化函数，<code>IDL</code> 提供了丰富的可视化过程和函数供用户调用，使用少量代码即可实现复杂的可视化结果。</li><li>软件开发 —— 跨平台支持、全新且统一的开发环境、有效的数据管理手段。</li><li>集成 —— 灵活的外部语言接口。<code>IDL</code> 是一个灵活的、可扩展的用于可视化、分析和开发的工具，能够轻松的与其他的软件工具集成。<code>IDL</code> 能够将其他编程语言的代码和函数导入，也可以将 <code>IDL</code> 实现的功能集成到其他语言编写的应用程序中去。</li><li>程序共享 —— 灵活多样的程序发布方式和轻松的成果共享。</li></ul><p><code>IDL</code>的帮助提供了详细的使用说明和函数功能描述，学会使用帮助是快速入门和解决问题的最佳途径。帮助的启动方式有以下三种：</p><ul><li>点击主菜单[帮助]下的[选中项目帮助]和[帮助内容]功能菜单；</li><li>工作台编辑代码时按 <code>F1</code> 或选择一个函数后按 <code>F1</code>，则启动帮助；</li><li>命令行中输入<code>?</code>回车后启动帮助。</li></ul><blockquote><p>注意事项：</p><p>（1）<code>IDL</code>不区分大小写；</p><p>（2）分号”;”表示注释内容的开始；</p><p>（3）符号”<code>$</code>“，续行符；符号”<code>&amp;</code>“，续命令符；</p><p>（4）创建<code>IDL</code>变量不需要事先声明，直接赋值，并且变量随时可以进行数据类型和维数的动态改变；</p><p>（5）科学计数法：<code>a = 6.63e-34，b = 2.998e8</code></p><p>（6）<code>help</code>命令可以帮助用户跟踪变量类型和大小。对于标量，显示变量的名称、类型和值；对于数组型变量，显示变量名称、类型和大小。</p></blockquote><h2 id="⛄IDL语法基础"><a href="#⛄IDL语法基础" class="headerlink" title="⛄IDL语法基础"></a>⛄<code>IDL</code>语法基础</h2><h3 id="👀数据类型"><a href="#👀数据类型" class="headerlink" title="👀数据类型"></a>👀数据类型</h3><p><code>IDL</code>中有17种基本数据类型。基本数据类型的名称、类型代码、字节大小、创建方式和范围，以及类型转换等。</p><table><thead><tr><th>数据类型</th><th align="center">代码</th><th align="center">字节数</th><th align="center">范围</th><th>创建变量</th><th>类型转换</th></tr></thead><tbody><tr><td>字节型</td><td align="center">1</td><td align="center">1</td><td align="center"><code>0~255</code></td><td><code>Var=0B</code></td><td><code>byte()</code></td></tr><tr><td>16位有符号整型</td><td align="center">2</td><td align="center">2</td><td align="center"><code>-32768~32767</code></td><td><code>Var=0</code></td><td><code>fix()</code></td></tr><tr><td>32位有符号长整型</td><td align="center">3</td><td align="center">4</td><td align="center"><code>-2^31~2^31-1</code></td><td><code>Var=0L</code></td><td><code>long()</code></td></tr><tr><td>64位有符号整型</td><td align="center">14</td><td align="center">8</td><td align="center"><code>-2^63~2^63-1</code></td><td><code>Var=0LL</code></td><td><code>long64()</code></td></tr><tr><td>16位无符号整型</td><td align="center">12</td><td align="center">2</td><td align="center"><code>0~65535</code></td><td><code>Var=0U</code></td><td><code>uint()</code></td></tr><tr><td>32位无符号长整型</td><td align="center">13</td><td align="center">4</td><td align="center"><code>0~2^32-1</code></td><td><code>Var=0UL</code></td><td><code>ulong()</code></td></tr><tr><td>64位无符号整型</td><td align="center">15</td><td align="center">8</td><td align="center"><code>0~2^64-1</code></td><td><code>Var==0ULL</code></td><td><code>ulong64()</code></td></tr><tr><td>浮点型</td><td align="center">4</td><td align="center">4</td><td align="center"><code>-10^38~2^38</code></td><td><code>Var=0.0</code></td><td><code>float()</code></td></tr><tr><td>双精度浮点型</td><td align="center">5</td><td align="center">8</td><td align="center"><code>-10^308~2^308</code></td><td><code>Var=0.0D</code></td><td><code>double()</code></td></tr><tr><td>复数</td><td align="center">6</td><td align="center">8</td><td align="center"><code>-10^38~2^38</code></td><td><code>Var=Complex(0.0,0.0)</code></td><td><code>complex()</code></td></tr><tr><td>双精度复数</td><td align="center">9</td><td align="center">16</td><td align="center"><code>-10^308~2^308</code></td><td><code>Var=Dcomplex(0.0D,0.0D)</code></td><td><code>dcomplex()</code></td></tr><tr><td>字符串</td><td align="center">7</td><td align="center">0~32767</td><td align="center"><code>None</code></td><td><code>Var=&#39; &#39;或Var=&quot; &quot;</code></td><td><code>string()</code></td></tr><tr><td>结构体</td><td align="center">8</td><td align="center">复合类型</td><td align="center"><code>None</code></td><td><code>St1=&#123;&#125;</code></td><td></td></tr><tr><td>指针</td><td align="center">10</td><td align="center">4</td><td align="center"><code>None</code></td><td><code>Var=Ptr_New()</code></td><td></td></tr><tr><td>对象</td><td align="center">11</td><td align="center">4</td><td align="center"><code>None</code></td><td><code>Var=Obj_New()</code></td><td></td></tr><tr><td>链表</td><td align="center">11</td><td align="center">复合类型</td><td align="center"><code>None</code></td><td><code>Ls=List()</code></td><td></td></tr><tr><td>哈希表</td><td align="center">11</td><td align="center">复合类型</td><td align="center"><code>None</code></td><td><code>Hs=Hash()</code></td><td></td></tr></tbody></table><p>变量的类型代码通过<code>Size(var, /type)</code>来获得，如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IDL&gt; a=10</span><br><span class="line">IDL&gt; print,size(a,/type)</span><br><span class="line">           2</span><br><span class="line">IDL&gt; b=10.0</span><br><span class="line">IDL&gt; print,size(b,/type)</span><br><span class="line">           4</span><br><span class="line">IDL&gt; c=10L</span><br><span class="line">IDL&gt; print,size(c,/type)</span><br><span class="line">           3</span><br></pre></td></tr></table></figure><h3 id="👀常量和变量"><a href="#👀常量和变量" class="headerlink" title="👀常量和变量"></a>👀常量和变量</h3><p>常量。常量是不能修改的固定值，分为整型常量、浮点型常量、复数型常量和字符型常量等类型。</p><p>变量。<code>IDL</code> 中的变量分为局部变量和系统变量。在 <code>IDL</code> 程序中，二者的区别在于生命周期不一样，局部变量仅仅在所在的函数或过程中有效，而系统变量则在始终有效或某个程序的周期中有效。</p><p>（1）命名规则</p><p>变量名称的最大长度不超过 255 个字符，变量的首位只能是字母和下划线，中后部只能是字母、数字、下划线<code>_</code>和连接符<code>$</code>。如下正确：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">abc_3$dok_24_bit IDL_type variable _day_month_year</span><br><span class="line">如下错误：</span><br><span class="line">abc.cha one%file 4_lists $file</span><br></pre></td></tr></table></figure><p>变量相关函数 <code>IDL_VALIDNAME</code>。该函数用来检测字符串是否可以作为 <code>IDL</code> 下的变量，并能够将无效字符转换为“<code>_</code>”并返回变量。调用格式为 <code>IDL_VALIDNAME ( String [, /CONVERT_ALL] [, /CONVERT_SPACES])</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IDL&gt; print,IDL_VALIDNAME(&#x27;idl&#x27;)</span><br><span class="line">idl</span><br><span class="line">IDL&gt; print,IDL_VALIDNAME(&#x27;i d l&#x27;, /CONVERT_SPACES)</span><br><span class="line">i_d_l</span><br><span class="line">IDL&gt; print,IDL_VALIDNAME(&#x27;16ENVIIDL&#x27;, /CONVERT_ALL)</span><br><span class="line">_16ENVIIDL</span><br></pre></td></tr></table></figure><p>判断变量是否已经被定义，可以使用<code>N_Elements</code>函数，示例代码如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IDL&gt; a=1</span><br><span class="line">IDL&gt; ;变量已经定义        </span><br><span class="line">IDL&gt; print,N_Elements(a)</span><br><span class="line">           1</span><br><span class="line">IDL&gt; ;变量没有定义</span><br><span class="line">IDL&gt; print,N_Elements(aa)</span><br><span class="line">           0</span><br></pre></td></tr></table></figure><p>（2）变量类型转换</p><p>变量可以通过类型转换函数进行强制类型转换。</p><table><thead><tr><th>类型转换</th><th>函数名称</th><th>操作</th><th>结果</th></tr></thead><tbody><tr><td>字节型</td><td><code>BYTE</code></td><td>BYTE(1.2)</td><td>1B</td></tr><tr><td>整型</td><td><code>FIX</code></td><td>FIX(2.5)</td><td>2</td></tr><tr><td>无符号整型</td><td><code>UINT</code></td><td>UINT([5.5,-3])</td><td>5 65533</td></tr><tr><td>长整型</td><td><code>LONG</code></td><td>LONG(65538.5)</td><td>65538</td></tr><tr><td>无符号长整型</td><td><code>ULONG</code></td><td>ULONG([5.5,-3])</td><td>5 4294967293</td></tr><tr><td>64 位长整型</td><td><code>LONG64</code></td><td>LONG64([5.5,-3])</td><td>5 -3</td></tr><tr><td>无符号 64 位长整型</td><td><code>ULONG64</code></td><td>ULONG64([5.5,-3])</td><td>5 18446744073709551613</td></tr><tr><td>浮点型</td><td><code>FLOAT</code></td><td>FLOAT([5.5,-3])</td><td>5.50000 -3.00000</td></tr><tr><td>双精度类型</td><td><code>DOUBLE</code></td><td>DOUBLE([5.5,-3])</td><td>5.5000000 -3.0000000</td></tr><tr><td>复数类型</td><td><code>COMPLEX</code></td><td>COMPLEX(1, 2)</td><td>(1.00000, 2.00000)</td></tr><tr><td>双精度复数类型</td><td><code>DCOMPLEX</code></td><td>DCOMPLEX(1, 2)</td><td>(1.0000000, 2.0000000)</td></tr></tbody></table><p>在进行数据的转换中需要注意转换后的数据的界限问题。如下面操作：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IDL&gt; ;整型转换为浮点</span><br><span class="line">IDL&gt; print,float(1)</span><br><span class="line">      1.00000</span><br><span class="line"></span><br><span class="line">IDL&gt; ;浮点数取整</span><br><span class="line">IDL&gt; print,fix(1.3+1.8)</span><br><span class="line">       3</span><br><span class="line"> </span><br><span class="line">IDL&gt; ;fix还可以指定输出类型</span><br><span class="line">IDL&gt; help,fix(1.3,type=5)</span><br><span class="line">&lt;Expression&gt;    DOUBLE    =        1.3000000</span><br><span class="line"></span><br><span class="line">IDL&gt; ;出现这个错误是因为整型变量是16Bit的，最大值为32767，此种情况下用长整型强制转换函数long(a)。</span><br><span class="line">IDL&gt; a=33000</span><br><span class="line">IDL&gt; print,fix(a)</span><br><span class="line">  -32536</span><br><span class="line"></span><br><span class="line">IDL&gt; ;注意整型变量的运算，如除法运算</span><br><span class="line">IDL&gt; ;结果是1，原因在于参与运算的两个数字为整数，运算结果依然是整数。</span><br><span class="line">IDL&gt; result = 8/5</span><br><span class="line">IDL&gt; print,result</span><br><span class="line">IDL&gt; ;在运算时需要增加强制类型转换，将整形类型转换为浮点类型。</span><br><span class="line">IDL&gt; result = 8/float(5)</span><br><span class="line">IDL&gt; print,result</span><br><span class="line">      1.60000</span><br><span class="line">IDL&gt; result = 8*1.0/5</span><br><span class="line">IDL&gt; print,result</span><br><span class="line">      1.60000</span><br></pre></td></tr></table></figure><p>浮点类型和双精度类型的取整操作函数如下：</p><table><thead><tr><th>函数名称</th><th>功能</th><th>操作</th><th>结果</th></tr></thead><tbody><tr><td><code>floor</code></td><td>向下取整</td><td>floor(2.4)<br />floor(2.5)</td><td>2<br />2</td></tr><tr><td><code>ceil</code></td><td>向上取整</td><td>floor(2.4)<br />floor(2.5)</td><td>3<br />3</td></tr><tr><td><code>round</code></td><td>四舍五入</td><td>floor(2.4)<br />floor(2.5)</td><td>2<br />3</td></tr></tbody></table><p>（3）变量类型的动态性</p><p>在使用的过程中，可以随时修改变量类型，即变量类型具备动态性。该特性使得<code>IDL</code>在数学运算中将低精度类型提升为高精度类型，确保计算结果具备足够的精度。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IDL&gt; num=6</span><br><span class="line">IDL&gt; help,num</span><br><span class="line">NUM             INT       =        6</span><br><span class="line">IDL&gt; num=num*1.1</span><br><span class="line">IDL&gt; help,num</span><br><span class="line">NUM             FLOAT     =       6.60000</span><br></pre></td></tr></table></figure><p>（4）系统变量</p><p>系统变量分为预定义系统变量和自定义系统变量。预定义系统变量是<code>IDL</code>中预先定义的系统变量，一般情况下不允许修改，包括常数变量、图形变量、系统配置和错误处理；自定义系统变量是用户创建的系统变量。</p><h3 id="👀数组"><a href="#👀数组" class="headerlink" title="👀数组"></a>👀数组</h3><p>程序设计中，为了处理方便， 把具有相同类型的若干变量按有序的形式组织起来。这些按序排列的同类数据元素的集合称为数组。<code>IDL</code> 是面向矩阵的第四代语言，对数组的维数为0～8 维，在数组的处理时非常的灵活、高效。</p><blockquote><p>注意，IDL 中数组下标的顺序先是列标，后是行标。</p></blockquote><h4 id="👁创建数组"><a href="#👁创建数组" class="headerlink" title="👁创建数组"></a>👁创建数组</h4><p>（1）赋值创建</p><p>通过方括号<code>[]</code>赋值创建数组。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IDL&gt; arr = [1,2,3]</span><br><span class="line">IDL&gt; help,arr</span><br><span class="line">ARR             INT       = Array[3]</span><br><span class="line">IDL&gt; arr = [[1,2,3],[4,5,6]]</span><br><span class="line">IDL&gt; help,arr</span><br><span class="line">ARR             INT       = Array[3, 2]</span><br><span class="line">IDL&gt; arr</span><br><span class="line">       1       2       3</span><br><span class="line">       4       5       6</span><br></pre></td></tr></table></figure><p>（2）函数创建</p><p>利用数组创建函数可创建不同类型或维数的数组。</p><p><strong>通用函数</strong>，可以用 <code>IDL</code> 的通用函数进行全零数组或索引数组的创建。</p><table><thead><tr><th>数据类型</th><th>创建全0数组</th><th>创建索引数组</th></tr></thead><tbody><tr><td>字节型</td><td><code>bytArr()</code></td><td><code>bindgen()</code></td></tr><tr><td>16位有符号整型</td><td><code>intarr()</code></td><td><code>indgen()</code></td></tr><tr><td>32位有符号长整型</td><td><code>lonarr()</code></td><td><code>lindgen()</code></td></tr><tr><td>64位有符号整型</td><td><code>lon64arr()</code></td><td><code>l64indgen()</code></td></tr><tr><td>16位无符号整型</td><td><code>uintarr()</code></td><td><code>uindgen()</code></td></tr><tr><td>32位无符号长整型</td><td><code>ulongarr()</code></td><td><code>ulindgen()</code></td></tr><tr><td>64位无符号整型</td><td><code>ulon64arr()</code></td><td><code>ul64indgen()</code></td></tr><tr><td>浮点型</td><td><code>fltarr()</code></td><td><code>findgen()</code></td></tr><tr><td>双精度浮点型</td><td><code>dblarr()</code></td><td><code>dindgen()</code></td></tr><tr><td>复数</td><td><code>complexarr()</code></td><td><code>cindgen()</code></td></tr><tr><td>双精度复数</td><td><code>dcomplexarr()</code></td><td><code>dcindgen()</code></td></tr><tr><td>字符串</td><td><code>strarr()</code></td><td><code>sindgen()</code></td></tr><tr><td>指针</td><td><code>ptrarr()</code></td><td></td></tr><tr><td>对象</td><td><code>objarr()</code></td><td></td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IDL&gt; num = findgen(20)</span><br><span class="line">IDL&gt; num</span><br><span class="line">      0.00000000       1.0000000       2.0000000       3.0000000       4.0000000         5.0000000   6.0000000       7.0000000       8.0000000       9.0000000         10.000000       11.000000   12.000000       13.000000       14.000000               15.000000       16.000000       17.00000018.000000       19.000000</span><br></pre></td></tr></table></figure><p><strong>常规函数</strong>，<code>MAKE_ARRAY()</code>函数：是在程序运行过程中创建特定的数组。</p><p>调用格式为： <code>Result = MAKE_ARRAY ( [D1 [, ..., D8]] [, /INDEX] [, DIMENSION = vector] [, /NOZERO] [, SIZE=vector] [, TYPE=type_code] [, VALUE=value] )</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IDL&gt; a = Make_array(4,5,/Integer,Value=6)</span><br><span class="line">IDL&gt; a</span><br><span class="line">       6       6       6       6</span><br><span class="line">       6       6       6       6</span><br><span class="line">       6       6       6       6</span><br><span class="line">       6       6       6       6</span><br><span class="line">       6       6       6       6</span><br></pre></td></tr></table></figure><blockquote><p>创建特殊数组：<code>RANDOMU()</code>函数返回一个或多个均匀分布的浮点型数组，值在[0,1]之间。<code>RANDOMN()</code>函数返回一个或多个正态分布的浮点型数组，这些数的平均为零，标准偏差为 1 。</p></blockquote><h4 id="👁数组存储"><a href="#👁数组存储" class="headerlink" title="👁数组存储"></a>👁数组存储</h4><p><code>IDL</code>中的矢量和数组均是以先行后列顺序存储的(<code>IDL</code>最初是设计用来处理行扫描的卫星数据)，下标值的起始值是 0。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IDL&gt; array = indgen(4,3)</span><br><span class="line">IDL&gt; array</span><br><span class="line">       0       1       2       3</span><br><span class="line">       4       5       6       7</span><br><span class="line">       8       9      10      11</span><br></pre></td></tr></table></figure><h4 id="👁数组访问"><a href="#👁数组访问" class="headerlink" title="👁数组访问"></a>👁数组访问</h4><p>（1）下标方式</p><p>可以使用下标来存取该数组中的每一个元素。按照“<code>数组名[下标]</code>”或“<code>数组名（下标）</code>”对数组中元素进行存取，数组下标起始值为0。因为函数的调用方式为“<code>函数名（参数）</code>”，为避免混淆，数组下标使用时一般使用<code>[]</code>。其中-1为最后一个元素的下标，可根据下标值依次获取元素。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IDL&gt; arr = indgen(9)</span><br><span class="line">IDL&gt; arr</span><br><span class="line">       0       1       2       3       4       5       6       7       8</span><br><span class="line">IDL&gt; arr(3)</span><br><span class="line">       3</span><br><span class="line">IDL&gt; arr[3]</span><br><span class="line">       3</span><br><span class="line">IDL&gt; arr[-1]</span><br><span class="line">       8</span><br><span class="line">IDL&gt; arr[-5:-1]</span><br><span class="line">       4       5       6       7       8</span><br></pre></td></tr></table></figure><p>（2）向量方式</p><p>下标可以通过向量方式表示。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IDL&gt; arr = indgen(9)+5</span><br><span class="line">IDL&gt; arr</span><br><span class="line">       5       6       7       8       9      10      11      12      13</span><br><span class="line">IDL&gt; index = [0,2,4,6,8]</span><br><span class="line">IDL&gt; arr[index]</span><br><span class="line">       5       7       9      11      13</span><br><span class="line">;对30行20列的索引数组取出第6~10列中第12~15行的数据，可以通过“:”方式</span><br><span class="line">IDL&gt; arr1 = indgen(20,30)</span><br><span class="line">IDL&gt; select_arr1 = arr1[5:9,11:14]</span><br><span class="line">IDL&gt; select_arr1</span><br><span class="line">     225     226     227     228     229</span><br><span class="line">     245     246     247     248     249</span><br><span class="line">     265     266     267     268     269</span><br><span class="line">     285     286     287     288     289 </span><br><span class="line">;对30行20列的索引数组取出第10行的数据，可以通过“*”方式</span><br><span class="line">IDL&gt; vec_10 = arr1[*,9]</span><br><span class="line">IDL&gt; vec_10</span><br><span class="line">     180     181     182     183     184     185     186     187     188     189     190 191 192     193     194     195     196     197     198     199</span><br></pre></td></tr></table></figure><h4 id="👁数组运算"><a href="#👁数组运算" class="headerlink" title="👁数组运算"></a>👁数组运算</h4><p>（1）求大、求小和求余</p><p>数组的求大(<code>&lt;</code>)、求小(<code>&gt;</code>)和求余(<code>mod</code>)操作返回的是同维数组的计算结果。数组求大（&lt;<code>value</code>）是将数组中小于<code>value</code>的元素赋为<code>value</code>；求小（&gt;<code>value</code>）是将数组中大于<code>value</code>的值赋为<code>value</code>；数组求余（<code>mod</code>)是计算数组中各元素的余数。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IDL&gt; a = indgen(8)+3</span><br><span class="line">IDL&gt; a</span><br><span class="line">       3       4       5       6       7       8       9      10</span><br><span class="line">IDL&gt; a&gt;6</span><br><span class="line">       6       6       6       6       7       8       9      10</span><br><span class="line">IDL&gt; a</span><br><span class="line">       3       4       5       6       7       8       9      10</span><br><span class="line">IDL&gt; a&lt;6</span><br><span class="line">       3       4       5       6       6       6       6       6</span><br></pre></td></tr></table></figure><p>（2）数组与数运算<br>数组与数的运算遵循的基本规律是，数组中的每个元素与数进行运算。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IDL&gt; a = indgen(8)</span><br><span class="line">IDL&gt; a</span><br><span class="line">       0       1       2       3       4       5       6       7</span><br><span class="line">IDL&gt; a = indgen(8)+5</span><br><span class="line">IDL&gt; a</span><br><span class="line">       5       6       7       8       9      10      11      12</span><br></pre></td></tr></table></figure><p>（3）数组与数组运算<br>数组与数组的运算，结果的元素个数与运算的最小数组个数一致，多维数组需要转换为一维数组来运算。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IDL&gt; arr = [2,4,6,8]</span><br><span class="line">IDL&gt; arr1  = [4.5]</span><br><span class="line">IDL&gt; arr + arr1</span><br><span class="line">       6.5000000</span><br><span class="line">IDL&gt; arr1  = [5,6]</span><br><span class="line">IDL&gt; arr + arr1</span><br><span class="line">       7      10</span><br><span class="line">IDL&gt; arr2 = [[1,3,5],[2,4,6]]</span><br><span class="line">IDL&gt; arr3 = [[1,2],[3,4]]</span><br><span class="line">IDL&gt; arr2 + arr3</span><br><span class="line">       2       5</span><br><span class="line">       8       6</span><br></pre></td></tr></table></figure><p>（4）数组合并</p><p>数组与数组的合并需要两个数组的行数或列数相同。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IDL&gt; a = indgen(2,5)</span><br><span class="line">IDL&gt; b = indgen(4,5)</span><br><span class="line">IDL&gt; ;行数相同，可直接使用[]</span><br><span class="line">IDL&gt; c = [a,b]</span><br><span class="line">IDL&gt; c</span><br><span class="line">       0       1       0       1       2       3</span><br><span class="line">       2       3       4       5       6       7</span><br><span class="line">       4       5       8       9      10      11</span><br><span class="line">       6       7      12      13      14      15</span><br><span class="line">       8       9      16      17      18      19</span><br><span class="line">IDL&gt; ;列数相同，需要使用[[],[]]</span><br><span class="line">IDL&gt; d = indgen(2,3)</span><br><span class="line">IDL&gt; e = [[a],[d]]</span><br><span class="line">IDL&gt; e</span><br><span class="line">       0       1</span><br><span class="line">       2       3</span><br><span class="line">       4       5</span><br><span class="line">       6       7</span><br><span class="line">       8       9</span><br><span class="line">       0       1</span><br><span class="line">       2       3</span><br><span class="line">       4       5</span><br></pre></td></tr></table></figure><h4 id="👁相关函数"><a href="#👁相关函数" class="headerlink" title="👁相关函数"></a>👁相关函数</h4><p>（1）数组信息 <code>Size()</code></p><p><code>Size()</code>函数能够返回数组的结构信息，调用格式为 <code>Result = SIZE(变量, [/KeyWords])</code>。输入变量可以是常量、数组、字符串、结构体、指针和对象等任何数据类型。不设置关键字时，函数返回变量的基本信息：变量维数、每一维的数值元素个数（维数），变量类型代码、元素总个数。设置关键字<code>N_Dimensions</code>、<code>N_Elements</code>、<code>Dimensions</code>、<code>Tname</code>和<code>Type</code>，则依次返回数组的维数、元素个数、每一维的维数、类型名称和类型代码信息。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IDL&gt; data = indgen(4,5)</span><br><span class="line">IDL&gt; size(data)</span><br><span class="line">           2           4           5           2          20</span><br><span class="line">IDL&gt; size(data,/N_dimensions)</span><br><span class="line">           2</span><br><span class="line">IDL&gt; size(data,/N_elements)</span><br><span class="line">          20</span><br><span class="line">IDL&gt; size(data,/Dimensions)</span><br><span class="line">           4           5</span><br><span class="line">IDL&gt; size(data,/Tname)</span><br><span class="line">INT</span><br></pre></td></tr></table></figure><p>（2）条件查找</p><p><code>WHERE()</code>函数返回满足指定条件（即数组表达式）数组元素的下标所组成的一维数组。调用格式为：</p><p> <code>Result =WHERE(数组表达式 [, count] [, COMPLEMENT=变量 1] [, /L64] [, NCOMPLEMENT=变量 2])</code>。</p><p>关键字：count 返回的是符合指定条件的个数；变量 1 是不满足条件的数组的下标信息；变量 2 是不满足条件的数组的个数；</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IDL&gt; a = indgen(10)+3</span><br><span class="line">IDL&gt; a</span><br><span class="line">       3       4       5       6       7       8       9      10      11      12</span><br><span class="line">IDL&gt; B = WHERE(a GT 6, count, COMPLEMENT=B_C, NCOMPLEMENT=count_c)</span><br><span class="line">IDL&gt; count</span><br><span class="line">           6</span><br><span class="line">IDL&gt; B</span><br><span class="line">           4           5           6           7           8           9</span><br><span class="line">IDL&gt; count_c</span><br><span class="line">           4</span><br><span class="line">IDL&gt; B_C</span><br><span class="line">           0           1           2           3</span><br></pre></td></tr></table></figure><p>（3）大小调整</p><p><code>Reform()</code>函数可以使数组在元素个数不修改的前提下，改变数组的维数，方便了数组的动态使用。调用格式：</p><blockquote><p><code>Result = REFORM(Array, D1 [, ..., D8] [, 关键字] )</code></p></blockquote><p><code>Rebin()</code>函数可以修改数组的维数大小，将维数调整为 <code>D1 [, ..., D8]</code>指定的维数，且大小必须原数据的大小的整数倍，默认抽样算法是双线性内插。调用格式：</p><blockquote><p><code>Result = REBIN(数组, D1 [, ..., D8] [, /SAMPLE] )</code><br><code>SAMPLE</code>：设置该关键字则使用最近临值抽样法。</p></blockquote><p><code>Congrid()</code>函数可以调整数组为同维任意大小的数组，默认在处理一维或二维数组时默认是最近邻重采样方式，处理三维数组时默认是双线性内插值。在数据缩小操作时，<code>Rebin</code> 做了插值处理，而 <code>Congrid</code> 仅仅是重新采样。调用格式为：</p><blockquote><p><code>Result = Congrid(数组, X,Y,Z [,关键字] )</code><br><code>INTERP</code>：抽样采用线性内插法；<br><code>CUBIC</code>：采用卷积内插法。</p></blockquote><p><code>EXPAND</code> 用来对二维数组进行大小修改，采用双线性内插算法。调用格式：</p><blockquote><p><code>EXPAND, A, Nx, Ny, Result[, FILLVAL=value] [, MAXVAL=value]</code> </p><p>其中 <code>A</code> 为源数组，<code>Nx</code>、<code>Ny</code> 为修改后的维数，<code>Result</code> 为修改后的数组，<code>FILLVAL</code> 是填充数据，默认为-1；<code>MAXVAL</code> 是数据的最大值，大于该值的赋为 <code>FILLVAL</code>。</p></blockquote><p><code>INTERPOLATE()</code>函数可以调整数组为同维任意大小的数组，并能够任意定位插值点。调用格式：</p><blockquote><p><code>INTERPOLATE(数组, X[, Y [, Z]] [, 关键字] )</code></p><p>其中，<code>X [, Y [, Z]]</code>为待调整数组下标索引，可以是单个变量或数组，若<code>X</code>为0.5，则表示计算下标[0]和下标[1]中间位置的数值；<br><code>GRID</code> 关键字：采用网格插值方式生成插值点，否则按线性方式生成；<br><code>Missing</code> 关键字：插值点坐标超出数组自身坐标范围时赋予该值。</p></blockquote><p>（4）数组反转</p><p><code>Reverse()</code>函数可以对数组进行反转。调用格式：</p><blockquote><p><code>result = Reverse(数组, index[, 关键字] )</code><br><code>index</code> 是反转的数组的维数索引，它不能大于数组的维数。</p></blockquote><p>（5）数组转置 Transpose()<br><code>Transpose ()</code>函数可以对数组进行反转。调用格式：</p><blockquote><p><code>result = Transpose(数组, [P])</code><br>关键字：<code>P</code> 是调整后的维数数组列表，如不设置则完全反转。</p></blockquote><p>（6）数组旋转</p><p>①<code>Rotate()</code>函数</p><p><code>Rotate()</code>函数可以以 <code>90°</code>整倍数的角度对数组进行旋转操作。调用格式：</p><blockquote><p><code>result = Rotate (数组, direction )</code><br><code>Direction</code>：该关键字为整数，范围 <code>0-7</code>，分别代表的图像旋转方式。</p></blockquote><p>②<code>Rot()</code>函数</p><p><code>Rot()</code>函数可以以任意的角度对数组进行旋转操作并能进行放大、缩小操作。调用格式：</p><blockquote><p><code>result = Rot(数组, Angle, [Mag, X0, Y0],[关键字])</code><br><code>Angle</code>：该关键字数组旋转地角度，单位为度(°)。<br><code>Mag</code>：为放大的倍数；<br><code>X0</code>：为旋转中心的 <code>X</code> 坐标，默认为列中心；<br><code>Y0</code>：为旋转中心的 <code>Y</code> 坐标，默认为行中心；<br><code>PIVOT</code>：该关键字控制旋转后<code>(X0,Y0)</code>点是否仍然在原图像中的位置，不设置则<code>(X0,Y0)</code>点在图像的中心位置。</p></blockquote><p>（7）数组平移</p><p><code>Shift()</code>函数是按指定的平移量 <code>S1、…、Sn</code>，分别对数组的第 <code>1、…、n</code> 维进行平移后生成新数组。其中 <code>Si</code> 为正表示向前平移；<code>Si</code> 为负表示向后平移。调用格式：</p><blockquote><p><code>result = Shift(数组，S1、…、Sn)</code></p></blockquote><p>（8）数组排序<br><code>Sort()</code>函数返回排序后的<strong>数组索引</strong>。调用格式：</p><blockquote><p><code>result = Sort(数组[, /L64])</code></p></blockquote><p>（9）数组唯一调整 （求不同值）<br><code>Uniq()</code>函数返回数组中<strong>相邻元素不同值</strong>的<strong>索引</strong>。该函数<strong>只能发现相邻值</strong>，若不相邻，则会认为是两个值。如果先对数组进行排序，则可求出数组中包含的不同值。调用格式为：</p><blockquote><p><code>result = UNIQ(数组 [, Index] )</code></p></blockquote><p>（10）判断数组</p><p><code>Array_Equal()</code>函数进行数组相同的判断。调用格式：</p><blockquote><p><code>result = Array_Equal(数组, /关键字)</code><br><code>result</code>：返回 0 或 1。<br><code>NO_TYPECONV</code>：添加该关键字，用于将两数组转换为同一类型，判断数据类型是否相同；为1时，数组可直接比较，不转换数据类型。</p></blockquote><p>（11）元素个数</p><p><code>N_Elements()</code>函数返回数组元素的个数。调用格式：</p><blockquote><p><code>result = N_Elements(数组)</code></p></blockquote><p>（12）求最值</p><p><code>Max()</code>函数返回满足数组元素的最大值。调用格式：</p><blockquote><p><code>result = Max(数组 [,关键字], min =变量 1)。</code><br><code>result</code>：返回的是数组的最大值；<br><code>变量 1</code>：返回的是数组的最小值；</p></blockquote><p><code>Min()</code>函数返回满足数组元素的最小值。调用格式：</p><blockquote><p><code>result = Min(数组 [,关键字], max =变量 1)。</code><br><code>result</code>：返回的是数组的最小值；<br><code>变量 1</code>：返回的是数组的最大值；</p></blockquote><p>（13）求和</p><p>Total()函数返回满足数组元素和，并可以通过关键字进行求和选项的控制。调用格式：</p><blockquote><p><code>result = Total(数组, Dimension, [,关键字])。</code><br><code>result</code>：返回的是数组元素求和结果；<br><code>Dimension</code>：数组求和元素的行列控制；<br><code>CUMULATIVE</code>：设置该关键字后，返回结果与原数组一致，第 <code>i</code> 个元素的值为 <code>0-i</code> 值的和；<br><code>Double</code>：返回双精度类型结果；<br><code>Integer</code>：返回整型数据结果；<br><code>PRESERVE_TYPE</code>：返回结果类型与原数组类型一致，设置该关键字的时，&#x2F;double 等关键字无效。</p></blockquote><p>（14）乘积计算<br><code>Product()</code>函数计算数组中所有或部分元素的乘积。调用格式：</p><blockquote><p><code>result = Product(数组, Dimension, [,关键字])。</code><br>关键字控制与 total 函数的关键字基本一致。</p></blockquote><p>（15）其它运算</p><p><code>Factorial()</code>函数计算满足数组元素阶乘。调用格式：</p><blockquote><p><code>result = Factorial(数组, [,关键字])。</code><br>关键字-<code>Stirling</code>：返回结果为Stirling近似值。</p></blockquote><p><code>Mean()</code>函数计算数组元素的平均值。调用格式为：</p><blockquote><p><code>result = Mean(数组, [,关键字])。</code></p></blockquote><p><code>Variance()</code>函数计算数组元素的方差。调用格式：</p><blockquote><p><code>result = Variance(数组, [,关键字])。</code></p></blockquote><p><code>Stddev()</code>函数计算数组元素的方差。调用格式：</p><blockquote><p><code>result = Variance(数组, [,关键字])。</code></p></blockquote><p><code>Moment()</code>函数计算数组元素的平均值、方差、倾斜度及频率曲线峰态。调用格式：</p><blockquote><p><code>result = Moment(数组, [,关键字])。</code></p></blockquote><h4 id="👁矩阵运算"><a href="#👁矩阵运算" class="headerlink" title="👁矩阵运算"></a>👁矩阵运算</h4><p>矩阵间的运算，遵循以下两个法则（注意与线性代数矩阵运算的区别和联系）：</p><p><code>A#B</code> 表示 A 的列乘以 B 的行，要求A的行数必须跟B的列数一致。</p><p><code>A##B</code> 表示 A 的行乘以 B 的列，要求A的列数必须跟B的行数一致。</p><h3 id="👀字符串"><a href="#👀字符串" class="headerlink" title="👀字符串"></a>👀字符串</h3><p>字符串和字符串数组的创建可以通过直接赋值或函数来实现。在IDL中字符串用双引号<code>&quot; &quot;</code>或单引号<code>&#39;&#39;</code>括起来表示。但以<code>&quot;</code>为首的字符串的首字符不能为数字，因为以<code>&quot;</code>开头的数字串代表一个8进制。</p><p>字符串连接直接用加号<code>&quot;+&quot;</code>。字符串操作在文件读取、命令行输入以及窗口参数输入时经常被用到。字符串操作都是通过字符串处理函数来实现的。</p><table><thead><tr><th>函数名</th><th>函数描述</th></tr></thead><tbody><tr><td><code>STRCMP(str1, str2, N, /FOLD_CASE)</code></td><td>对两个字符串进行比较，如果 N 存在，只对前 N 个进行比较，<code>/FOLD_CASE</code> 表示模糊比较</td></tr><tr><td><code>STRCOMPRESS(str1)</code></td><td>删除字符串 <code>str1</code> 中的空格</td></tr><tr><td><code>STREGEX()</code></td><td>正则表达式</td></tr><tr><td><code>STRJOIN()</code></td><td>字符串相连接</td></tr><tr><td><code>STRLEN(）</code></td><td>返回字符串的长度</td></tr><tr><td><code>STRLOWCASE(）</code></td><td>将所有的大写字母改写成小写字母</td></tr><tr><td><code>STRMATCH(Str1,str2)</code></td><td>字符串 <code>Str1</code> 中是否存在 <code>Str2</code>，可以使用通配符</td></tr><tr><td><code>STRMID(Str1,po1,Len,REVERSE_OFFSET)</code></td><td>从字符串 <code>po1</code> 开始取出 <code>Len</code> 个字符。字符串的第一个字符的位置为 0</td></tr><tr><td><code>STRPOS(Exp_Str1,Sea_Str2,Pos,&lt;br /&gt;REVERSE_OFFSET,/REVERSE_SEARCH] )</code></td><td>从一个字符串中查找与另外一个字符串完全匹配的起始点所在的位置。<code>Pos</code>是查找点的起始位置，默认值 为0、1（如果指定<code>/REVERSE_SEARCH]</code>）；指定时，则表示从开始的Pos起，或者从末尾开始的<code>Pos</code> 起（如果指定 <code>REVERSE_OFFSET</code> ）</td></tr><tr><td><code>STRPUT,Des_Var_str,Sou_str,Pos</code></td><td>将字符串<code>Sou_str</code>插入到字符串<code>Des_Var_str</code>之中，<code>POS</code>插入点的位置，默认值为 0，依次将字符串Sou_str覆盖插入到<code>Des_Var_str</code>中。<code>Sou_str</code> 不为字符串，则按默认格式自动转化从 <code>POS</code> 处开始插入<code>Des_Var_str</code>，如果插入值的位置超过了 <code>Des_Var</code> 的最大长度，则自然截断</td></tr><tr><td><code>STRSPLIT(Str1)</code></td><td>根据特定要求拆分字符串<code>str1</code>；</td></tr><tr><td><code>STRTRIM(str,Flag)</code></td><td>移去字符串中的空格。<code>Flag</code>：0(移去右边空格），1(移去左边空格），2（移去两边的空格）</td></tr><tr><td><code>STRUPCASE(）</code></td><td>将所有的小写字母改写成大写字母</td></tr></tbody></table><h3 id="👀其它数据类型"><a href="#👀其它数据类型" class="headerlink" title="👀其它数据类型"></a>👀其它数据类型</h3><p><strong>结构体</strong>：创建结构体时用大括号<code>&#123;&#125;</code>，同时需要赋予结构体名称。</p><blockquote><p>注意：通过<code>&quot;help, struct1, /structure&quot;</code>语句可以查看结构体<code>struct1</code>的基本信息。通过结构体<code>&quot;变量名.成员名&quot;</code>或<code>&quot;变量名.(index)&quot;</code>的方式访问。</p></blockquote><p><strong>指针</strong>：指针用指针函数<code>Ptr_New()</code>来创建，通过<code>&quot;*&quot;</code>+指针变量名来访问。</p><blockquote><p>指针赋值与变量赋值不一样，指针赋值是使两个指针指向同一个堆向量，修改任意一个会影响另一个。</p></blockquote><p><strong>对象</strong>：对象是数据（属性）和程序（方法）封装在一起的实体。<code>IDL</code>中用<code>Obj_New</code>函数或<code>ObjArr</code>函数来创建对象。<code>ObjArr()</code>函数用来创建对象数组；<code>Obj_New()</code>函数用来创建某一特定类的对象。</p><blockquote><p>调用对象、销毁对象、处理函数</p></blockquote><p><strong>链表</strong>：链表（<code>list</code>)是一个复合数据类型，它可以包含变量、数组、结构体、指针、对象、链表和哈希表等数据类型。链表中的元素是有次序的，可以通过索引来进行编辑操作。</p><blockquote><p>链表是由<code>list()</code>函数来创建。链表访问与数组访问一样，通过下标索引来实现。创建链表、访问链表、增加链表、删除链表、链表反转、转为数组、链表连接、链表比较、销毁链表</p></blockquote><p><strong>哈希表</strong>：哈希表（<code>Hash</code>)是一个高效的复合数据类型，可以包含变量、数组、结构体、指针、对象、链表和哈希表等数据类型。哈希表的特点是关键字（<code>keys</code>）与值对应，通过链表函数或关键字快速访问处理。</p><blockquote><p>哈希表创建通过创建函数<code>Hash()</code>创建；元素访问是根据关键字；哈希表元素添加与数组元素的添加类似；其他操作：关键字输出、关键字查询、删除哈希表、转换为结构体、哈希表组合、哈希表比较、销毁哈希表。</p></blockquote><h3 id="👀运算符"><a href="#👀运算符" class="headerlink" title="👀运算符"></a>👀运算符</h3><ul><li>数学运算符</li></ul><blockquote><p>加（<code>+</code>）、减（<code>-</code>）、增运算（<code>++</code>）、减运算（<code>--</code>）、乘（<code>*</code>）、除（<code>/</code>）、幂（<code>^</code>）、取余（<code>mod</code>）、取小（<code>&lt;</code>）、取大（<code>&gt;</code>）</p></blockquote><ul><li>逻辑运算符</li></ul><blockquote><p>逻辑与（<code>&amp;&amp;</code>）、逻辑或（<code>||</code>）、逻辑非（<code>~</code>）</p></blockquote><ul><li>位运算符</li></ul><blockquote><p>位加符（<code>AND</code>）、位取反符（<code>NOT</code>）、位或符（<code>OR</code>）、位异或符（<code>XOR</code>）</p></blockquote><ul><li>关系运算符</li></ul><blockquote><p>等于（<code>EQ</code>）、不等于（<code>NE</code>）、大于等于（<code>GE</code>）、大于（<code>GT</code>）、小于等于（<code>LE</code>）、小于（<code>LT</code>）。返回值是真（<code>1</code>）假（<code>0</code>）</p></blockquote><ul><li>数组（矩阵）运算符</li></ul><blockquote><p>数组乘（<code>#</code>）是第一个数组的列元素乘以第二个数组的行元素并求和。</p><p>矩阵乘（<code>##</code>）与数组乘类似，区别是行乘以列。</p></blockquote><ul><li>其它运算符</li></ul><blockquote><p>圆括号<code>()</code>用来对表达式进行组合或一系列表达式控制优先级。</p><p>方括号<code>[]</code>用来数组连接或对数组进行元素调用。</p><p>条件运算符是<code>？:</code>，<code>value = expr1 ? expr2 : expr3</code> 如果 <code>expr1</code> 是 <code>true</code>，那么 <code>value</code> 等于 <code>expr2</code> ，否则 <code>value</code> &#x3D;等于<code>expr3</code>。</p><p>对象方法调用符<code>.</code>或<code>-&gt;</code>两种，对象可以通过这两种符号来调用相关的方法。</p><p>指针调用符为<code>*</code>，引用格式为<code>*指针变量名</code>。</p></blockquote><ul><li>运算符优先级</li></ul><table><thead><tr><th align="center">优先级</th><th align="left">操作符</th></tr></thead><tbody><tr><td align="center">一级（最高）</td><td align="left"><code>()</code> (公式表达式)<br /><code>[]</code> (数组连接)</td></tr><tr><td align="center">二级</td><td align="left"><code>.</code> (结构体域表达式)<br /><code>[]</code> (数组元素调用)<br /><code>()</code> (函数引用)</td></tr><tr><td align="center">三级</td><td align="left"><code>*</code> (指针调用)<br /><code>^</code> (幂函数)<br /><code>++</code> (增函数)<br /><code>--</code> (减函数)</td></tr><tr><td align="center">四级</td><td align="left"><code>*</code> (乘)<br /><code>#</code> 和 <code>##</code> (矩阵乘)<br /><code>/</code>(除)<br /><code>MOD</code> (取余数)</td></tr><tr><td align="center">五级</td><td align="left"><code>+</code> (加)<br /><code>-</code> (减和取反)<br /><code>&lt;</code> (求小)<br /><code>&gt;</code> (求大)<br /><code>NOT</code> (位取反)<br /><code>~</code> (逻辑取反)</td></tr><tr><td align="center">六级</td><td align="left"><code>EQ</code> (等于) <br/><code>NE</code> (不等于)<br /><code>LE</code> (小于等于) <br/><code>LT</code> (小于) <br/><code>GE</code> (大于等于) <br/><code>GT</code> (大于)</td></tr><tr><td align="center">七级</td><td align="left"><code>AND</code> (位与) <br/><code>OR</code> (位或) <br/><code>XOR</code> (位异或)</td></tr><tr><td align="center">八级</td><td align="left"><code>&amp;&amp;</code> (逻辑与)</td></tr><tr><td align="center">九级</td><td align="left"><code>?:</code> (条件表达式)</td></tr></tbody></table><h3 id="👀其他符号"><a href="#👀其他符号" class="headerlink" title="👀其他符号"></a>👀其他符号</h3><p><code>$</code>续行符：续行符主要应用在一条语句过长或参数过多时进行格式化显示；</p><p><code>&amp;</code>同行符：使用了同行符相当于两行代码写在一行之中；</p><p><code>;</code>注释符：此符号之后的该行所有代码都将看做是注释，不参与编译运行。</p><p>笔者不才，请多交流！！！</p>]]></content>
      
      
      <categories>
          
          <category> IDL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ENVI </tag>
            
            <tag> IDL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python异常处理-模块Model/Package-文件处理</title>
      <link href="/2022/09/25/Ex-Model-File/"/>
      <url>/2022/09/25/Ex-Model-File/</url>
      
        <content type="html"><![CDATA[<h2 id="⛄异常处理"><a href="#⛄异常处理" class="headerlink" title="⛄异常处理"></a>⛄异常处理</h2><p>编写计算机程序时，通常能够区分<strong>正常</strong>和<strong>异常</strong>（不正常）情况。异常事件可能是错误（如试图除以零），也可能是通常不会发生的事情。为处理这些异常事件，可在每个可能发生这些事件的地方都使用条件语句。例如，对于每个除法运算，都检查除数是否为零。然而，这样做不仅效率低下、缺乏灵活性，还可能导致程序难以卒读。你可能很想忽略这些异常事件，希望它们不会发生，但<code>Python</code>提供功能强大的替代解决方案——异常处理机制。</p><p><code>Python</code>使用异常对象来表示异常状态，并在遇到错误时引发异常。异常对象未被处理（或捕获）时，程序将终止并显示一条错误消息（<code>traceback</code>）。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">1</span>]:<span class="number">1</span>/<span class="number">0</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;ipython-input-2-9e1622b385b6&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    <span class="number">1</span>/<span class="number">0</span></span><br><span class="line">ZeroDivisionError: division by zero</span><br></pre></td></tr></table></figure><p>如果异常只能用来显示错误消息，就没多大意思了。但事实上，每个异常都是某个类的实例。你能以各种方式引发和捕获这些实例，从而逮住错误并采取措施，而不是放任整个程序失败。</p><h3 id="👀异常的概念"><a href="#👀异常的概念" class="headerlink" title="👀异常的概念"></a>👀异常的概念</h3><ul><li>程序在运行时，如果<code>Python解释器</code>遇到到一个错误，会停止程序的执行，并且提示一些错误信息，这就是<strong>异常</strong>。</li><li>程序停止执行并且提示错误信息这个动作，我们通常称之为：<strong>抛出(<code>raise</code>)异常</strong>。</li></ul><blockquote><p>程序开发时，很难将所有的特殊情况，都处理的面面俱到，通过<strong>异常捕获</strong>可以针对突发事件做集中的处理，从而保证程序的<strong>稳定性和健壮性</strong>。</p></blockquote><h3 id="👀捕获异常"><a href="#👀捕获异常" class="headerlink" title="👀捕获异常"></a>👀捕获异常</h3><p>（1）简单的捕获异常语法</p><p>在程序开发中，如果对某些代码的执行不能确定是否正确，可以增加<code>try(尝试)</code>来<strong>捕获异常</strong>。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 捕获异常最简单的语法格式</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line"><span class="comment"># 尝试执行的代码</span></span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line"><span class="comment"># 出现错误的处理</span></span><br></pre></td></tr></table></figure><ul><li><code>try</code>尝试，下方编写要尝试代码，不确定是否能够正常执行的代码。</li><li><code>except</code>如果不是，下方编写尝试失败的代码。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># 提示用户输入一个数字</span></span><br><span class="line">    num = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入数字：&quot;</span>))</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;请输入正确的数字&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果样例</span></span><br><span class="line">请输入数字：<span class="number">1</span></span><br><span class="line"></span><br><span class="line">请输入数字：a</span><br><span class="line">请输入正确的数字</span><br></pre></td></tr></table></figure><p>（2）错误类型捕获及完整语法</p><p>在程序执行时，可能会遇到<strong>不同类型的异常</strong>，并且需要<strong>针对不同类型的异常</strong>，<strong>做出不同的响应</strong>，这个时候，就需要捕获错误类型了。</p><p><strong>捕获未知错误</strong></p><ul><li>在开发时，<strong>要预判到所有可能出现的错误</strong>，还是有一定难度的。</li><li>如果希望程序<strong>无论出现任何错误</strong>，都不会因为<code>Python解释器</code><strong>抛出异常而被终止</strong>，可以再增加一个<code>except</code>。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 语法</span></span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> result:</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;未知错误%s&quot;</span>%result)</span><br></pre></td></tr></table></figure><p>异常捕获完整语法：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 语法</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># 尝试执行的代码</span></span><br><span class="line">    <span class="keyword">pass</span> </span><br><span class="line"><span class="keyword">except</span> 错误类型<span class="number">1</span>:</span><br><span class="line">    <span class="comment"># 针对错误类型1,对应的代码处理</span></span><br><span class="line">    <span class="keyword">pass</span> </span><br><span class="line"><span class="keyword">except</span>(错误类型<span class="number">2</span>, 错误类型<span class="number">3</span>):</span><br><span class="line">    <span class="comment"># 针对错误类型2和3,对应的代码处理</span></span><br><span class="line">    <span class="keyword">pass</span> </span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> result:</span><br><span class="line">    <span class="comment"># 捕获未知错误</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;未知错误%s&quot;</span>%result)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="comment"># 只有没有异常时才会执行的代码</span></span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="comment"># 无论是否有异常，都会执行的代码</span></span><br></pre></td></tr></table></figure><p>完整捕获异常的例子：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># 提示用户输入一个数字</span></span><br><span class="line">    num = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入数字：&quot;</span>))</span><br><span class="line">    result = <span class="number">8</span> / num</span><br><span class="line">    <span class="built_in">print</span>(result)</span><br><span class="line"><span class="keyword">except</span> ValueError:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;请输入正确的数字&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> ZeroDivisionError:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;除0错误&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> result:</span><br><span class="line">    <span class="comment"># 捕获未知错误</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;未知错误%s&quot;</span>%result)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;正常执行&quot;</span>)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;执行完成，但是不保证正确&quot;</span>)   </span><br></pre></td></tr></table></figure><h3 id="👀异常的传递"><a href="#👀异常的传递" class="headerlink" title="👀异常的传递"></a>👀异常的传递</h3><ul><li><strong>异常的传递</strong>——当<strong>函数&#x2F;方法</strong>执行<strong>出现异常</strong>，会将异常传递给函数&#x2F;方法的调用一方；</li><li>如果<strong>传递到主程序</strong>，仍然<strong>没有异常处理</strong>，程序才会被终止。</li></ul><blockquote><ul><li>在开发中，可以在<strong>主函数</strong>中增加<strong>异常捕获</strong>；</li><li>而在主函数中调用的其他函数，只要出现异常，都会传递到主函数的<strong>异常捕获</strong>中；</li><li>这样就不需要在代码中，增加大量的<strong>异常捕获</strong>，能够保证代码的整洁和健壮性。</li></ul></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">demo1</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入一个整数：&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">demo2</span>():</span><br><span class="line">    <span class="keyword">return</span> demo1()</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">print</span>(demo2())</span><br><span class="line"><span class="keyword">except</span> ValueError:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;请输入正确的数字&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> result:</span><br><span class="line">    <span class="comment"># 捕获未知错误</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;未知错误%s&quot;</span>%result)</span><br></pre></td></tr></table></figure><h3 id="👀抛出raise异常"><a href="#👀抛出raise异常" class="headerlink" title="👀抛出raise异常"></a>👀抛出<code>raise</code>异常</h3><p><strong>应用场景</strong></p><ul><li>在开发中，除了<strong>代码执行出错</strong><code>Python解释器</code>会抛出异常之外；</li><li>还可以根据应用程序特有的业务需求<strong>主动抛出异常</strong>。</li></ul><p><strong>示例</strong></p><ul><li>提示用户输入密码，如果长度少于8，抛出异常。</li></ul><p><strong>注意</strong></p><ul><li>当前函数只负责提示用户输入密码，如果密码长度不正确，需要其他的函数进行额外处理；</li><li>因此可以<strong>抛出异常</strong>，由其他需要处理的函数<strong>捕获异常</strong>。</li></ul><p><strong>抛出异常</strong></p><ul><li><p><code>Python</code>中提供了一个<code>Exception</code> 异常类。</p></li><li><p>在开发时，如果满足<strong>特定业务需求</strong>时，希望抛出异常，可以：</p><ul><li><p>创建一个<code>Exception</code>的对象</p></li><li><p>使用<code>raise</code>关键字抛出异常对象</p></li></ul></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">input_passward</span>():</span><br><span class="line">    <span class="comment"># 提示输入密码</span></span><br><span class="line">    pwd = <span class="built_in">input</span>(<span class="string">&quot;请输入密码：&quot;</span>)</span><br><span class="line">    <span class="comment"># 判断，如果密码长度≥8，返回用户输入的密码</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(pwd) &gt;= <span class="number">8</span>:</span><br><span class="line">        <span class="keyword">return</span> pwd</span><br><span class="line">    <span class="comment"># 如果密码长度&lt;8，主动抛出异常</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;主动抛出异常&quot;</span>)</span><br><span class="line">    <span class="comment"># 1.创建异常对象，可以使用错误信息字符串作为参数</span></span><br><span class="line">    ex = Exception(<span class="string">&quot;密码长度不够&quot;</span>)</span><br><span class="line">    <span class="comment"># 2.抛出异常</span></span><br><span class="line">    <span class="keyword">raise</span> ex</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">print</span>(input_passward())</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> result:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;异常为:%s&quot;</span> % result)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果样例</span></span><br><span class="line">请输入密码：<span class="number">123</span></span><br><span class="line">主动抛出异常</span><br><span class="line">异常为:密码长度不够</span><br></pre></td></tr></table></figure><h2 id="⛄模块和包-Package"><a href="#⛄模块和包-Package" class="headerlink" title="⛄模块和包(Package)"></a>⛄模块和包(Package)</h2><h3 id="👀模块"><a href="#👀模块" class="headerlink" title="👀模块"></a>👀模块</h3><p>（1）模块的概念</p><p>模块是<code>Python</code>程序架构的一个核心概念</p><ul><li>每一个以扩展名<code>py</code>结尾的<code>Python</code>源代码文件都是一个<strong>模块</strong>，文件名就是<strong>模块名</strong>；</li><li><strong>模块名</strong>同样也是一个标识符，需要符合标识符的命名规则(字母、数字、下划线，不能以数字开头)；</li><li>在模块中定义的<strong>全局变量</strong>、<strong>函数</strong>、<strong>类</strong>都是提供给外界直接使用的工具；</li><li><strong>模块</strong>就好比是<strong>工具包</strong>，要想使用这个工具包中的工具，就需要先<strong>导入</strong>这个模块。</li></ul><p>（2）模块导入方式</p><p>① <code>import</code>导入</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> 模块名<span class="number">1</span>, 模块名<span class="number">2</span></span><br></pre></td></tr></table></figure><blockquote><p>提示：在导入模块时，<code>PEP8</code>建议每个导入应该独占一行</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> 模块名<span class="number">1</span></span><br><span class="line"><span class="keyword">import</span> 模块名<span class="number">2</span></span><br></pre></td></tr></table></figure><p>导入之后，通过<code>模块名.</code>使用模块提供的工具–全局变量、函数、类。如果模块的名字太长，可以使用<code>as</code>指定模块的名称，以方便在代码中的使用。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> 模块名 <span class="keyword">as</span> 模块别名</span><br></pre></td></tr></table></figure><blockquote><p>注意：<strong>模块别名</strong>应该符合<strong>大驼峰命名法</strong></p></blockquote><p>② <code>from..import</code>导入</p><ul><li>如果希望从某一个模块中，导入部分工具，就可以使用<code>from..import</code>的方式；</li><li><code>import 模块名</code>是<strong>一次性</strong>把模块中<strong>所有工具全部导入</strong>，并且通过<strong>模块名&#x2F;别名</strong>访问。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 从模块导入某一个工具</span></span><br><span class="line"><span class="keyword">from</span> 模块名<span class="number">1</span> <span class="keyword">import</span> 工具名</span><br></pre></td></tr></table></figure><p>导入之后</p><ul><li>不需要通过<code>模块名.</code>；</li><li>可以直接使用<code>模块提供的工具</code>——全局变量、函数、类。</li></ul><p>注意</p><p>如果两个模块，存在<strong>同名的函数</strong>，那么<strong>后导入模块的函数</strong>，会<strong>覆盖掉先导入的函数</strong>。</p><ul><li>开发时<code>import</code>代码应该统一写在<strong>代码的顶部</strong>，更容易及时发现冲突；</li><li>一旦发现冲突，可以使用<code>as</code>关键字<strong>给其中一个工具起一个别名</strong>。</li></ul><p>③ <code>from...import *</code> (知道)</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 从模块导入所有工具</span></span><br><span class="line"><span class="keyword">from</span> 模块名<span class="number">1</span> <span class="keyword">import</span> *</span><br></pre></td></tr></table></figure><blockquote><p>注意：这种方式不推荐使用，不需要通过<code>模块名.</code>调用，因为函数重名并没有任何提示，出现问题不好排查。</p></blockquote><p>（3）模块的搜索顺序</p><p><code>Python</code>的解释器在导入模块时，会：</p><ul><li>搜索<strong>当前目录</strong>指定模块名的文件，如果有就直接导入；</li><li>如果没有，再搜索<strong>系统目录</strong>。</li></ul><blockquote><p>在开发时，给文件起名，不要和系统的模块文件重名</p></blockquote><p><code>Python</code>中每一个模块都有一个内置属性<code>__file__</code>可以查看模块的<strong>完整路径</strong>。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="comment"># 生成一个0~18的数字</span></span><br><span class="line">rand = random.randint(e,<span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(rand)</span><br></pre></td></tr></table></figure><blockquote><p>注意：如果当前目录下，存在一个<code>random.py</code>的文件，程序就无法正常执行了！这个时候，<code>Python</code>的解释器会加载当前目录下的<code>random.py</code>而不会加载系统的<code>random</code>模块。</p></blockquote><p>（4）每一个文件都应该是可以被导入的</p><ul><li>一个独立的<code>Python</code>文件就是一个<strong>模块</strong>；</li><li>在导入文件时，文件中<strong>所有没有任何缩进的代码</strong>都会被执行一遍！</li></ul><p>实际开发场景</p><ul><li>在实际开发中，每一个模块都是独立开发的，大多都有专人负责；</li><li>开发人员通常会在模块下方增加一些<strong>测试代码</strong>，仅在模块内使用，而被导入到其他文件中不需要执行。</li></ul><p><code>__name__</code>属性</p><ul><li><code>__name__</code>属性可以做到，测试模块的代码<strong>只在测试情况下被运行</strong>，而在被<strong>导入时不会被执行</strong>！</li><li><code>__name__</code>是<code>Python</code>的一个内置属性，记录着一个字符串；</li><li>如果是被其他文件导入的，<code>__name__</code>就是模块名；</li><li>如果是当前执行的程序，<code>__name__</code>是<code>__main__</code>。</li></ul><p>​    在很多<code>Python</code>文件中都会看到以下格式的代码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 导入模块</span></span><br><span class="line"><span class="comment"># 定义全局变量</span></span><br><span class="line"><span class="comment"># 定义类</span></span><br><span class="line"><span class="comment"># 定义函数</span></span><br><span class="line">        </span><br><span class="line"><span class="comment"># 在代码的最下方</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line"><span class="comment">#...</span></span><br><span class="line"><span class="keyword">pass</span></span><br><span class="line"><span class="comment"># 根据_name判断是否执行下方代码</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">main()</span><br></pre></td></tr></table></figure><h3 id="👀包-Package"><a href="#👀包-Package" class="headerlink" title="👀包(Package)"></a>👀包(<code>Package</code>)</h3><ul><li><strong>包</strong>是一个<strong>包含多个模块</strong>的<strong>特殊目录</strong>；</li><li>目录下有一个<strong>特殊的文件</strong><code>__init__.py</code>；</li><li>包名的<strong>命名方式</strong>和变量名一致，小写字母、下划线等。</li></ul><blockquote><p>好处：使用<code>import 包名</code>可以一次性导入包中所有的模块。</p></blockquote><p> <code>__init__.py</code>，要在外界使用包中的模块，需要在<code>__init__.py</code>中指定对外界提供的模块列表。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 从当前目录导入模块列表</span></span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> 模块名<span class="number">1</span></span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> 模块名<span class="number">2</span></span><br></pre></td></tr></table></figure><h2 id="⛄文件处理"><a href="#⛄文件处理" class="headerlink" title="⛄文件处理"></a>⛄文件处理</h2><h3 id="👀文件的概念"><a href="#👀文件的概念" class="headerlink" title="👀文件的概念"></a>👀文件的概念</h3><ul><li>计算机的文件，就是存储在某种长期储存设备上的一段数据。</li><li>文件的存储方式：是以二进制的方式保存在磁盘上。</li></ul><h3 id="👀文件的基本操作"><a href="#👀文件的基本操作" class="headerlink" title="👀文件的基本操作"></a>👀文件的基本操作</h3><p>文本文件和二进制文件，在计算机中操作文件的套路非常固定，一共包含三个步骤：</p><ul><li><p>打开文件</p></li><li><p>读、写文件</p><ul><li><p>读，将文件内容读入内存</p></li><li><p>写，将内存内容写入文件</p></li></ul></li><li><p>关闭文件</p></li></ul><p>在<code>Python</code>中要操作文件需要记住1个函数和3个方法</p><table><thead><tr><th>序号</th><th>函数&#x2F;方法</th><th>说明</th></tr></thead><tbody><tr><td>01</td><td><code>open</code></td><td>打开文件，并且返回文件操作对象</td></tr><tr><td>02</td><td><code>read</code></td><td>将文件内容读取到内存</td></tr><tr><td>03</td><td><code>write</code></td><td>将指定内容写入文件</td></tr><tr><td>04</td><td><code>close</code></td><td>关闭文件</td></tr></tbody></table><blockquote><p><code>open</code>函数负责打开文件，并且返回文件对象；</p><p><code>read</code>&#x2F;<code>write</code>&#x2F;<code>close</code>三个方法都需要通过<strong>文件对象</strong>调用。</p></blockquote><h3 id="👀read-方法"><a href="#👀read-方法" class="headerlink" title="👀read()方法"></a>👀<code>read()</code>方法</h3><ul><li><p><code>open</code>函数的第一个参数是要打开的文件名(文件名区分大小写)。</p><ul><li><p>如果文件<strong>存在</strong>，返回文件操作对象；</p></li><li><p>如果文件<strong>不存在</strong>，会抛出异常。</p></li></ul></li><li><p><code>read</code>方法可以一次性<strong>读入</strong>并<strong>返回</strong>文件的<strong>所有内容</strong>。</p></li><li><p><code>close</code>方法负责<strong>关闭文件</strong>。</p><ul><li>如果忘记关闭文件，会造成系统资源消耗，而且会影响到后续对文件的访问。</li></ul></li><li><p>注意：<code>read</code>方法执行后，会把<strong>文件指针</strong>移动到<strong>文件的末尾</strong>。</p></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1.打开-文件名需要注意大小写</span></span><br><span class="line">file = <span class="built_in">open</span>(<span class="string">&quot;README&quot;</span>)</span><br><span class="line"><span class="comment"># 2.读取</span></span><br><span class="line">text = file.read()</span><br><span class="line"><span class="built_in">print</span>(text)</span><br><span class="line"><span class="comment"># 3.关闭</span></span><br><span class="line">file.close()</span><br></pre></td></tr></table></figure><blockquote><p>提示：在开发中，通常会先编写打开和关闭的代码，再编写中间针对文件的读&#x2F;写操作！使用 <code>with</code> 关键字系统会自动调用 <code>f.close()</code> 方法， <code>with</code> 的作用等效于 <code>try/finally</code> 语句是一样的。</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 打开文件</span></span><br><span class="line">filename=<span class="built_in">open</span>(<span class="string">&quot;file.txt&quot;</span>)</span><br><span class="line"><span class="comment"># 读取文件内容</span></span><br><span class="line">text = filename.read()</span><br><span class="line"><span class="built_in">print</span>(text)</span><br><span class="line"><span class="comment"># 如果执行了一次read方法,读取了所有内容,那么再次调用read方法,还能够获得到内容吗？读取不到</span></span><br><span class="line"><span class="comment"># 当执行了read方法后,文件指针会移动到读取内容的末尾</span></span><br><span class="line">text1 = filename.read()</span><br><span class="line"><span class="built_in">print</span>(text1)</span><br><span class="line"><span class="comment"># 关闭文件</span></span><br><span class="line">filename.close()</span><br></pre></td></tr></table></figure><p>文件指针（知道）</p><ul><li><strong>文件指针</strong>标记<strong>从哪个位置开始读取数据</strong>；</li><li><strong>第一次打开</strong>文件时，通常<strong>文件指针会指向文件的开始位置</strong>；</li><li>当执行了<code>read</code>方法后，<strong>文件指针</strong>会移动到<strong>读取内容的末尾</strong>；<ul><li>默认情况下会移动到<strong>文件末尾</strong>。</li></ul></li></ul><blockquote><p>思考：</p><p>如果执行了一次<code>read</code>方法，读取了所有内容，那么再次调用<code>read</code>方法，还能够获得到内容吗？</p><p>不能，第一次读取之后，文件指针移动到了文件末尾，再次调用不会读取到任何的内容。</p></blockquote><h3 id="👀打开文件的方式"><a href="#👀打开文件的方式" class="headerlink" title="👀打开文件的方式"></a>👀打开文件的方式</h3><p><code>open</code>函数默认以只读方式打开文件，并且返回文件对象语法如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;文件名&quot;</span>,<span class="string">&quot;访问方式&quot;</span>)</span><br></pre></td></tr></table></figure><p>访问方式说明</p><table><thead><tr><th align="center">访问方式</th><th align="left">说明</th></tr></thead><tbody><tr><td align="center"><code>r</code></td><td align="left">以只读方式打开文件。<br />文件的指针将会放在文件的开头，这是默认模式。如果文件不存在，抛出异常。</td></tr><tr><td align="center"><code>w</code></td><td align="left">以只写方式打开文件。<br />如果文件存在会被覆盖。如果文件不存在，创建新文件。</td></tr><tr><td align="center"><code>a</code></td><td align="left">以追加方式打开文件。<br />如果该文件已存在，文件指针将会放在文件的结尾。如果文件不存在，创建新文件进行写入。</td></tr><tr><td align="center"><code>r+</code></td><td align="left">以读写方式打开文件。<br />文件的指针将会放在文件的开头。如果文件不存在，抛出异常。</td></tr><tr><td align="center"><code>w+</code></td><td align="left">以读写方式打开文件。<br />如果文件存在会被覆盖。如果文件不存在，创建新文件。</td></tr><tr><td align="center"><code>a+</code></td><td align="left">以读写方式打开文件。<br />如果该文件已存在，文件指针将会放在文件的结尾。如果文件不存在，创建新文件进行写入。</td></tr></tbody></table><blockquote><p>提示：频繁的移动文件指针，会影响文件的读写效率，开发中更多会以只读、只写的方式来操作文件。</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 写入文件</span></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;README&quot;</span>, <span class="string">&quot;w&quot;</span>)</span><br><span class="line"></span><br><span class="line">f.write(<span class="string">&quot;hello python \n&quot;</span>)</span><br><span class="line">f.write(<span class="string">&quot;我是谁&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭文件</span></span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure><h3 id="👀按行读取文件内容"><a href="#👀按行读取文件内容" class="headerlink" title="👀按行读取文件内容"></a>👀按行读取文件内容</h3><ul><li><code>read</code>方法默认会把文件的<strong>所有内容一次性读取到内存</strong>；</li><li>如果文件太大，对内存的占用会非常严重。</li></ul><p><code>readline</code>方法</p><ul><li><code>readline</code>方法可以一次读取一行内容；</li><li>方法执行后，会把文件指针移动到下一行，准备再次读取。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 读取大文件的正确方法</span></span><br><span class="line"><span class="comment"># 打开文件</span></span><br><span class="line">file=<span class="built_in">open</span>(<span class="string">&quot;README&quot;</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="comment"># 读取一行内容</span></span><br><span class="line">    text=file.readline()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 判断是否读到内容</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> text:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment"># 每读取一行的末尾已经有了一个&#x27;\n&#x27;</span></span><br><span class="line">    <span class="built_in">print</span>(text,end=<span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="comment"># 关闭文件</span></span><br><span class="line">file.close()</span><br></pre></td></tr></table></figure><h3 id="👀文件-x2F-目录常用管理操作os"><a href="#👀文件-x2F-目录常用管理操作os" class="headerlink" title="👀文件&#x2F;目录常用管理操作os"></a>👀文件&#x2F;目录常用管理操作<code>os</code></h3><ul><li>在<strong>终端&#x2F;文件浏览器</strong>中可以执行常规的<strong>文件&#x2F;目录</strong>管理操作，例如：<ul><li>创建、重命名、删除、改变路径、查看目录内容、……</li></ul></li><li>在<code>Python</code>中，如果希望通过程序实现上述功能，需要导入<code>os</code>模块。</li></ul><p>文件操作</p><table><thead><tr><th align="center">序号</th><th>方法名</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td align="center">01</td><td><code>rename</code></td><td>重命名文件</td><td><code>os.rename(源文件名，目标文件名)</code></td></tr><tr><td align="center">02</td><td><code>remove</code></td><td>删除文件</td><td><code>os.remove(文件名)</code></td></tr></tbody></table><p>目录操作</p><table><thead><tr><th align="center">序号</th><th>方法名</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td align="center">01</td><td><code>listdir</code></td><td>目录列表</td><td><code>os.listdir(目录名)</code></td></tr><tr><td align="center">02</td><td><code>mkdir</code></td><td>创建目录</td><td><code>os.mkdir(目录名)</code></td></tr><tr><td align="center">03</td><td><code>rmdir</code></td><td>删除目录</td><td><code>os.rmdir(目录名)</code></td></tr><tr><td align="center">04</td><td><code>getcwd</code></td><td>获取当前目录</td><td><code>os.getcwd()</code></td></tr><tr><td align="center">05</td><td><code>chdir</code></td><td>修改工作目录</td><td><code>os.chdir(目标目录)</code></td></tr><tr><td align="center">06</td><td><code>path.isdir</code></td><td>判断是否是文件</td><td><code>os.path.isdir(文件路径)</code></td></tr></tbody></table><blockquote><p>提示：文件或者目录操作都支持<strong>相对路径</strong>和<strong>绝对路径</strong>。其他操作，可以具体了解<code>os</code>模块详细内容。</p></blockquote><p>文本文件的编码格式（科普）。文本文件存储的内容是基于字符编码的文件,常见的编码有<code>ASCII</code>编码，<code>UNICODE</code>编码等。</p><ul><li><code>Python 2.x</code>默认使用<code>ASCII</code>编码</li><li><code>Python 3.x</code>默认使用<code>UTF-8</code>编码</li></ul><p><code>unicode</code>字符串</p><ul><li>在<code>Python2.x</code>中，即使指定了文件使用<code>UTF-8</code>的编码格式，但是在遍历字符时，仍然会以字节为单位遍历字符串；</li><li>要能够正确的遍历字符串，在定义字符串时，需要在字符串的引号前，增加一个小写字母<code>u</code>，告诉解释器这是一个<code>unicode</code>字符串(使用<code>UTF-8</code>编码格式的字符串)。</li></ul><h2 id="⛄eval-函数"><a href="#⛄eval-函数" class="headerlink" title="⛄eval()函数"></a>⛄<code>eval()</code>函数</h2><p><code>eval()</code>函数十分强大，将<strong>字符串</strong>当成<strong>有效的表达式</strong>来求值并<strong>返回计算结果</strong>，但是不能滥用。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 基本的数学计算</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">eval</span>(<span class="string">&quot;1+1&quot;</span>))</span><br><span class="line"><span class="comment"># 字符串重复</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">eval</span>(<span class="string">&quot;&#x27;*&#x27;*10&quot;</span>))</span><br><span class="line"><span class="comment"># 将字符串转换成列表</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="built_in">eval</span>(<span class="string">&quot;[1,2,3,4,5]&quot;</span>)))</span><br><span class="line"><span class="comment"># 将字符串转换成字典</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="built_in">eval</span>(<span class="string">&quot;&#123;&#x27;name&#x27;:&#x27;xiaoming&#x27;,&#x27;age&#x27;:18&#125;&quot;</span>)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line">**********</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;list&#x27;</span>&gt;</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;dict&#x27;</span>&gt;</span><br></pre></td></tr></table></figure><p>笔者不才，请多交流！！！</p><p>参考文献：黑马程序员《<code>Python</code>入门教程完整版》</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Python基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python面向对象详解</title>
      <link href="/2022/09/18/Python-OOP/"/>
      <url>/2022/09/18/Python-OOP/</url>
      
        <content type="html"><![CDATA[<h2 id="⛄面向对象基本概念"><a href="#⛄面向对象基本概念" class="headerlink" title="⛄面向对象基本概念"></a>⛄面向对象基本概念</h2><p>面向过程和面向对象，是两种不同的编程方式。</p><h3 id="👀面向过程"><a href="#👀面向过程" class="headerlink" title="👀面向过程"></a>👀面向过程</h3><ol><li>把完成某一个需求的所有步骤，<strong>从头到尾</strong>逐步实现；</li><li>根据开发需求，将某些功能独立的代码封装成一个又一个函数；</li><li>最后完成的代码，就是<strong>顺序</strong>地调用不同的函数。</li></ol><p>特点：</p><ul><li>注重<strong>步骤与过程</strong>，不注重职责分工；</li><li>如果需求复杂，代码会变得很复杂；</li><li>开发复杂项目，没有固定的套路，开发难度很大！</li></ul><h3 id="👀面向对象"><a href="#👀面向对象" class="headerlink" title="👀面向对象"></a>👀面向对象</h3><p>相比较函数，面向对象是更大的封装，根据职责在一个对象中封装多个方法。</p><ol><li>在完成某一个需求前，首先确定<strong>职责</strong>——<strong>要做的事情（方法）</strong>；</li><li>根据<strong>职责</strong>确定不同的<strong>对象</strong>，在<strong>对象</strong>内部封装不同的<strong>方法</strong>（多个）；</li><li>最后完成的代码，就是顺序地让<strong>不同的对象</strong>调用<strong>不同的方法</strong>。</li></ol><p>特点</p><ul><li>注重<strong>对象和职责</strong>，不同的对象承担不同的职责；</li><li>更加适合应对复杂的需求变化，是专门应对复杂项目开发，提供的固定套路；</li><li>需要在面向过程基础上，再学习一些面向对象的语法。</li></ul><h2 id="⛄类和对象"><a href="#⛄类和对象" class="headerlink" title="⛄类和对象"></a>⛄类和对象</h2><h3 id="👀类和对象的概念"><a href="#👀类和对象的概念" class="headerlink" title="👀类和对象的概念"></a>👀类和对象的概念</h3><p>类和对象是面向对象编程的两个核心概念。</p><p>（1）类</p><ol><li><p><strong>类</strong>是对一群具有<strong>相同特征</strong>或者<strong>行为</strong>的事物的一个统称，是抽象的，不能直接使用。</p><ul><li><p><strong>特征</strong>被称为<strong>属性</strong>；</p></li><li><p><strong>行为</strong>被称为<strong>方法</strong>；</p></li></ul></li><li><p><strong>类</strong>就相当于制造飞机时的图纸，是一个模板，是<strong>负责创建对象</strong>的</p></li></ol><p>（2）对象</p><ol><li><p><strong>对象</strong>是<strong>由类创建出来的一个具体存在</strong>，可以直接使用。</p></li><li><p>由<strong>哪一个类</strong>创建出来的<strong>对象</strong>，就拥有在<strong>哪一个类</strong>中定义的：</p><ul><li><p>属性</p></li><li><p>方法</p></li></ul></li><li><p><strong>对象</strong>就相当于用图纸制造的飞机。在程序开发中，应该<strong>先有类</strong>，<strong>再有对象</strong>。</p></li></ol><p>（3）类和对象的关系</p><ol><li><strong>类是模板</strong>，对象是根据类这个模板创建出来的，应该<strong>先有类</strong>，<strong>再有对象</strong>。</li><li>类只有一个，而对象可以有很多个<ul><li><strong>不同的对象</strong>之间<strong>属性</strong>可能会各不相同</li></ul></li><li><strong>类</strong>中定义了什么属性和方法，对象中就有什么属性和方法，不可能多，也不可能少。</li></ol><h3 id="👀类的设计"><a href="#👀类的设计" class="headerlink" title="👀类的设计"></a>👀类的设计</h3><p>在程序开发中，要设计一个类，通常需要满足一下三个要素：</p><ol><li><strong>类名</strong>这类事物的名字，满足<strong>大驼峰命名法</strong>；</li><li><strong>属性</strong>这类事物具有什么样的特征；</li><li><strong>方法</strong>这类事物具有什么样的行为。</li></ol><blockquote><p>大驼峰命名法：HelloWorld，每一个单词的首字母大写；单词与单词之间没有下划线。</p></blockquote><p>（1）类名的确定</p><p>名词提炼法分析整个业务流程，出现的名词，通常就是找到的类。</p><p>（2）属性和方法的确定</p><ul><li><strong>对象的特征描述</strong>，通常可以定义成<strong>属性</strong>；</li><li><strong>对象具有的行为</strong>（<strong>动词</strong>），通常可以定义成<strong>方法</strong>。</li></ul><blockquote><p>提示：需求中没有涉及的属性或者方法在设计类时，不需要考虑。</p></blockquote><h2 id="⛄面向对象基础语法"><a href="#⛄面向对象基础语法" class="headerlink" title="⛄面向对象基础语法"></a>⛄面向对象基础语法</h2><h3 id="👀dir-内置函数"><a href="#👀dir-内置函数" class="headerlink" title="👀dir()内置函数"></a>👀dir()内置函数</h3><p>在<code>Python</code>中对象几乎是无所不在的，我们之前学习的<strong>变量</strong>、<strong>数据</strong>、<strong>函数</strong>都是对象。</p><p>在<code>Python</code>中可以使用以下两个方法验证：</p><ol><li>在<strong>标识符&#x2F;数据</strong>后输入一个<code>.</code>，然后按下<code>TAB</code>键，<code>ipython</code>会提示该对象能够调用的<strong>方法列表</strong>。</li><li>使用内置函数<code>dir()</code>传入<strong>标识符&#x2F;数据</strong>，可以查看对象内的<strong>所有属性及方法</strong>。</li></ol><blockquote><p>提示：<code>__方法名__</code>格式的方法是<code>Python</code> 提供的<strong>内置方法&#x2F;属性</strong>。</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">__new__|方法|创建对象时，会被自动调用</span><br><span class="line">__init__|方法|对象被初始化时，会被自动调用</span><br><span class="line">__del__|方法|对象被从内存中销毁前，会被自动调用</span><br><span class="line">__str__|方法|返回对象的描述信息，<span class="built_in">print</span>函数输出使用</span><br></pre></td></tr></table></figure><h3 id="👀定义简单的类"><a href="#👀定义简单的类" class="headerlink" title="👀定义简单的类"></a>👀定义简单的类</h3><p>面向对象是更大的封装，在一个类中封装多个方法，这样通过这个类创建出来的对象，就可以直接调用这些方法了！！</p><p>（1）定义只包含方法的类</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 类名的命名格式符合大驼峰命名法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">类名</span>：</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">方法1</span>(<span class="params">self, 参数列表</span>)：</span><br><span class="line">      <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">方法2</span>(<span class="params">self, 参数列表</span>)：</span><br><span class="line">      <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>方法的定义格式和之前学习过的函数几乎一样；区别在于第一个参数必须是<code>self</code>。</p><p>（2）创建对象</p><p>当一个类定义完成之后，要使用这个类来创建对象：</p><p><code>对象变量 = 类名（）</code></p><h3 id="👀self的使用"><a href="#👀self的使用" class="headerlink" title="👀self的使用"></a>👀<code>self</code>的使用</h3><p>在<code>Python</code>中，给对象设置属性，只需要在类的外部的代码中直接通过<code>.</code>设置一个属性即可（这种方式虽然简单，但是不推荐使用）。</p><ul><li>在类封装的方法内部，<code>self</code>就表示当前调用方法的对象自己；</li><li>由哪一个对象调用的方法，方法内的<code>self</code>就是哪一个对象的引用；</li><li>调用方法时，程序员不需要传递<code>self</code>参数；</li><li>在方法内部，可以通过<code>self.</code>访问对象的属性，可以通过<code>self.</code>调用其它对象方法；</li></ul><blockquote><p>在类的外部，通过<code>变量名.</code>访问对象的属性和方法；</p><p>在类封装的方法中，通过<code>self.</code>访问对象的属性和方法。</p></blockquote><h3 id="👀-init-方法"><a href="#👀-init-方法" class="headerlink" title="👀__init__方法"></a>👀<code>__init__</code>方法</h3><p>在日常开发中，不推荐在<strong>类的外部</strong>给对象增加属性；如果在运行时，没有找到属性，程序会报错；对象应该包含有哪些属性，应该<strong>封装在类的内部</strong>。</p><ol><li><p>当使用<code>类名()</code>创建对象时，会自动执行以下操作：</p><ul><li><p>为对象在内存中分配空间——创建对象</p></li><li><p>为对象的属性设置初始值——初始化方法（<code>__init__</code>）</p></li></ul></li><li><p>这个初始化方法就是<code>__init__</code>方法，<code>__init__</code>是对象的内置方法</p></li></ol><p><code>__init__</code>方法是专门用来定义一个类具有哪些属性的方法！在<code>__init__</code>方法内部使用<code>self.属性名 = 属性的初始值</code>就可以<strong>定义属性</strong>。</p><p>在开发中，如果希望在创建对象的同时，就设置对象的属性，可以对<code>__init__</code>方法进行改造：</p><ul><li>把希望设置的属性值，定义成<code>__init__</code>方法的参数</li><li>在方法内部使用<code>se1f.属性 = 形参</code>接收外部传递的参数</li><li>在创建对象时，使用<code>类名（属性1，属性2..…）</code>调用</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">People</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;初始化方法%s&quot;</span> % self.name)</span><br><span class="line">xt = People(<span class="string">&quot;xiaotang&quot;</span>)</span><br><span class="line">xm = People(<span class="string">&quot;xiaoming&quot;</span>)</span><br><span class="line"><span class="comment"># 使用id()函数查看数据在内存中的地址</span></span><br><span class="line"><span class="built_in">print</span>(xt, <span class="built_in">id</span>(xt))</span><br><span class="line"><span class="built_in">print</span>(xm, <span class="built_in">id</span>(xm))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">初始化方法xiaotang</span><br><span class="line">初始化方法xiaoming</span><br><span class="line">&lt;__main__.People <span class="built_in">object</span> at <span class="number">0x0000027E373FC408</span>&gt; <span class="number">2741116060680</span></span><br><span class="line">&lt;__main__.People <span class="built_in">object</span> at <span class="number">0x0000027E37E98348</span>&gt; <span class="number">2741127185224</span></span><br></pre></td></tr></table></figure><h3 id="👀-del-和-str-方法"><a href="#👀-del-和-str-方法" class="headerlink" title="👀__del__和__str__方法"></a>👀<code>__del__</code>和<code>__str__</code>方法</h3><p>（1）<code>__del__</code>方法</p><ol><li><p>在<code>Python</code>中</p><ul><li><p>当使用<code>类名()</code>创建对象时，为对象分配完空间后，<strong>自动</strong>调用<code>__init__</code>方法；</p></li><li><p>当一个对象被从内存中销毁前，<strong>自动</strong>调用<code>__del__</code>方法。</p></li></ul></li><li><p>应用场景</p><ul><li><p><code>__init__</code>改造初始化方法，可以让创建对象更加灵活；</p></li><li><p><code>__del__</code>如果希望在对象被销毁前，再做一些事情，可以考虑一下<code>__del__</code>方法。</p></li></ul></li><li><p>生命周期</p><ul><li><p>一个对象从调用<code>类名()</code>创建，生命周期开始；</p></li><li><p>一个对象的<code>__del__</code>方法一旦被调用，生命周期结束；</p></li><li><p>在对象的生命周期内，可以访问对象属性，或者让对象调用方法。</p></li></ul></li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">People</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;初始化方法%s&quot;</span> % self.name)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__del__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;对象销毁，%s&quot;</span> % self.name)</span><br><span class="line">xt = People(<span class="string">&quot;xiaotang&quot;</span>)</span><br><span class="line">xm = People(<span class="string">&quot;xiaoming&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(xt, <span class="built_in">id</span>(xt))</span><br><span class="line"><span class="built_in">print</span>(xm, <span class="built_in">id</span>(xm))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">初始化方法xiaotang</span><br><span class="line">初始化方法xiaoming</span><br><span class="line">&lt;__main__.People <span class="built_in">object</span> at <span class="number">0x0000027E37EC63C8</span>&gt; <span class="number">2741127373768</span></span><br><span class="line">&lt;__main__.People <span class="built_in">object</span> at <span class="number">0x0000027E37EC6448</span>&gt; <span class="number">2741127373896</span></span><br><span class="line">对象销毁，xiaotang</span><br><span class="line">对象销毁，xiaoming</span><br></pre></td></tr></table></figure><p>（2）<code>__str__</code>方法</p><ul><li>在<code>Python</code>中，使用<code>print</code> 输出对象变量，默认情况下，会输出这个变量<strong>引用的对象</strong>是由<strong>哪一个类创建的对象</strong>，以及在<strong>内存中的地址</strong>（<strong>十六进制表示</strong>）；</li><li>如果在开发中，希望使用<code>print</code>输出<code>对象变量</code>时，能够打印<strong>自定义的内容</strong>，就可以利用<code>__str__</code>这个内置方法了。</li></ul><p>注意：<code>__str__</code>方法必须返回一个字符串</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">People</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;初始化方法%s&quot;</span> % self.name)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__del__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;对象销毁，%s&quot;</span> % self.name)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;我的名字：%s&quot;</span> % self.name</span><br><span class="line">xt = People(<span class="string">&quot;xiaotang&quot;</span>)</span><br><span class="line">xm = People(<span class="string">&quot;xiaoming&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(xt, <span class="built_in">id</span>(xt))</span><br><span class="line"><span class="built_in">print</span>(xm, <span class="built_in">id</span>(xm))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果（对比上一条代码的输出结果）</span></span><br><span class="line">初始化方法xiaotang</span><br><span class="line">初始化方法xiaoming</span><br><span class="line">我的名字：xiaotang <span class="number">2741123224968</span></span><br><span class="line">我的名字：xiaoming <span class="number">2741127144648</span></span><br><span class="line">对象销毁，xiaotang</span><br><span class="line">对象销毁，xiaoming</span><br></pre></td></tr></table></figure><h2 id="⛄面向对象三个基本特征"><a href="#⛄面向对象三个基本特征" class="headerlink" title="⛄面向对象三个基本特征"></a>⛄面向对象三个基本特征</h2><p>面向对象三大特性：</p><ol><li><p><strong>封装</strong>，根据职责将属性和方法封装到一个抽象的类中。</p><ul><li>定义类的准则</li></ul></li><li><p><strong>继承</strong>，实现代码的重用，相同的代码不需要重复的编写。</p><ul><li><p>设计类的技巧</p></li><li><p>子类针对自己特有的需求，编写特定的代码</p></li></ul></li><li><p><strong>多态</strong>，不同的子类对象调用相同的父类方法，产生不同的执行结果。</p><ul><li><p>多态可以增加代码的灵活度</p></li><li><p>以继承和重写父类方法为前提</p></li><li><p>是调用方法的技巧，不会影响到类的内部设计</p></li></ul></li></ol><h2 id="⛄封装"><a href="#⛄封装" class="headerlink" title="⛄封装"></a>⛄封装</h2><h3 id="👀封装概述"><a href="#👀封装概述" class="headerlink" title="👀封装概述"></a>👀封装概述</h3><ul><li><strong>封装</strong>是面向对象编程的一大特点；</li><li>面向对象编程的第一步，将<strong>属性</strong>和<strong>方法</strong>封装到一个抽象的<strong>类</strong>中；</li><li>外界使用<strong>类</strong>创建<strong>对象</strong>，然后让<strong>对象调用方法</strong>；</li><li>对象方法的<strong>细节</strong>都被<strong>封装</strong>在类的内部；</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Gun</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, model</span>):</span><br><span class="line">        <span class="comment"># 枪的型号</span></span><br><span class="line">        self.model = model</span><br><span class="line">        <span class="comment"># 子弹数量</span></span><br><span class="line">        self.bullet_count = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add_bullet</span>(<span class="params">self, count</span>):</span><br><span class="line">        self.bullet_count += count</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">shoot</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> self.bullet_count &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;没有子弹了&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.bullet_count -= <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%s发射子弹[%d]...&quot;</span>%(self.model, self.bullet_count))</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Soldier</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        <span class="comment"># 姓名</span></span><br><span class="line">        self.name = name</span><br><span class="line">        <span class="comment"># 士兵出事没有枪，None表示什么都没有</span></span><br><span class="line">        self.gun = <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fire</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> self.gun <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;%s没有枪...&quot;</span>% self.name)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;冲啊....[%s]&quot;</span>% self.name)</span><br><span class="line">        self.gun.add_bullet(<span class="number">50</span>)</span><br><span class="line">        self.gun.shoot()</span><br><span class="line">        </span><br><span class="line"><span class="comment"># 创建对象</span></span><br><span class="line">ak47 = Gun(<span class="string">&quot;ak47&quot;</span>)</span><br><span class="line">person = Soldier(<span class="string">&quot;xiaotang&quot;</span>)</span><br><span class="line">person.fire()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">20</span>)</span><br><span class="line">person.gun = ak47</span><br><span class="line">person.fire()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">xiaotang没有枪...</span><br><span class="line">********************</span><br><span class="line">冲啊....[xiaotang]</span><br><span class="line">ak47发射子弹[<span class="number">49</span>]...</span><br></pre></td></tr></table></figure><h3 id="👀is与-x3D-x3D-区别"><a href="#👀is与-x3D-x3D-区别" class="headerlink" title="👀is与&#x3D;&#x3D;区别"></a>👀is与&#x3D;&#x3D;区别</h3><p>（1）身份运算符</p><p>身份运算符用于<strong>比较</strong>两个对象的<strong>内存地址</strong>是否一致，<strong>是否是对同一个对象的引用</strong>。在<code>Python</code>中针对<code>None</code>比较时，建议使用<code>is</code>判断。</p><table><thead><tr><th>运算符</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td><code>is</code></td><td><code>is</code>是判断两个标识符是不是引用同一对象</td><td><code>x is y</code>，类似于<code>id(x) == id(y)</code></td></tr><tr><td><code>is not</code></td><td><code>is not</code>是判断两个标识符是不是引用不同对象</td><td><code>x is not y</code>，类似于<code>id(a) != id(y)</code></td></tr></tbody></table><p>（2）<code>is</code>与<code>==</code>区别</p><p><code>is</code>用于判断<strong>两个变量引用对象是否为同一个</strong>；</p><p><code>==</code>用于判断<strong>引用变量的值</strong>是否相等。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">b = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="built_in">print</span>(b <span class="keyword">is</span> a)</span><br><span class="line"><span class="built_in">print</span>(b == a)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><h3 id="👀私有属性和私有方法"><a href="#👀私有属性和私有方法" class="headerlink" title="👀私有属性和私有方法"></a>👀私有属性和私有方法</h3><ol><li><p>在实际开发中，<strong>对象</strong>的<strong>某些属性</strong>或<strong>方法</strong>可能只希望<strong>在对象的内部被使用</strong>，而<strong>不希望在外部被访问</strong>。</p><ul><li><p><strong>私有属性</strong>就是对象不希望公开的属性；</p></li><li><p><strong>私有方法</strong>就是对象不希望公开的方法；</p></li></ul></li><li><p>在定义属性或方法时，在属性名或者方法名前增加<strong>两个下划线</strong>，定义的就是<strong>私有属性或者方法</strong>。</p><ul><li><p>私有属性&#x2F;方法，在外界不能够被直接访问；</p></li><li><p>在对象的方法内部，是可以访问对象的私有属性&#x2F;方法的。</p></li></ul></li><li><p>伪私有属性和私有方法（不建议使用），Python中，并没有真正意义的私有。</p><ul><li><p>在给属性、方法命名时，实际是对名称做了一些特殊处理，使得外界无法访问到；</p></li><li><p><strong>处理方式</strong>：在名称前面加上<code>_类名</code>，即<code>_类名__名称</code>。</p></li></ul></li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">People</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">        self.__height = <span class="number">180</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__mimi</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;我的身高是%d&quot;</span>% self.__height)</span><br><span class="line"></span><br><span class="line">xiaotang = People(<span class="string">&quot;小汤&quot;</span>, <span class="number">20</span>)</span><br><span class="line"><span class="comment"># 私有属性，外部不能访问</span></span><br><span class="line"><span class="comment"># AttributeError: &#x27;People&#x27; object has no attribute &#x27;__height&#x27;</span></span><br><span class="line"><span class="comment"># print(xiaotang.__height)</span></span><br><span class="line"><span class="comment"># AttributeError: &#x27;People&#x27; object has no attribute &#x27;__mimi&#x27;</span></span><br><span class="line"><span class="comment"># xiaotang.__mimi()   </span></span><br><span class="line"><span class="built_in">print</span>(xiaotang._People__height)   <span class="comment"># 180</span></span><br><span class="line">xiaotang._People__mimi()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="number">180</span></span><br><span class="line">我的身高是<span class="number">180</span></span><br></pre></td></tr></table></figure><h3 id="👀单例设计模式"><a href="#👀单例设计模式" class="headerlink" title="👀单例设计模式"></a>👀单例设计模式</h3><ol><li><p>设计模式</p><ul><li><p><strong>设计模式</strong>是<strong>前人工作的总结和提炼</strong>，通常，被人们广泛流传的设计模式都是针对<strong>某一特定问题</strong>的成熟的解决方案；</p></li><li><p>使用<strong>设计模式</strong>是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。</p></li></ul></li><li><p>单例设计模式</p><ul><li><p><strong>目的</strong>–让类创建的对象，在系统中<strong>只有唯一的一个实例</strong>；</p></li><li><p>每一次执行<code>类名()</code>返回的对象，<strong>内存地址是相同的</strong>。</p></li></ul></li><li><p>单例设计模式的应用场景</p><ul><li><p>音乐播放对象</p></li><li><p>回收站对象</p></li><li><p>打印机对象</p></li></ul></li></ol><p>（1）<code>__new__</code>方法</p><ul><li><p>使用<code>类名()</code>创建对象时，<code>Python</code>的解释器首先会调用<code>__new__</code>方法为对象<strong>分配空间</strong>；</p></li><li><p><code>__new__</code>是一个由<code>object</code>基类提供的<strong>内置的静态方法</strong>，主要作用有两个：</p><ul><li><p>在内存中为对象<strong>分配空间</strong></p></li><li><p><strong>返回对象的引用</strong></p></li></ul></li><li><p><code>Python</code>的解释器获得对象的<strong>引用</strong>后，将引用作为第一个参数，传递给<code>__init__</code>方法。</p></li></ul><p>重写<code>__new__</code>方法的代码非常固定：</p><ul><li>重写<code>__new__</code>方法一定要<code>return super().__new__(cls)</code></li><li>否则<code>Python</code>的解释器得不到分配了空间的对象引用，就不会调用对象的初始化方法</li><li>注意：<code>__new__</code>是一个静态方法，在调用时需要<strong>主动传递</strong><code>cls</code>参数</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MusicPlayer</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">cls</span>):</span><br><span class="line">        <span class="comment"># 创建对象时，new方法会被自动调用</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;分配空间&quot;</span>)</span><br><span class="line">        <span class="comment"># 为对象分配空间，返回对象的引用</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>().__new__(cls)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;初始化&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建对象</span></span><br><span class="line">player = MusicPlayer()</span><br><span class="line"><span class="built_in">print</span>(player)      </span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">分配空间</span><br><span class="line">初始化</span><br><span class="line">&lt;__main__.MusicPlayer <span class="built_in">object</span> at <span class="number">0x000002343B97DD48</span>&gt;</span><br></pre></td></tr></table></figure><p>（2）<code>Python</code>中的单例</p><p>单例——让类创建的对象，在系统中只有唯一的一个实例</p><ul><li>定义一个<strong>类属性</strong>，初始值是<code>None</code>，用于记录<strong>单例对象的引用</strong>；</li><li>重写<code>__new__</code>方法；</li><li>如果<strong>类属性</strong><code>is None</code>，调用父类方法分配空间，并在类属性中记录结果；</li><li>返回<strong>类属性</strong>中记录的<strong>对象引用</strong>。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 单例设计模式实现</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MusicPlayers</span>():</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 记录第一个被创建对象的引用</span></span><br><span class="line">    instance = <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">cls</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;分配空间&quot;</span>)</span><br><span class="line">        <span class="comment"># 判断类属性是否为空对象</span></span><br><span class="line">        <span class="keyword">if</span> cls.instance <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="comment"># 调用父类的方法，为第一个对象分配空间</span></span><br><span class="line">            cls.instance = <span class="built_in">super</span>().__new__(cls)</span><br><span class="line">        <span class="keyword">return</span> cls.instance</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;初始化&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建多个实例,无论调用多少次创建对象类的方法，得到的对象内存地址都是相同的</span></span><br><span class="line">player1 = MusicPlayers()</span><br><span class="line">player2 = MusicPlayers()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(player1)</span><br><span class="line"><span class="built_in">print</span>(player2)   </span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">分配空间</span><br><span class="line">初始化</span><br><span class="line">分配空间</span><br><span class="line">初始化</span><br><span class="line">&lt;__main__.MusicPlayers <span class="built_in">object</span> at <span class="number">0x000002343B945248</span>&gt;</span><br><span class="line">&lt;__main__.MusicPlayers <span class="built_in">object</span> at <span class="number">0x000002343B945248</span>&gt;</span><br></pre></td></tr></table></figure><p>（3）存在的问题</p><p><strong>问题所在</strong></p><ul><li><p>在每次使用<code>类名()</code>创建对象时，<code>Python</code>的解释器都会自动调用两个方法。</p><ul><li><p><code>__new__</code>分配空间</p></li><li><p><code>__init__</code>对象初始化</p></li></ul></li><li><p>在上一小节对<code>__new__</code>方法改造之后，每次都会得到第一次被创建对象的引用。</p></li><li><p>但是：<strong>初始化方法还会被再次调用</strong>。</p></li></ul><p><strong>需求</strong>：让初始化动作只被执行一次。</p><p><strong>解决办法</strong></p><ul><li>定义一个类属性<code>init_flag</code>标记<strong>是否执行过初始化动作</strong>，初始值为<code>False</code>；</li><li>在<code>__init__</code>方法中，判断<code>init_flag</code>，如果为<code>False</code>就执行初始化动作；</li><li>然后将<code>init_flag</code>设置为<code>True</code>；</li><li>这样，再次自动调用<code>__init__</code>方法时，初始化动作就不会被再次执行了。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MPlayers</span>():</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 记录第一个被创建对象的引用</span></span><br><span class="line">    instance = <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 记录是否执行过初始化的动作</span></span><br><span class="line">    init_flag = <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">cls</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;分配空间&quot;</span>)</span><br><span class="line">        <span class="comment"># 判断类属性是否为空对象</span></span><br><span class="line">        <span class="keyword">if</span> cls.instance <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="comment"># 调用父类的方法，为第一个对象分配空间</span></span><br><span class="line">            cls.instance = <span class="built_in">super</span>().__new__(cls)</span><br><span class="line">        <span class="keyword">return</span> cls.instance</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> MPlayers.init_flag:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;初始化了，一次&quot;</span>)</span><br><span class="line">        MPlayers.init_flag = <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line"><span class="comment"># 创建多个实例,无论调用多少次创建对象类的方法，得到的对象内存地址都是相同的</span></span><br><span class="line">player3 = MPlayers()</span><br><span class="line">player4 = MPlayers()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(player3)</span><br><span class="line"><span class="built_in">print</span>(player4)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">分配空间</span><br><span class="line">初始化了，一次</span><br><span class="line">分配空间</span><br><span class="line">&lt;__main__.MPlayers <span class="built_in">object</span> at <span class="number">0x000001E149BB2F08</span>&gt;</span><br><span class="line">&lt;__main__.MPlayers <span class="built_in">object</span> at <span class="number">0x000001E149BB2F08</span>&gt;</span><br></pre></td></tr></table></figure><h2 id="⛄继承"><a href="#⛄继承" class="headerlink" title="⛄继承"></a>⛄继承</h2><h3 id="👀继承概述"><a href="#👀继承概述" class="headerlink" title="👀继承概述"></a>👀继承概述</h3><p>（1）继承的概念：<strong>子类</strong>拥有<strong>父类</strong>的所有<strong>方法</strong>和<strong>属性</strong>。</p><p>（2）继承的语法</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">类名</span>(<span class="title class_ inherited__">父类名</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p><strong>子类</strong>继承自<strong>父类</strong>，可以直接享受父类中已经封装好的方法，不需要再次开发；</p><p><strong>子类</strong>中应该根据职责，封装<strong>子类特有的属性和方法</strong>。</p><blockquote><p>子类        父类<br>派生类    基类</p></blockquote><p>（3）继承的传递性</p><ul><li>C类是B类继承，B类又从A类继承；</li><li>那么C类就具有B类和A类的所有属性和方法；</li><li>子类拥有父类以及父类的父类中封装的所有属性和方法。</li></ul><h3 id="👀方法重写"><a href="#👀方法重写" class="headerlink" title="👀方法重写"></a>👀方法重写</h3><p>（1）方法的重写</p><p><strong>子类</strong>拥有<strong>父类</strong>的所有<strong>方法</strong>和<strong>属性</strong>。</p><p><strong>子类</strong>继承自<strong>父类</strong>，可以直接享受父类中已经封装好的方法，不需要再次开发</p><p>（2）应用场景</p><p>当<strong>父类</strong>的方法实现不能满足子类需求时，可以对方法进行重写（<code>override</code>）</p><p>重写父类方法有两种情况：①覆盖父类的方法；②对父类方法进行扩展。</p><p>①覆盖父类的方法</p><ul><li>如果在开发中，<strong>父类的方法实现</strong>和<strong>子类的方法实现</strong>，<strong>完全不同</strong>；</li><li>就可以使用<strong>覆盖</strong>的方式，在子类中<strong>重新编写</strong>父类的方法实现；</li></ul><blockquote><p>【具体的实现方式】，就相当于在子类中定义了一个和父类同名的方法并且实现。</p><p>重写之后，在运行时，只会调用子类中重写的方法，而不再会调用父类封装的方法</p></blockquote><p>②对父类方法进行扩展</p><p>如果在开发中，子类的方法实现中包含父类的方法实现，父类原本封装的方法实现是子类方法的一部分。</p><p>使用扩展的方式：</p><ul><li>在子类中重写父类的方法；</li><li>在需要的位置使用<code>super().父类方法</code>来调用父类方法的执行；</li><li>代码其他的位置针对子类的需求，编写<strong>子类特有的代码</strong>实现。</li></ul><p>（3）<code>super</code></p><ul><li>在<code>Python</code>中<code>super</code>是一个特殊的类；</li><li><code>super()</code>就是使用<code>super</code>类创建出来的对象；</li><li>最常使用的场景就是在重写父类方法时，调用在父类中封装的方法实现。</li></ul><p>（4）调用父类方法的另外一种方式（知道）</p><p>在<code>Python 2.x</code>时，如果需要调用父类的方法,还可以使用以下方式：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">父类名.方法(self)</span><br></pre></td></tr></table></figure><ul><li>这种方式,目前在Python 3.x还支持这种方式</li><li>这种方法不推荐使用，因为一旦父类发生变化，方法调用位置的类名同样需要修改</li></ul><blockquote><p>提示：</p><p>在开发时，父类名和<code>super()</code>两种方式不要混用；</p><p>如果使用当前子类名调用方法，会形成递归调用，出现死循环。</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">People</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">language</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;地球语言:汉语、俄语、西班牙语、英语、德语...&quot;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(<span class="title class_ inherited__">People</span>):</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">language</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>().language()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%s是中国人，说汉语&quot;</span>%self.name)</span><br><span class="line">    </span><br><span class="line">xiaotang = Person(<span class="string">&quot;小汤&quot;</span>) </span><br><span class="line"><span class="built_in">print</span>(xiaotang.name)</span><br><span class="line">xiaotang.language()  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">小汤</span><br><span class="line">地球语言:汉语、俄语、西班牙语、英语、德语...</span><br><span class="line">小汤是中国人，说汉语</span><br></pre></td></tr></table></figure><h3 id="👀父类的私有属性和私有方法"><a href="#👀父类的私有属性和私有方法" class="headerlink" title="👀父类的私有属性和私有方法"></a>👀父类的私有属性和私有方法</h3><p>父类的私有属性和私有方法</p><ul><li>子类对象<strong>不能</strong>在自己的方法内部，直接访问父类的私有属性或私有方法；</li><li>子类对象可以通过父类的公有方法<strong>间接访问</strong>私有属性或私有方法。</li></ul><blockquote><p><strong>私有属性、方法</strong>是对象的隐私，不对外公开，<strong>外界</strong>以及<strong>子类</strong>都不能直接访问；</p><p><strong>私有属性、方法</strong>通常用于做一些内部的事情。</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">People</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        <span class="comment"># 私有属性</span></span><br><span class="line">        self.__num = <span class="number">8000000000</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">language</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;地球语言:汉语、俄语、西班牙语、英语、德语...&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 私有方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__protect</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;人数：%d，这是一个秘密&quot;</span>% self.__num)</span><br><span class="line">   </span><br><span class="line"><span class="comment"># 通过公有方法间接调用私有属性和私有方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">people_num</span>(<span class="params">self</span>):</span><br><span class="line">        self.__protect()</span><br><span class="line">    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(<span class="title class_ inherited__">People</span>):</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">language</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>().language()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%s是中国人，说汉语&quot;</span>%self.name)</span><br><span class="line">        <span class="comment"># 访问父类中私有方法,是访问不到的</span></span><br><span class="line">        <span class="comment"># self.__protect()</span></span><br><span class="line">        self.people_num()</span><br><span class="line">        </span><br><span class="line">xiaotang = Person(<span class="string">&quot;小汤&quot;</span>) </span><br><span class="line"><span class="built_in">print</span>(xiaotang.name)</span><br><span class="line"><span class="comment"># 访问父类中私有属性,是访问不到的</span></span><br><span class="line"><span class="comment"># print(xiaotang.__num)</span></span><br><span class="line">xiaotang.language()  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">小汤</span><br><span class="line">地球语言:汉语、俄语、西班牙语、英语、德语...</span><br><span class="line">小汤是中国人，说汉语</span><br><span class="line">人数：<span class="number">8000000000</span>，这是一个秘密</span><br></pre></td></tr></table></figure><h3 id="👀多继承"><a href="#👀多继承" class="headerlink" title="👀多继承"></a>👀多继承</h3><p>子类可以拥有多个父类，并且具有所有父类的属性和方法。</p><p>例如：孩子会继承父亲和母亲的特性</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 语法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">子类名</span>(父类名<span class="number">1</span>,父类名<span class="number">2.</span>..):</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p><strong>多继承的使用注意事项</strong></p><p>​    如果<strong>不同的父类</strong>中存在<strong>同名的方法</strong>，<strong>子类</strong>对象在调用方法时，会调用<strong>哪一个父类</strong>中的方法。开发时，应该尽量避免这种容易产生混淆的情况！如果父类之间存在同名的属性或方法，应该尽量避免使用多继承。</p><p><code>python</code>中的<code>MRO</code>—-方法搜索顺序（了解）</p><ul><li><code>python</code>中针对类提供了一个内置属性<code>__mro__</code>可以查看方法的搜索顺序。</li><li><code>MRO</code>是<code>method resolution order</code>，主要用于在<strong>多继承时判断方法、属性的调用路径</strong>。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(*.__mro__)</span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">(&lt;<span class="keyword">class</span> <span class="string">&#x27;__main__.*&#x27;</span>&gt;,&lt;<span class="keyword">class</span> <span class="string">&#x27;__main__.*&#x27;</span>&gt;,&lt;<span class="keyword">class</span> <span class="string">&#x27;object&#x27;</span>&gt;)</span><br></pre></td></tr></table></figure><ul><li>在搜索方法时，是按照<code>__mro__</code>的输出结果从左至右的顺序查找的；</li><li>如果在当前类中找到方法，就直接执行，不再搜索；</li><li>如果没有找到，就查找下一个类中是否有对应的方法，如果找到，就直接执行，不再搜索；</li><li>如果找到最后一个类，还没有找到方法，程序报错。</li></ul><h3 id="👀新式类与旧式-经典-类"><a href="#👀新式类与旧式-经典-类" class="headerlink" title="👀新式类与旧式(经典)类"></a>👀新式类与旧式(经典)类</h3><p><code>object</code> 是<code>Python</code>为所有对象提供的基类，提供有一些内置的属性和方法，可以使用<code>dir</code>函数查看。</p><ul><li>新式类：以<code>object</code>为基类的类，推荐使用；</li><li>经典类：不以<code>object</code>为基类的类，不推荐使用；</li><li>在<code>Python 3.x</code>中定义类时，如果没有指定父类，会默认使用<code>object</code>作为该类的基类–<code>Python 3.x</code>中定义的类都是新式类；</li><li>在<code>Python 2.x</code>中定义类时，如果没有指定父类，则不会以<code>object</code>作为基类。</li></ul><blockquote><p>​    新式类和经典类在多继承时–会影响到方法的搜索顺序</p></blockquote><p>为了保证编写的代码能够同时在<code>Python 2.x</code>和<code>Python 3.x</code>运行！今后在定义类时，如果没有父类，建议统一继承自<code>object</code>。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 语法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">类名</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><h2 id="⛄多态"><a href="#⛄多态" class="headerlink" title="⛄多态"></a>⛄多态</h2><p><strong>多态</strong>，不同的子类对象调用相同的父类方法，产生不同的执行结果。</p><ul><li><p>多态可以增加代码的灵活度</p></li><li><p>以继承和重写父类方法为前提</p></li><li><p>是调用方法的技巧，不会影响到类的内部设计</p></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">game</span>(<span class="params">self</span>):</span><br><span class="line">         <span class="built_in">print</span>(<span class="string">&quot;%s简单的玩耍&quot;</span>%self.name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">T_Dog</span>(<span class="title class_ inherited__">Dog</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">game</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%s在天上玩耍&quot;</span>%self.name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">game_with_dog</span>(<span class="params">self, dog</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%s和%s一起快乐的玩耍&quot;</span>%(self.name, dog.name))</span><br><span class="line">        dog.game()</span><br><span class="line"><span class="comment"># 定义一个狗对象</span></span><br><span class="line"><span class="comment"># wangcai = Dog(&quot;旺财&quot;)</span></span><br><span class="line">wangcai = T_Dog(<span class="string">&quot;飞天旺财&quot;</span>)</span><br><span class="line"><span class="comment"># 定义一个小明对象</span></span><br><span class="line">X_Ming = Person(<span class="string">&quot;小明&quot;</span>)</span><br><span class="line"><span class="comment"># 调用一起玩耍的方法</span></span><br><span class="line">X_Ming.game_with_dog(wangcai)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">小明和飞天旺财一起快乐的玩耍</span><br><span class="line">飞天旺财在天上玩耍</span><br></pre></td></tr></table></figure><h2 id="⛄类属性和类方法"><a href="#⛄类属性和类方法" class="headerlink" title="⛄类属性和类方法"></a>⛄类属性和类方法</h2><h3 id="👀类的结构"><a href="#👀类的结构" class="headerlink" title="👀类的结构"></a>👀类的结构</h3><p>（1）实例</p><p>使用<code>类名()</code>创建对象（分配空间、对象初始化）后，内存中就有了一个对象的实实在在的存在–实例。</p><ul><li>创建出来的<strong>对象</strong>叫做类的<strong>实例</strong>；</li><li>创建对象的<strong>动作</strong>叫做<strong>实例化</strong>；</li><li><strong>对象的属性</strong>叫做<strong>实例属性</strong>；</li><li><strong>对象调用的方法</strong>叫做<strong>实例方法</strong>。</li></ul><p>在程序执行时：</p><ul><li><p>对象各自拥有自己的<strong>实例属性</strong>；</p></li><li><p>调用对象方法，可以通过<code>self.</code></p><ul><li><p>访问自己的属性</p></li><li><p>调用自己的方法</p></li></ul></li></ul><p>结论</p><ul><li>每一个对象都有自己独立的内存空间，保存各自不同的属性；</li><li>多个对象的方法，在内存中只有一份，在调用方法时，需要把对象的引用传递到方法内部。</li></ul><p>（2）类是一个特殊的对象</p><blockquote><p><code>Python</code> 中一切皆对象：</p><ul><li><code>class AAA</code>：定义的类属于<strong>类对象</strong></li><li><code>obj1=AAA()</code> 属于<strong>实例对象</strong></li></ul></blockquote><ul><li><p>在程序运行时，<strong>类</strong>同样会被加载到内存；</p></li><li><p>在<code>Python</code>中，<strong>类</strong>是一个特殊的对象–类对象；</p></li><li><p>在程序运行时，<strong>类对象</strong>在内存中<strong>只有一份</strong>，使用一个类可以<strong>创建出很多个对象实例</strong>；</p></li><li><p>除了封装<strong>实例</strong>的<strong>属性</strong>和<strong>方法</strong>外，<strong>类对象</strong>还可以拥有自己的<strong>属性</strong>和<strong>方法</strong>：</p><ul><li><p>类属性</p></li><li><p>类方法</p></li></ul></li><li><p>通过<code>类名.</code>的方式可以<strong>访问类的属性</strong>或者<strong>调用类的方法</strong>。</p><ul><li><p><code>类名.类属性</code></p></li><li><p><code>类名.方法名()</code></p></li></ul></li></ul><h3 id="👀类属性和实例属性"><a href="#👀类属性和实例属性" class="headerlink" title="👀类属性和实例属性"></a>👀类属性和实例属性</h3><p>（1）概念和使用</p><ul><li><strong>类属性</strong>就是在类对象中定义的属性；</li><li>通常用来记录与这个类相关的<strong>特征</strong>；</li><li><strong>类属性</strong>不会用于记录具体对象的特征。</li></ul><p>（2）属性的获取机制</p><p>在<code>Python</code>中属性的获取存在一个向上查找机制。因此，要访问类属性有两种方式：</p><ul><li><code>类名.类属性</code></li><li><code>对象.类属性</code>(不推荐)，遵循向上查找机制（先在对象内部查找，没有就会向上查找类属性）</li></ul><blockquote><p>注意：如果使用【对象.类属性&#x3D;值赋值语句】，只会给对象添加一个属性，而不会影响到类属性的值。</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Tool</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="comment"># 使用赋值语句,定义类属性,记录创建工具对象的总数</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        <span class="comment"># 计数</span></span><br><span class="line">        Tool.count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建工具对象</span></span><br><span class="line">tool1 = Tool(<span class="string">&quot;钳子&quot;</span>)</span><br><span class="line">tool2 = Tool(<span class="string">&quot;斧头&quot;</span>)</span><br><span class="line">tool3 = Tool(<span class="string">&quot;锤子&quot;</span>)</span><br><span class="line"><span class="comment"># 使用Tool类创建了多少个对象</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;现在创建了%d个工具&quot;</span>% Tool.count)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">现在创建了<span class="number">3</span>个工具</span><br></pre></td></tr></table></figure><h3 id="👀类方法和静态方法"><a href="#👀类方法和静态方法" class="headerlink" title="👀类方法和静态方法"></a>👀类方法和静态方法</h3><p>（1）类方法</p><p><strong>类属性</strong>就是针对<strong>类对象</strong>定义的<strong>属性</strong></p><ul><li>使用赋值语句在<code>class</code>关键字下方可以定义类属性；</li><li>类属性用于记录与这个类相关的特征。</li></ul><p><strong>类方法</strong>就是针对<strong>类对象</strong>定义的<strong>方法</strong></p><ul><li>在<strong>类方法</strong>内部可以直接访问<strong>类属性</strong>或者<strong>调用其他的类方法</strong>。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 语法</span></span><br><span class="line"><span class="meta">@classmethod </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">类方法名</span>(<span class="params">cls</span>):</span><br><span class="line"><span class="keyword">pass</span></span><br></pre></td></tr></table></figure><ul><li><p>类方法需要用<strong>修饰器</strong><code>@classmethod</code>来标识,告诉解释器这是一个类方法。</p></li><li><p>类方法的<strong>第一个参数</strong>应该是<code>cls</code></p><ul><li><p>由<strong>哪一个类</strong>调用的方法，方法内的<code>cls</code>就是<strong>哪一个类的引用</strong>；</p></li><li><p>这个<strong>参数</strong>和<strong>实例方法</strong>的第一个参数是<code>self</code>类似；</p></li><li><p>提示：使用其他名称也可以，不过习惯使用<code>cls</code>。</p></li></ul></li><li><p>通过<code>类名.</code>调用<strong>类方法</strong>，调用方法时，不需要传递<code>cls</code>参数。</p></li><li><p>在方法内部</p><ul><li><p>可以通过<code>c1s.</code><strong>访问类的属性</strong></p></li><li><p>也可以通过<code>c1s.</code><strong>调用其他的类方法</strong></p></li></ul></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Tool</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="comment"># 使用赋值语句,定义类属性,记录创建工具对象的总数</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        <span class="comment"># 计数</span></span><br><span class="line">        Tool.count += <span class="number">1</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">show_tool_count</span>(<span class="params">cls</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;工具对象的总数:%d&quot;</span> % cls.count)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建工具对象</span></span><br><span class="line">tool1 = Tool(<span class="string">&quot;钳子&quot;</span>)</span><br><span class="line">tool2 = Tool(<span class="string">&quot;斧头&quot;</span>)</span><br><span class="line">tool3 = Tool(<span class="string">&quot;锤子&quot;</span>)</span><br><span class="line"><span class="comment"># 使用Tool类创建了多少个对象</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;现在创建了%d个工具&quot;</span>% Tool.count)</span><br><span class="line">Tool.show_tool_count()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">现在创建了<span class="number">3</span>个工具</span><br><span class="line">工具对象的总数:<span class="number">3</span></span><br></pre></td></tr></table></figure><blockquote><p>在类方法内部，可以直接使用<code>cls</code>访问类属性或者调用类方法。</p></blockquote><p>（2）静态方法</p><ul><li><p>在开发时，如果需要在类中封装一个方法，这个方法：</p><ul><li><p>既<strong>不需要</strong>访问<strong>实例属性</strong>或者调用<strong>实例方法</strong></p></li><li><p>也<strong>不需要</strong>访问<strong>类属性</strong>或者调用<strong>类方法</strong></p></li></ul></li><li><p>这个时候，可以把这个方法封装成一个<strong>静态方法</strong>语法如下。</p></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 语法</span></span><br><span class="line"><span class="meta">@staticmethod </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">静态方法名</span>():</span><br><span class="line"><span class="keyword">pass</span></span><br></pre></td></tr></table></figure><ul><li><p>静态方法需要用修饰器<code>@staticmethod</code> 来标识，告诉解释器这是一个静态方法。</p></li><li><p>通过<code>类名.</code>调用静态方法，不需要创建对象。</p></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Game</span>:</span><br><span class="line">    <span class="comment"># 类属性</span></span><br><span class="line">    top_score = <span class="number">100</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 实例属性,在初始化方法内部定义</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,player_name</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.name = player_name</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 静态方法</span></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">show_help</span>():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;帮助信息&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 类方法</span></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">show_top_score</span>(<span class="params">cls</span>):</span><br><span class="line">        <span class="comment"># print(&quot;历史最高分：%d&quot;%Game.top_score)</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;历史最高分：%d&quot;</span>%cls.top_score)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 实例方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">start_game</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%s开始的游戏&quot;</span>%self.name)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 【类名.】</span></span><br><span class="line">Game.show_help()</span><br><span class="line">Game.show_top_score()</span><br><span class="line"><span class="comment"># 创建对象，【对象.】</span></span><br><span class="line">Tom = Game(<span class="string">&quot;小汤&quot;</span>)</span><br><span class="line">Tom.start_game()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">帮助信息</span><br><span class="line">历史最高分：<span class="number">100</span></span><br><span class="line">小汤开始的游戏</span><br></pre></td></tr></table></figure><blockquote><p>小结</p><ol><li>实例方法–方法内部需要访问<strong>实例属性</strong></li><li>实例方法–方法内部可以使用<code>类名.</code>访问<strong>类属性</strong></li><li>类方法–方法内部<strong>只需要</strong>访问<strong>类属性</strong>，或<strong>类方法</strong></li><li>静态方法–方法内部，<strong>不需要访问</strong>实例属性和类属性</li></ol><p>如果方法内部即需要访问实例属性，又需要访问类属性，应该定义成什么方法？(实例方法)</p></blockquote><p>笔者不才，请多交流！！！</p><p>参考文献：黑马程序员《<code>Python</code>入门教程完整版》</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Python基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python小知识点</title>
      <link href="/2022/09/17/Python-Add05/"/>
      <url>/2022/09/17/Python-Add05/</url>
      
        <content type="html"><![CDATA[<h2 id="⛄变量的应用"><a href="#⛄变量的应用" class="headerlink" title="⛄变量的应用"></a>⛄变量的应用</h2><p>变量和数据都是保存在内存中的，在<code>Python</code>中函数的参数传递以及返回值都是通过引用传递的。</p><h3 id="👀引用的概念"><a href="#👀引用的概念" class="headerlink" title="👀引用的概念"></a>👀引用的概念</h3><p>在<code>Python</code>中：</p><ul><li>变量和数据是分开存储的；</li><li>数据保存在内存中的一个位置；</li><li>变量中保存着数据在内存中的地址；</li><li>变量中记录数据的地址，就叫作<strong>引用</strong>；</li><li>使用<strong>id()<strong>函数可以查看变量中保存数据所在的</strong>内存地址</strong>。</li></ul><blockquote><p>注意：如果变量已经被定义，当给一个变量赋值的时候，本质上是修改了数据的引用。</p><ul><li>变量不再对之前的数据引用；</li><li>变量改为对新赋值的数据引用。</li></ul></blockquote><h3 id="👀函数的参数和返回值的传递"><a href="#👀函数的参数和返回值的传递" class="headerlink" title="👀函数的参数和返回值的传递"></a>👀函数的参数和返回值的传递</h3><p>在<code>Python</code>中，函数的实参&#x2F;返回值都是通过引用来传递的。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">mytest</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">50</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;%d 在函数内的内存地址是%x&quot;</span> % (n,<span class="built_in">id</span>(n)))</span><br><span class="line">    </span><br><span class="line">    result = <span class="number">10000</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;返回值%d在函数内的内存地址是%x&quot;</span> % (result,<span class="built_in">id</span>(result)))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">50</span>)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">a = <span class="number">100</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;调用函数前，内存地址是%x&quot;</span> % <span class="built_in">id</span>(a))</span><br><span class="line">r = mytest(a)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;调用函数后，实参内存地址是%x&quot;</span> % <span class="built_in">id</span>(a))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;调用函数前，返回值内存地址是%x&quot;</span> % <span class="built_in">id</span>(r))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">调用函数前，内存地址是7ffd3378adf0</span><br><span class="line">**************************************************</span><br><span class="line"><span class="number">100</span> 在函数内的内存地址是7ffd3378adf0</span><br><span class="line">返回值<span class="number">10000</span>在函数内的内存地址是1cd96276b70</span><br><span class="line">**************************************************</span><br><span class="line">调用函数后，实参内存地址是7ffd3378adf0</span><br><span class="line">调用函数前，返回值内存地址是1cd96276b70</span><br></pre></td></tr></table></figure><h2 id="⛄可变和不可变类型"><a href="#⛄可变和不可变类型" class="headerlink" title="⛄可变和不可变类型"></a>⛄可变和不可变类型</h2><ol><li><p>不可变类型，内存中的数据不允许被修改：</p><ul><li><p>数字类型：<code>int</code>、<code>bool</code>、<code>float</code>、<code>complex</code>、<code>long</code></p></li><li><p>字符串：<code>str</code></p></li><li><p>元组：<code>tuple</code></p></li></ul></li><li><p>可变类型，内存中的数据可以被修改：</p><ul><li><p>列表：<code>list</code></p></li><li><p>字典：<code>dict</code>，字典中的<code>key</code>只能使用不可变类型的数据</p></li></ul></li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">emo_list = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;定义列表后内存地址是%d&quot;</span> % <span class="built_in">id</span>(demo_list))</span><br><span class="line"></span><br><span class="line">demo_list.append(<span class="number">10</span>)</span><br><span class="line">demo_list.remove(<span class="number">1</span>)</span><br><span class="line">demo_list[<span class="number">0</span>] = <span class="number">30</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;修改数据后内存地址是%d&quot;</span> % <span class="built_in">id</span>(demo_list))</span><br><span class="line"></span><br><span class="line">demo_dict = &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;小李子&quot;</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;定义字典后内存地址是%d&quot;</span> % <span class="built_in">id</span>(demo_dict))</span><br><span class="line"></span><br><span class="line">demo_dict[<span class="string">&quot;age&quot;</span>] = <span class="number">20</span></span><br><span class="line">demo_dict[<span class="string">&quot;name&quot;</span>] = <span class="string">&quot;小喜子&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;修改数据后内存地址是%d&quot;</span> % <span class="built_in">id</span>(demo_dict))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">定义列表后内存地址是<span class="number">1982499211272</span></span><br><span class="line">修改数据后内存地址是<span class="number">1982499211272</span></span><br><span class="line">定义字典后内存地址是<span class="number">1982498720808</span></span><br><span class="line">修改数据后内存地址是<span class="number">1982498720808</span></span><br></pre></td></tr></table></figure><p>可变类型的数据变化，是通过方法来实现的；如果给一个可变类型的变量，赋值一个新的数据，引用会修改：</p><ul><li>变量不再对之前的数据引用；</li><li>变量改为对新赋值的数据引用</li></ul><h2 id="⛄局部变量和全局变量"><a href="#⛄局部变量和全局变量" class="headerlink" title="⛄局部变量和全局变量"></a>⛄局部变量和全局变量</h2><p><strong>局部变量</strong>是在<strong>函数内部</strong>定义的变量，只能在函数内部使用；函数执行结束后，函数内部的局部变量，会被系统回收；不同的函数，可以定义相同名字的局部变量，但是彼此之间不会产生影响；</p><p>局部变量的生命周期：</p><ul><li>所谓<strong>生命周期</strong>就是变量从<strong>被创建</strong>到<strong>被系统回收</strong>的过程；</li><li>局部变量在函数执行时才会被创建；</li><li>函数执行结束后，局部变量被系统回收；</li><li>局部变量在生命周期内，可以用来存储函数内部临时使用到的数据。</li></ul><p><strong>全局变量</strong>是在<strong>函数外部</strong>定义的变量，所有函数内部都可以使用这个变量。（不推荐使用，不易维护）</p><blockquote><p>注意：函数执行时，需要处理变量时，会首先查找函数内部是否存在指定名称的局部变量，如果有，直接使用；如果没有，查找函数外部是否存在指定名称的全局变量，如果有，直接使用；如果还没有，程序报错！！！</p><p>注意：如果在函数内部定义了一个与全局变量同名的局部变量，只是变量名相同，不能直接修改全局变量的值。</p></blockquote><p>如果在函数中需要修改全局变量，需要使用<code>global</code>进行声明。</p><h2 id="⛄函数进阶"><a href="#⛄函数进阶" class="headerlink" title="⛄函数进阶"></a>⛄函数进阶</h2><h3 id="👀函数参数和返回值的作用"><a href="#👀函数参数和返回值的作用" class="headerlink" title="👀函数参数和返回值的作用"></a>👀函数参数和返回值的作用</h3><p>定义函数时，是否接收参数，或者是否返回结果，是根据实际的功能需求来确定的。</p><ul><li>如果函数内部处理的数据不确定，就可以将外界的数据以参数传递到函数内部；</li><li>如果希望一个函数执行完成后，向外界汇报执行结果，就可以增加函数的返回值。</li></ul><blockquote><p>如果全局变量的数据类型是一个可变类型，在函数内部可以使用方法修改全局变量的内容，变量的引用不会改变；在函数内部，通过赋值语句才会修改变量的引用。</p></blockquote><h3 id="👀函数的返回值进阶"><a href="#👀函数的返回值进阶" class="headerlink" title="👀函数的返回值进阶"></a>👀函数的返回值进阶</h3><ul><li>程序开发中，希望一个函数执行结束后，告诉调用者一个结果，以便调用者针对具体的结果做后续的处理；</li><li>返回值是函数完成工作后，最后给调用者的一个结果；</li><li>在函数中使用<code>return</code>关键字可以返回结果；</li><li>调用函数一方，可以使用变量来接收函数的返回结果。</li></ul><blockquote><ul><li>注意：如果一个函数执行后返回多个结果，可以利用元组，元祖括号可以省略；</li><li>返回结果也是一个元组，可以将元组返回值赋值给<strong>一个变量</strong>或者<strong>相同个数的多个变量</strong>。</li></ul></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">my_description</span>():</span><br><span class="line">    stu = <span class="string">&quot;00000001&quot;</span></span><br><span class="line">    name = <span class="string">&quot;xiaotang&quot;</span></span><br><span class="line">    age = <span class="number">20</span></span><br><span class="line">    height = <span class="number">180</span></span><br><span class="line">    <span class="comment"># return (stu, name, age, height) 括号可以省略</span></span><br><span class="line">    <span class="keyword">return</span> stu, name, age, height</span><br><span class="line">stu, name, age, height = my_description()</span><br><span class="line"><span class="built_in">print</span>(stu, name, age, height)</span><br><span class="line">my_des = my_description()</span><br><span class="line"><span class="built_in">print</span>(my_des)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">00000001 xiaotang <span class="number">20</span> <span class="number">180</span></span><br><span class="line">(<span class="string">&#x27;00000001&#x27;</span>, <span class="string">&#x27;xiaotang&#x27;</span>, <span class="number">20</span>, <span class="number">180</span>)</span><br></pre></td></tr></table></figure><p>例如：利用元组交换两个数字</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">10</span></span><br><span class="line">b = <span class="number">5</span></span><br><span class="line"><span class="comment"># (1)使用中间变量</span></span><br><span class="line">c = b</span><br><span class="line">b = a</span><br><span class="line">a = c</span><br><span class="line"><span class="built_in">print</span>(a, b)</span><br><span class="line"><span class="comment"># (2)不使用中间变量</span></span><br><span class="line">a = <span class="number">10</span></span><br><span class="line">b = <span class="number">5</span></span><br><span class="line">a = a + b</span><br><span class="line">b = a - b</span><br><span class="line">a = a - b</span><br><span class="line"><span class="built_in">print</span>(a, b)</span><br><span class="line">a = <span class="number">10</span></span><br><span class="line">b = <span class="number">5</span></span><br><span class="line"><span class="comment"># 利用元祖</span></span><br><span class="line">a, b = b, a</span><br><span class="line"><span class="built_in">print</span>(a, b)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="number">5</span> <span class="number">10</span></span><br><span class="line"><span class="number">5</span> <span class="number">10</span></span><br><span class="line"><span class="number">5</span> <span class="number">10</span></span><br></pre></td></tr></table></figure><h3 id="👀函数的参数进阶"><a href="#👀函数的参数进阶" class="headerlink" title="👀函数的参数进阶"></a>👀函数的参数进阶</h3><h4 id="（1）不可变和可变的参数"><a href="#（1）不可变和可变的参数" class="headerlink" title="（1）不可变和可变的参数"></a><strong>（1）不可变和可变的参数</strong></h4><p>在函数内部，针对参数使用赋值语句，不会影响调用函数时传递的实参变量。</p><ul><li>无论传递的参数是可变还是不可变，只要针对参数使用<strong>赋值语句</strong>，会在函数内部<strong>修改</strong>局部变量的引用，<strong>不会影响</strong>到外部变量的引用。</li><li>如果传递的参数是<strong>可变类型</strong>，在函数内部，使用<strong>方法</strong>修改了数据的内容，同样<strong>会影响</strong>到外部的数据。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">demo1</span>(<span class="params">num, num_list</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;函数内部&quot;</span>)</span><br><span class="line">    <span class="comment"># 赋值语句</span></span><br><span class="line">    num = <span class="number">200</span></span><br><span class="line">    num_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">    <span class="built_in">print</span>(num)</span><br><span class="line">    <span class="built_in">print</span>(num_list)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;函数执行完成&quot;</span>)</span><br><span class="line"></span><br><span class="line">gl_num = <span class="number">99</span></span><br><span class="line">gl_list = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">demo1(gl_num, gl_list)</span><br><span class="line"><span class="built_in">print</span>(gl_num)</span><br><span class="line"><span class="built_in">print</span>(gl_list)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">50</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">demo2</span>(<span class="params">num_list</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;函数内部&quot;</span>)</span><br><span class="line">    <span class="comment"># 赋值语句</span></span><br><span class="line">    num_list.extend([<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>])</span><br><span class="line">    <span class="built_in">print</span>(num_list)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;函数执行完成&quot;</span>)</span><br><span class="line"></span><br><span class="line">gl_list = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">demo2(gl_list)</span><br><span class="line"><span class="built_in">print</span>(gl_list)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">函数内部</span><br><span class="line"><span class="number">200</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">函数执行完成</span><br><span class="line"><span class="number">99</span></span><br><span class="line">[<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">**************************************************</span><br><span class="line">函数内部</span><br><span class="line">[<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br><span class="line">函数执行完成</span><br><span class="line">[<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br></pre></td></tr></table></figure><p>在<code>Python</code>中，列表变量调用<code>+=</code>本质上是在执行列表变量的<code>extend()</code>方法，不会修改变量的引用。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">demo3</span>(<span class="params">num, num_list</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;函数内部&quot;</span>)</span><br><span class="line">    <span class="comment"># 赋值语句</span></span><br><span class="line">    num = <span class="number">200</span></span><br><span class="line">    num_list += [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">    <span class="built_in">print</span>(num)</span><br><span class="line">    <span class="built_in">print</span>(num_list)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;函数执行完成&quot;</span>)</span><br><span class="line"></span><br><span class="line">gl_num = <span class="number">99</span></span><br><span class="line">gl_list = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">demo3(gl_num, gl_list)</span><br><span class="line"><span class="built_in">print</span>(gl_num)</span><br><span class="line"><span class="built_in">print</span>(gl_list)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">函数内部</span><br><span class="line"><span class="number">200</span></span><br><span class="line">[<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">函数执行完成</span><br><span class="line"><span class="number">99</span></span><br><span class="line">[<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure><h4 id="（2）缺省参数"><a href="#（2）缺省参数" class="headerlink" title="（2）缺省参数"></a><strong>（2）缺省参数</strong></h4><ul><li>定义函数时，可以给某个参数指定一个默认值，具有默认值的参数就叫做<strong>缺省参数</strong>；</li><li>调用函数时，如果没有传入<strong>缺省参数</strong>的值，则在函数内部使用定义函数时指定的<strong>参数默认值</strong>；</li><li>函数的缺省参数，将<strong>常见的值</strong>设置为参数的缺省值，从而简化函数的调用。</li></ul><p>例如：对列表排序的方法</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">num_list = [<span class="number">6</span>, <span class="number">4</span>, <span class="number">8</span>]</span><br><span class="line"><span class="comment"># 默认就是升序排序,因为这种应用需求更多</span></span><br><span class="line">num_list.sort()</span><br><span class="line"><span class="built_in">print</span>(num_list)</span><br><span class="line"><span class="comment"># 当需要降序排序时, 才需要传递&quot;reverse&quot;参数</span></span><br><span class="line">num_list.sort(reverse=<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(num_list)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[<span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>]</span><br><span class="line">[<span class="number">8</span>, <span class="number">6</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure><p>缺省参数的注意事项：</p><ul><li>缺省参数的定义位置，必须保证带有默认值的缺省参数在参数列表<strong>末尾</strong>；</li><li>调用带有多个缺省参数的函数，需要<strong>指定参数名</strong>，这样解释器才能知道对应关系。</li></ul><h4 id="（3）多值参数"><a href="#（3）多值参数" class="headerlink" title="（3）多值参数"></a><strong>（3）多值参数</strong></h4><ul><li><p>有时可能需要一个函数能够处理的<strong>参数个数是不确定的</strong>，这个时候，就可以使用<strong>多值参数</strong>。</p></li><li><p><code>python</code> 中有<strong>两种</strong>多值参数：</p><ul><li><p>参数名前增加<strong>一个</strong><code>*</code>，可以接收<strong>元组</strong></p></li><li><p>参数名前增加<strong>两个</strong><code>*</code>，可以接收<strong>字典</strong></p></li></ul></li><li><p>一般在给多值参数命名时，习惯使用以下两个名字</p><ul><li><p><code>*args</code>——存放<strong>元组</strong>参数，前面有<strong>一个</strong><code>*</code></p></li><li><p><code>**Kwargs</code>——存放<strong>字典</strong>参数，前面有<strong>两个</strong><code>*</code></p></li></ul></li><li><p><code>args</code>是<code>arguments</code>的缩写，有变量的含义</p></li><li><p><code>kw</code>是<code>keyword</code>的缩写，<code>kwargs</code> 可以记忆键值对参数</p></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">demo4</span>(<span class="params">num, *args, **kwargs</span>):</span><br><span class="line">    <span class="built_in">print</span>(num)</span><br><span class="line">    <span class="built_in">print</span>(args)</span><br><span class="line">    <span class="built_in">print</span>(kwargs)</span><br><span class="line">demo4(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, name=<span class="string">&quot;小明&quot;</span>, age=<span class="number">18</span>, gender=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line">(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;小明&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">18</span>, <span class="string">&#x27;gender&#x27;</span>: <span class="literal">True</span>&#125;</span><br></pre></td></tr></table></figure><h4 id="（4）元组和字典的拆包（了解）"><a href="#（4）元组和字典的拆包（了解）" class="headerlink" title="（4）元组和字典的拆包（了解）"></a><strong>（4）元组和字典的拆包（了解）</strong></h4><ul><li><p>在调用带有多值参数的函数时，如果希望：</p><ul><li><p>将一个<strong>元组</strong>变量，直接传递给<code>args</code></p></li><li><p>将一个<strong>字典</strong>变量，直接传递给<code>kwargs</code></p></li></ul></li><li><p>可以使用拆包，简化参数的传递，<strong>拆包</strong>的方式是：</p><ul><li><p>在<strong>元组</strong>变量前，增加<strong>一个</strong><code>*</code></p></li><li><p>在<strong>字典</strong>变量前，增加<strong>两个</strong><code>*</code></p></li></ul></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">demo5</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">    <span class="built_in">print</span>(args)</span><br><span class="line">    <span class="built_in">print</span>(kwargs)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 需要将一个元组变量/字典变量传递给函数对应的参数</span></span><br><span class="line">num = (<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line">dict_name = &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;小汤&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">20</span>&#125;</span><br><span class="line"><span class="comment"># 会把num, dict_name作为元组传递给args</span></span><br><span class="line">demo5(num, dict_name)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">50</span>)</span><br><span class="line"><span class="comment"># 元组和字典的拆包</span></span><br><span class="line">demo5(*num, **dict_name)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">((<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>), &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;小汤&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">20</span>&#125;)</span><br><span class="line">&#123;&#125;</span><br><span class="line">**************************************************</span><br><span class="line">(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line">&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;小汤&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">20</span>&#125;</span><br></pre></td></tr></table></figure><h3 id="👀递归函数"><a href="#👀递归函数" class="headerlink" title="👀递归函数"></a>👀递归函数</h3><p><strong>函数内部调用自己</strong>。函数内部可以调用其他函数，当然在函数内部也可以调用自己。</p><p>代码特点：</p><ul><li>函数内部的代码是相同的，只是针对参数不同，处理的结果不同</li><li>当参数满足一个条件时，函数不再执行。这个非常重要，通常被称为递归的出口，否则会出现死循环！</li></ul><p>例如：计算数字累加</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sum_number</span>(<span class="params">num</span>):</span><br><span class="line">    <span class="keyword">if</span> num == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    temp = sum_number(num - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> num + temp</span><br><span class="line"><span class="built_in">print</span>(sum_number(<span class="number">10</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="number">55</span></span><br></pre></td></tr></table></figure><p>笔者不才，请多交流！！！</p><p>参考文献：黑马程序员《Python入门教程完整版》</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Python基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python中的正则表达式详解</title>
      <link href="/2022/09/11/re/"/>
      <url>/2022/09/11/re/</url>
      
        <content type="html"><![CDATA[<h2 id="⛄正则表达式概述"><a href="#⛄正则表达式概述" class="headerlink" title="⛄正则表达式概述"></a>⛄正则表达式概述</h2><p>正则表达式（<code>Regular Expression</code>）是强大、便捷、高效的文本处理工具。正则表达式本身，加上如同一门袖珍编程语言的通用模式表示法（<code>general pattern notation</code>），赋予使用者描述和分析文本的能力。配合上特定工具提供的额外支持，正则表达式能够添加、删除、分离、叠加、插入和修整各种类型的文本和数据。</p><p>正则表达式使用单个字符串来描述、匹配一系列匹配某个句法规则的字符串。正则表达式是繁琐的，但它是强大的，学会之后的应用会让你除了提高效率外，会给你带来绝对的成就感。正则表达式的使用难度只相当于文本编辑器的搜索命令，但功能却与完整的文本处理语言一样强大。正则表达式的特点是：</p><ul><li>灵活性、逻辑性和功能性非常强；</li><li>可以迅速地用极简单的方式达到字符串的复杂控制；</li><li>对于刚接触的人来说，比较晦涩难懂。</li></ul><h2 id="⛄RE语法中特殊元素"><a href="#⛄RE语法中特殊元素" class="headerlink" title="⛄RE语法中特殊元素"></a>⛄<code>RE</code>语法中特殊元素</h2><h3 id="👀-匹配所有字符"><a href="#👀-匹配所有字符" class="headerlink" title="👀.匹配所有字符"></a>👀<code>.</code>匹配所有字符</h3><p><code>.</code>表示要匹配除了换行符之外的<strong>任何单个字符</strong>。其中点代表了任意的一个字符，注意是一个字符。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="built_in">str</span> = re.<span class="built_in">compile</span>(<span class="string">r&quot;.&quot;</span>).findall(<span class="string">&quot;xiaotangsmile&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[<span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;t&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;n&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;s&#x27;</span>, <span class="string">&#x27;m&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;e&#x27;</span>]</span><br></pre></td></tr></table></figure><h3 id="👀-重复匹配任意次"><a href="#👀-重复匹配任意次" class="headerlink" title="👀*重复匹配任意次"></a>👀<code>*</code>重复匹配任意次</h3><p><code>*</code> 表示匹配前面的子表达式<strong>任意次</strong>，包括<strong>0</strong>次。</p><blockquote><p>注意， .* 在正则表达式中非常常见，表示匹配任意字符任意次数。当然这个 * 前面不是非得是点，也可以是其它字符。</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">str1 = re.<span class="built_in">compile</span>(<span class="string">r&quot;ia*&quot;</span>).findall(<span class="string">&quot;xiaaaaaaaotangsmile&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(str1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[<span class="string">&#x27;iaaaaaaa&#x27;</span>, <span class="string">&#x27;i&#x27;</span>]</span><br></pre></td></tr></table></figure><h3 id="👀-重复匹配多次"><a href="#👀-重复匹配多次" class="headerlink" title="👀+重复匹配多次"></a>👀<code>+</code>重复匹配多次</h3><p><code>+</code>表示匹配前面的子表达式一次或多次，不包括0次。即：表示至少匹配1次</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">str2 = re.<span class="built_in">compile</span>(<span class="string">r&quot;ia+&quot;</span>).findall(<span class="string">&quot;xiaaaaaaaotangsmile&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(str2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[<span class="string">&#x27;iaaaaaaa&#x27;</span>]</span><br></pre></td></tr></table></figure><h3 id="👀-匹配0-1次"><a href="#👀-匹配0-1次" class="headerlink" title="👀?匹配0-1次"></a>👀<code>?</code>匹配0-1次</h3><p><code>?</code> 表示匹配前面的子表达式0次或1次。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">str3 = re.<span class="built_in">compile</span>(<span class="string">r&quot;ia?&quot;</span>).findall(<span class="string">&quot;xiaaaaaaaotangsmile&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(str3)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[<span class="string">&#x27;ia&#x27;</span>, <span class="string">&#x27;i&#x27;</span>]</span><br></pre></td></tr></table></figure><h3 id="👀-匹配指定次数"><a href="#👀-匹配指定次数" class="headerlink" title="👀{}匹配指定次数"></a>👀<code>&#123;&#125;</code>匹配指定次数</h3><p><code>&#123;&#125;</code>花括号表示前面的字符匹配 指定的次数。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">str4 = re.<span class="built_in">compile</span>(<span class="string">r&quot;ia&#123;2,5&#125;&quot;</span>).findall(<span class="string">&quot;xiaaaaaaaotangsmile&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(str4)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[<span class="string">&#x27;iaaaaa&#x27;</span>]</span><br></pre></td></tr></table></figure><h3 id="👀-匹配几个字符之一"><a href="#👀-匹配几个字符之一" class="headerlink" title="👀[]匹配几个字符之一"></a>👀<code>[]</code>匹配几个字符之一</h3><p><code>[]</code>方括号表示要匹配指定的几个字符之一。比如：</p><ul><li>[abc] 可以匹配 a, b, 或者c里面的任意一个字符，等价于 [a-c]；</li><li>[a-c] 中间的 -表示一个范围从a到c；</li><li>如果你想匹配所有的小写字母，可以使用[a-z]；</li></ul><ol><li>一些元字符在方括号内失去了本意，变得和普通字符一样了。例如：[evol.] 匹配 <code>evol.</code> 里面任意一个字符，这里 <code>.</code> 在括号里面不在表示匹配任意字符了，而就是表示匹配 <code>.</code> 这个字符。</li><li>如果在方括号中使用<code>^</code>，表示非方括号里面的字符集合。例如：<code>[^\d]</code>表示，选择非数字的字符。</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">str5 = re.<span class="built_in">compile</span>(<span class="string">r&quot;i[a-z]&quot;</span>).findall(<span class="string">&quot;xiaaaaaaaotangsmile&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(str5)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[<span class="string">&#x27;ia&#x27;</span>, <span class="string">&#x27;il&#x27;</span>]</span><br></pre></td></tr></table></figure><h3 id="👀贪婪模式和贪婪模式"><a href="#👀贪婪模式和贪婪模式" class="headerlink" title="👀贪婪模式和贪婪模式"></a>👀贪婪模式和贪婪模式</h3><p>在正则表达式中， ‘<code>*</code>‘, ‘<code>+</code>‘, ‘<code>?</code>‘ 都是贪婪地，使用他们时，会尽可能多的匹配内容。</p><p>解决这个问题，就需要使用非贪婪模式，也就是在星号后面加上<code>?</code> ，变成这样<code>&lt;.*?&gt;</code></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">str6 = re.<span class="built_in">compile</span>(<span class="string">r&quot;&lt;.*&gt;&quot;</span>).findall(<span class="string">&quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;Title&lt;/title&gt;&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(str6)</span><br><span class="line">str7 = re.<span class="built_in">compile</span>(<span class="string">r&quot;&lt;.*?&gt;&quot;</span>).findall(<span class="string">&quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;Title&lt;/title&gt;&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(str7)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[<span class="string">&#x27;&lt;html&gt;&lt;head&gt;&lt;title&gt;Title&lt;/title&gt;&#x27;</span>]</span><br><span class="line">[<span class="string">&#x27;&lt;html&gt;&#x27;</span>, <span class="string">&#x27;&lt;head&gt;&#x27;</span>, <span class="string">&#x27;&lt;title&gt;&#x27;</span>, <span class="string">&#x27;&lt;/title&gt;&#x27;</span>]</span><br></pre></td></tr></table></figure><h3 id="👀元字符转义"><a href="#👀元字符转义" class="headerlink" title="👀元字符转义"></a>👀元字符转义</h3><p>反斜杠 <code>\</code> 在正则表达式中有多种用途。</p><p>如果，我们这样写正则表达式 <code>.*.</code> ，聪明的你肯定发现不对劲。因为点是一个元字符，直接出现在正则表达式中，表示匹配任意的单个字符，不能表示<code>.</code>这个字符本身的意思了。</p><blockquote><p>怎么办呢？如果我们要搜索的内容本身就包含元字符，就可以使用<strong>反斜杠</strong>进行转义。这里我们就应用使用这样的表达式： <code>.*\.</code></p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">str8 = re.<span class="built_in">compile</span>(<span class="string">r&quot;[a-zA-Z0-9]*@[1-9]&#123;3&#125;\.com&quot;</span>).findall(<span class="string">&quot;xiao@163.cn,tangsmile@126.com&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(str8)</span><br><span class="line">str9 = re.<span class="built_in">compile</span>(<span class="string">r&quot;[\w]*@[1-9]&#123;3&#125;\.com&quot;</span>).findall(<span class="string">&quot;xiaoxiao@163.cn,tangsmile@126.com&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(str9)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[<span class="string">&#x27;tangsmile@126.com&#x27;</span>]</span><br><span class="line">[<span class="string">&#x27;tangsmile@126.com&#x27;</span>]</span><br></pre></td></tr></table></figure><h3 id="👀特殊字符类"><a href="#👀特殊字符类" class="headerlink" title="👀特殊字符类"></a>👀特殊字符类</h3><p>反斜杠后面接一些字符，表示匹配某种类型的一个字符。</p><table><thead><tr><th><strong>实例</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><code>\d</code></td><td>匹配任意一个数字字符。等价于[<code>0-9]</code>。</td></tr><tr><td><code>\D</code></td><td>匹配任意一个非数字字符。等价于[<code>^0-9</code>]。</td></tr><tr><td><code>\s</code></td><td>匹配任意一个空白字符，包括空格、制表符、换页符等等。等价于[<code>\f\n\r\t\v</code>]。</td></tr><tr><td><code>\S</code></td><td>匹配任意一个非空白字符。等价于[<code>^\f\n\r\t\v</code>]。</td></tr><tr><td><code>\w</code></td><td>匹配任意一个文字字符，包括大小写字母、数字、下划线。等价于[<code>A-Za-z0-9_</code>]。</td></tr><tr><td><code>\W</code></td><td>匹配任意一个非文字字符。等价于[<code>^A-Za-z0-9_</code>]。</td></tr></tbody></table><p>反斜杠也可以用在方括号里面，例如： [<code>\s,.</code>] 表示匹配 任何空白字符，或者逗号，或者点。</p><h3 id="👀起始、结尾位置和单-x2F-行模式"><a href="#👀起始、结尾位置和单-x2F-行模式" class="headerlink" title="👀起始、结尾位置和单&#x2F;行模式"></a>👀起始、结尾位置和单&#x2F;行模式</h3><p><code>^</code> 在方括号里面表示非；除此之外，<code>^</code>表示匹配文本的开头位置。</p><p>正则表达式可以设定单行模式和多行模式</p><ul><li>如果是单行模式，表示匹配整个文本的开头位置。</li><li>如果是多行模式，表示匹配文本每行的开头位置。</li></ul><p><code>$</code> 表示匹配文本的 结尾 位置。</p><ul><li>如果是单行模式，表示匹配整个文本的结尾位置。</li><li>如果是多行模式，表示匹配文本每行的结尾位置。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">content = <span class="string">&#x27;&#x27;&#x27;001-小汤-99</span></span><br><span class="line"><span class="string">002-小明-98</span></span><br><span class="line"><span class="string">003-小红-97&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># 注意，compile 的第二个参数 re.M ，指明了使用多行模式，</span></span><br><span class="line">str10 = re.<span class="built_in">compile</span>(<span class="string">r&#x27;^\d+&#x27;</span>, re.M).findall(content)</span><br><span class="line"><span class="built_in">print</span>(str10)</span><br><span class="line">str11 = re.<span class="built_in">compile</span>(<span class="string">r&#x27;^\d+&#x27;</span>).findall(content)</span><br><span class="line"><span class="built_in">print</span>(str11)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[<span class="string">&#x27;001&#x27;</span>, <span class="string">&#x27;002&#x27;</span>, <span class="string">&#x27;003&#x27;</span>]</span><br><span class="line">[<span class="string">&#x27;001&#x27;</span>]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">content = <span class="string">&#x27;&#x27;&#x27;001-小汤-99</span></span><br><span class="line"><span class="string">002-小明-98</span></span><br><span class="line"><span class="string">003-小红-97&#x27;&#x27;&#x27;</span></span><br><span class="line">str12 = re.<span class="built_in">compile</span>(<span class="string">r&#x27;\d+$&#x27;</span>, re.M).findall(content)</span><br><span class="line"><span class="built_in">print</span>(str12)</span><br><span class="line">str13 = re.<span class="built_in">compile</span>(<span class="string">r&#x27;\d+$&#x27;</span>).findall(content)</span><br><span class="line"><span class="built_in">print</span>(str13)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[<span class="string">&#x27;99&#x27;</span>, <span class="string">&#x27;98&#x27;</span>, <span class="string">&#x27;97&#x27;</span>]</span><br><span class="line">[<span class="string">&#x27;97&#x27;</span>]</span><br></pre></td></tr></table></figure><h3 id="👀-竖线"><a href="#👀-竖线" class="headerlink" title="👀|竖线"></a>👀<code>|</code>竖线</h3><p>竖线表示<strong>匹配其中之一</strong> 。特别要注意的是，竖线在正则表达式的优先级是最低的，这就意味着，竖线隔开的部分是一个整体。</p><p>比如，小明|王 表示要匹配：<strong>小明</strong>或者<strong>王</strong> ，而不是 <strong>小明</strong> 或者 <strong>小王</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">str14 = re.<span class="built_in">compile</span>(<span class="string">r&#x27;小汤|明|红|王&#x27;</span>).findall(<span class="string">&quot;小汤小明小红小王&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(str14)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[<span class="string">&#x27;小汤&#x27;</span>, <span class="string">&#x27;明&#x27;</span>, <span class="string">&#x27;红&#x27;</span>, <span class="string">&#x27;王&#x27;</span>]</span><br></pre></td></tr></table></figure><h3 id="👀-括号"><a href="#👀-括号" class="headerlink" title="👀()括号"></a>👀<code>()</code>括号</h3><p>括号称之为正则表达式的组选择。组就是把正则表达式匹配的内容里面 中的某些部分标记为某个组。我们可以在 正则表达式中标记多个组。</p><blockquote><p>为什么要有组的概念呢？因为我们往往需要提取已经匹配的内容里面的某些部分。</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">content = <span class="string">&#x27;&#x27;&#x27;001小汤,你最棒</span></span><br><span class="line"><span class="string">002小明,你更棒</span></span><br><span class="line"><span class="string">003小红,你较棒&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># 输出包含逗号</span></span><br><span class="line">str15 = re.<span class="built_in">compile</span>(<span class="string">r&#x27;^.*,&#x27;</span>).findall(content)</span><br><span class="line"><span class="built_in">print</span>(str15)</span><br><span class="line"><span class="comment"># 输出不包含逗号</span></span><br><span class="line">str16 = re.<span class="built_in">compile</span>(<span class="string">r&#x27;^(.*),&#x27;</span>).findall(content)</span><br><span class="line"><span class="built_in">print</span>(str16)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[<span class="string">&#x27;001小汤,&#x27;</span>]</span><br><span class="line">[<span class="string">&#x27;001小汤&#x27;</span>]</span><br></pre></td></tr></table></figure><h3 id="👀点匹配换行符"><a href="#👀点匹配换行符" class="headerlink" title="👀点匹配换行符"></a>👀点匹配换行符</h3><p>点是不匹配换行符的，可是有时候，特征字符串就是跨行的，比如要找出下面文字中所有的职位名称。</p><p>设置点也匹配换行符：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用re.S和re.DOTALL匹配出来的内容都是一样的,都表示包括换行符内容的匹配</span></span><br><span class="line"><span class="comment"># re.DOTALL</span></span><br><span class="line"><span class="comment"># re.S</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line">content = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">&lt;div class=&quot;el&quot;&gt;</span></span><br><span class="line"><span class="string">        &lt;p class=&quot;t1&quot;&gt;           </span></span><br><span class="line"><span class="string">            &lt;span&gt;</span></span><br><span class="line"><span class="string">                &lt;a&gt;Python开发工程师&lt;/a&gt;</span></span><br><span class="line"><span class="string">            &lt;/span&gt;</span></span><br><span class="line"><span class="string">        &lt;/p&gt;</span></span><br><span class="line"><span class="string">        &lt;span class=&quot;t2&quot;&gt;南京&lt;/span&gt;</span></span><br><span class="line"><span class="string">        &lt;span class=&quot;t3&quot;&gt;1.5-2万/月&lt;/span&gt;</span></span><br><span class="line"><span class="string">&lt;/div&gt;</span></span><br><span class="line"><span class="string">&lt;div class=&quot;el&quot;&gt;</span></span><br><span class="line"><span class="string">        &lt;p class=&quot;t1&quot;&gt;</span></span><br><span class="line"><span class="string">            &lt;span&gt;</span></span><br><span class="line"><span class="string">                &lt;a&gt;java开发工程师&lt;/a&gt;</span></span><br><span class="line"><span class="string">            &lt;/span&gt;</span></span><br><span class="line"><span class="string">&lt;/p&gt;</span></span><br><span class="line"><span class="string">        &lt;span class=&quot;t2&quot;&gt;苏州&lt;/span&gt;</span></span><br><span class="line"><span class="string">        &lt;span class=&quot;t3&quot;&gt;1.5-2/月&lt;/span&gt;</span></span><br><span class="line"><span class="string">&lt;/div&gt;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">str16 = re.<span class="built_in">compile</span>(<span class="string">r&#x27;class=\&quot;t1\&quot;&gt;.*?&lt;a&gt;(.*?)&lt;/a&gt;&#x27;</span>, re.S).findall(content)</span><br><span class="line"><span class="built_in">print</span>(str16)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[<span class="string">&#x27;Python开发工程师&#x27;</span>, <span class="string">&#x27;java开发工程师&#x27;</span>]</span><br></pre></td></tr></table></figure><h2 id="⛄常用的函数"><a href="#⛄常用的函数" class="headerlink" title="⛄常用的函数"></a>⛄常用的函数</h2><p><code>re</code>模块使<code>Python</code>语言拥有全部的正则表达式功能。</p><ul><li><code>compile()</code>函数根据一个模式字符串和可选的标志参数生成一个正则表达式对象,该对象拥有一系列方法用于正则表达式匹配和替换。</li><li><code>re</code> 模块也提供了与这些方法功能完全一致的函数，这些函数使用一个模式字符串做为它们的第一个参数。</li></ul><h3 id="👀re-match"><a href="#👀re-match" class="headerlink" title="👀re.match()"></a>👀re.match()</h3><p><code>re.match()</code>尝试从字符串的<strong>起始位置匹配一个模式</strong>，如果不是起始位置匹配成功的话，就返回<code>none</code>。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 函数语法</span></span><br><span class="line">re.match(pattern, string, flags=<span class="number">0</span>)</span><br><span class="line"><span class="comment"># 参数</span></span><br><span class="line">pattern 匹配的正则表达式</span><br><span class="line">string  要匹配的字符串。</span><br><span class="line">flags 标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等。</span><br></pre></td></tr></table></figure><p>匹配成功&#96;&#96;re.match()<code>方法**返回一个匹配的</code>Match<code>对象**，而不是匹配的正则表达式，否则返回</code>None<code>。通过</code>span()<code>可以获取匹配的位置，使用</code>group(num)<code>或</code>groups()&#96; 匹配对象函数来获取匹配表达式。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="comment"># 在起始位置匹配</span></span><br><span class="line"><span class="built_in">print</span>(re.match(<span class="string">&#x27;www&#x27;</span>, <span class="string">&#x27;www.runoob.com&#x27;</span>).span())</span><br><span class="line"><span class="comment"># 不在起始位置匹配</span></span><br><span class="line"><span class="built_in">print</span>(re.match(<span class="string">&#x27;com&#x27;</span>, <span class="string">&#x27;www.runoob.com&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">(<span class="number">0</span>, <span class="number">3</span>)</span><br><span class="line"><span class="literal">None</span></span><br></pre></td></tr></table></figure><h3 id="👀re-search"><a href="#👀re-search" class="headerlink" title="👀re,search()"></a>👀re,search()</h3><p><code>re.search()</code>扫描<strong>整个字符串并返回第一个成功的匹配</strong>。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 函数语法</span></span><br><span class="line">re.search(pattern, string, flags=<span class="number">0</span>)</span><br><span class="line"><span class="comment"># 参数</span></span><br><span class="line">pattern 匹配的正则表达式</span><br><span class="line">string  要匹配的字符串。</span><br><span class="line">flags 标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等。</span><br></pre></td></tr></table></figure><p>匹配成功<code>re.search()</code>方法<strong>返回一个匹配的<code>Match</code>对象</strong>，而不是匹配的正则表达式，否则返回<code>None</code>。通过<code>span()</code>可以获取匹配的位置，使用<code>group(num)</code> 或<code>groups()</code> 匹配对象函数来获取匹配表达式。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="comment"># 在起始位置匹配</span></span><br><span class="line"><span class="built_in">print</span>(re.search(<span class="string">&#x27;www&#x27;</span>, <span class="string">&#x27;www.runoob.com&#x27;</span>).span())</span><br><span class="line"><span class="comment"># 不在起始位置匹配</span></span><br><span class="line"><span class="built_in">print</span>(re.search(<span class="string">&#x27;com&#x27;</span>, <span class="string">&#x27;www.runoob.com&#x27;</span>).span())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">(<span class="number">0</span>, <span class="number">3</span>)</span><br><span class="line">(<span class="number">11</span>, <span class="number">14</span>)</span><br></pre></td></tr></table></figure><blockquote><p><code>re.match()</code>只匹配字符串的开始，如果字符串开始不符合正则表达式，则匹配失败，函数返回 <code>None</code>，而<code>re.search()</code>匹配整个字符串，直到找到一个匹配。</p></blockquote><h3 id="👀re-sub-检索和替换"><a href="#👀re-sub-检索和替换" class="headerlink" title="👀re.sub()检索和替换"></a>👀re.sub()检索和替换</h3><p><code>Python</code>的<code>re</code>模块提供了<code>re.sub()</code>用于替换字符串中的匹配项。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 函数语法：</span></span><br><span class="line">re.sub(pattern, repl, string, count=<span class="number">0</span>, flags=<span class="number">0</span>)</span><br><span class="line"><span class="comment"># 参数</span></span><br><span class="line">pattern: 正则中的模式字符串。</span><br><span class="line">repl: 替换的字符串，也可为一个函数。</span><br><span class="line">string: 要被查找替换的原始字符串。</span><br><span class="line">count: 模式匹配后替换的最大次数，默认<span class="number">0</span>表示替换所有的匹配。</span><br><span class="line">flags: 编译时用的匹配模式，数字形式。</span><br><span class="line"></span><br><span class="line"><span class="comment"># 前三个为必选参数，后两个为可选参数；返回替换后的字符串。</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re </span><br><span class="line">phone = <span class="string">&quot;2004-959-559 # 这是一个电话号码&quot;</span> </span><br><span class="line"><span class="comment"># 删除注释 </span></span><br><span class="line">num = re.sub(<span class="string">r&#x27;#.*$&#x27;</span>, <span class="string">&quot;&quot;</span>, phone) </span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;电话号码 : &quot;</span>, num) </span><br><span class="line"><span class="comment"># 移除非数字的内容 </span></span><br><span class="line">num = re.sub(<span class="string">r&#x27;\D&#x27;</span>, <span class="string">&quot;&quot;</span>, phone) </span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;电话号码 : &quot;</span>, num)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">电话号码 :  <span class="number">2004</span>-<span class="number">959</span>-<span class="number">559</span> </span><br><span class="line">电话号码 :  <span class="number">2004959559</span></span><br></pre></td></tr></table></figure><h3 id="👀compile"><a href="#👀compile" class="headerlink" title="👀compile()"></a>👀compile()</h3><p><code>compile()</code>函数用于编译正则表达式，生成一个正则表达式（<code>Pattern</code>）对象，供<code>match()</code>和 <code>search()</code>这两个函数使用。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 语法格式</span></span><br><span class="line">re.<span class="built_in">compile</span>(pattern[, flags])</span><br><span class="line"><span class="comment"># 参数</span></span><br><span class="line">pattern: 一个字符串形式的正则表达式</span><br><span class="line">flags: 可选，表示匹配模式，比如忽略大小写，多行模式等，具体参数为：</span><br><span class="line">re.I 忽略大小写</span><br><span class="line">re.L 表示特殊字符集\w,\W,\b,\B,\s,\S依赖于当前环境</span><br><span class="line">re.M 多行模式</span><br><span class="line">re.S 即为<span class="string">&#x27;.&#x27;</span>匹配包括换行符在内的任意字符（<span class="string">&#x27;.&#x27;</span>不包括换行符）</span><br><span class="line">re.U 表示特殊字符集\w,\W,\b,\B,\d,\D,\s,\S依赖于Unicode字符属性数据库</span><br><span class="line">re.X 为了增加可读性，忽略空格和<span class="string">&#x27; # &#x27;</span>后面的注释</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pattern = re.<span class="built_in">compile</span>(<span class="string">r&#x27;([a-z]+) ([a-z]+)&#x27;</span>, re.I) <span class="comment"># re.I表示忽略大小写 </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m = pattern.match(<span class="string">&#x27;Hello World Wide Web&#x27;</span>) </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>( m ) <span class="comment"># 匹配成功，返回一个 Match 对象 </span></span><br><span class="line">&lt;_sre.SRE_Match <span class="built_in">object</span> at <span class="number">0x10bea83e8</span>&gt; </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m.group(<span class="number">0</span>) <span class="comment"># 返回匹配成功的整个子串 </span></span><br><span class="line"><span class="string">&#x27;Hello World&#x27;</span> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m.span(<span class="number">0</span>)  <span class="comment"># 返回匹配成功的整个子串的索引 </span></span><br><span class="line">(<span class="number">0</span>, <span class="number">11</span>) </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m.group(<span class="number">1</span>) <span class="comment"># 返回第一个分组匹配成功的子串 </span></span><br><span class="line"><span class="string">&#x27;Hello&#x27;</span></span><br><span class="line"> &gt;&gt;&gt; m.span(<span class="number">1</span>) <span class="comment"># 返回第一个分组匹配成功的子串的索引</span></span><br><span class="line"> (<span class="number">0</span>, <span class="number">5</span>) </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m.group(<span class="number">2</span>) <span class="comment"># 返回第二个分组匹配成功的子串 </span></span><br><span class="line"><span class="string">&#x27;World&#x27;</span> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m.span(<span class="number">2</span>)  <span class="comment"># 返回第二个分组匹配成功的子串索引</span></span><br><span class="line"> (<span class="number">6</span>, <span class="number">11</span>) </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m.groups() <span class="comment"># 等价于 (m.group(1), m.group(2), ...) </span></span><br><span class="line">(<span class="string">&#x27;Hello&#x27;</span>, <span class="string">&#x27;World&#x27;</span>) </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m.group(<span class="number">3</span>) <span class="comment"># 不存在第三个分组</span></span><br><span class="line"> Traceback (most recent call last): File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt; IndexError: no such group</span><br></pre></td></tr></table></figure><h3 id="👀findall"><a href="#👀findall" class="headerlink" title="👀findall()"></a>👀findall()</h3><p>在字符串中找到正则表达式所匹配的所有子串，并<strong>返回一个列表</strong>，如果有多个匹配模式，则返回元组列表，如果没有找到匹配的，则返回空列表。</p><blockquote><p>注意： match()和search()是匹配一次，findall()匹配所有。</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 语法格式</span></span><br><span class="line">re.findall(pattern, string, flags=<span class="number">0</span>)</span><br><span class="line">或</span><br><span class="line">pattern.findall(string[, pos[, endpos]])</span><br><span class="line"><span class="comment"># 参数</span></span><br><span class="line">pattern 匹配模式。</span><br><span class="line">string  待匹配的字符串。</span><br><span class="line">pos 可选参数，指定字符串的起始位置，默认为 <span class="number">0</span>。</span><br><span class="line">endpos 可选参数，指定字符串的结束位置，默认为字符串的长度。</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># (1)查找字符串中的所有数字</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line">result1 = re.findall(<span class="string">r&#x27;\d+&#x27;</span>,<span class="string">&#x27;runoob 123 google 456&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(result1)</span><br><span class="line">pattern = re.<span class="built_in">compile</span>(<span class="string">r&#x27;\d+&#x27;</span>) <span class="comment"># 查找数字</span></span><br><span class="line">result2 = pattern.findall(<span class="string">&#x27;runoob 123 google 456&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(result2)</span><br><span class="line">result3 = pattern.findall(<span class="string">&#x27;run88oob123google456&#x27;</span>, <span class="number">0</span>, <span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(result3)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[<span class="string">&#x27;123&#x27;</span>, <span class="string">&#x27;456&#x27;</span>]</span><br><span class="line">[<span class="string">&#x27;123&#x27;</span>, <span class="string">&#x27;456&#x27;</span>]</span><br><span class="line">[<span class="string">&#x27;88&#x27;</span>, <span class="string">&#x27;12&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 多个匹配模式，返回元组列表</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line">result = re.findall(<span class="string">r&#x27;(\w+)=(\d+)&#x27;</span>, <span class="string">&#x27;set width=20 and height=10&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[(<span class="string">&#x27;width&#x27;</span>, <span class="string">&#x27;20&#x27;</span>), (<span class="string">&#x27;height&#x27;</span>, <span class="string">&#x27;10&#x27;</span>)]</span><br></pre></td></tr></table></figure><h3 id="👀re-finditer"><a href="#👀re-finditer" class="headerlink" title="👀re.finditer()"></a>👀re.finditer()</h3><p>和 <code>findall(</code>)类似，在字符串中找到正则表达式所匹配的所有子串，并把它们作为一个<strong>迭代器</strong>返回。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 语法格式</span></span><br><span class="line">re.finditer(pattern, string, flags=<span class="number">0</span>)</span><br><span class="line"><span class="comment"># 参数</span></span><br><span class="line">pattern 匹配的正则表达式</span><br><span class="line">string 要匹配的字符串。</span><br><span class="line">flags 标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等。</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">it = re.finditer(<span class="string">r&quot;\d+&quot;</span>,<span class="string">&quot;12a32bc43jf3&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(it)</span><br><span class="line"><span class="keyword">for</span> match <span class="keyword">in</span> it:</span><br><span class="line"><span class="built_in">print</span> (match.group())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">&lt;callable_iterator <span class="built_in">object</span> at <span class="number">0x000001FA199BA0C8</span>&gt;</span><br><span class="line"><span class="number">12</span> </span><br><span class="line"><span class="number">32</span> </span><br><span class="line"><span class="number">43</span> </span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><h3 id="👀re-split"><a href="#👀re-split" class="headerlink" title="👀re.split()"></a>👀re.split()</h3><p><code>split()</code>方法按照能够匹配的子串将字符串分割后，<strong>返回列表</strong>。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 语法格式</span></span><br><span class="line">re.split(pattern, string[, maxsplit=<span class="number">0</span>, flags=<span class="number">0</span>])</span><br><span class="line"><span class="comment"># 参数</span></span><br><span class="line">pattern 匹配的正则表达式</span><br><span class="line">string 要匹配的字符串。</span><br><span class="line">maxsplit 分割次数，maxsplit=<span class="number">1</span> 分割一次，默认为 <span class="number">0</span>，不限制次数。</span><br><span class="line">flags 标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等。</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="keyword">import</span> re </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.split(<span class="string">&#x27;\W+&#x27;</span>, <span class="string">&#x27;runoob, runoob, runoob.&#x27;</span>) </span><br><span class="line">[<span class="string">&#x27;runoob&#x27;</span>, <span class="string">&#x27;runoob&#x27;</span>, <span class="string">&#x27;runoob&#x27;</span>, <span class="string">&#x27;&#x27;</span>] </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.split(<span class="string">&#x27;(\W+)&#x27;</span>, <span class="string">&#x27; runoob, runoob, runoob.&#x27;</span>) </span><br><span class="line">[<span class="string">&#x27;&#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;runoob&#x27;</span>, <span class="string">&#x27;, &#x27;</span>, <span class="string">&#x27;runoob&#x27;</span>, <span class="string">&#x27;, &#x27;</span>, <span class="string">&#x27;runoob&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;&#x27;</span>] </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.split(<span class="string">&#x27;\W+&#x27;</span>, <span class="string">&#x27; runoob, runoob, runoob.&#x27;</span>, <span class="number">1</span>) </span><br><span class="line">[<span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;runoob, runoob, runoob.&#x27;</span>] </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.split(<span class="string">&#x27;ab*&#x27;</span>, <span class="string">&#x27;hello world&#x27;</span>) <span class="comment"># 对于一个找不到匹配的字符串而言，split 不会对其作出分割</span></span><br><span class="line">[<span class="string">&#x27;hello world&#x27;</span>]</span><br></pre></td></tr></table></figure><h3 id="👀正则表达式对象"><a href="#👀正则表达式对象" class="headerlink" title="👀正则表达式对象"></a>👀正则表达式对象</h3><p><strong>re.RegexObject</strong></p><ul><li><code>re.compile()</code> 返回 <code>RegexObject</code> 对象。</li></ul><p><strong>re.MatchObject</strong></p><ul><li><p><code>group()</code> 返回被 <code>RE</code> 匹配的字符串。</p><ul><li><p><code>start()</code> 返回匹配开始的位置</p></li><li><p><code>end()</code> 返回匹配结束的位置</p></li><li><p><code>span()</code> 返回一个元组包含匹配 (开始,结束) 的位置</p></li></ul></li></ul><h3 id="👀正则表达式修饰符-可选标志"><a href="#👀正则表达式修饰符-可选标志" class="headerlink" title="👀正则表达式修饰符-可选标志"></a>👀正则表达式修饰符-可选标志</h3><p>正则表达式可以包含一些可选标志修饰符来控制匹配的模式。修饰符被指定为一个可选的标志。多个标志可以通过按位 <code>OR(|)</code> 它们来指定。如<code>re.I</code> | <code>re.M</code> 被设置成 I 和 M 标志：</p><table><thead><tr><th align="center">修饰符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="center"><code>re.I</code></td><td align="left">使匹配对大小写不敏感</td></tr><tr><td align="center"><code>re.L</code></td><td align="left">做本地化识别（local-aware）匹配</td></tr><tr><td align="center"><code>re.M</code></td><td align="left">多行匹配，影响^和$</td></tr><tr><td align="center"><code>re.S</code></td><td align="left">使<code>.</code>匹配包括换行在内的所有字符</td></tr><tr><td align="center"><code>re.U</code></td><td align="left">根据<code>Unicode</code>字符集解析字符。这个标志影响<code>\w</code>，<code>\W</code>，<code>\b</code>，<code>\B</code></td></tr><tr><td align="center"><code>re.X</code></td><td align="left">该标志通过给予你更灵活的格式以便你将正则表达式写得更易于理解。</td></tr></tbody></table><h3 id="👀正则表达式实例"><a href="#👀正则表达式实例" class="headerlink" title="👀正则表达式实例"></a>👀正则表达式实例</h3><p>（1）字符匹配</p><table><thead><tr><th><strong>实例</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><code>python</code></td><td>匹配 “<code>python</code>“.</td></tr></tbody></table><p>（2）字符类</p><table><thead><tr><th><strong>实例</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><code>[Pp]ython</code></td><td>匹配 “<code>Python</code>“ 或 “<code>python</code>“</td></tr><tr><td><code>rub[ye]</code></td><td>匹配 “<code>ruby</code>“ 或 “<code>rube</code>“</td></tr><tr><td><code>[aeiou]</code></td><td>匹配中括号内的任意一个字母</td></tr><tr><td><code>[0-9]</code></td><td>匹配任何数字。类似于 [<code>0123456789</code>]</td></tr><tr><td><code>[a-z]</code></td><td>匹配任何小写字母</td></tr><tr><td><code>[A-Z]</code></td><td>匹配任何大写字母</td></tr><tr><td><code>[a-zA-Z0-9]</code></td><td>匹配任何字母及数字</td></tr><tr><td><code>[^aeiou]</code></td><td>除了<code>aeiou</code>字母以外的所有字符</td></tr><tr><td><code>[^0-9]</code></td><td>匹配除了数字外的字符</td></tr></tbody></table><p>（3）特殊字符类</p><table><thead><tr><th><strong>实例</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><code>.</code></td><td>匹配除 “<code>\n</code>“ 之外的任何单个字符。要匹配包括 ‘<code>\n</code>‘ 在内的任何字符，请使用象 ‘<code>[.\n]</code>‘ 的模式。</td></tr><tr><td><code>\d</code></td><td>匹配一个数字字符。等价于[<code>0-9</code>]。</td></tr><tr><td><code>\D</code></td><td>匹配一个非数字字符。等价于[<code>^0-9</code>]。</td></tr><tr><td><code>\s</code></td><td>匹配任何空白字符，包括空格、制表符、换页符等等。等价于[<code>\f\n\r\t\v</code>]。</td></tr><tr><td><code>\S</code></td><td>匹配任何非空白字符。等价于[<code>^\f\n\r\t\v</code>]。</td></tr><tr><td><code>\w</code></td><td>匹配包括下划线的任何单词字符。等价于[<code>A-Za-z0-9_</code>]。</td></tr><tr><td><code>\W</code></td><td>匹配任何非单词字符。等价于[<code>^A-Za-z0-9_</code>]。</td></tr></tbody></table><p>笔者不才，请多交流！！！</p><p>参考文献：正则表达式 - 教程|菜鸟教程</p>]]></content>
      
      
      <categories>
          
          <category> 正则表达式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 正则表达式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ERA5数据下载和批处理教程</title>
      <link href="/2022/09/08/ERA5-data/"/>
      <url>/2022/09/08/ERA5-data/</url>
      
        <content type="html"><![CDATA[<p><code>ERA5</code> 再分析数据是最新一代的再分析数据，由欧盟资助的哥白尼气候变化服务（<code>C3S</code>）创建，由 <code>ECMWF</code> 运营。同化了包括全球范围内不同区域和来源的遥感资料、地表与上层大气常规气象资料。它覆盖了 1950 年至今的历史时期，实现了实时更新，延迟约 3 个月。<code>ERA5</code> 在其前身 <code>ERA-Interim</code> 的基础上进行了大幅升级，在时间分辨率和空间分辨率上都有显著提高。</p><p><code>ERA5</code> 再分析资料提供了许多种类的要素，包括 2m 温度、2m 相对湿度、海平面气压、10m 风等地面要素以及温度、相对湿度、位势高度、风场等高空要素。</p><h2 id="⛄ERA5数据下载"><a href="#⛄ERA5数据下载" class="headerlink" title="⛄ERA5数据下载"></a>⛄ERA5数据下载</h2><p>本例子以<code>ERA5 monthly averaged data on single levels from 1959 to present</code>数据为基础，下载2017、2018、2019、2020、2021年ERA5再分析数据，并进行批处理。数据变量主要包括：</p><ul><li>2m_temperature</li><li>skin_temperature</li><li>total_precipitation</li></ul><h3 id="👀前期准备"><a href="#👀前期准备" class="headerlink" title="👀前期准备"></a>👀前期准备</h3><p>进入 <strong>Climate Data Store</strong>（CDS），<a href="https://cds.climate.copernicus.eu/cdsapp#!/home">官方网站</a>，<a href="https://cds.climate.copernicus.eu/user/register?destination=/%23!/home">注册新用户</a>（已有请忽略）</p><ul><li>选择需要的数据，以<a href="https://cds.climate.copernicus.eu/cdsapp#!/dataset/reanalysis-era5-single-levels-monthly-means">ERA5 monthly averaged data on single levels from 1959 to present</a>数据为例，</li><li>在<code>Download data</code>选项卡里面产品类型<code>Product type</code>和变量<code>Variable</code></li><li>选择对应的<code>Year</code>、<code>Month</code>、<code>Time</code>；地理区域<code>Geographical area</code>；格式<code>Format</code>为<code>NetCDF</code>；</li><li><code>Terms of use</code> 勾上对号<code>Licence to use Copernicus Products</code>；</li><li>最下面有三种下载方式①<code>Show API request</code>；②<code>Show Toolbox request</code>；③<code>Submit Form</code>。</li></ul><h3 id="👀Python方式下载"><a href="#👀Python方式下载" class="headerlink" title="👀Python方式下载"></a>👀Python方式下载</h3><p>点击<code>Show API request</code>，出现Python代码，是根据你选择的数据自动生成的API请求。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cdsapi</span><br><span class="line"></span><br><span class="line">c = cdsapi.Client()</span><br><span class="line"></span><br><span class="line">c.retrieve(</span><br><span class="line">    <span class="string">&#x27;reanalysis-era5-single-levels-monthly-means&#x27;</span>,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&#x27;product_type&#x27;</span>: <span class="string">&#x27;monthly_averaged_reanalysis&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;variable&#x27;</span>: [</span><br><span class="line">            <span class="string">&#x27;2m_temperature&#x27;</span>, <span class="string">&#x27;skin_temperature&#x27;</span>, <span class="string">&#x27;total_precipitation&#x27;</span>,</span><br><span class="line">        ],</span><br><span class="line">        <span class="string">&#x27;year&#x27;</span>: [</span><br><span class="line">            <span class="string">&#x27;2017&#x27;</span>, <span class="string">&#x27;2018&#x27;</span>, <span class="string">&#x27;2019&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;2020&#x27;</span>, <span class="string">&#x27;2021&#x27;</span>,</span><br><span class="line">        ],</span><br><span class="line">        <span class="string">&#x27;month&#x27;</span>: [</span><br><span class="line">            <span class="string">&#x27;01&#x27;</span>, <span class="string">&#x27;02&#x27;</span>, <span class="string">&#x27;03&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;04&#x27;</span>, <span class="string">&#x27;05&#x27;</span>, <span class="string">&#x27;06&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;07&#x27;</span>, <span class="string">&#x27;08&#x27;</span>, <span class="string">&#x27;09&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;10&#x27;</span>, <span class="string">&#x27;11&#x27;</span>, <span class="string">&#x27;12&#x27;</span>,</span><br><span class="line">        ],</span><br><span class="line">        <span class="string">&#x27;time&#x27;</span>: <span class="string">&#x27;00:00&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;area&#x27;</span>: [</span><br><span class="line">            <span class="number">60</span>, <span class="number">70</span>, <span class="number">0</span>,</span><br><span class="line">            <span class="number">140</span>,</span><br><span class="line">        ],</span><br><span class="line">        <span class="string">&#x27;format&#x27;</span>: <span class="string">&#x27;netcdf&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&#x27;download.nc&#x27;</span>)</span><br></pre></td></tr></table></figure><p>运行成功此代码，需要以下准备：</p><p>（1）安装cdsapi模块</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip install cdsapi</span><br></pre></td></tr></table></figure><p>（2）此时可能运行出错</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Exception: Missing/incomplete configuration file:C:\Users\Administrator/.cdsapirc</span><br></pre></td></tr></table></figure><p><strong>初步分析</strong>：在目标路径下缺少<code>.cdsapirc</code>文件，该文件里含有下载数据的<code>url</code>和<code>key</code></p><p><strong>解决方案</strong>：针对已注册的用户，进入<a href="https://cds.climate.copernicus.eu/api-how-to">How to use the CDS API</a>网站，获得<code>url</code>和<code>key</code></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">url: https://cds.climate.copernicus.eu/api/v2</span><br><span class="line">key: *****************************************(已隐藏)</span><br></pre></td></tr></table></figure><ul><li>新建<code>txt</code>文件，将自己的<code>url</code>和<code>key</code>复制进去，然后保存；</li><li>把<code>txt</code>文件名改为<code>.cdsapirc</code>(注意有<code>.</code>)，同时修改文件后缀名，即把<code>.txt</code>后缀删除；</li><li>将文件复制或剪切到之前报错的目标路径下；</li><li>运行Python程序，即可成功下载。</li></ul><h3 id="👀IDM下载器方式下载"><a href="#👀IDM下载器方式下载" class="headerlink" title="👀IDM下载器方式下载"></a>👀IDM下载器方式下载</h3><p>点击<code>Submit Form</code>，跳转界面到<code>Your requests</code>，会显示当前下载数据的请求状态，需要你耐心等待一会儿。</p><p>通过请求之后，即可通过<code>Internet Download Manager</code>（<code>IDM</code>）下载器下载（前提已安装）。</p><h2 id="⛄ERA5数据批处理"><a href="#⛄ERA5数据批处理" class="headerlink" title="⛄ERA5数据批处理"></a>⛄ERA5数据批处理</h2><p>ERA5数据批处理目标要求：</p><ul><li>读取nc文件；</li><li>查看并获取nc文件中对应变量的信息；</li><li>根据数据的经纬度，计算分辨率；</li><li>定义投影；</li><li>保存数据为tif格式。</li></ul><h3 id="👀流程步骤"><a href="#👀流程步骤" class="headerlink" title="👀流程步骤"></a>👀流程步骤</h3><p>（1）读取nc文件</p><p>安装对应的netCDF4模块</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip install netCDF4</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> netCDF4 <span class="keyword">as</span> nc</span><br><span class="line"><span class="comment"># 读取nc文件</span></span><br><span class="line">tep_data = nc.Dataset(input_path)</span><br></pre></td></tr></table></figure><p>（2）查看并获取nc文件中对应变量的信息</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看nc文件中的变量信息</span></span><br><span class="line"><span class="built_in">print</span>(tep_data.variables.keys())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取nc文件中对应变量的信息</span></span><br><span class="line">lon_data = tep_data.variables[<span class="string">&quot;longitude&quot;</span>][:]</span><br><span class="line">lat_data = tep_data.variables[<span class="string">&quot;latitude&quot;</span>][:]</span><br></pre></td></tr></table></figure><p>（3）根据数据的经纬度，计算分辨率</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"> <span class="comment"># 影像的左上角&amp;右下角坐标</span></span><br><span class="line">lonmin, latmax, lonmax, latmin = [lon_data.<span class="built_in">min</span>(), lat_data.<span class="built_in">max</span>(), lon_data.<span class="built_in">max</span>(), lat_data.<span class="built_in">min</span>()]</span><br><span class="line"><span class="comment"># print(lonmin, latmax, lonmax, latmin)</span></span><br><span class="line">    </span><br><span class="line"><span class="comment"># 分辨率计算</span></span><br><span class="line">num_lon = <span class="built_in">len</span>(lon_data)  </span><br><span class="line">num_lat = <span class="built_in">len</span>(lat_data)  </span><br><span class="line">lon_res = (lonmax - lonmin) / (<span class="built_in">float</span>(num_lon) - <span class="number">1</span>)</span><br><span class="line">lat_res = (latmax - latmin) / (<span class="built_in">float</span>(num_lat) - <span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(num_lon, num_lat)</span><br><span class="line"><span class="built_in">print</span>(lon_res, lat_res)</span><br></pre></td></tr></table></figure><p>（4）定义投影</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义投影</span></span><br><span class="line">proj = osr.SpatialReference()</span><br><span class="line">proj.ImportFromEPSG(<span class="number">4326</span>)  <span class="comment"># WGS84</span></span><br><span class="line">proj = proj.ExportToWkt()  <span class="comment"># 重点，转成wkt格式</span></span><br><span class="line"><span class="comment"># print(prj)     字符串</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义六参数，设置影像的显示范围和分辨率</span></span><br><span class="line"><span class="comment"># 影像左上角横坐标：geoTransform[0]</span></span><br><span class="line"><span class="comment"># 影像左上角纵坐标：geoTransform[3]</span></span><br><span class="line"><span class="comment"># 遥感图像的水平空间分辨率为geoTransform[1]</span></span><br><span class="line"><span class="comment"># 遥感图像的垂直空间分辨率为geoTransform[5]</span></span><br><span class="line"><span class="comment"># 通常geoTransform[5] 与 geoTransform[1]相等</span></span><br><span class="line"><span class="comment"># 如果遥感影像方向没有发生旋转，即上北、下南，则geoTransform[2] 与 row *geoTransform[4] 为零。</span></span><br><span class="line">geotransform = (lonmin, lon_res, <span class="number">0.0</span>, latmax, <span class="number">0.0</span>, -lat_res)</span><br></pre></td></tr></table></figure><p>（5）保存数据为tif格式，以2m_temperature（t2m）温度为例</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">t2m = tep_data.variables[<span class="string">&quot;t2m&quot;</span>][:]  </span><br><span class="line"><span class="comment"># 用np.array把数据转化成数组（矩阵）类型</span></span><br><span class="line">t2m_arr = np.asarray(t2m)</span><br><span class="line"><span class="comment">#年份</span></span><br><span class="line">yearlist = [<span class="number">2017</span>,<span class="number">2018</span>,<span class="number">2019</span>,<span class="number">2020</span>,<span class="number">2021</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(yearlist)):</span><br><span class="line">    year = yearlist[i]</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">12</span>*i, <span class="number">12</span>*(i+<span class="number">1</span>)):</span><br><span class="line">        month = (j % <span class="number">12</span>) + <span class="number">1</span></span><br><span class="line">        outputpath = output_path + <span class="built_in">str</span>(year) + <span class="string">&quot;_&quot;</span> + <span class="built_in">str</span>(month) + <span class="string">&quot;_t2m.tif&quot;</span></span><br><span class="line">        write_img(outputpath, proj, geotransform, t2m_arr[j])</span><br></pre></td></tr></table></figure><h3 id="👀结果文件展示"><a href="#👀结果文件展示" class="headerlink" title="👀结果文件展示"></a>👀结果文件展示</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">2017_1_t2m.tif</span><br><span class="line">2017_2_t2m.tif</span><br><span class="line">2017_3_t2m.tif</span><br><span class="line">2017_4_t2m.tif</span><br><span class="line">2017_5_t2m.tif</span><br><span class="line">2017_6_t2m.tif</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">2021_7_t2m.tif</span><br><span class="line">2021_8_t2m.tif</span><br><span class="line">2021_9_t2m.tif</span><br><span class="line">2021_10_t2m.tif</span><br><span class="line">2021_11_t2m.tif</span><br><span class="line">2021_12_t2m.tif</span><br></pre></td></tr></table></figure><p>以2017_1_t2m.tif结果为例，如下图：</p><p><img src="https://s2.loli.net/2022/12/10/UNrouOseVYvwRhL.jpg"></p><h3 id="👀完整参考代码"><a href="#👀完整参考代码" class="headerlink" title="👀完整参考代码"></a>👀完整参考代码</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> netCDF4 <span class="keyword">as</span> nc</span><br><span class="line"><span class="keyword">from</span> osgeo <span class="keyword">import</span> gdal, osr</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment">#1.2定义写图像文件的函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">write_img</span>(<span class="params">filename, im_proj, im_geotrans, im_data</span>):</span><br><span class="line">    <span class="comment"># 判断栅格数据的数据类型</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;int8&#x27;</span> <span class="keyword">in</span> im_data.dtype.name:</span><br><span class="line">        datatype = gdal.GDT_Byte</span><br><span class="line">    <span class="keyword">elif</span> <span class="string">&#x27;int16&#x27;</span> <span class="keyword">in</span> im_data.dtype.name:</span><br><span class="line">        datatype = gdal.GDT_UInt16</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        datatype = gdal.GDT_Float32</span><br><span class="line">    <span class="comment"># 判读数组维数</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(im_data.shape) == <span class="number">3</span>:</span><br><span class="line">        im_bands, im_height, im_width = im_data.shape</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        im_bands, (im_height, im_width) = <span class="number">1</span>, im_data.shape</span><br><span class="line">    <span class="comment"># 创建文件</span></span><br><span class="line">    driver = gdal.GetDriverByName(<span class="string">&quot;GTiff&quot;</span>)</span><br><span class="line">    dataset = driver.Create(filename, im_width, im_height, im_bands, datatype)</span><br><span class="line">    dataset.SetGeoTransform(im_geotrans)  <span class="comment"># 写入仿射变换参数</span></span><br><span class="line">    dataset.SetProjection(im_proj)  <span class="comment"># 写入投影</span></span><br><span class="line">    <span class="keyword">if</span> im_bands == <span class="number">1</span>:</span><br><span class="line">        dataset.GetRasterBand(<span class="number">1</span>).WriteArray(im_data)  <span class="comment"># 写入数组数据</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(im_bands):</span><br><span class="line">            dataset.GetRasterBand(i + <span class="number">1</span>).WriteArray(im_data[i])</span><br><span class="line">    <span class="keyword">del</span> dataset</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">nc_totif</span>(<span class="params">input_path, output_path</span>):</span><br><span class="line">    <span class="comment"># 读取nc文件</span></span><br><span class="line">    tep_data = nc.Dataset(input_path)</span><br><span class="line">    <span class="comment"># 获取nc文件中对应变量的信息</span></span><br><span class="line">    lon_data = tep_data.variables[<span class="string">&quot;longitude&quot;</span>][:]</span><br><span class="line">    lat_data = tep_data.variables[<span class="string">&quot;latitude&quot;</span>][:]</span><br><span class="line">    <span class="comment"># 影像的左上角&amp;右下角坐标</span></span><br><span class="line">    lonmin, latmax, lonmax, latmin = [lon_data.<span class="built_in">min</span>(), lat_data.<span class="built_in">max</span>(), lon_data.<span class="built_in">max</span>(), lat_data.<span class="built_in">min</span>()]</span><br><span class="line">    <span class="comment"># 分辨率计算</span></span><br><span class="line">    num_lon = <span class="built_in">len</span>(lon_data)  <span class="comment"># 281</span></span><br><span class="line">    num_lat = <span class="built_in">len</span>(lat_data)  <span class="comment"># 241</span></span><br><span class="line">    lon_res = (lonmax - lonmin) / (<span class="built_in">float</span>(num_lon) - <span class="number">1</span>)</span><br><span class="line">    lat_res = (latmax - latmin) / (<span class="built_in">float</span>(num_lat) - <span class="number">1</span>)</span><br><span class="line">    <span class="comment"># 定义投影</span></span><br><span class="line">    proj = osr.SpatialReference()</span><br><span class="line">    proj.ImportFromEPSG(<span class="number">4326</span>)  <span class="comment"># WGS84</span></span><br><span class="line">    proj = proj.ExportToWkt()  <span class="comment"># 重点，转成wkt格式</span></span><br><span class="line">    <span class="comment"># print(prj)     字符串</span></span><br><span class="line">    geotransform = (lonmin, lon_res, <span class="number">0.0</span>, latmax, <span class="number">0.0</span>, -lat_res)</span><br><span class="line">    <span class="comment"># 获取2m温度</span></span><br><span class="line">    t2m = tep_data.variables[<span class="string">&quot;t2m&quot;</span>][:]  <span class="comment"># (60, 241, 281)</span></span><br><span class="line">    t2m_arr = np.asarray(t2m)</span><br><span class="line">    <span class="comment">#年份</span></span><br><span class="line">    yearlist = [<span class="number">2017</span>,<span class="number">2018</span>,<span class="number">2019</span>,<span class="number">2020</span>,<span class="number">2021</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(yearlist)):</span><br><span class="line">        year = yearlist[i]</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">12</span>*i, <span class="number">12</span>*(i+<span class="number">1</span>)):</span><br><span class="line">            month = (j % <span class="number">12</span>) + <span class="number">1</span></span><br><span class="line">            outputpath = output_path + <span class="built_in">str</span>(year) + <span class="string">&quot;_&quot;</span> + <span class="built_in">str</span>(month) + <span class="string">&quot;_t2m.tif&quot;</span></span><br><span class="line">            write_img(outputpath, proj, geotransform, t2m_arr[j])</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># nc文件输入输出路径</span></span><br><span class="line">    input_path = <span class="string">&quot;D:/Study/Data_Process/ERA5/Code/Monthly_averaged_2017_2021.nc&quot;</span></span><br><span class="line">    output_path = <span class="string">&quot;D:/Study/Data_Process/ERA5/Code/数据转换/&quot;</span></span><br><span class="line">    <span class="comment"># 读取nc文件，转换为tif文件</span></span><br><span class="line">    nc_totif(input_path, output_path)</span><br></pre></td></tr></table></figure><p>笔者不才，多多交流！！！</p>]]></content>
      
      
      <categories>
          
          <category> ERA5 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ERA5 </tag>
            
            <tag> 数据处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python基础知识（04）</title>
      <link href="/2022/09/03/Python-Basic04/"/>
      <url>/2022/09/03/Python-Basic04/</url>
      
        <content type="html"><![CDATA[<h2 id="⛄字符串的定义"><a href="#⛄字符串的定义" class="headerlink" title="⛄字符串的定义"></a>⛄字符串的定义</h2><p>字符串就是一串字符，用途众多，是编程语言中表示文本的数据类型，如”Hello World”。在Python中可以使用一对双引号<code>&quot; &quot;</code>或者一对单引号<code>&#39;&#39;</code>定义一个字符串。虽然可以使用<code>\&quot;</code>或者<code>\&#39;</code>做字符串的转义，但是在实际开发中：</p><ul><li>如果字符串内部需要使用<code>&quot;</code>，可以使用<code>&#39;</code>定义字符串</li><li>如果字符串内部需要使用<code>&#39;</code>，可以使用<code>&quot;</code>定义字符串</li></ul><p>可以使用索引获取一个字符串中指定位置的字符，索引计数从0开始；也可以使用<code>for</code>循环遍历字符串中每一个字符。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">str1 = <span class="string">&quot;My name is &#x27;xiaotang&#x27;&quot;</span></span><br><span class="line">str2 = <span class="string">&#x27;My name is &quot;HeartLoveLife&quot;&#x27;</span></span><br><span class="line"><span class="comment"># len(字符串)获取字符串的长度</span></span><br><span class="line">str1_len = <span class="built_in">len</span>(str1)</span><br><span class="line">str2_len = <span class="built_in">len</span>(str2)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(str1, <span class="string">&quot;;&quot;</span>, str2)</span><br><span class="line"><span class="built_in">print</span>(str1_len, <span class="string">&quot;;&quot;</span>, str2_len)</span><br><span class="line"><span class="comment"># 字符串.count(字符串)统计小字符串在大字符串中出现的次数</span></span><br><span class="line"><span class="built_in">print</span>(str1.count(<span class="string">&quot;n&quot;</span>))</span><br><span class="line"><span class="comment"># 字符串[索引]从字符串中取出单个字符</span></span><br><span class="line"><span class="built_in">print</span>(str1[<span class="number">0</span>])</span><br><span class="line"><span class="comment"># 字符串.index(字符串)获得小字符串第一次出现的索引</span></span><br><span class="line"><span class="built_in">print</span>(str1.index(<span class="string">&quot;n&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">My name <span class="keyword">is</span> <span class="string">&#x27;xiaotang&#x27;</span> ; My name <span class="keyword">is</span> <span class="string">&quot;HeartLoveLife&quot;</span></span><br><span class="line"><span class="number">21</span> ; <span class="number">26</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line">M</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><h2 id="⛄字符串常用操作"><a href="#⛄字符串常用操作" class="headerlink" title="⛄字符串常用操作"></a>⛄字符串常用操作</h2><p>Python内置提供的方法有很多，使得在开发时，能够针对字符串进行更加灵活的操作，应对更多的开发需求。使用Python内置函数dir()返回字符串的属性、方法列表。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">str_list = <span class="built_in">dir</span>(<span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(str_list)</span><br><span class="line"></span><br><span class="line">[<span class="string">&#x27;__add__&#x27;</span>, <span class="string">&#x27;__class__&#x27;</span>, <span class="string">&#x27;__contains__&#x27;</span>, <span class="string">&#x27;__delattr__&#x27;</span>, <span class="string">&#x27;__dir__&#x27;</span>, <span class="string">&#x27;__doc__&#x27;</span>, <span class="string">&#x27;__eq__&#x27;</span>, <span class="string">&#x27;__format__&#x27;</span>, <span class="string">&#x27;__ge__&#x27;</span>, <span class="string">&#x27;__getattribute__&#x27;</span>, <span class="string">&#x27;__getitem__&#x27;</span>, <span class="string">&#x27;__getnewargs__&#x27;</span>, <span class="string">&#x27;__gt__&#x27;</span>, <span class="string">&#x27;__hash__&#x27;</span>, <span class="string">&#x27;__init__&#x27;</span>, <span class="string">&#x27;__init_subclass__&#x27;</span>, <span class="string">&#x27;__iter__&#x27;</span>, <span class="string">&#x27;__le__&#x27;</span>, <span class="string">&#x27;__len__&#x27;</span>, <span class="string">&#x27;__lt__&#x27;</span>, <span class="string">&#x27;__mod__&#x27;</span>, <span class="string">&#x27;__mul__&#x27;</span>, <span class="string">&#x27;__ne__&#x27;</span>, <span class="string">&#x27;__new__&#x27;</span>, <span class="string">&#x27;__reduce__&#x27;</span>, <span class="string">&#x27;__reduce_ex__&#x27;</span>, <span class="string">&#x27;__repr__&#x27;</span>, <span class="string">&#x27;__rmod__&#x27;</span>, <span class="string">&#x27;__rmul__&#x27;</span>, <span class="string">&#x27;__setattr__&#x27;</span>, <span class="string">&#x27;__sizeof__&#x27;</span>, <span class="string">&#x27;__str__&#x27;</span>, <span class="string">&#x27;__subclasshook__&#x27;</span>, <span class="string">&#x27;capitalize&#x27;</span>, <span class="string">&#x27;casefold&#x27;</span>, <span class="string">&#x27;center&#x27;</span>, <span class="string">&#x27;count&#x27;</span>, <span class="string">&#x27;encode&#x27;</span>, <span class="string">&#x27;endswith&#x27;</span>, <span class="string">&#x27;expandtabs&#x27;</span>, <span class="string">&#x27;find&#x27;</span>, <span class="string">&#x27;format&#x27;</span>, <span class="string">&#x27;format_map&#x27;</span>, <span class="string">&#x27;index&#x27;</span>, <span class="string">&#x27;isalnum&#x27;</span>, <span class="string">&#x27;isalpha&#x27;</span>, <span class="string">&#x27;isascii&#x27;</span>, <span class="string">&#x27;isdecimal&#x27;</span>, <span class="string">&#x27;isdigit&#x27;</span>, <span class="string">&#x27;isidentifier&#x27;</span>, <span class="string">&#x27;islower&#x27;</span>, <span class="string">&#x27;isnumeric&#x27;</span>, <span class="string">&#x27;isprintable&#x27;</span>, <span class="string">&#x27;isspace&#x27;</span>, <span class="string">&#x27;istitle&#x27;</span>, <span class="string">&#x27;isupper&#x27;</span>, <span class="string">&#x27;join&#x27;</span>, <span class="string">&#x27;ljust&#x27;</span>, <span class="string">&#x27;lower&#x27;</span>, <span class="string">&#x27;lstrip&#x27;</span>, <span class="string">&#x27;maketrans&#x27;</span>, <span class="string">&#x27;partition&#x27;</span>, <span class="string">&#x27;replace&#x27;</span>, <span class="string">&#x27;rfind&#x27;</span>, <span class="string">&#x27;rindex&#x27;</span>, <span class="string">&#x27;rjust&#x27;</span>, <span class="string">&#x27;rpartition&#x27;</span>, <span class="string">&#x27;rsplit&#x27;</span>, <span class="string">&#x27;rstrip&#x27;</span>, <span class="string">&#x27;split&#x27;</span>, <span class="string">&#x27;splitlines&#x27;</span>, <span class="string">&#x27;startswith&#x27;</span>, <span class="string">&#x27;strip&#x27;</span>, <span class="string">&#x27;swapcase&#x27;</span>, <span class="string">&#x27;title&#x27;</span>, <span class="string">&#x27;translate&#x27;</span>, <span class="string">&#x27;upper&#x27;</span>, <span class="string">&#x27;zfill&#x27;</span>]</span><br></pre></td></tr></table></figure><h3 id="👀-判断类型"><a href="#👀-判断类型" class="headerlink" title="👀 判断类型"></a>👀 判断类型</h3><table><thead><tr><th align="left">方法</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">string.isspace()</td><td align="left">如果string中只包含空格，则返回True</td></tr><tr><td align="left">string.isalnum()</td><td align="left">如果string至少有一个字符并且所有字符都是字母或数字则返回True</td></tr><tr><td align="left">string.isalpha()</td><td align="left">如果string至少有一个字符并且所有字符都是字母则返回True</td></tr><tr><td align="left">string.isdecimal()</td><td align="left">如果 string只包含数字则返回True，<code>全角数字</code></td></tr><tr><td align="left">string.isdigit()</td><td align="left">如果 string只包含数字则返回True，<code>全角数字</code></td></tr><tr><td align="left">string.isnumeric()</td><td align="left">如果 string只包含数字则返回True，<code>全角数字</code>，<code>汉字数字</code></td></tr><tr><td align="left">string.istitle()</td><td align="left">如果 string是标题化的（每个单词的首字母大写）则返回True</td></tr><tr><td align="left">string.islower()</td><td align="left">如果string中包含至少一个区分大小写的字符，并且所有这些（区分大小写的）字符都是小写，则返回True</td></tr><tr><td align="left">string.isupper()</td><td align="left">如果 string中包含至少一个区分大小写的字符，并且所有这些（区分大小写的）字符都是大写，则返回True</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">str_space = <span class="string">&quot;   &quot;</span> </span><br><span class="line"><span class="built_in">print</span>(str_space.isspace())</span><br><span class="line"></span><br><span class="line">str1 = <span class="string">&quot;a_&quot;</span></span><br><span class="line">str2 = <span class="string">&quot;a9527&quot;</span></span><br><span class="line"><span class="built_in">print</span>(str1.isalnum(), str2.isalnum())</span><br><span class="line"></span><br><span class="line">str3 = <span class="string">&quot;a9527&quot;</span></span><br><span class="line">str4 = <span class="string">&quot;abc&quot;</span></span><br><span class="line"><span class="built_in">print</span>(str3.isalpha(), str4.isalpha())</span><br><span class="line"></span><br><span class="line">str5 = <span class="string">&quot;9527&quot;</span></span><br><span class="line">str6 = <span class="string">&quot;1&quot;</span></span><br><span class="line">str7 = <span class="string">&quot;一&quot;</span></span><br><span class="line"><span class="built_in">print</span>(str5.isdecimal(), str6.isdigit(), str7.isnumeric())</span><br><span class="line"></span><br><span class="line">str8 = <span class="string">&quot;Xiaotang&quot;</span></span><br><span class="line"><span class="built_in">print</span>(str8.istitle())</span><br><span class="line"></span><br><span class="line">str9 = <span class="string">&quot;xiaotang&quot;</span></span><br><span class="line">str10 = <span class="string">&quot;XIAOTANG&quot;</span></span><br><span class="line"><span class="built_in">print</span>(str9.islower(), str10.isupper())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="literal">False</span> <span class="literal">True</span></span><br><span class="line"><span class="literal">False</span> <span class="literal">True</span></span><br><span class="line"><span class="literal">True</span> <span class="literal">True</span> <span class="literal">True</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="literal">True</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><h3 id="👀-查找和替换"><a href="#👀-查找和替换" class="headerlink" title="👀 查找和替换"></a>👀 查找和替换</h3><table><thead><tr><th align="left">方法</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">string.startswith(str)</td><td align="left">检查字符串是否是以str开头，是则返回True</td></tr><tr><td align="left">string.endswith(str)</td><td align="left">检查字符串是否是以str结束，是则返回True</td></tr><tr><td align="left">string.find(str,start&#x3D;0,end&#x3D;len(string))</td><td align="left">检测str是否包含在string中，如果start和end指定范围，则检查是否包含在指定范围内，如果是返回开始的索引值，否则返回-1</td></tr><tr><td align="left">string.rfind(str,start&#x3D;0,end&#x3D;len(string))</td><td align="left">类似于find()，不过是从右边开始查找</td></tr><tr><td align="left">string.index(str,start&#x3D;0,end&#x3D;len(string))</td><td align="left">跟find()方法类似，不过如果str不在string会报错</td></tr><tr><td align="left">string.rindex(str,start&#x3D;0,end&#x3D;len(string))</td><td align="left">类似于index()，不过是从右边开始</td></tr><tr><td align="left">string.replace(old_str,new_str,num&#x3D;string.count(old))</td><td align="left">把string中的old_str替换成new_str，如果num指定，则替换不超过num次</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">str1 = <span class="string">&quot;his name is xiaotang, see you&quot;</span></span><br><span class="line"><span class="built_in">print</span>(str1.startswith(<span class="string">&quot;his&quot;</span>), str1.endswith(<span class="string">&quot;you&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(str1.find(<span class="string">&quot;is&quot;</span>, <span class="number">0</span>, <span class="number">5</span>), str1.rfind(<span class="string">&quot;is&quot;</span>), str1.find(<span class="string">&quot;iss&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(str1.index(<span class="string">&quot;is&quot;</span>), str1.rindex(<span class="string">&quot;is&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(str1.replace(<span class="string">&quot;xiaotang&quot;</span>, <span class="string">&quot;heartlovelife&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="literal">True</span> <span class="literal">True</span></span><br><span class="line"><span class="number">1</span> <span class="number">9</span> -<span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">9</span></span><br><span class="line">his name <span class="keyword">is</span> heartlovelife, see you</span><br></pre></td></tr></table></figure><h3 id="👀-大小写转换"><a href="#👀-大小写转换" class="headerlink" title="👀 大小写转换"></a>👀 大小写转换</h3><table><thead><tr><th align="left">方法</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">string.capitalize()</td><td align="left">把字符串的第一个字符大写</td></tr><tr><td align="left">string.title()</td><td align="left">把字符串的每个单词首字母大写</td></tr><tr><td align="left">string.lower()</td><td align="left">转换string中所有大写字符为小写</td></tr><tr><td align="left">string.upper()</td><td align="left">转换string中的小写字母为大写</td></tr><tr><td align="left">string.swapcase()</td><td align="left">翻转string中的大小写</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">str1 = <span class="string">&quot;xiao tang heLLo heLLo&quot;</span></span><br><span class="line"><span class="built_in">print</span>(str1.capitalize())</span><br><span class="line"><span class="built_in">print</span>(str1.title())</span><br><span class="line"><span class="built_in">print</span>(str1.lower())</span><br><span class="line"><span class="built_in">print</span>(str1.upper())</span><br><span class="line"><span class="built_in">print</span>(str1.swapcase())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">Xiao tang hello hello</span><br><span class="line">Xiao Tang Hello Hello</span><br><span class="line">xiao tang hello hello</span><br><span class="line">XIAO TANG HELLO HELLO</span><br><span class="line">XIAO TANG HEllO HEllO</span><br></pre></td></tr></table></figure><h3 id="👀-文本对齐"><a href="#👀-文本对齐" class="headerlink" title="👀 文本对齐"></a>👀 文本对齐</h3><table><thead><tr><th align="left">方法</th><th>说明</th></tr></thead><tbody><tr><td align="left">string.ljust(width，[填充字符])</td><td>返回一个原字符串左对齐，并使用填充字符（默认空格）填充至长度width的新字符串</td></tr><tr><td align="left">string.rjust(width，[填充字符])</td><td>返回一个原字符串右对齐，并使用填充字符（默认空格）填充至长度width的新字符串</td></tr><tr><td align="left">string.center(width，[填充字符])</td><td>返回一个原字符串居中，并使用填充字符（默认空格）填充至长度width的新字符串</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">str1 = <span class="string">&quot;-xiaotang hello hello-&quot;</span></span><br><span class="line"><span class="built_in">print</span>(str1.ljust(<span class="number">50</span>,<span class="string">&quot;a&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(str1.rjust(<span class="number">50</span>,<span class="string">&quot;b&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(str1.center(<span class="number">50</span>,<span class="string">&quot;a&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">-xiaotang hello hello-aaaaaaaaaaaaaaaaaaaaaaaaaaaa</span><br><span class="line">bbbbbbbbbbbbbbbbbbbbbbbbbbbb-xiaotang hello hello-</span><br><span class="line">aaaaaaaaaaaaaa-xiaotang hello hello-aaaaaaaaaaaaaa</span><br></pre></td></tr></table></figure><h3 id="👀去除空白字符"><a href="#👀去除空白字符" class="headerlink" title="👀去除空白字符"></a>👀去除空白字符</h3><table><thead><tr><th align="left">方法</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">string.lstrip()</td><td align="left">截掉string左边（开始）的空白字符</td></tr><tr><td align="left">string.rstrip()</td><td align="left">截掉string右边（末尾）的空白字符</td></tr><tr><td align="left">string.strip()</td><td align="left">截掉 string左右两边的空白字符</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">str1 = <span class="string">&quot;   xiaotangxiaotang   &quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;=&quot;</span>*<span class="number">5</span>, str1.lstrip(), <span class="string">&quot;=&quot;</span>*<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;=&quot;</span>*<span class="number">5</span>, str1.rstrip(), <span class="string">&quot;=&quot;</span>*<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;=&quot;</span>*<span class="number">5</span>, str1.strip(), <span class="string">&quot;=&quot;</span>*<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">===== xiaotangxiaotang    =====</span><br><span class="line">=====    xiaotangxiaotang =====</span><br><span class="line">===== xiaotangxiaotang =====</span><br></pre></td></tr></table></figure><h3 id="👀拆分和连接"><a href="#👀拆分和连接" class="headerlink" title="👀拆分和连接"></a>👀拆分和连接</h3><table><thead><tr><th align="left">方法</th><th>说明</th></tr></thead><tbody><tr><td align="left">string.partition(str)</td><td>把字符串string分成一个3元素的元组（str前面，str，str 后面）</td></tr><tr><td align="left">string.rpartition(str)</td><td>类似于partition()方法，不过是从右边开始查找</td></tr><tr><td align="left">string.split(str&#x3D;””,num)</td><td>以str为分隔符拆分string，返回列表；如果num有指定值，则仅分隔num+1个子字符串，str默认包含’r’，’t’，’n’和空格</td></tr><tr><td align="left">string.splitlines()</td><td>按照行（’r’，’n’，’rn’）分隔，返回一个包含各行作为元素的列表</td></tr><tr><td align="left">string.join(seq)</td><td>以string作为分隔符，将seq（要连接的元素序列）中所有的元素合并为一个新的字符串</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">str1 = <span class="string">&quot;xiaotang=or=xiaoming=or=xiaolizi&quot;</span></span><br><span class="line">str2 = <span class="string">&quot;xiaotang=or=xiaoming=or=xiaolizi\nxiaotang&quot;</span></span><br><span class="line">str3 = (<span class="string">&quot;I&quot;</span>,<span class="string">&quot;love&quot;</span>,<span class="string">&quot;you&quot;</span>)</span><br><span class="line">str4 = [<span class="string">&quot;I&quot;</span>,<span class="string">&quot;love&quot;</span>,<span class="string">&quot;you&quot;</span>]</span><br><span class="line"><span class="built_in">print</span>(str1.partition(<span class="string">&quot;or&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(str1.rpartition(<span class="string">&quot;or&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(str1.split(<span class="string">&quot;=&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(str2.splitlines())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;@&quot;</span>.join(str3))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;#&quot;</span>.join(str4))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">(<span class="string">&#x27;xiaotang=&#x27;</span>, <span class="string">&#x27;or&#x27;</span>, <span class="string">&#x27;=xiaoming=or=xiaolizi&#x27;</span>)</span><br><span class="line">(<span class="string">&#x27;xiaotang=or=xiaoming=&#x27;</span>, <span class="string">&#x27;or&#x27;</span>, <span class="string">&#x27;=xiaolizi&#x27;</span>)</span><br><span class="line">[<span class="string">&#x27;xiaotang&#x27;</span>, <span class="string">&#x27;or&#x27;</span>, <span class="string">&#x27;xiaoming&#x27;</span>, <span class="string">&#x27;or&#x27;</span>, <span class="string">&#x27;xiaolizi&#x27;</span>]</span><br><span class="line">[<span class="string">&#x27;xiaotang=or=xiaoming=or=xiaolizi&#x27;</span>, <span class="string">&#x27;xiaotang&#x27;</span>]</span><br><span class="line">I@love@you</span><br><span class="line">I<span class="comment">#love#you</span></span><br></pre></td></tr></table></figure><h3 id="👀字符串的切片"><a href="#👀字符串的切片" class="headerlink" title="👀字符串的切片"></a>👀字符串的切片</h3><p><strong>切片</strong>方法适用于<strong>字符串</strong>、<strong>列表</strong>、<strong>元组</strong></p><ul><li><strong>切片</strong>使用<strong>索引值</strong>来限定范围，从一个大的字符串中切出小的字符串</li><li><strong>列表</strong>和<strong>元组</strong>都是有序的集合，都能够<strong>通过索引值</strong>获取对应的数据</li><li><strong>字典</strong>是一个无序的集合，是使用<strong>键值对</strong>保存数据</li></ul><p>注意事项：</p><ul><li>指定的区间属于左闭右开型<code>[开始索引，结束索引]</code>相当于从起始位开始，到结束位的前一位结束（<strong>不包含结束位本身</strong>）</li><li>从头开始，<strong>开始索引</strong>数字可以省略，冒号不能省略</li><li>到末尾结束，<strong>结束索引</strong>数字可以省略，冒号不能省略</li><li>步长默认为1，如果连续切片，数字和冒号都可以省略</li><li>不仅支持<strong>顺序索引</strong>，还支持<strong>倒序索引</strong>；所谓倒序索引就是从右向左计算索引，最右边的索引值是**-1**，依次递减。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">str</span> = <span class="string">&quot;xiaotang9527helloworld&quot;</span></span><br><span class="line"><span class="comment"># 截取3~6位置的字符串,相当于索引为[2:5],因为不包含末尾,所以为[2,6]</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[<span class="number">2</span>:<span class="number">6</span>])</span><br><span class="line"><span class="comment"># 截取3~末尾的字符串</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[<span class="number">2</span>:])</span><br><span class="line"><span class="comment"># 截取从开始~6位置的字符串,6位置相当于索引为5,因为不包含末尾,所以为[:6]</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[:<span class="number">6</span>])</span><br><span class="line"><span class="comment"># 取完整的字符串</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[:])</span><br><span class="line"><span class="comment"># 从开始位置,每隔一个字符截取字符串</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[::<span class="number">2</span>])</span><br><span class="line"><span class="comment"># 倒序切片</span></span><br><span class="line"><span class="comment"># -1表示倒数第一个字符</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[-<span class="number">1</span>])</span><br><span class="line"><span class="comment"># 截取3-末尾的字符串(不包含最后一个字符)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[<span class="number">2</span>:-<span class="number">1</span>])</span><br><span class="line"><span class="comment"># 截取字符串末尾两个字符</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[-<span class="number">2</span>:])</span><br><span class="line"><span class="comment"># 字符串的逆序</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[::-<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">aota</span><br><span class="line">aotang9527helloworld</span><br><span class="line">xiaota</span><br><span class="line">xiaotang9527helloworld</span><br><span class="line">xatn92hlool</span><br><span class="line">d</span><br><span class="line">aotang9527helloworl</span><br><span class="line">ld</span><br><span class="line">dlrowolleh7259gnatoaix</span><br></pre></td></tr></table></figure><h2 id="⛄公共方法及特殊用法"><a href="#⛄公共方法及特殊用法" class="headerlink" title="⛄公共方法及特殊用法"></a>⛄公共方法及特殊用法</h2><h3 id="👀内置函数"><a href="#👀内置函数" class="headerlink" title="👀内置函数"></a>👀内置函数</h3><table><thead><tr><th>函数</th><th>描述</th><th>备注</th></tr></thead><tbody><tr><td>len(item)</td><td>计算容器中元素个数</td><td></td></tr><tr><td>del(item)</td><td>删除变量</td><td>del有两种方式</td></tr><tr><td>max(item)</td><td>返回容器中元素最大值</td><td>如果是字典，只针对key比较</td></tr><tr><td>min(item)</td><td>返回容器中元素最小值</td><td>如果是字典，只针对key比较</td></tr><tr><td>cmp(item1,item2)</td><td>比较两个值，-1小于&#x2F;0相等&#x2F;1大于</td><td>Python3.x取消了cmp函数</td></tr></tbody></table><h3 id="👀运算符特殊用法"><a href="#👀运算符特殊用法" class="headerlink" title="👀运算符特殊用法"></a>👀运算符特殊用法</h3><table><thead><tr><th>运算符</th><th>表达式</th><th>结果</th><th>描述</th><th>支持数据类型</th></tr></thead><tbody><tr><td>+</td><td>[1,2] + [3,4]</td><td>[1,2,3,4]</td><td>合并</td><td>字符串、列表、元组</td></tr><tr><td>*</td><td>[“a”] * 2</td><td>[“a”,”a”]</td><td>重复</td><td>字符串、列表、元组</td></tr><tr><td>in</td><td>2 in (1,2,3)</td><td>True</td><td>元素是否存在</td><td>字符串、列表、元组、字典</td></tr><tr><td>not in</td><td>5 not in(1,2,3)</td><td>True</td><td>元素是否不存在</td><td>字符串、列表、元组、字典</td></tr></tbody></table><blockquote><p><code>in</code> 在对字典操作时，判断的是字典的键；<code>in</code>和<code>not in</code>被称为成员运算符，用于测试序列中是否包含指定的成员。</p></blockquote><h3 id="👀完成的for循环语法·"><a href="#👀完成的for循环语法·" class="headerlink" title="👀完成的for循环语法·"></a>👀完成的for循环语法·</h3><p>在Python中完整的<code>for</code>循环语法如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> 变量 <span class="keyword">in</span> 集合:</span><br><span class="line">循环体代码</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">没有通过<span class="keyword">break</span>退出循环，循环结束后，会执行的代码</span><br></pre></td></tr></table></figure><p>应用场景</p><ol><li>在迭代遍历嵌套的数据类型时，例如一个列表包含了多个字典</li><li>需求：判断某一个字典中，是否存在指定的值</li></ol><ul><li>如果存在，提示并且退出循环</li><li>如果不存在，在循环整体结束后，希望得到一个统一的提示</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 第一种</span></span><br><span class="line">stu = [</span><br><span class="line">       &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;xiaotang&quot;</span>,</span><br><span class="line">        <span class="string">&quot;age&quot;</span>: <span class="string">&quot;25&quot;</span>,</span><br><span class="line">        <span class="string">&quot;gender&quot;</span>: <span class="literal">True</span>,</span><br><span class="line">        <span class="string">&quot;height&quot;</span>: <span class="number">180</span>,</span><br><span class="line">        <span class="string">&quot;weight&quot;</span>: <span class="number">66</span>&#125;,</span><br><span class="line">       &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;xiaoming&quot;</span>,</span><br><span class="line">        <span class="string">&quot;age&quot;</span>: <span class="string">&quot;26&quot;</span>,</span><br><span class="line">        <span class="string">&quot;gender&quot;</span>: <span class="literal">True</span>,</span><br><span class="line">        <span class="string">&quot;height&quot;</span>: <span class="number">179</span>,</span><br><span class="line">        <span class="string">&quot;weight&quot;</span>: <span class="number">65</span>&#125;</span><br><span class="line">       ]</span><br><span class="line">find_name = <span class="string">&quot;xiaotang&quot;</span></span><br><span class="line"><span class="keyword">for</span> stu_dict <span class="keyword">in</span> stu:</span><br><span class="line">    <span class="built_in">print</span>(stu_dict)</span><br><span class="line">    <span class="comment"># 判断当前遍历的字典中姓名是否为find_name</span></span><br><span class="line">    <span class="keyword">if</span> stu_dict[<span class="string">&quot;name&quot;</span>] == find_name:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;找到阿汤了&quot;</span>)</span><br><span class="line">        <span class="comment"># 如果找到,直接退出循环,不需对后续的数据进行比较</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;怎么搞的，没有找到！！&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;循环结束&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;xiaotang&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="string">&#x27;25&#x27;</span>, <span class="string">&#x27;gender&#x27;</span>: <span class="literal">True</span>, <span class="string">&#x27;height&#x27;</span>: <span class="number">180</span>, <span class="string">&#x27;weight&#x27;</span>: <span class="number">66</span>&#125;</span><br><span class="line">找到阿汤了</span><br><span class="line">循环结束</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二种</span></span><br><span class="line">stu = [</span><br><span class="line">       &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;xiaotang&quot;</span>,</span><br><span class="line">        <span class="string">&quot;age&quot;</span>: <span class="string">&quot;25&quot;</span>,</span><br><span class="line">        <span class="string">&quot;gender&quot;</span>: <span class="literal">True</span>,</span><br><span class="line">        <span class="string">&quot;height&quot;</span>: <span class="number">180</span>,</span><br><span class="line">        <span class="string">&quot;weight&quot;</span>: <span class="number">66</span>&#125;,</span><br><span class="line">       &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;xiaoming&quot;</span>,</span><br><span class="line">        <span class="string">&quot;age&quot;</span>: <span class="string">&quot;26&quot;</span>,</span><br><span class="line">        <span class="string">&quot;gender&quot;</span>: <span class="literal">True</span>,</span><br><span class="line">        <span class="string">&quot;height&quot;</span>: <span class="number">179</span>,</span><br><span class="line">        <span class="string">&quot;weight&quot;</span>: <span class="number">65</span>&#125;</span><br><span class="line">       ]</span><br><span class="line">find_name = <span class="string">&quot;xiaotang1&quot;</span></span><br><span class="line"><span class="keyword">for</span> stu_dict <span class="keyword">in</span> stu:</span><br><span class="line">    <span class="built_in">print</span>(stu_dict)</span><br><span class="line">    <span class="comment"># 判断当前遍历的字典中姓名是否为find_name</span></span><br><span class="line">    <span class="keyword">if</span> stu_dict[<span class="string">&quot;name&quot;</span>] == find_name:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;找到阿汤了&quot;</span>)</span><br><span class="line">        <span class="comment"># 如果找到,直接退出循环,不需对后续的数据进行比较</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;怎么搞的，没有找到！！&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;循环结束&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;xiaotang&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="string">&#x27;25&#x27;</span>, <span class="string">&#x27;gender&#x27;</span>: <span class="literal">True</span>, <span class="string">&#x27;height&#x27;</span>: <span class="number">180</span>, <span class="string">&#x27;weight&#x27;</span>: <span class="number">66</span>&#125;</span><br><span class="line">&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;xiaoming&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="string">&#x27;26&#x27;</span>, <span class="string">&#x27;gender&#x27;</span>: <span class="literal">True</span>, <span class="string">&#x27;height&#x27;</span>: <span class="number">179</span>, <span class="string">&#x27;weight&#x27;</span>: <span class="number">65</span>&#125;</span><br><span class="line">怎么搞的，没有找到！！</span><br><span class="line">循环结束</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Python基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python基础知识（03）</title>
      <link href="/2022/08/07/Python-Basic03/"/>
      <url>/2022/08/07/Python-Basic03/</url>
      
        <content type="html"><![CDATA[<p>作为一个实用主义的学习者，最关心的问题一定是【我为什么要选择学<code>Python</code>，学会之后我可以用来做什么？】首先，对于初学者来说，比起其它编程语言，<code>Python</code>更容易上手。<code>Python</code>的设计哲学是优雅、明确、简单。</p><blockquote><p>在官方的The Zen of Python《Python之禅》中：There should be one – and preferably only one – obvious way to do it.</p></blockquote><p><code>Python</code>追求的是找到最好的解决方案。</p><h2 id="⛄函数"><a href="#⛄函数" class="headerlink" title="⛄函数"></a>⛄函数</h2><p>所谓函数，就是把具有独立功能的代码块组织为一个小模块，在需要的时候调用。</p><p>函数的使用包含两个步骤：</p><p>（1）定义函数——封装独立的功能；</p><p>（2）调用函数——享受封装的成果；</p><p>函数的作用，在开发程序时，使用函数可以提高编写的效率以及代码的重用。其实我们早已掌握了函数的用法，例如：</p><blockquote><p><code>print</code>() ：是一个放入对象就能将结果打印的函数；</p><p><code>input</code>()：是一个可以让用户输入信息的函数；</p><p><code>len</code>()：是一个可以测量对象长度的函数；</p><p><code>int</code>()：是一个可以将字符串类型的数字转换成是整数类型的函数。</p></blockquote><p>通过观察其实不难发现，<code>Python</code>中所谓的函数就是把你要处理的对象放到一个名字后面的括号里就可以了。</p><h3 id="👀函数的定义"><a href="#👀函数的定义" class="headerlink" title="👀函数的定义"></a>👀函数的定义</h3><p>定义函数的格式如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">函数名</span>（参数<span class="number">1</span>，参数<span class="number">2</span>）:</span><br><span class="line">函数封装的代码</span><br><span class="line"><span class="keyword">return</span> </span><br></pre></td></tr></table></figure><p>（1）<code>def</code>：是英文<code>define</code>的缩写。</p><p>（2）函数名称：应该能够表达函数封装代码的功能，方便后续的调用。</p><p>（3）函数名称的命名应该符合标识符的命名规则。</p><p>​①可以由字母、下划线和数字组成</p><p>​②不能以数字开头</p><p>​③不能与关键字重名</p><blockquote><p>函数调用：调用函数很简单的，通过<code>函数名（）</code>即可完成对函数的调用；函数调用应该放在函数定义的下方。</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">say_hello</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;hello world_1&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;hello world_2&quot;</span>)</span><br><span class="line"><span class="comment"># 只有在调用函数时，之前定义的函数才会执行</span></span><br><span class="line"><span class="comment"># 函数执行完成之后，会重新回到之前的程序中，继续执行后续的代码</span></span><br><span class="line">say_hello()</span><br></pre></td></tr></table></figure><h3 id="👀函数的参数"><a href="#👀函数的参数" class="headerlink" title="👀函数的参数"></a>👀函数的参数</h3><p><strong>函数</strong>，把<strong>具有独立功能的代码块</strong>组织为一个小模块，在需要的时候调用。</p><p><strong>函数的参数</strong>，增加函数的通用性，针对相同数据处理逻辑，能够适应更多的数据。</p><p>（1）在函数内部，把参数当做变量使用，进行需要的数据处理；</p><p>（2）函数调用时，按照函数定义的参数顺序，把希望在函数内部处理的数据，通过参数传递。</p><blockquote><p>形参：定义函数时，小括号中的参数，是用来接收参数用的，在函数内部作为变量使用；</p><p>实参：调用函数时，小括号中的参数，是用来把数据传递到函数内部用的。</p></blockquote><p>函数返回值。在程序开发中，有时候，会希望一个函数执行结束后，告诉调用者一个结果，以便调用者针对具体的结果做后续的处理。</p><p>返回值是函数完成工作后，最后给调用者的一个结果；在函数中使用<code>return</code>关键字可以返回结果；调用函数一方，可以使用变量来接收函数的返回结果。</p><blockquote><p>注意：return表示返回，后续的代码都不会被执行。</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sum</span>(<span class="params">num1, num2</span>):</span><br><span class="line">    <span class="keyword">return</span> num1 + num2</span><br><span class="line"><span class="comment"># 调用函数，并使用result变量接收计算结果</span></span><br><span class="line">result = <span class="built_in">sum</span>(<span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;计算结果是%d&quot;</span>%result)</span><br></pre></td></tr></table></figure><h2 id="⛄数据结构"><a href="#⛄数据结构" class="headerlink" title="⛄数据结构"></a>⛄数据结构</h2><p>   <code>Python</code> 有四种数据结构，分别是：列表、字典、元组，集合。每种数据结构都有自己的特点，并且都有着独到的用处。为了避免过早地陷入细枝末节，我们先从整体上来认识一下这四种数据结构：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">list</span> = [vall,val2,val3,val4]</span><br><span class="line"><span class="built_in">dict</span> = &#123;key1:vall,key2:val2&#125;</span><br><span class="line"><span class="built_in">tuple</span> = (vall,val2,val3,val4)</span><br><span class="line"><span class="built_in">set</span> = &#123;vall,val2,val3,val4&#125;</span><br></pre></td></tr></table></figure><p>从最容易识别的特征上来说，列表中的元素使用方括号扩起来，字典和集合是花括号，而元组则是圆括号。其中字典中的元素是均带有”:”的<code>key</code>与<code>value</code>的对应关系组。</p><p><code>Python</code>中数据类型可以分为<strong>数字型</strong>和<strong>非数字型</strong></p><p>（1）数字型</p><ul><li><p>整型（<code>int</code>）</p></li><li><p>浮点型（<code>float</code>）</p></li><li><p>布尔型（<code>bool</code>）</p><ul><li>真<code>True</code>非<code>0</code>数——<strong>非零即真</strong></li><li>假<code>False</code>  0</li></ul></li><li><p>复数型（<code>complex</code>）主要用于科学计算，例如：平面场问题、波动问题、电感电容等问题</p></li></ul><p>（2）非数字型</p><ul><li>字符串</li><li>列表</li><li>元组</li><li>字典</li></ul><p>（3）在<code>Python</code>中，所有非数字型变量都支持以下特点</p><ul><li>都是一个序列<code>sequence</code>，也可以理解为容器</li><li>取值<code>[]</code></li><li>遍历<code>for in</code></li><li>计算长度、最大&#x2F;最小值、比较、删除</li><li>链接<code>+</code>和重复<code>*</code></li><li>切片</li></ul><h3 id="👀列表"><a href="#👀列表" class="headerlink" title="👀列表"></a>👀列表</h3><p>列表具有的最显著的特征：</p><ul><li>列表中的每一个元素都是<strong>可变</strong>的；</li><li>列表中的元素是<strong>有序</strong>的，也就是说每一个元素都有一个位置；</li><li>列表可以容纳<code>Python</code>中的任何对象。</li></ul><p>列表中的元素是可变的，这意味着我们可以在列表中添加、删除和修改元素。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Weekday = [<span class="string">&quot;Monday&quot;</span>, <span class="string">&quot;Tuesday&quot;</span>, <span class="string">&quot;Wednesday&quot;</span>, <span class="string">&quot;Thursday&quot;</span>, <span class="string">&quot;Friday&quot;</span>, <span class="string">&quot;Sunday&quot;</span>]</span><br><span class="line"><span class="built_in">print</span>(Weekday[<span class="number">0</span>])</span><br></pre></td></tr></table></figure><p><code>List</code>（列表）是<code>Python</code>中使用最频繁的数据类型，在其他语言中通常叫做数组。专门用于存储一串信息；列表用<code>[]</code>定义，数据之间使用<code>,</code>分隔；列表的索引从0开始。</p><blockquote><p>索引就是数据在列表中的位置编号，索引又可以被称为下标。从列表中取值时，如果超出索引范围，程序会报错</p></blockquote><table><thead><tr><th align="center">序号</th><th align="center">分类</th><th align="center">关键字&#x2F;函数&#x2F;方法</th><th align="center">说明描述</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">增加</td><td align="center">列表.<code>insert</code>(索引，数据)</td><td align="center">在指定位置插入数据</td></tr><tr><td align="center"></td><td align="center"></td><td align="center">列表.<code>append</code>(数据)</td><td align="center">在末尾追加数据</td></tr><tr><td align="center"></td><td align="center"></td><td align="center">列表.<code>extend</code>(列表2)</td><td align="center">将列表2的数据追加到列表</td></tr><tr><td align="center">2</td><td align="center">修改</td><td align="center">列表[索引] &#x3D; 数据</td><td align="center">修改指定索引的数据</td></tr><tr><td align="center">3</td><td align="center">删除</td><td align="center"><code>del</code> 列表[索引]</td><td align="center">删除指定索引的数据</td></tr><tr><td align="center"></td><td align="center"></td><td align="center">列表.<code>remove</code>[数据]</td><td align="center">删除第一个出现的指定数据</td></tr><tr><td align="center"></td><td align="center"></td><td align="center">列表.<code>pop</code></td><td align="center">删除末尾数据</td></tr><tr><td align="center"></td><td align="center"></td><td align="center">列表.<code>pop</code>(索引)</td><td align="center">删除指定索引数据</td></tr><tr><td align="center"></td><td align="center"></td><td align="center">列表.<code>clear</code></td><td align="center">清空列表</td></tr><tr><td align="center">4</td><td align="center">统计</td><td align="center"><code>len</code>(列表)</td><td align="center">列表长度</td></tr><tr><td align="center"></td><td align="center"></td><td align="center">列表.<code>count</code>(数据)</td><td align="center">数据在列表中出现的次数</td></tr><tr><td align="center">5</td><td align="center">排序</td><td align="center">列表.<code>sort</code>()</td><td align="center">升序排序</td></tr><tr><td align="center"></td><td align="center"></td><td align="center">列表.<code>sort</code>(<code>reverse</code> &#x3D; <code>True</code>)</td><td align="center">降序排序</td></tr><tr><td align="center"></td><td align="center"></td><td align="center">列表.<code>reverse</code>()</td><td align="center">逆序、反转</td></tr></tbody></table><p><strong><code>del</code>关键字</strong></p><ul><li>使用<code>del</code>关键字（<code>delete</code>）同样可以删除列表中元素；</li><li><code>del</code>关键字本质上是用来将一个变量从内存中删除的；</li><li>如果使用<code>del</code>关键字将变量从内存中删除，后续的代码就不能再使用这个变量了。</li></ul><p>在日常开发中，要从列表删除数据，建议使用列表提供的方法。</p><p><strong>循环遍历</strong></p><p>遍历就是从头到尾依次从列表中获取数据；在循环体内部针对每一个元素，执行相同的操作。在<code>Python</code>中为了提高列表的遍历效率，专门提供的迭代<code>iteration</code>遍历。使用<code>for</code>就能实现迭代遍历。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> name_list:</span><br><span class="line">    <span class="built_in">print</span>(name)</span><br></pre></td></tr></table></figure><p><strong>应用场景</strong></p><p>尽管Python的列表中可以存储不同类型的数据。但是在开发中，更多的应用场景是</p><ul><li>列表存储相同类型的数据</li><li>通过迭代遍历，在循环体内部，针对列表中的每一项元素，执行相同的操作</li></ul><h3 id="👀元组（Tuple）"><a href="#👀元组（Tuple）" class="headerlink" title="👀元组（Tuple）"></a>👀元组（Tuple）</h3><p>元组其实可以理解成一个稳固版的列表，因为元组是<strong>不可修改</strong>的，因此在列表中的存在的方法均不可以使用在元组上，但是元组是可以被查看索引的，方式就和列表一样：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">letters = (<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>, <span class="string">&quot;e&quot;</span>, <span class="string">&quot;f&quot;</span>, <span class="string">&quot;g&quot;</span>, <span class="string">&quot;h&quot;</span>)</span><br><span class="line">letter[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>（1）<code>Tuple</code>（元组）与列表类似，不同之处在于元组的元素不能修改</p><ul><li><p>元组表示多个元素组成的序列</p></li><li><p>元组在<code>Python</code>开发中，有特定的应用场景</p></li></ul><p>（2）用于存储一串信息，数据之间使用<code>,</code>分隔</p><p>（3）元组用<code>（）</code>定义</p><p>（4）元组的索引从<code>0</code>开始，索引就是数据在元组中的位置编号</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">info_tuple = (<span class="string">&quot;zhangsan&quot;</span>,<span class="number">18</span>,<span class="number">1.75</span>)</span><br><span class="line"><span class="comment"># 创建空元组</span></span><br><span class="line">first_tuple = ()</span><br><span class="line"><span class="comment"># 元组中只包含一个元素时，需要在元素后面添加逗号</span></span><br><span class="line">second_tuple = (<span class="number">50</span>,)</span><br></pre></td></tr></table></figure><blockquote><p>元组的索引值是从0开始的，<code>len</code>(元组)获取元组的长度n+1，元组.<code>count</code>(数据)数据在元组中出现的次数。</p></blockquote><ul><li>元组[索引]表示从列表中取值</li><li>元组.<code>index</code>[数据]表示获得数据第一次出现的索引。</li></ul><p><strong>循环遍历</strong></p><p>取值就是从元组中获取存储在指定位置的数据。</p><p>遍历就是从头到尾依次从元组中获取数据。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> name_tuple:</span><br><span class="line">    <span class="built_in">print</span>(item)</span><br></pre></td></tr></table></figure><blockquote><p>在<code>Python</code>中，可以使用<code>for</code> 循环遍历所有非数字型类型的变量：列表、元组、字典以及字符串提示：在实际开发中，除非能够确认元组中的数据类型，否则针对元组的循环遍历需求并不是很多</p></blockquote><p><strong>应用场景</strong></p><p>尽管可以使用<code>for in</code> 遍历元组。但是在开发中，更多的应用场景是：</p><ul><li>函数的参数和返回值，一个函数可以接收任意多个参数，或者一次返回多个数据（可以利用元组保存数据，即返回值默认是以元组形式保存的）；</li><li>格式化字符串，格式化字符串后面的（）本质上就是一个元组；</li><li>让列表不可以被修改，以保护数据安全。</li></ul><p><strong>元组和列表之间的转换</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用list函数可以把元组转换成列表</span></span><br><span class="line"><span class="built_in">list</span>(元组)</span><br><span class="line"><span class="comment"># 使用tuple函数可以把列表转换成元组</span></span><br><span class="line"><span class="built_in">tuple</span>(列表)</span><br></pre></td></tr></table></figure><h3 id="👀字典-Dictionary"><a href="#👀字典-Dictionary" class="headerlink" title="👀字典(Dictionary)"></a>👀字典(Dictionary)</h3><p>编程世界中其实有很多概念都基于现实生活的原型，字典这种数据结构的特征也正如现实世界中的字典一样，使用名称一内容进行数据的构建，在<code>Python</code>中分别对应着键（<code>key</code>）-值（<code>value</code>），习惯上称之为键值对。</p><p>字典的特征总结如下：</p><ul><li>字典中数据必须是以键值对的形式出现的；</li><li>逻辑上讲，键是不能重复的，而值可以重复；</li><li>字典中的键（<code>key</code>）是不可变的，也就是无法修改的；而值（<code>value</code>）是可变的，可修改的，可以是任何对象。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">xiaotang = &#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;xiaotang&quot;</span>,</span><br><span class="line">    <span class="string">&quot;age&quot;</span>: <span class="number">18</span>,</span><br><span class="line">    <span class="string">&quot;gender&quot;</span>: <span class="literal">True</span>,</span><br><span class="line">    <span class="string">&quot;height&quot;</span>: <span class="number">1.80</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（1）<code>dictionary</code>（字典）是除列表以外<code>Python</code>之中最灵活的数据类型</p><p>（2）字典同样可以用来存储多个数据</p><ul><li>通常用于存储描述一个物体的相关信息</li></ul><p>（3）字典和列表的区别</p><ul><li><strong>列表</strong>是<strong>有序</strong>的对象集合</li><li><strong>字典</strong>是<strong>无序</strong>的对象集合</li></ul><p>（4）字典用<code>&#123;&#125;</code>定义</p><p>（5）字典使用键值对存储数据，键值对之间使用<code>,</code>分隔</p><ul><li><p>键<code>key</code>是索引</p></li><li><p>值<code>value</code>是数据</p></li><li><p>键和值之间使用<code>:</code>分隔</p></li><li><p>键必须是唯一的</p></li><li><p>值可以取任何数据类型，但键只能使用字符串、数字或元组</p></li></ul><p><strong>字典的常用操作</strong></p><table><thead><tr><th align="center">关键字&#x2F;函数&#x2F;方法</th><th align="center">描述说明</th></tr></thead><tbody><tr><td align="center"><code>len</code>(字典)</td><td align="center">获取字典的键值对数量</td></tr><tr><td align="center">字典.<code>keys</code>()</td><td align="center">所有<code>key</code>列表</td></tr><tr><td align="center">字典.<code>values</code>()</td><td align="center">所有<code>value</code>列表</td></tr><tr><td align="center">字典.<code>items</code>()</td><td align="center">所有（<code>key</code>，<code>value</code>）元组列表</td></tr><tr><td align="center">字典[<code>key</code>]</td><td align="center">可以从字典中取值，<code>key</code>不存在会报错</td></tr><tr><td align="center">字典.<code>get(key)</code></td><td align="center">可以从字典中取值，<code>key</code>不存在不会报错</td></tr><tr><td align="center"><code>del</code> 字典<code>[key]</code></td><td align="center">删除指定键值对，<code>key</code>不存在会报错</td></tr><tr><td align="center">字典.<code>pop(key)</code></td><td align="center">删除指定键值对，<code>key</code>不存在会报错</td></tr><tr><td align="center">字典.<code>popitem()</code></td><td align="center">随机删除一个键值对</td></tr><tr><td align="center">字典.<code>clear()</code></td><td align="center">清空字典</td></tr><tr><td align="center">字典<code>[key]</code> &#x3D; <code>value</code></td><td align="center">如果<code>key</code>存在，修改数据<br />如果<code>key</code>不存在，新建键值对</td></tr><tr><td align="center">字典.<code>setdefault</code>(<code>key</code>, <code>value</code>)</td><td align="center">如果<code>key</code>存在，不会修改数据<br />如果<code>key</code>不存在，新建键值对</td></tr><tr><td align="center">字典1.<code>update</code>(字典2)</td><td align="center">将字典2的数据合并到字典1</td></tr></tbody></table><p><strong>循环遍历</strong></p><p>遍历就是依次从字典中获取所有键值对。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> item_key <span class="keyword">in</span> name_dic:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;%s: %s&quot;</span> % (item_key, name_dic[item_key]))</span><br></pre></td></tr></table></figure><blockquote><p>在实际开发中，由于字典中每一个键值对保存数据的类型是不同的，所以针对字典的循环遍历需求并不是很多。</p></blockquote><p><strong>应用场景</strong></p><p>尽管可以使用<code>for in</code>遍历字典。但是在开发中，更多的应用场景是：</p><ul><li>使用多个键值对，存储描述一个物体的相关信息——描述更复杂的数据信息</li><li>将多个字典放在一个列表中，再进行遍历，在循环体内部针对每一个字典进行相同的处理</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">card_list=[</span><br><span class="line">    &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;张三”，</span></span><br><span class="line"><span class="string">&quot;</span>qq<span class="string">&quot;: &quot;</span><span class="number">12345</span><span class="string">&quot;，</span></span><br><span class="line"><span class="string">&quot;</span>phone<span class="string">&quot;: &quot;</span><span class="number">110</span><span class="string">&quot;&#125;，</span></span><br><span class="line"><span class="string">&#123;&quot;</span>name<span class="string">&quot;: &quot;</span>李四<span class="string">&quot;，</span></span><br><span class="line"><span class="string">            &quot;</span>qq<span class="string">&quot;: &quot;</span><span class="number">54321</span><span class="string">&quot;，</span></span><br><span class="line"><span class="string">&quot;</span>phone<span class="string">&quot;: &quot;</span><span class="number">10086</span><span class="string">&quot;&#125;</span></span><br><span class="line"><span class="string">          ]</span></span><br></pre></td></tr></table></figure><h3 id="👀集合-Set"><a href="#👀集合-Set" class="headerlink" title="👀集合(Set)"></a>👀集合(Set)</h3><p>集合则更接近数学上集合的概念。每一个集合中的元素是<strong>无序的</strong>、<strong>不重复</strong>的任意对象，我们可以通过集合去判断数据的从属关系，有时还可以通过集合把数据结构中重复的元素减掉。</p><p>集合不能被切片也不能被索引，除了做集合运算之外，集合元素可以被添加还有删除。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">item_set = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;</span><br><span class="line">item_add(<span class="number">5</span>)</span><br><span class="line">item_discard(<span class="number">5</span>)</span><br></pre></td></tr></table></figure><p>参考文献：</p><p>《编程小白的第1本Python入门书》侯爵</p><p>《Python入门教程完整版》黑马程序员</p><p>《Python基础教程（第3版）》 Magnus Lie Hetland（著）袁国忠（译）</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Python基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python基础知识（02）</title>
      <link href="/2022/07/12/Python-Basic02/"/>
      <url>/2022/07/12/Python-Basic02/</url>
      
        <content type="html"><![CDATA[<p>编程语言是最有意思的，如果要实现一个复杂的功能或程序，条件语句和循环语句必不可少。除了常见的顺序结构，<code>if-elif-else</code>是常见的条件语句，当你写出这样的语句的时候，就意味着你告诉了计算机什么时候该怎么做，或者什么是不用做的。<code>for</code>循环和<code>while</code>循环是常见的循环语句，循环作为编程语言中最强力的特性之一，能够帮助我们做很多重复性的事情，比如批量命名、批量操作等。</p><h2 id="⛄顺序结构"><a href="#⛄顺序结构" class="headerlink" title="⛄顺序结构"></a>⛄顺序结构</h2><p>在我们最开始编写的基础程序中，语句都是逐条执行的。即从上而下，顺序执行代码。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = <span class="string">&quot;xiaotang&quot;</span></span><br><span class="line">name_describe =<span class="string">&quot;this is My name&quot;</span></span><br><span class="line">age = <span class="number">20</span></span><br><span class="line">age_describe = <span class="string">&quot;this is My age&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;=&quot;</span>*<span class="number">50</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;this is a line&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;this is another block&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hello World&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;My friends&quot;</span>)</span><br><span class="line">......</span><br></pre></td></tr></table></figure><h2 id="⛄分支结构"><a href="#⛄分支结构" class="headerlink" title="⛄分支结构"></a>⛄分支结构</h2><h3 id="👀布尔值"><a href="#👀布尔值" class="headerlink" title="👀布尔值"></a>👀布尔值</h3><p>现在，如果想更进一步，让程序选择是否执行特定的语句块，该怎么办呢？在介绍分支语句之前，我们先了解一下布尔值的用武之地，布尔值（<code>True</code>和<code>False</code>）作为一种变量的类型，实际上，<code>True</code>和<code>False</code>不过是0和1的别名，虽然看起来不同，但作用是相同的。换而言之，标准值<code>False</code>和<code>None</code>、各种类型（包括浮点数、复数等）的数值0、空序列（如空字符串、空元组和空列表）以及空映射（如空字典）都被视为假，而其他各种值都被视为真，包括特殊值<code>True</code>。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="literal">True</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="literal">False</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="literal">True</span> == <span class="number">1</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="literal">False</span> == <span class="number">0</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="literal">True</span> + <span class="literal">False</span> + <span class="number">20</span></span><br><span class="line"><span class="number">21</span></span><br></pre></td></tr></table></figure><blockquote><p>因此，如果你看到一个返回1或0的表达式（可能是使用较旧的<code>Python</code>版本编写的），就知道这实际上意味着<code>True</code>或<code>False</code>。</p></blockquote><p>布尔值<code>True</code>和<code>False</code>属于类型<code>bool</code>，而<code>bool</code>与<code>list</code>、<code>str</code>和<code>tuple</code>一样，可用来转换其他的值。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">bool</span>(<span class="string">&quot;I think, there I am&quot;</span>)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">bool</span>(<span class="number">20</span>)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">bool</span>(<span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">bool</span>(<span class="number">0</span>)</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure><blockquote><p>鉴于任何值都可用作布尔值，因此你几乎不需要显式地进行转换（<code>Python</code>会自动转换）。</p></blockquote><h3 id="👀if语句"><a href="#👀if语句" class="headerlink" title="👀if语句"></a>👀if语句</h3><p>真值可合并，至于如何合并稍后再讲，先来看看真值可用来做什么。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = <span class="built_in">input</span>(<span class="string">&quot;请输入你的语句：&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> name.endswith(<span class="string">&quot;wow!!&quot;</span>)：</span><br><span class="line"><span class="built_in">print</span>（<span class="string">&quot;hello xiaotang wow!!&quot;</span>）</span><br></pre></td></tr></table></figure><blockquote><p><code>endswith()</code>方法用于判断字符串是否以指定后缀结尾，如果以指定后缀结尾返回<code>True</code>，否则返回<code>False</code>。可选参数”<code>start</code>“和”<code>end</code>“为检索字符串的开始与结束位置。</p></blockquote><p>这就是if语句，让你能够有条件地执行代码。这意味着如果条件（<code>if</code>和冒号之间的表达式）为前面定义的真，就执行后续代码块（这里是一条<code>print</code>语句）；如果条件为假，就不执行（你应该猜到了）。</p><h3 id="👀else子句"><a href="#👀else子句" class="headerlink" title="👀else子句"></a>👀else子句</h3><p>在前一节的示例中，如果你输入以Gumby结尾的名字，方法<code>name.endswith</code>将返回<code>True</code>，导致后续代码块执行——打印问候语。如果你愿意，可使用else子句增加一种选择（之所以叫子句是因为<code>else</code>不是独立的语句，而是if语句的一部分）。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = <span class="built_in">input</span>(<span class="string">&quot;请输入你的语句：&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> name.endswith(<span class="string">&quot;wow!!&quot;</span>)：</span><br><span class="line"><span class="built_in">print</span>（<span class="string">&quot;hello xiaotang wow!!&quot;</span>）</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello people&quot;</span>)</span><br></pre></td></tr></table></figure><p>在这里，如果没有执行第一个代码块（因为条件为假），将进入第二个代码块。这个示例表明，<code>Python</code>代码很容易理解，不是吗？如果从if开始将代码大声朗读出来，听起来将像普通句子一样（也可能不那么普通）。</p><p>还有一个与<code>if</code>语句很像的“亲戚”，它就是条件表达式——C语言中三目运算符的<code>Python</code>版本。下面的表达式使用<code>if</code>和<code>else</code>确定其值：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">status = <span class="string">&quot;friend&quot;</span> <span class="keyword">if</span> name.endswith(<span class="string">&quot;wow!!&quot;</span>) <span class="keyword">else</span> <span class="string">&quot;people&quot;</span></span><br></pre></td></tr></table></figure><p>如果条件（紧跟在if后面）为真，表达式的结果为提供的第一个值（这里为”<code>friend</code>“），否则为第二个值（这里为”<code>people</code>“）。</p><h3 id="👀elif子句"><a href="#👀elif子句" class="headerlink" title="👀elif子句"></a>👀elif子句</h3><p>要检查多个条件，可使用<code>elif</code>。<code>elif</code>是<code>else if</code>的缩写，由一个<code>if</code>子句和一个<code>else</code>子句组合而成，也就是包含条件的<code>else</code>子句。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">num = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;Enter a number: &#x27;</span>)) </span><br><span class="line"><span class="keyword">if</span> num &gt; <span class="number">0</span>: </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;The number is positive&#x27;</span>) </span><br><span class="line"><span class="keyword">elif</span> num &lt; <span class="number">0</span>: </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;The number is negative&#x27;</span>) </span><br><span class="line"><span class="keyword">else</span>: </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;The number is zero&#x27;</span>) </span><br></pre></td></tr></table></figure><h3 id="👀代码块嵌套"><a href="#👀代码块嵌套" class="headerlink" title="👀代码块嵌套"></a>👀代码块嵌套</h3><p>下面穿插点额外的内容。你可将if语句放在其他if语句块中，如下所示：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> 条件 <span class="number">1</span>：</span><br><span class="line"><span class="comment"># 条件1满足执行的代码</span></span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> 条件<span class="number">1</span>基础上的条件<span class="number">2</span>：</span><br><span class="line">    <span class="comment"># 条件2满足时，执行的代码</span></span><br><span class="line">        ......</span><br><span class="line"><span class="comment"># 条件2不满足的处理</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 条件2不满足时，执行的代码</span></span><br><span class="line"><span class="comment"># 条件1不满足的处理</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="comment"># 条件1不满足时，执行的代码</span></span><br><span class="line">    ......</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = <span class="built_in">input</span>(<span class="string">&#x27;What is your name? &#x27;</span>) </span><br><span class="line"><span class="keyword">if</span> name.endswith(<span class="string">&#x27;Gumby&#x27;</span>): </span><br><span class="line"><span class="keyword">if</span> name.startswith(<span class="string">&#x27;Mr.&#x27;</span>): </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Hello, Mr. Gumby&#x27;</span>) </span><br><span class="line"><span class="keyword">elif</span> name.startswith(<span class="string">&#x27;Mrs.&#x27;</span>): </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Hello, Mrs. Gumby&#x27;</span>) </span><br><span class="line"><span class="keyword">else</span>: </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Hello, Gumby&#x27;</span>) </span><br><span class="line"><span class="keyword">else</span>: </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Hello, stranger&#x27;</span>) </span><br></pre></td></tr></table></figure><p>在这里，如果名字以Gumby结尾，就同时检查名字开头，这是在第一个代码块中使用一条独立的if语句完成的。请注意，这里还使用了<code>elif</code>。最后一个分支（<code>else</code>子句）没有指定条件——如果没有选择其他分支，就选择最后一个分支。如果需要，这里的两个<code>else</code>子句都可省略。如果省略里面的<code>else</code>子句，将忽略并非以Mr.或Mrs.打头的名字（假设名字为Gumby）。如果省略外面的<code>else</code>子句，将忽略陌生人。</p><h2 id="⛄循环结构"><a href="#⛄循环结构" class="headerlink" title="⛄循环结构"></a>⛄循环结构</h2><p>至此，你知道了如何在条件为真（或假）时执行操作，但如何重复操作多次呢？例如，你可能想创建一个程序，要打印1~100的所有数。当然，你可能会想到：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="number">5</span>)</span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line"><span class="built_in">print</span>(<span class="number">98</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="number">99</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="number">100</span>)</span><br></pre></td></tr></table></figure><p>但如果你愿意使用笨办法，就不会求助于<code>Python</code>了，不是吗？</p><p>循环的作用就是让<strong>指定的代码</strong>重复的执行。</p><h3 id="👀while循环"><a href="#👀while循环" class="headerlink" title="👀while循环"></a>👀while循环</h3><p>为避免前述示例所示的繁琐代码，可以使用<code>while</code>循环快速地打印出1~100的所有数。<code>while</code>循环最常用的应用场景就是让<strong>执行的代码</strong>按照<strong>指定的次数重复</strong>执行。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = <span class="number">1</span> </span><br><span class="line"><span class="keyword">while</span> x &lt;= <span class="number">100</span>: </span><br><span class="line"><span class="built_in">print</span>(x) </span><br><span class="line">x += <span class="number">1</span></span><br></pre></td></tr></table></figure><p>就像上面那样做，不太复杂，不是吗？你还可以使用循环来确保用户输入名字，如下所示：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = <span class="string">&#x27;&#x27;</span> </span><br><span class="line"><span class="keyword">while</span> <span class="keyword">not</span> name: </span><br><span class="line">name = <span class="built_in">input</span>(<span class="string">&#x27;Please enter your name: &#x27;</span>) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Hello, &#123;&#125;!&#x27;</span>.<span class="built_in">format</span>(name)) </span><br></pre></td></tr></table></figure><p>请尝试运行这些代码，并在要求你输入名字时直接按回车键。你会看到提示信息再次出现，因为name还是为空字符串，这相当于假。</p><blockquote><p>如果你只是输入一个空格字符（将其作为你的名字），结果将如何呢？程序将接受这个名字，因为包含一个空格字符的字符串不是空的，因此不会将name视为假。这无疑是这个小程序的一个瑕疵，但很容易修复：只需将<code>while not name</code>改为<code>while not name or name.isspace()</code>或<code>while not name.strip()</code>即可。</p><p><code>isspace()</code>方法：如果字符串中的所有字符均为空格字符，则返回”<code>True</code>“，否则，返回”<code>False</code>“;</p><p><code>strip()</code>方法：用于移除字符串头尾指定的字符（默认为空格或换行符）或字符序列。该方法只能删除开头或结尾的字符，不能删除中间部分的字符。</p></blockquote><p><strong>while循环语句基本语法</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">初始条件设置--通常是重复执行的计数器</span><br><span class="line"><span class="keyword">while</span> 条件（判断计数器是否达到目标次数）：</span><br><span class="line">条件满足时，做的事情<span class="number">1</span></span><br><span class="line">    条件满足时，做的事情<span class="number">2</span></span><br><span class="line">    条件满足时，做的事情<span class="number">3</span></span><br><span class="line">    ......</span><br><span class="line">    处理条件（例如：计数器 + <span class="number">1</span>）</span><br></pre></td></tr></table></figure><p><code>while</code>语句以及缩进部分是一个<strong>完整的代码块</strong>。例子：打印100遍<code>Hello Python</code></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1 初始条件设置--通常是重复执行的计数器</span></span><br><span class="line">i = <span class="number">1</span></span><br><span class="line"><span class="comment"># 2 使用while判断条件</span></span><br><span class="line"><span class="keyword">while</span> i &lt;= <span class="number">5</span>：</span><br><span class="line"><span class="comment"># 要重复执行的代码</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello Python&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 处理计数器 i</span></span><br><span class="line">    i = i + <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;循环结束后 i = %d&quot;</span> % i)</span><br></pre></td></tr></table></figure><p>注意：循环结束后，之前定义的计数器条件的数值时依旧存在的。</p><blockquote><p>死循环，由于程序员的问题，忘记在循环内部<strong>修改循环的判断条件</strong>，导致<strong>循环持续执行</strong>，程序无法终止。</p></blockquote><h3 id="👀for循环"><a href="#👀for循环" class="headerlink" title="👀for循环"></a>👀for循环</h3><p><code>while</code>语句非常灵活，可用于在条件为真时反复执行代码块。这在通常情况下很好，但有时候你可能想根据需要进行定制。一种这样的需求是为序列（或其他可迭代对象）中每个元素执行代码块。</p><blockquote><p>基本上，可迭代对象是可使用for循环进行遍历的对象。就目前而言，只需将可迭代对象视为序列即可。</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">words = [<span class="string">&#x27;this&#x27;</span>, <span class="string">&#x27;is&#x27;</span>, <span class="string">&#x27;an&#x27;</span>, <span class="string">&#x27;ex&#x27;</span>, <span class="string">&#x27;parrot&#x27;</span>] </span><br><span class="line"><span class="keyword">for</span> word <span class="keyword">in</span> words: </span><br><span class="line"><span class="built_in">print</span>(word) </span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">numbers = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>] </span><br><span class="line"><span class="keyword">for</span> number <span class="keyword">in</span> numbers: </span><br><span class="line"><span class="built_in">print</span>(number)</span><br></pre></td></tr></table></figure><p>鉴于迭代（也就是遍历）特定范围内的数是一种常见的任务，<code>Python</code>提供了一个创建范围的内置函数。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">range</span>(<span class="number">0</span>, <span class="number">10</span>) </span><br><span class="line"><span class="built_in">range</span>(<span class="number">0</span>, <span class="number">10</span>) </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">0</span>, <span class="number">10</span>)) </span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>] </span><br></pre></td></tr></table></figure><p>范围类似于切片。它们包含起始位置（这里为0），但不包含结束位置（这里为10）。在很多情况下，你都希望范围的起始位置为0。实际上，如果只提供了一个位置，将把这个位置视为结束位置，并假定起始位置为0。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">range</span>(<span class="number">10</span>) </span><br><span class="line"><span class="built_in">range</span>(<span class="number">0</span>, <span class="number">10</span>) </span><br></pre></td></tr></table></figure><p>下面的程序打印数1～100：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> number <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">101</span>): </span><br><span class="line"><span class="built_in">print</span>(number) </span><br></pre></td></tr></table></figure><p>（1）迭代字典</p><p>要遍历字典的所有关键字，可像遍历序列那样使用普通的for语句。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d = &#123;<span class="string">&#x27;x&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;y&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;z&#x27;</span>: <span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> d:</span><br><span class="line"><span class="built_in">print</span>(key, <span class="string">&#x27;corresponds to&#x27;</span>, d[key])</span><br></pre></td></tr></table></figure><p>也可使用<code>keys</code>等字典方法来获取所有的键。如果只对值感兴趣，可使用<code>d.values</code>。你可能还记得，<code>d.items</code>以元组的方式返回键值对。<code>for</code>循环的优点之一是，可在其中使用序列解包。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> key, value <span class="keyword">in</span> d.items(): </span><br><span class="line"><span class="built_in">print</span>(key, <span class="string">&#x27;corresponds to&#x27;</span>, value)</span><br></pre></td></tr></table></figure><p>（2）遍历列表</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">names = [<span class="string">&#x27;anne&#x27;</span>, <span class="string">&#x27;beth&#x27;</span>, <span class="string">&#x27;george&#x27;</span>, <span class="string">&#x27;damon&#x27;</span>]</span><br><span class="line">ages = [<span class="number">12</span>, <span class="number">45</span>, <span class="number">32</span>, <span class="number">102</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(names)):</span><br><span class="line"><span class="built_in">print</span>(names[i], <span class="string">&#x27;is&#x27;</span>, ages[i], <span class="string">&#x27;years old&#x27;</span>) </span><br></pre></td></tr></table></figure><h3 id="👀break和continue"><a href="#👀break和continue" class="headerlink" title="👀break和continue"></a>👀break和continue</h3><p><code>break</code>和<code>continue</code>是专门在循环中使用的关键字。</p><blockquote><p><code>break</code>：在循环过程中，如果某一条件满足后，不希望执行循环，可以使用<code>break</code>退出循环；</p><p><code>continue</code>：在循环过程中，如果某一条件满足后，不希望执行循环，但又不退出循环，可以使用<code>continue</code>跳过当次循环。即：在整个循环中，只有某些条件，不需要执行循环代码，而其它条件都需要执行。</p></blockquote><h3 id="👀练习"><a href="#👀练习" class="headerlink" title="👀练习"></a>👀练习</h3><p>（1）打印小星星</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 打印小星星</span></span><br><span class="line">i = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> i &lt;= <span class="number">5</span>:</span><br><span class="line">    j = <span class="number">1</span></span><br><span class="line">    <span class="comment"># 在循环内部，再增加一个循环，实现每一行的星星打印</span></span><br><span class="line">    <span class="keyword">while</span> j &lt;= i:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>,end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">        j += <span class="number">1</span></span><br><span class="line">    <span class="comment"># 每一行星号输出完成后，再增加一个换行</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&quot;</span>)</span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">*</span><br><span class="line">**</span><br><span class="line">***</span><br><span class="line">****</span><br><span class="line">*****</span><br></pre></td></tr></table></figure><blockquote><p>默认情况下，<code>print()</code>函数输出内容之后，会自动在内容末尾增加换行；如果不希望末尾增加换行，可以在<code>print()</code>函数输出内容的后面增加，<code>end=&quot;&quot;</code>；其中””中间可以指定<code>print()</code>函数输出内容之后，继续希望显示的内容。</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 向控制台输出内容结束之后，不会换行</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>,end=<span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="comment"># 单纯的换行</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&quot;</span>)</span><br></pre></td></tr></table></figure><p>（2）打印九九乘法表</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 打印九九乘法表</span></span><br><span class="line">i = <span class="number">1</span></span><br><span class="line"><span class="comment"># 最大打印9行</span></span><br><span class="line"><span class="keyword">while</span> i &lt;= <span class="number">9</span>:</span><br><span class="line">    <span class="comment"># 定义起始列</span></span><br><span class="line">    j = <span class="number">1</span></span><br><span class="line">    <span class="comment"># 最大打印i列</span></span><br><span class="line">    <span class="keyword">while</span> j &lt;= i:</span><br><span class="line">        <span class="comment"># 转义字符，\t在控制台输出一个制表符，协助在输出文件时，垂直方向保持对齐</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%d*%d=%d&quot;</span>%(j,i,i*j),end=<span class="string">&quot;\t&quot;</span>)</span><br><span class="line">        j += <span class="number">1</span></span><br><span class="line">    <span class="comment"># 一行打印完成后，换行</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&quot;</span>)</span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="number">1</span>*<span class="number">1</span>=<span class="number">1</span></span><br><span class="line"><span class="number">1</span>*<span class="number">2</span>=<span class="number">2</span>   <span class="number">2</span>*<span class="number">2</span>=<span class="number">4</span></span><br><span class="line"><span class="number">1</span>*<span class="number">3</span>=<span class="number">3</span>   <span class="number">2</span>*<span class="number">3</span>=<span class="number">6</span>   <span class="number">3</span>*<span class="number">3</span>=<span class="number">9</span></span><br><span class="line"><span class="number">1</span>*<span class="number">4</span>=<span class="number">4</span>   <span class="number">2</span>*<span class="number">4</span>=<span class="number">8</span>   <span class="number">3</span>*<span class="number">4</span>=<span class="number">12</span>  <span class="number">4</span>*<span class="number">4</span>=<span class="number">16</span></span><br><span class="line"><span class="number">1</span>*<span class="number">6</span>=<span class="number">6</span>   <span class="number">2</span>*<span class="number">6</span>=<span class="number">12</span>  <span class="number">3</span>*<span class="number">6</span>=<span class="number">18</span>  <span class="number">4</span>*<span class="number">6</span>=<span class="number">24</span>  <span class="number">5</span>*<span class="number">6</span>=<span class="number">30</span>  <span class="number">6</span>*<span class="number">6</span>=<span class="number">36</span></span><br><span class="line"><span class="number">1</span>*<span class="number">7</span>=<span class="number">7</span>   <span class="number">2</span>*<span class="number">7</span>=<span class="number">14</span>  <span class="number">3</span>*<span class="number">7</span>=<span class="number">21</span>  <span class="number">4</span>*<span class="number">7</span>=<span class="number">28</span>  <span class="number">5</span>*<span class="number">7</span>=<span class="number">35</span>  <span class="number">6</span>*<span class="number">7</span>=<span class="number">42</span>  <span class="number">7</span>*<span class="number">7</span>=<span class="number">49</span></span><br><span class="line"><span class="number">1</span>*<span class="number">8</span>=<span class="number">8</span>   <span class="number">2</span>*<span class="number">8</span>=<span class="number">16</span>  <span class="number">3</span>*<span class="number">8</span>=<span class="number">24</span>  <span class="number">4</span>*<span class="number">8</span>=<span class="number">32</span>  <span class="number">5</span>*<span class="number">8</span>=<span class="number">40</span>  <span class="number">6</span>*<span class="number">8</span>=<span class="number">48</span>  <span class="number">7</span>*<span class="number">8</span>=<span class="number">56</span>  <span class="number">8</span>*<span class="number">8</span>=<span class="number">64</span></span><br><span class="line"><span class="number">1</span>*<span class="number">9</span>=<span class="number">9</span>   <span class="number">2</span>*<span class="number">9</span>=<span class="number">18</span>  <span class="number">3</span>*<span class="number">9</span>=<span class="number">27</span>  <span class="number">4</span>*<span class="number">9</span>=<span class="number">36</span>  <span class="number">5</span>*<span class="number">9</span>=<span class="number">45</span>  <span class="number">6</span>*<span class="number">9</span>=<span class="number">54</span>  <span class="number">7</span>*<span class="number">9</span>=<span class="number">63</span>  <span class="number">8</span>*<span class="number">9</span>=<span class="number">72</span>  <span class="number">9</span>*<span class="number">9</span>=<span class="number">81</span></span><br></pre></td></tr></table></figure><blockquote><p><code>\t</code> 在控制台输出一个制表符，协助在输出文本时垂直方向保持对齐</p><p><code>\n</code> 在控制台输出一个换行符</p><p>制表符的功能是在不使用表格的情况下在垂直方向按列对齐文本。</p></blockquote><h2 id="⛄转义字符"><a href="#⛄转义字符" class="headerlink" title="⛄转义字符"></a>⛄转义字符</h2><p>转义字符是很多程序语言、数据格式和通信协议的形式文法的一部分。对于一个给定的字母表，一个转义字符的目的是开始一个字符序列，使得转义字符开头的该字符序列具有不同于该字符序列单独出现时的语义。因此转义字符开头的字符序列被叫做转义序列。</p><p>转义序列通常有两种功能。第一个是编码一个句法上的实体，如设备命令或者无法被字母表直接表示的特殊数据。第二种功能，也叫字符引用，用于表示无法在当前上下文中被键盘录入的字符（如字符串中的回车符），或者在当前上下文中会有不期望的含义的字符（如C语言字符串中的双引号字符”，不能直接出现，必须用转义序列表示）。在后面那种情况，转义序列是一种由转义字符自身和一个被引用的字符组成的一个二合字母（<code>digraph</code>）情形。</p><table><thead><tr><th align="center">转义字符</th><th align="center">描述说明</th></tr></thead><tbody><tr><td align="center">\\</td><td align="center">反斜杠符号</td></tr><tr><td align="center">&#39;</td><td align="center">单引号</td></tr><tr><td align="center">&quot;</td><td align="center">双引号</td></tr><tr><td align="center">\n</td><td align="center">换行</td></tr><tr><td align="center">\t</td><td align="center">横向制表符</td></tr><tr><td align="center">\r</td><td align="center">回车</td></tr></tbody></table><p>参考文献：</p><p>《编程小白的第1本Python入门书》侯爵</p><p>《Python基础教程（第3版）》 Magnus Lie Hetland（著）袁国忠（译）</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Python基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python基础知识（01）</title>
      <link href="/2022/07/09/Python-Basic01/"/>
      <url>/2022/07/09/Python-Basic01/</url>
      
        <content type="html"><![CDATA[<p>1999年，吉多·范罗苏姆向<code>DARPA</code>提交了一条名为”<code>Computer Programming for Everybody</code>“的资金申请，并在后来说明了他对<code>Python</code>的目标：</p><ul><li>一门简单直观的语言并与主要竞争者一样强大</li><li>开源，以便任何人都可以为它做贡献</li><li>代码像纯英语那样容易理解</li><li>适用于短期开发的日常任务</li></ul><p>计算机不能直接理解任何除<strong>机器语言</strong>以外的语言，所以必须要把程序员所写的程序语言翻译成机器语言，计算机才能执行程序。将其他语言翻译成机器语言的工具，被称为<strong>编译器</strong>。</p><p>编译器翻译的方式有两种：一个是<strong>编译</strong>，另外一个是<strong>解释</strong>。两种方式之间的区别在于翻译时间点的不同。当编译器以解释方式运行的时候，也称之为<strong>解释器</strong>。</p><ul><li><strong>编译型语言</strong>：程序在执行之前需要一个专门的编译过程，把程序编译成为机器语言的文件，运行时不需要重新翻译，直接使用编译的结果就行了。程序执行效率高，依赖编译器，跨平台性差些。如<code>C</code>、<code>C++</code>。</li><li><strong>解释型语言</strong>：解释型语言编写的程序不进行预先编译，以文本方式存储程序代码，会将代码一句一句直接运行。在发布程序时，看起来省了道编译工序，但是在运行程序的时候，必须先解释再运行</li></ul><blockquote><p>编译型语言和解释型语言对比</p><ul><li>速度——编译型语言比解释型语言执行速度快</li><li>跨平台性——解释型语言比编译型语言跨平台性好</li></ul></blockquote><h2 id="⛄Python-概述"><a href="#⛄Python-概述" class="headerlink" title="⛄Python 概述"></a>⛄Python 概述</h2><h3 id="👀Python特点"><a href="#👀Python特点" class="headerlink" title="👀Python特点"></a>👀Python特点</h3><ul><li><code>Python</code> 是完全面向对象的语言</li></ul><ol><li><p>函数、模块、数字、字符串都是对象，在<code>Python</code>中一切皆对象</p></li><li><p>完全支持继承、重载、多重继承</p></li><li><p>支持重载运算符，也支持泛型设计</p></li></ol><ul><li><code>Python</code> 拥有一个强大的标准库，</li></ul><ol><li><code>Python</code>语言的核心只包含数字、字符串、列表、字典、文件等常见类型和函数，而由<code>Python</code>标准库提供了系统管理、网络通信、文本处理、数据库接口、图形系统、<code>XML</code>处理等额外的功能。</li><li><code>Python</code> 社区提供了大量的第三方模块，使用方式与标准库类似。它们的功能覆盖科学计算、人工智能、机器学习、<code>Web</code>开发、数据库接口、图形系统多个领域。</li></ol><h3 id="👀Python程序执行方式"><a href="#👀Python程序执行方式" class="headerlink" title="👀Python程序执行方式"></a>👀Python程序执行方式</h3><ul><li><code>Python</code>解释器</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用Python2.x解释器</span></span><br><span class="line">python xxx.py</span><br><span class="line"><span class="comment"># 使用Python3.x解释器</span></span><br><span class="line">python3 xxx.py</span><br><span class="line"></span><br><span class="line"><span class="comment"># 其他语言Python解释器</span></span><br><span class="line">CPython       <span class="comment"># 官方版本的C语言实现</span></span><br><span class="line">Jython        <span class="comment"># 可以运行在Java平台</span></span><br><span class="line">IronPython    <span class="comment"># 可以运行在.NET和Mono平台</span></span><br><span class="line">PyPy          <span class="comment"># Python实现的，支持JIT即时编译</span></span><br></pre></td></tr></table></figure><ul><li>交互式运行<code>Python</code>程序</li></ul><p>直接在终端中运行解释器，而不输入要执行的文件名；在<code>Python</code>的<code>Shell</code>中直接输入<code>Python</code>的代码，会立即看到程序执行结果。优缺点：适合于学习&#x2F;验证<code>Python</code>语法或者局部代码；代码不能保存，不适合运行太大的程序。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">退出官方的解释器</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">(1) 直接输入<span class="built_in">exit</span>()</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; <span class="built_in">exit</span>()</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">(2)使用热键退出</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在python解释器中，使用热键ctrl+d可以退出解释器</span></span><br></pre></td></tr></table></figure><ul><li><code>IPython</code></li></ul><p><code>Ipython</code>中的“<code>I</code>”代表交互<code>interactive</code></p><p>特点：<code>IPython</code>是一个<code>python</code>的交互式<code>shell</code>，比默认的<code>python shell</code>好用得多。<code>IPython</code>是基于<code>BSD</code>开源的。</p><ol><li>支持自动补全；</li><li>自动缩进；</li><li>支持<code>bash shell</code>命令；</li><li>内置了许多很有用的功能和函数。</li></ol><blockquote><p>单行注释，行注释，以#开头</p><p>多行注释，块注释，一对连续的三个引号</p></blockquote><h2 id="⛄Python基础知识（快速入门）"><a href="#⛄Python基础知识（快速入门）" class="headerlink" title="⛄Python基础知识（快速入门）"></a>⛄Python基础知识（快速入门）</h2><h3 id="👀标识符和关键字"><a href="#👀标识符和关键字" class="headerlink" title="👀标识符和关键字"></a>👀标识符和关键字</h3><p><strong>标识符</strong>就是程序员定义变量名、函数名。</p><blockquote><p>命名规则：在<code>Python</code>中，<strong>标识符</strong>（名称）只能由字母、数字和下划线（<code>_</code>）构成；不能以数字开头；不能与<strong>关键字</strong>重名；区分大小写。</p></blockquote><p><strong>关键字</strong>就是在<code>Python</code>内部已经使用的标识符；<strong>关键字</strong>具有特殊的功能和含义；开发者不允许定义和关键字相同名字的标识符。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 通过以下命令查看可以查看Python中的关键字</span></span><br><span class="line"><span class="keyword">import</span> keyword             <span class="comment"># import关键字可以导入一个“工具包”</span></span><br><span class="line"><span class="built_in">print</span>(keyword.kwlist)</span><br></pre></td></tr></table></figure><h3 id="👀变量"><a href="#👀变量" class="headerlink" title="👀变量"></a>👀变量</h3><p>变量是表示（或指向）特定值的名称。例如，可以使用名称<code>X</code>来表示<code>6</code>。不同于其它一些语言，使用Python变量前必须给它赋值，因为Python变量没有默认值。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Python中的标识符是区分大小写的</span></span><br><span class="line">x = <span class="number">6</span>    <span class="comment"># 赋值，表示将6赋给了变量x，等号（=）用来给变量赋值；</span></span><br><span class="line"><span class="comment"># 变量赋值之后，就可在表达式中使用它</span></span><br></pre></td></tr></table></figure><p>在定义变量时，为了保证代码格式，<code>=</code>的左右应该各保留一个空格；在<code>Python</code>中，如果变量名需要<strong>两个</strong>或<strong>多个单词</strong>组成时，可以按照以下方式命名：</p><ul><li>每个单词都使用小写字母；</li><li>单词与单词之间使用<code>_</code>下划线连接，例如：<code>first_name</code>&#x2F;<code>last_name</code>。</li></ul><p><strong>驼峰命名法</strong>，当变量名是由两个或多个单词组成时，还可以利用驼峰命名法来命名。</p><p>小驼峰式命名法：第一个单词以小写字母开始，后续单词的首字母大写。例如：<code>firstName</code>&#x2F;<code>lastName</code>。</p><p>大驼峰式命名法：每一个单词的首字母都采用大写字母。例如：<code>FirstName</code>&#x2F;<code>LastName</code>。</p><h3 id="👀变量的类型"><a href="#👀变量的类型" class="headerlink" title="👀变量的类型"></a>👀变量的类型</h3><p>首先，在内存中创建一个变量，会包括：</p><ul><li>变量的名称</li><li>变量保存的数据</li><li>变量存储数据的类型</li><li>变量的地址</li></ul><p>在Python中定义变量是<strong>不需要指定类型</strong>，数据类型可以分为数字型和非数字型；</p><table><thead><tr><th align="center">数字型</th><th align="center">非数字型</th></tr></thead><tbody><tr><td align="center">整型（<code>int</code>)</td><td align="center">字符串（<code>string</code>）</td></tr><tr><td align="center">浮点型（<code>float</code>)</td><td align="center">列表（<code>list</code>）</td></tr><tr><td align="center">布尔型（<code>bool</code>：<code>True</code>非0、<code>False</code>）</td><td align="center">元组（<code>tuple</code>不能修改）</td></tr><tr><td align="center">复数型（主要用于科学计算）</td><td align="center">字典（<code>dict</code>:键和值）</td></tr></tbody></table><h3 id="👀不同类型变量之间的计算"><a href="#👀不同类型变量之间的计算" class="headerlink" title="👀不同类型变量之间的计算"></a>👀不同类型变量之间的计算</h3><ol><li><p>数字型变量之间可以直接计算</p><p>在<code>Python</code>中，两个数字型变量是可以直接进行算术运算的，如果变量是<code>bool</code>型，在计算时：</p><ul><li><p><code>True</code>对应的数字是1</p></li><li><p><code>False</code>对应的数字是0</p></li></ul></li><li><p>字符串变量之间使用<code>+</code>拼接字符串</p><p>在Python中，字符串之间可以使用<code>+</code>拼接生成新的字符串。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">first_name = <span class="string">&quot;张&quot;</span></span><br><span class="line">last_name = <span class="string">&quot;三&quot;</span></span><br><span class="line">Name = first_name + last_name</span><br><span class="line"><span class="comment"># 输出“张三”</span></span><br></pre></td></tr></table></figure></li><li><p>字符串变量可以和整数使用<code>*</code>重复拼接相同的字符串</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;%&quot;</span> * <span class="number">10</span></span><br><span class="line"><span class="comment"># 输出“%%%%%%%%%%”</span></span><br></pre></td></tr></table></figure></li><li><p>数字型变量和字符串之间不能进行其它计算</p></li></ol><h3 id="👀变量的输入"><a href="#👀变量的输入" class="headerlink" title="👀变量的输入"></a>👀变量的输入</h3><p>所谓<strong>输入</strong>，就是用<strong>代码</strong>获取用户通过<strong>键盘输入的信息</strong>。例如：输入密码</p><p>在<code>Python</code>中，如果要获取用户在<strong>键盘</strong>上的输入信息，需要使用到<code>input</code>函数。</p><p>（1）关于函数</p><table><thead><tr><th align="center">函数</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center"><code>print(x)</code></td><td align="center">将<code>x</code>输出到控制台</td></tr><tr><td align="center"><code>type(x)</code></td><td align="center">查看<code>x</code>的变量类型</td></tr></tbody></table><p>（2）<code>input</code>函数实现键盘输入</p><p>在<code>Python</code>中可以使用<code>input</code>函数从键盘中等待用户的输入；</p><p>用户输入的任何内容，<code>Python</code>都认为是一个字符串；</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">字符串变量 = <span class="built_in">input</span>(<span class="string">&quot;提示信息：&quot;</span>)</span><br><span class="line">浮点数变量 = <span class="built_in">float</span>(<span class="built_in">input</span>(<span class="string">&quot;提示信息：&quot;</span>))</span><br><span class="line">整数型变量 = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;提示信息：&quot;</span>))</span><br></pre></td></tr></table></figure><p>（3）类型转换函数</p><table><thead><tr><th align="center">函数</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center"><code>int(x)</code></td><td align="center">将<code>x</code>转换为一个整数</td></tr><tr><td align="center"><code>float(x)</code></td><td align="center">将<code>x</code>转换为一个浮点数</td></tr></tbody></table><h3 id="👀变量的格式化输出"><a href="#👀变量的格式化输出" class="headerlink" title="👀变量的格式化输出"></a>👀变量的格式化输出</h3><p>在<code>Python</code>中可以使用<code>print</code>函数将信息输出到控制台；如果希望输出文字信息的同时，一起输出数据，就需要使用到<strong>格式化操作符</strong>。</p><p><code>%</code>被称为格式化操作符，专门用于处理字符串中的格式。</p><ul><li><p>包含<code>%</code>的字符串，被称为<strong>格式化字符串</strong>；</p></li><li><p><code>%</code>和不同的<strong>字符</strong>连用，<strong>不同类型的数据</strong>需要使用<strong>不同的格式化字符</strong>。</p></li></ul><table><thead><tr><th align="center">格式化字符</th><th align="center">含义说明</th></tr></thead><tbody><tr><td align="center"><code>%s</code></td><td align="center">字符串</td></tr><tr><td align="center"><code>%d</code></td><td align="center">有符号十进制整数，<code>%06d</code>表示输出的整数显示位数，不足的地方使用<code>0</code>补全</td></tr><tr><td align="center"><code>%f</code></td><td align="center">浮点数，<code>%.2f</code>表示小数点后只显示两位</td></tr><tr><td align="center"><code>%%</code></td><td align="center">输出<code>%</code></td></tr></tbody></table><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 语法格式</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;格式化字符串&quot;</span> % 变量<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;格式化字符串&quot;</span> % （变量<span class="number">1</span>，变量<span class="number">2.</span>..）)</span><br><span class="line"></span><br><span class="line">name = <span class="string">&quot;小明&quot;</span></span><br><span class="line">student = 000001</span><br><span class="line">scale = <span class="number">10.00</span>%</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;我的名字叫%s&quot;</span> % name)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;我的学号是%06d&quot;</span> % student)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;数据比例是%.2f%%&quot;</span> % (scale * <span class="number">100</span>)</span><br></pre></td></tr></table></figure><h2 id="⛄运算符"><a href="#⛄运算符" class="headerlink" title="⛄运算符"></a>⛄运算符</h2><p>运算符主要包括：</p><ul><li>算术运算符</li><li>比较（关系）运算符</li><li>逻辑运算符</li><li>赋值运算符</li><li>运算符的优先级</li></ul><h3 id="👀算术运算符"><a href="#👀算术运算符" class="headerlink" title="👀算术运算符"></a>👀算术运算符</h3><p>算术运算符是完成基本的算术运算使用的符号，用来处理四则运算。</p><table><thead><tr><th align="center">运算符</th><th align="center">描述</th><th align="center">实例</th></tr></thead><tbody><tr><td align="center"><code>+</code></td><td align="center">加</td><td align="center"><code>30 + 20 = 50</code></td></tr><tr><td align="center"><code>-</code></td><td align="center">减</td><td align="center"><code>30 - 20 = 10</code></td></tr><tr><td align="center"><code>*</code></td><td align="center">乘（也可计算字符串重复次数）</td><td align="center"><code>30 * 20 = 600</code></td></tr><tr><td align="center"><code>/</code></td><td align="center">除</td><td align="center"><code>30 / 20 = 1.5</code></td></tr><tr><td align="center"><code>//</code></td><td align="center">取整除</td><td align="center"><code>9 // 2 = 4</code></td></tr><tr><td align="center"><code>%</code></td><td align="center">取余数</td><td align="center"><code>9 % 2 = 1</code></td></tr><tr><td align="center"><code>**</code></td><td align="center">幂</td><td align="center"><code>2 ** 3 = 8</code></td></tr></tbody></table><h3 id="👀比较（关系）运算符"><a href="#👀比较（关系）运算符" class="headerlink" title="👀比较（关系）运算符"></a>👀比较（关系）运算符</h3><table><thead><tr><th align="center">运算符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="center"><code>==</code></td><td align="left">检查两个操作数的值是否<strong>相等</strong>，如果是，则条件成立，返回<code>True</code></td></tr><tr><td align="center"><code>!=</code></td><td align="left">检查两个操作数的值是否<strong>不相等</strong>，如果是，则条件成立，返回<code>True</code></td></tr><tr><td align="center"><code>&gt;</code></td><td align="left">检查左操作数的值是否<strong>大于</strong>右操作数的值，如果是，则条件成立，返回<code>True</code></td></tr><tr><td align="center"><code>&lt;</code></td><td align="left">检查左操作数的值是否<strong>小于</strong>右操作数的值，如果是，则条件成立，返回<code>True</code></td></tr><tr><td align="center"><code>&gt;=</code></td><td align="left">检查左操作数的值是否<strong>大于或等于</strong>右操作数的值，如果是，则条件成立，返回<code>True</code></td></tr><tr><td align="center"><code>&lt;=</code></td><td align="left">检查左操作数的值是否<strong>小于或等于</strong>右操作数的值，如果是，则条件成立，返回<code>True</code></td></tr></tbody></table><h3 id="👀逻辑运算符"><a href="#👀逻辑运算符" class="headerlink" title="👀逻辑运算符"></a>👀逻辑运算符</h3><table><thead><tr><th align="center">运算符</th><th align="center">逻辑表达式</th><th>描述</th></tr></thead><tbody><tr><td align="center"><code>and</code></td><td align="center"><code>x and y</code></td><td>只有<code>x</code>和<code>y</code>的值都为<code>True</code>，才会返回<code>True</code><br />否则只要<code>x</code>或者<code>y</code>有一个值为<code>False</code>，就返回<code>False</code></td></tr><tr><td align="center"><code>or</code></td><td align="center"><code>a or y</code></td><td>只要<code>x</code>或者<code>y</code>有一个值为<code>True</code>，就返回True<br />只有<code>x</code>和<code>y</code>的值都为<code>False</code>，才会返回<code>False</code></td></tr><tr><td align="center"><code>not</code></td><td align="center"><code>not x</code></td><td>如果<code>x</code>为<code>True</code>，返回<code>False</code><br />如果<code>x</code>为<code>False</code>，返回<code>True</code></td></tr></tbody></table><h3 id="👀-赋值运算符"><a href="#👀-赋值运算符" class="headerlink" title="👀 赋值运算符"></a>👀 赋值运算符</h3><p>在<code>Python</code>中，使用&#x3D;可以给变量赋值；在算术运算时，为了简化代码的编写，<code>python</code>还提供了一系列与算术运算符对应的赋值运算符。注意：赋值运算符中间不能使用空格。</p><table><thead><tr><th align="center">运算符</th><th align="center">描述</th><th>实例</th></tr></thead><tbody><tr><td align="center"><code>=</code></td><td align="center">简单的赋值运算符</td><td>c &#x3D; a + b将a + b的运算结果赋值为c</td></tr><tr><td align="center"><code>+=</code></td><td align="center">加法赋值运算符</td><td>c +&#x3D; a等效于c &#x3D; c + a</td></tr><tr><td align="center"><code>-=</code></td><td align="center">减法赋值运算符</td><td>c -&#x3D; a等效于c &#x3D; c - a</td></tr><tr><td align="center"><code>*=</code></td><td align="center">乘法赋值运算符</td><td>c *&#x3D; a等效于c &#x3D;c * a</td></tr><tr><td align="center"><code>/=</code></td><td align="center">除法赋值运算符</td><td>c &#x2F;&#x3D; a等效于c &#x3D; c  &#x2F;a</td></tr><tr><td align="center"><code>//=</code></td><td align="center">取整除赋值运算符</td><td>c &#x2F;&#x2F;&#x3D; a等效于c &#x3D; c &#x2F;&#x2F; a</td></tr><tr><td align="center"><code>%=</code></td><td align="center">取模（余数）赋值运算符</td><td>c %&#x3D; a等效于c &#x3D; c % a</td></tr><tr><td align="center"><code>**=</code></td><td align="center">幂赋值运算符</td><td>c **&#x3D; a等效于c &#x3D; c ** a</td></tr></tbody></table><h3 id="👀-运算符的优先级"><a href="#👀-运算符的优先级" class="headerlink" title="👀 运算符的优先级"></a>👀 运算符的优先级</h3><p>优先级由高到低顺序排列：</p><table><thead><tr><th align="center">运算符</th><th>描述</th></tr></thead><tbody><tr><td align="center"><code>**</code></td><td>幂（最高优先级）</td></tr><tr><td align="center"><code>*</code>  <code>/</code>  <code>%</code>  <code>//</code></td><td>乘、除、取余数、取整数</td></tr><tr><td align="center"><code>+</code>  <code>-</code></td><td>加法、减法</td></tr><tr><td align="center"><code>&lt;=</code>  <code>&lt;</code>  <code>&gt;</code>  <code>&gt;=</code></td><td>比较运算符</td></tr><tr><td align="center"><code>==</code>  <code>!=</code></td><td>等于运算符</td></tr><tr><td align="center"><code>=</code>  <code>%=</code>  <code>/=</code>  <code>//=</code>  <code>-=</code>  <code>+=</code>  <code>*=</code></td><td>赋值运算符</td></tr><tr><td align="center"><code>not</code> <code>or</code> <code>and</code></td><td>逻辑运算符</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Python基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（一）Google Earth Engine概述</title>
      <link href="/2022/05/16/GEE01/"/>
      <url>/2022/05/16/GEE01/</url>
      
        <content type="html"><![CDATA[<p><code>Google Earth Engine (GEE)</code> 是由谷歌公司开发的众多应用之一。借助谷歌公司超强的服务器运算能力以及与 <code>NASA</code> 的合作关系，<code>GEE</code> 平台将<code>Landsat</code>、<code>MODIS</code>、 <code>Sentinel</code> 等可以公开获取的遥感图像数据存储在谷歌的磁盘阵列中，使得 <code>GEE</code> 用户可以方便的提取、调用和分析海量的遥感大数据资源。</p><p><code>GEE</code>它是一个集科学分析以及地理信息数据可视化的综合性平台。简单的说，<code>GEE</code>是一个“遥感大数据”分析和呈现的平台。作为<strong>地理云计算服务平台</strong>，<code>GEE</code> 将地理数据分析算法封装成函数接口的形式提供给用户，通过互联网可以使用户快速地访问海量的影像数据以及其他空间数据，而不需要下载到本地，在云端实现当前地理空间数据分析的全部流程。通过云计算还可以使共享的计算机软硬件资源和地理大数据，按需求提供给用户使用，使任何用户都可以使用服务商提供的多平台软硬件资源和地理大数据，开展常规个人计算机无法实现的地理计算和数据分析。</p><blockquote><p><code>GEE</code> 在设计之初就是为了服务科研人员而构建的，因此在概念上可以将 <code>GEE</code> 视为一种工具，类似于菜刀之于厨师或者猎枪之于猎手，而不应该将其当作一种复杂的计算机编程平台。</p></blockquote><p><code>GEE</code>包含图形用户界面和应用程序编程接口。<code>GEE</code> 是一个主要依靠编码命令进行空间分析和操作的平台，但 <code>GEE</code> 也有适合界面操作的平台：<code>GEE</code> 的图形用户界面(<code>Graphical User Interface, GUI</code>)。<code>GEE</code> 的 <code>GUI</code> 的优点在于符合人的操作直觉，并且对新用户友好，缺点是功能较少，可以实现的空间分析有限。<code>GEE</code> 的应用程序编程接口(<code>Application Programming Interface, API</code>)是 <code>GEE</code> 的核心功能所在，也是 <code>GEE</code> 用户最为关注的平台，与 <code>GUI</code> 相比，<code>API</code> 可以调用 <code>GEE</code> 平台中的所有数据和功能。可以说，学习 <code>GEE</code> 就是学习 <code>GEE</code> 的 <code>API</code>。</p><p><code>GEE</code> 中存储着海量的遥感数据，熟悉这些数据能够让用户更加便捷的实现空间和地理分析目标。总体上，<code>GEE</code> 的数据可以分为 4 个种类：栅格数据，栅格集数据，矢量数据，矢量集数据。</p><h2 id="⛄栅格数据"><a href="#⛄栅格数据" class="headerlink" title="⛄栅格数据"></a>⛄栅格数据</h2><p><code>GEE</code> 中的栅格数据主要包括来源自遥感卫星的数据和空间插值数据产品。</p><table><thead><tr><th align="center">数据集</th><th align="center">空间分辨率</th><th align="center">时间分辨率</th><th align="center">时间覆盖</th><th align="center">空间覆盖</th></tr></thead><tbody><tr><td align="center"><strong>Landsat</strong></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">Landsat 8 OLI&#x2F;TIRS</td><td align="center">30m</td><td align="center">16day</td><td align="center">2013-Now</td><td align="center">Global</td></tr><tr><td align="center">Landsat 7 ETM+</td><td align="center">30m</td><td align="center">16day</td><td align="center">2000-Now</td><td align="center">Global</td></tr><tr><td align="center">Landsat 5 TM</td><td align="center">30m</td><td align="center">16day</td><td align="center">1984-2012</td><td align="center">Global</td></tr><tr><td align="center">Landsat 4–8 surface reflectance</td><td align="center">30m</td><td align="center">16day</td><td align="center">1984-Now</td><td align="center">Global</td></tr><tr><td align="center"><strong>Sentinel</strong></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">Sentinel 1 A&#x2F;B ground range detected</td><td align="center">10m</td><td align="center">6day</td><td align="center">2014-Now</td><td align="center">Global</td></tr><tr><td align="center">Sentinel 2A MSI</td><td align="center">20m</td><td align="center">10day</td><td align="center">2015-Now</td><td align="center">Global</td></tr><tr><td align="center"><strong>MODIS</strong></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">MOD08 atmosphere</td><td align="center">1°</td><td align="center">daily</td><td align="center">2000-Now</td><td align="center">Global</td></tr><tr><td align="center">MOD09 surface reflectance</td><td align="center">500m</td><td align="center">1&#x2F;8day</td><td align="center">2000-Now</td><td align="center">Global</td></tr><tr><td align="center">MOD10 snow cover</td><td align="center">500m</td><td align="center">1day</td><td align="center">2000-Now</td><td align="center">Global</td></tr><tr><td align="center">MOD11 temperature and emissivity</td><td align="center">1000m</td><td align="center">1&#x2F;8day</td><td align="center">2000-Now</td><td align="center">Global</td></tr><tr><td align="center">MCD12 Land cover</td><td align="center">500m</td><td align="center">Annual</td><td align="center">2000-Now</td><td align="center">Global</td></tr><tr><td align="center">MOD13 Vegetation indices</td><td align="center">500&#x2F;250m</td><td align="center">16day</td><td align="center">2000-Now</td><td align="center">Global</td></tr><tr><td align="center">MOD14 Thermal anomalies &amp; fire</td><td align="center">1000m</td><td align="center">8day</td><td align="center">2000-Now</td><td align="center">Global</td></tr><tr><td align="center">MCD15 Leaf area index&#x2F;FPAR</td><td align="center">500m</td><td align="center">4day</td><td align="center">2000-Now</td><td align="center">Global</td></tr><tr><td align="center">MOD17 Gross primary productivity</td><td align="center">500m</td><td align="center">8day</td><td align="center">2000-Now</td><td align="center">Global</td></tr><tr><td align="center">MCD43 BRDF-adjusted reflectance</td><td align="center">1000&#x2F;500m</td><td align="center">8&#x2F;16day</td><td align="center">2000-Now</td><td align="center">Global</td></tr><tr><td align="center">MOD44 veg. cover conversion</td><td align="center">250m</td><td align="center">Annual</td><td align="center">2000-Now</td><td align="center">Global</td></tr><tr><td align="center">MCD45 thermal anomalies and fire</td><td align="center">500m</td><td align="center">30day</td><td align="center">2000-Now</td><td align="center">Global</td></tr><tr><td align="center"><strong>ASTER</strong></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">L1 T radiance</td><td align="center">15&#x2F;30&#x2F;90m</td><td align="center">1day</td><td align="center">2000-Now</td><td align="center">Global</td></tr><tr><td align="center">Global emissivity</td><td align="center">100m</td><td align="center">Once</td><td align="center">2000-2010</td><td align="center">Global</td></tr><tr><td align="center">Other imagery</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">PROBA-V top of canopy reflectance</td><td align="center">100&#x2F;300m</td><td align="center">2day</td><td align="center">2013-Now</td><td align="center">Global</td></tr><tr><td align="center">EO-1 hyperion hyperspectral radiance</td><td align="center">30m</td><td align="center">Targeted</td><td align="center">2001-Now</td><td align="center">Global</td></tr><tr><td align="center">DMSP-OLS nighttime lights</td><td align="center">1km</td><td align="center">Annual</td><td align="center">1992-2013</td><td align="center">Global</td></tr><tr><td align="center">USDA NAIP aerial imagery</td><td align="center">1m</td><td align="center">Sub-annual</td><td align="center">2003-2015</td><td align="center">CONUS</td></tr><tr><td align="center"><strong>地形</strong></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">Shuttle Radar Topography Mission</td><td align="center">30m</td><td align="center">single</td><td align="center">2000</td><td align="center">60°N–54°S</td></tr><tr><td align="center">USGS GMTED2010</td><td align="center">10m</td><td align="center">single</td><td align="center">Multiple</td><td align="center">US</td></tr><tr><td align="center">USGS National Elevation Dataset</td><td align="center">7.5″</td><td align="center">single</td><td align="center">Multiple</td><td align="center">83°N–57°S</td></tr><tr><td align="center">GTOPO30</td><td align="center">30″</td><td align="center">single</td><td align="center">Multiple</td><td align="center">Global</td></tr><tr><td align="center">ETOPO1</td><td align="center">1′</td><td align="center">single</td><td align="center">Multiple</td><td align="center">Global</td></tr></tbody></table><p>注：来源 <code>Google Earth Engine: Planetary-scale geospatial analysis for everyone [J]. Remote Sensing of Environment</code> </p><p><code>GEE</code> 中其他的主要栅格产品包括土地利用数据，气象数据和人口数据等。这些数据与遥感影像数据相比，主要用来反映某些社会因子的空间分布，或者反映地表以上空间的自然特征。</p><table><thead><tr><th align="center">数据集</th><th align="center">空间分辨率</th><th align="center">时间分辨率</th><th align="center">时间覆盖</th><th align="center">空间覆盖</th></tr></thead><tbody><tr><td align="center"><strong>土地利用</strong></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">GlobCover</td><td align="center">300m</td><td align="center">Non-periodic</td><td align="center">2009</td><td align="center">90°N–65°S</td></tr><tr><td align="center">USGS National Landcover Database</td><td align="center">30m</td><td align="center">Non-periodic</td><td align="center">1992-2011</td><td align="center">CONUS</td></tr><tr><td align="center">UMD global forest change</td><td align="center">30m</td><td align="center">Annual</td><td align="center">2000-2014</td><td align="center">80°N–57°S</td></tr><tr><td align="center">JRC global surface water</td><td align="center">300m</td><td align="center">Monthly</td><td align="center">1984-2015</td><td align="center">78°N–60°S</td></tr><tr><td align="center">GLCF tree cover</td><td align="center">30m</td><td align="center">5year</td><td align="center">2000-2010</td><td align="center">Global</td></tr><tr><td align="center">USDA NASS cropland data layer</td><td align="center">30m</td><td align="center">Annual</td><td align="center">1997-2015</td><td align="center">CONUS</td></tr><tr><td align="center"><strong>气象</strong></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">Global precipitation measurement</td><td align="center">6′</td><td align="center">3h</td><td align="center">2014-Now</td><td align="center">Global</td></tr><tr><td align="center">TRMM 3B42 precipitation</td><td align="center">15′</td><td align="center">3h</td><td align="center">1985-2015</td><td align="center">50°N–50°S</td></tr><tr><td align="center">CHIRPS precipitation</td><td align="center">3′</td><td align="center">5day</td><td align="center">1981-Now</td><td align="center">50°N–50°S</td></tr><tr><td align="center">NLDAS-2</td><td align="center">7.5′</td><td align="center">1h</td><td align="center">1979-Now</td><td align="center">North America</td></tr><tr><td align="center">GLDAS-2</td><td align="center">15′</td><td align="center">3h</td><td align="center">1948-2010</td><td align="center">Global</td></tr><tr><td align="center">NCEP reanalysis</td><td align="center">2.5°</td><td align="center">6h</td><td align="center">1948-Now</td><td align="center">Global</td></tr><tr><td align="center">ORNL DAYMET weather</td><td align="center">1km</td><td align="center">12 Images</td><td align="center">1980-Now</td><td align="center">North America</td></tr><tr><td align="center">GRIDMET</td><td align="center">4km</td><td align="center">1day</td><td align="center">1979-Now</td><td align="center">CONUS</td></tr><tr><td align="center">NCEP global forecast system</td><td align="center">15′</td><td align="center">6h</td><td align="center">2015-Now</td><td align="center">Global</td></tr><tr><td align="center">NCEP climate forecast system</td><td align="center">12′</td><td align="center">6h</td><td align="center">1979-Now</td><td align="center">Global</td></tr><tr><td align="center">WorldClim</td><td align="center">30″</td><td align="center">12 Images</td><td align="center">1960-1990</td><td align="center">Global</td></tr><tr><td align="center">NEX downscaled climate projections</td><td align="center">1km</td><td align="center">1day</td><td align="center">1950-2099</td><td align="center">North America</td></tr><tr><td align="center"><strong>人口</strong></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">WorldPop</td><td align="center">100m</td><td align="center">5year</td><td align="center">Multiple</td><td align="center">2010–2015</td></tr><tr><td align="center">GPWv4</td><td align="center">30″</td><td align="center">5year</td><td align="center">2000-2020</td><td align="center">85°N–60°S</td></tr></tbody></table><p>注：来源 <code>Google Earth Engine: Planetary-scale geospatial analysis for everyone [J]. Remote Sensing of Environment</code></p><h2 id="⛄矢量数据"><a href="#⛄矢量数据" class="headerlink" title="⛄矢量数据"></a>⛄矢量数据</h2><p>简单来说，矢量数据可以理解为点、线和面类型的数据。在处理空间问题时，常常需要确定某个地理要素的位置(例如某区域商店的位置)，或者某些线状地物的位置(河流、道路等)，以及某些面状物的分布(行政边界等)。在确定矢量空间要素空间特征的基础上，再给这些空间要素贴上标签(名称，面积，权属等)，那么就得到了包含一定信息的矢量数据。我们通常将这种矢量数据成为“特征矢量”(<code>Feature</code>)，将其空间形状称为“地理特征”(<code>Geometry</code>)，将贴上去的标签信息称为“属性”(<code>Property</code>)。我们分别从<code>ArcGIS</code>和<code>GEE</code> 中添加并查看<code>Feature</code>的信息，以此加深对矢量数据的理解。</p><h2 id="⛄数据类型和参数类型"><a href="#⛄数据类型和参数类型" class="headerlink" title="⛄数据类型和参数类型"></a>⛄数据类型和参数类型</h2><h3 id="👀GEE-的数据类型-String-Number"><a href="#👀GEE-的数据类型-String-Number" class="headerlink" title="👀GEE 的数据类型 (String, Number)"></a>👀GEE 的数据类型 (<code>String</code>, <code>Number</code>)</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">显示：<span class="title function_">print</span>(string)</span><br><span class="line">创建：ee.<span class="title class_">String</span>()</span><br><span class="line">修改：string.<span class="title function_">cat</span>()string.<span class="title function_">replace</span>()</span><br><span class="line">段落：string.<span class="title function_">split</span>() string.<span class="property">match</span></span><br><span class="line">查询：string.<span class="title function_">slice</span>() string.<span class="title function_">length</span>()</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">创建：ee.<span class="title class_">Number</span>()</span><br><span class="line">修改：number.<span class="title function_">uint8</span>() number.<span class="title class_">Uint8</span>() number.<span class="title function_">int8</span>() number.<span class="title function_">toInt8</span>()……</span><br><span class="line">比较：number.<span class="title function_">eq</span>() number.<span class="title function_">neq</span>()……</span><br><span class="line">    number.<span class="title function_">and</span>() number.<span class="title function_">or</span>() ee.<span class="property">Algorithms</span>.<span class="title class_">IsEqua</span>()……</span><br><span class="line">运算：number.<span class="title function_">abs</span>() number.<span class="title function_">round</span>() number.<span class="title function_">pow</span>()……</span><br><span class="line">字位：number.<span class="title function_">bitwiseAnd</span>() number.<span class="title function_">bitwiseOr</span>() number.<span class="title function_">bitwise_and</span>()</span><br><span class="line">    number.<span class="title function_">bitwise_or</span>() number.<span class="title function_">leftShift</span>() number.<span class="title function_">right_shift</span>()……</span><br></pre></td></tr></table></figure><h3 id="👀GEE-的数据类型-Dictionary，List，Array"><a href="#👀GEE-的数据类型-Dictionary，List，Array" class="headerlink" title="👀GEE 的数据类型(Dictionary，List，Array)"></a>👀GEE 的数据类型(<code>Dictionary</code>，<code>List</code>，<code>Array</code>)</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">创建：ee.<span class="title class_">Dicionary</span>()</span><br><span class="line">修改：dictionary.<span class="title function_">combine</span>() dinctionary.<span class="title function_">set</span>()</span><br><span class="line">查询：dictionary.<span class="title function_">keys</span>() dictionary.<span class="title function_">get</span>() dictionary.<span class="title function_">values</span>()</span><br><span class="line">对比：dictionary.<span class="title function_">contains</span>()</span><br><span class="line">尺寸：dictionary.<span class="title function_">size</span>()</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">创建：ee.<span class="title class_">List</span>() list.<span class="title function_">repeat</span>() list.<span class="title function_">sequence</span>()</span><br><span class="line">修改：list.<span class="title function_">set</span>() list.<span class="title function_">replaceAll</span>() list.<span class="title function_">add</span>() list.<span class="title function_">insert</span>() list.<span class="title function_">zip</span>()</span><br><span class="line">list.<span class="title function_">reverse</span>() list.<span class="title function_">rotate</span>() list.<span class="title function_">sort</span>() list.<span class="title function_">swap</span>() list.<span class="title function_">flatten</span>()</span><br><span class="line">查询：list.<span class="title function_">get</span>() list.<span class="title function_">remove</span>() list.<span class="title function_">removeAll</span>()</span><br><span class="line">比较：list.<span class="title function_">equals</span>() list.<span class="title function_">contains</span>() list.<span class="title function_">containsALL</span>() list. <span class="title function_">indexOf</span>()          </span><br><span class="line">list.<span class="title function_">indexOfSubList</span>() list.<span class="title function_">lastIndexOfSubList</span>() list.<span class="title function_">frequency</span>()</span><br><span class="line">其他：list.<span class="title function_">map</span>() list.<span class="title function_">iterate</span>() list.<span class="title function_">length</span>() list.<span class="title function_">size</span>()</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">创建：ee.<span class="title class_">Array</span>() ee.<span class="property">Array</span>.<span class="title function_">identity</span>() ee.<span class="property">Array</span>.<span class="title function_">repeat</span>()</span><br><span class="line">修改：array.<span class="title function_">mask</span>()array.<span class="title function_">transpose</span>() array.<span class="title function_">uint8</span>()array.<span class="title class_">Uint8</span>()</span><br><span class="line">数学：array.<span class="title function_">eq</span>() array.<span class="title function_">and</span>() array.<span class="title function_">or</span>() array.<span class="title function_">round</span>()</span><br><span class="line">array.<span class="title function_">bitwiseAnd</span>() array.<span class="title function_">leftShift</span>() </span><br></pre></td></tr></table></figure><h3 id="👀GEE-的数据类型-Geometry，Feature，FeatureCollection"><a href="#👀GEE-的数据类型-Geometry，Feature，FeatureCollection" class="headerlink" title="👀GEE 的数据类型(Geometry，Feature，FeatureCollection)"></a>👀GEE 的数据类型(<code>Geometry</code>，<code>Feature</code>，<code>FeatureCollection</code>)</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">创建：ee.<span class="property">Geometry</span>.<span class="title class_">Point</span>() ee.<span class="property">Geometry</span>.<span class="title class_">Multipoint</span>() 绘图工具 ……</span><br><span class="line">几何：<span class="title class_">Geometry</span>.<span class="title function_">transform</span>() geometry.<span class="title function_">centroid</span>() geometry.<span class="title function_">simplify</span>()            </span><br><span class="line">geometry.<span class="title function_">bounds</span>() geometry.<span class="title function_">buffer</span>() geometry.<span class="title function_">union</span>() ……</span><br><span class="line">查询：geometry.<span class="title function_">geometries</span>() geometry.<span class="title function_">coordinates</span>() geometry.<span class="title function_">length</span>() </span><br><span class="line">geometry.<span class="title function_">area</span>() geometry.<span class="title function_">perimeter</span>() geometry.<span class="title function_">distance</span>() </span><br><span class="line">转换：geometry.<span class="title function_">toGeoJSON</span>()</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">创建：ee.<span class="title class_">Feature</span>()绘图工具</span><br><span class="line">编辑：<span class="title class_">Feature</span>.<span class="title function_">select</span>() <span class="title class_">Feature</span>.<span class="title function_">transform</span>() <span class="title class_">Feature</span>.<span class="property">set</span>/<span class="title function_">setMulti</span>()</span><br><span class="line">几何：<span class="title class_">Feature</span>.<span class="property">centroid</span>/simplify/bounds/convexHull/<span class="title function_">buffer</span>()</span><br><span class="line"><span class="title class_">Feature</span>.<span class="property">union</span>/intersection/difference/<span class="title function_">symmetricDifference</span>()</span><br><span class="line">提取：<span class="title class_">Feature</span>.<span class="title function_">geometry</span>() <span class="title class_">Feature</span>.<span class="title function_">get</span>() <span class="title class_">Feature</span>.<span class="property">Length</span>/<span class="title class_">Area</span>/<span class="title class_">Perimeter</span>()</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">创建：<span class="variable constant_">GEE</span>自带 上传 <span class="title class_">FushionTable</span> ee.<span class="title class_">FeatureCollection</span>() .<span class="title function_">randomPoints</span>() 手绘…</span><br><span class="line">编辑：.<span class="title function_">filterMetadata</span>() .<span class="title function_">limit</span>() .<span class="title function_">filterDate</span>() .<span class="title function_">filterBounds</span>() .<span class="title function_">filter</span>() </span><br><span class="line">    .<span class="title function_">select</span>() .<span class="title function_">distinct</span>() .<span class="title function_">union</span>() .<span class="title function_">merge</span>() .<span class="title function_">set</span>() .<span class="title function_">remap</span>() .<span class="title function_">sort</span>()</span><br><span class="line">    .<span class="title function_">makeArray</span>()</span><br><span class="line">转换：.<span class="title function_">geometry</span>() .<span class="title function_">reduceToImage</span>()</span><br><span class="line">查询：.<span class="title function_">first</span>() .<span class="title function_">toList</span>() .<span class="title function_">aggregate_first</span>() .<span class="title function_">aggregate_array</span>()</span><br><span class="line">统计：.<span class="property">aggregate_stats</span>/_histogram/_count/_count_distinct       </span><br><span class="line">    .<span class="property">aggregate_max</span>/_min/_sum/_mean/_product          </span><br><span class="line">    .<span class="property">aggregate_sample_var</span>/_total_var/_sample_sd/_total_sd/</span><br><span class="line">其他: .<span class="title function_">map</span>()</span><br></pre></td></tr></table></figure><h3 id="👀GEE-的数据类型-Image，ImageCollection"><a href="#👀GEE-的数据类型-Image，ImageCollection" class="headerlink" title="👀GEE 的数据类型 (Image，ImageCollection)"></a>👀GEE 的数据类型 (<code>Image</code>，<code>ImageCollection</code>)</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">创建: <span class="variable constant_">GEE</span>自带 用户上传 ee.<span class="title function_">image</span>()/<span class="title function_">constant</span>() ee.<span class="property">Image</span>.<span class="title function_">pixelLonLat</span>() </span><br><span class="line">编辑: .<span class="title function_">mask</span>() .<span class="title function_">clip</span>() .<span class="title function_">select</span>() .<span class="title function_">slice</span>() .<span class="title function_">addBands</span>() .<span class="title function_">reproject</span>() .<span class="title function_">rbgtohsv</span>()         </span><br><span class="line">    .<span class="title function_">hsvtorbg</span>() .<span class="title function_">unit8</span>() .<span class="title function_">cast</span>() .<span class="title function_">set</span>() .<span class="title function_">setMulti</span>() .<span class="title function_">remap</span>() .<span class="title function_">where</span>()   </span><br><span class="line">    .<span class="title function_">metadata</span>() .<span class="title function_">clamp</span>() .<span class="title function_">unitScale</span>() .<span class="title function_">interpolate</span>() .<span class="title function_">eq</span>()…… .<span class="title function_">abs</span>()…… .<span class="title function_">sin</span>() …… </span><br><span class="line">    .<span class="title function_">bitWiseAnd</span>()…… .<span class="title function_">reduce</span>()</span><br><span class="line">地形: image.<span class="title function_">derivative</span>() ee.<span class="property">Terrain</span>.<span class="title function_">products</span>() ee.<span class="property">Algorithm</span>.<span class="title class_">Terrain</span>()</span><br><span class="line">     ee.<span class="property">Terrain</span>.<span class="title function_">slope</span>() ee.<span class="property">Terrain</span>.<span class="title function_">aspect</span>() ee.<span class="property">Terrain</span>.<span class="title function_">fillMinima</span>()  </span><br><span class="line"> ee.<span class="property">Terrain</span>.<span class="title function_">hillshade</span>() ee.<span class="property">Terrain</span>.<span class="title function_">hillshadow</span>() ee.<span class="property">Algorithm</span>.<span class="title class_">Hillshadow</span>()</span><br><span class="line">纹理: .<span class="title function_">entropy</span>() .<span class="title class_">Texture</span>() .<span class="title function_">zeroCrossing</span>() .<span class="property">ee</span>.<span class="property">Algorithms</span>.<span class="title class_">CannyEdgeDetector</span>()   </span><br><span class="line">    ee.<span class="property">Algorithms</span>.<span class="title class_">HoughTransform</span>()</span><br><span class="line">邻域: .<span class="title function_">focal_max</span>() .<span class="title function_">focal_min</span>() .<span class="title function_">focal_median</span>() .<span class="title function_">focal_mode</span>() .<span class="title function_">convolve</span>()                </span><br><span class="line">    .<span class="title function_">reduceNeighborhood</span>()</span><br><span class="line">转换: .<span class="property">Image</span>.<span class="title class_">ToVector</span>() <span class="title class_">Image</span>.<span class="title class_">ToArray</span>() <span class="title class_">Image</span>.<span class="title function_">arrayFlatten</span>()</span><br><span class="line">其他: .<span class="title class_">CrossCorrelation</span>() .<span class="title function_">distance</span>() <span class="title class_">Export</span>.<span class="title function_">image</span>()</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">创建: ee.<span class="title class_">ImageCollection</span>() ee.<span class="property">ImageCollection</span>.<span class="title function_">load</span>()</span><br><span class="line">筛选: .<span class="title function_">limit</span>() .<span class="title function_">filterMetadata</span>() .<span class="title function_">filterDate</span>() .<span class="title function_">filterBounds</span>() .<span class="title function_">filter</span>() .<span class="title function_">select</span>()     </span><br><span class="line">.<span class="title function_">distinct</span>() .<span class="title function_">comnibe</span>() .<span class="title function_">unit8</span>()…… .<span class="title function_">set</span>() .<span class="title function_">setMulti</span>()</span><br><span class="line">求值: .<span class="title function_">mosaic</span>() .<span class="property">and</span>/<span class="title function_">or</span>() .<span class="property">sum</span>/product/max/min/mean/mode/median/<span class="title function_">count</span>()</span><br><span class="line">转换: .<span class="title function_">first</span>() .<span class="title function_">toList</span>() .<span class="title function_">toArray</span>()     </span><br></pre></td></tr></table></figure><h3 id="👀GEE-的数据类型-Landsat-Images-ConfusionMarix"><a href="#👀GEE-的数据类型-Landsat-Images-ConfusionMarix" class="headerlink" title="👀GEE 的数据类型 (Landsat Images, ConfusionMarix)"></a>👀GEE 的数据类型 (<code>Landsat Images</code>, <code>ConfusionMarix</code>)</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">LansatCollection</span>.<span class="title function_">qualityMosaic</span>()</span><br><span class="line"><span class="title class_">LansatCollection</span>.<span class="title function_">unmixing</span>()</span><br><span class="line"><span class="title class_">LansatCollection</span>.<span class="title function_">normalizedDifference</span>()</span><br><span class="line">ee.<span class="property">Algorithms</span>.<span class="property">Landsat</span>.<span class="title function_">simpleCloudScore</span>()</span><br><span class="line">ee.<span class="property">Algorithms</span>.<span class="property">Landsat</span>.<span class="title function_">simpleComposite</span>()</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">创建: ee.<span class="title class_">ConfusionMatrix</span>() </span><br><span class="line">转换: <span class="title class_">ConfusionMatrix</span>.<span class="title function_">array</span>()</span><br><span class="line">精度: .<span class="title function_">kappa</span>() .<span class="title function_">accuracy</span>() .<span class="title function_">producersAccuracy</span>() .<span class="title function_">consumersAccuracy</span>() .<span class="title function_">order</span>()</span><br></pre></td></tr></table></figure><h3 id="👀GEE-的参数类型-Date-DateRange"><a href="#👀GEE-的参数类型-Date-DateRange" class="headerlink" title="👀GEE 的参数类型 (Date, DateRange)"></a>👀GEE 的参数类型 (<code>Date</code>, <code>DateRange</code>)</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">创建：ee.<span class="title class_">Date</span>() ee.<span class="property">Algorithms</span>.<span class="title class_">Date</span>() ee.<span class="property">Date</span>.<span class="title function_">fromYMD</span>() ee.<span class="property">Date</span>.<span class="title function_">parse</span>()</span><br><span class="line">编辑：<span class="title class_">Date</span>.<span class="title function_">advance</span>() <span class="title class_">Date</span>.<span class="title function_">update</span>()</span><br><span class="line">调整：<span class="title class_">Date</span>.<span class="title function_">format</span>() <span class="title class_">Date</span>.<span class="title function_">milis</span>() <span class="title class_">Date</span>.<span class="title function_">getRange</span>()</span><br><span class="line">提取：<span class="title class_">Date</span>.<span class="title function_">get</span>() <span class="title class_">Date</span>.<span class="title function_">gerFraction</span>() <span class="title class_">Date</span>.<span class="title function_">unitRation</span>() <span class="title class_">Date</span>.<span class="title function_">difference</span>()</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">创建: ee.<span class="title class_">DateRange</span>() ee.<span class="property">DateRange</span>.<span class="title function_">unbounded</span>()</span><br><span class="line">联并: <span class="title class_">DateRange</span>.<span class="title class_">Union</span>() <span class="title class_">DateRange</span>.<span class="title function_">intersection</span>()</span><br><span class="line">查询: <span class="title class_">DateRange</span>.<span class="title function_">start</span>() <span class="title class_">DateRange</span>.<span class="title function_">end</span>()</span><br><span class="line">判断: .<span class="title function_">intersencts</span>() .<span class="title function_">contains</span>() .<span class="title function_">inEmpty</span>() .<span class="title function_">isUnbounded</span>()</span><br></pre></td></tr></table></figure><h3 id="👀GEE-的参数类型-Filter，Join"><a href="#👀GEE-的参数类型-Filter，Join" class="headerlink" title="👀GEE 的参数类型 (Filter，Join)"></a>👀GEE 的参数类型 (<code>Filter</code>，<code>Join</code>)</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">创建：ee.<span class="property">Filter</span>.<span class="title function_">eq</span>() ee.<span class="property">Filter</span>.<span class="title function_">neq</span>() ee.<span class="property">Filter</span>.<span class="title function_">ge</span>() ee.<span class="property">Filter</span>.<span class="title function_">gte</span>() ee.<span class="property">Filter</span>.<span class="title function_">le</span>() </span><br><span class="line">ee.<span class="property">Filter</span>.<span class="title function_">lte</span>() ee.<span class="property">Filter</span>.<span class="title function_">maxDifference</span>()</span><br><span class="line">字段：ee.<span class="property">Filter</span>.<span class="title function_">stringContains</span>() ee.<span class="property">Filter</span>.<span class="title class_">StarsWith</span>() ee.<span class="property">Filter</span>.<span class="title class_">EndWith</span>() </span><br><span class="line">ee.<span class="property">Filter</span>.<span class="title class_">Rangecontains</span>() ee.<span class="property">Filter</span>.<span class="title function_">listContains</span>() ee.<span class="property">Filter</span>.<span class="title function_">inList</span>()</span><br><span class="line">时间：ee.<span class="property">Filter</span>.<span class="title function_">calendarRange</span>() ee.<span class="title class_">FilterDateRangeContains</span>() </span><br><span class="line">ee.<span class="property">Filter</span>.<span class="title function_">dayOfYear</span>()</span><br><span class="line">转换：ee.<span class="property">Filter</span>.<span class="title function_">and</span>() ee.<span class="property">Filter</span>.<span class="title function_">or</span>() ee.<span class="property">Filter</span>.<span class="title function_">not</span>() ee.<span class="title class_">Filter</span>()</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ee.<span class="property">Join</span>.<span class="title function_">simple</span>() ee.<span class="property">Join</span>.<span class="title function_">inverted</span>() ee.<span class="property">Join</span>.<span class="title function_">inner</span>()</span><br><span class="line">ee.<span class="property">Join</span>.<span class="title function_">saveAll</span>() ee.<span class="property">Join</span>.<span class="title function_">saveBest</span>() ee.<span class="property">Join</span>.<span class="title function_">saveFirst</span>()</span><br><span class="line"><span class="title class_">Spatial</span> <span class="title class_">Joins</span> (ee.<span class="property">Filter</span>.<span class="property">withinDistance</span>/ee.<span class="property">Filter</span>.<span class="property">intersects</span>)</span><br></pre></td></tr></table></figure><h3 id="👀GEE-的参数类型-Reducer，Kernel，Algorithm"><a href="#👀GEE-的参数类型-Reducer，Kernel，Algorithm" class="headerlink" title="👀GEE 的参数类型 (Reducer，Kernel，Algorithm)"></a>👀GEE 的参数类型 (<code>Reducer</code>，<code>Kernel</code>，<code>Algorithm</code>)</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">创建: ee.<span class="property">Reducer</span>.<span class="title function_">count</span>() .<span class="title function_">countEvery</span>() .<span class="title function_">first</span>() .<span class="title function_">histogram</span>() .<span class="title function_">allNonZero</span>() </span><br><span class="line">    .<span class="title function_">anyNonZero</span>() .<span class="title function_">frequencyHistrogram</span>() .<span class="title function_">toList</span>() .<span class="title function_">toCollection</span>()</span><br><span class="line">数学: <span class="title function_">sum</span>() .<span class="title function_">product</span>() .<span class="title function_">mean</span>() .<span class="title function_">variance</span>() .<span class="title function_">std_dev</span>() .<span class="title function_">sampleVariance</span>()       </span><br><span class="line">    .<span class="title function_">sampleStdDev</span>() .<span class="title function_">max</span>() .<span class="title function_">min</span>() .<span class="title function_">minMax</span>() .<span class="title function_">median</span>() .<span class="title function_">mode</span>()         </span><br><span class="line">    .<span class="title function_">intervalMean</span>() .<span class="title function_">percentile</span>() .<span class="title function_">linearFit</span>()</span><br><span class="line">转换: .<span class="title function_">setOutputs</span>() .<span class="title function_">getOutputs</span>() .<span class="title function_">combine</span>() .<span class="title function_">repeat</span>() .<span class="title function_">repeat</span>()      </span><br><span class="line">     .<span class="title function_">group</span>() .<span class="title function_">unweighted</span>() .<span class="title function_">splitWeights</span>()</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">创建: ee.<span class="property">Kernel</span>.<span class="title function_">roberts</span>() ee.<span class="property">Kernel</span>.<span class="title function_">prewitt</span>() ee.<span class="property">Kernel</span>.<span class="title function_">sobel</span>()    </span><br><span class="line">ee.<span class="property">Kernel</span>.<span class="title function_">compass</span>() ee.<span class="property">Kernel</span>.<span class="title function_">kirsch</span>() ee.<span class="property">Kernel</span>.<span class="title function_">laplacian4</span>()</span><br><span class="line">ee.<span class="property">Kernel</span>.<span class="title function_">laplacian8</span>() ee.<span class="property">Kernel</span>.<span class="title function_">euclidean</span>() ee.<span class="property">Kernel</span>.<span class="title function_">gaussian</span>()</span><br><span class="line">ee.<span class="property">Kernel</span>.<span class="title function_">manhattan</span>() ee.<span class="property">Kernel</span>.<span class="title function_">chebyshev</span>() ee.<span class="property">Kernel</span>.<span class="title function_">circle</span>()      </span><br><span class="line">ee.<span class="property">Kernel</span>.<span class="title function_">octagon</span>() ee.<span class="property">Kernel</span>.<span class="title function_">square</span>() ee.<span class="property">Kernel</span>.<span class="title function_">diamond</span>() ee.<span class="property">Kernel</span>.<span class="title function_">cross</span>()</span><br><span class="line">ee.<span class="property">Kernel</span>.<span class="title function_">plus</span>() ee.<span class="property">Kernel</span>.<span class="title function_">fixed</span>()</span><br><span class="line">编辑: <span class="title class_">Kernel</span>.<span class="title function_">rotate</span>() kernel.<span class="title function_">add</span>() <span class="title function_">print</span>(<span class="title class_">Kernel</span>)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Algorithm</span>,算法的目的是减少重复运算，我们可将其理解为一个“小程序”，借助这个小程序可以对数据集内的每一个数据都进行同样的操作。下边是算法的语法格式：</span><br><span class="line"><span class="keyword">function</span> 函数名(变量)</span><br><span class="line">   &#123; 操作 &#125;</span><br><span class="line">算法的核心在于操作的编写。编写操作时要注意两点，第一，应该按照目标数据集确定变量名，比如针对栅格数据集的操作变量可以写作 <span class="title class_">Image</span> 或者 img，这样能够提高操作的可读性。第二，操作必须包含 <span class="keyword">return</span> 命令以告诉 <span class="variable constant_">GEE</span> 算法的目的是什么。</span><br></pre></td></tr></table></figure><h2 id="⛄GEE平台优势与应用"><a href="#⛄GEE平台优势与应用" class="headerlink" title="⛄GEE平台优势与应用"></a>⛄GEE平台优势与应用</h2><p>随着云计算技术的不断发展，<code>GEE</code> 从2008 年提出构想不断发展至今天，已经成为提供覆盖全球的地理空间数据的集成、处理、可视化和综合分析一站式解决方案的云端共享平台，总结GEE的平台具有如下优势：</p><ul><li><strong>免费向非商业用户提供使用</strong>。<code>GEE</code>面向全球科研人员、学生、教育工作者等提供非商业性质用户提供免费服务。</li><li><strong>算法高集成度以及可定制性</strong>。在算法集成方面，提供了持续更新的智能算法以及可供研究者定制的功能接口，这将激励研究者不断尝试新的算法来实现科学构想，而不只是停留在理论层面，这将进一步促进平台的智能化发展，很多以往难以解决的问题都将开启新的思路。</li><li><strong>后台处理运算能力强</strong>。使用<code>GEE</code>平台，用户可以比较方便地处理全球影像数据，解决了用户受限自己本地机器运算能力不强，以及存储空间不足的问题，能够高校、快速地处理大范围的影像。</li><li><strong>完整的生态开发环境</strong>。目前<code>GEE</code> 已经拥有一个完整而良好的开发生态环境，开发者和平台核心团队人员可以通过论坛，会议等多种形式进行深入甲流，探讨各种问题，除了现有的工具资源，用户还可以利用GEE提供的开发包做二次开发，满足更多的需求，实现更加强大的功能。</li></ul><p><code>GEE</code>被广泛应用于各个领域，涵盖全球森林变化，全球地表水变化、作物产量估算、稻田制图、城市测绘、洪水测绘、火灾恢复和疟疾风险绘图等等不同主题。它还被整合到许多第三方应用中，例如分析物种栖息地范围（<code>Map of Life</code>）、监测气候（<code>Climate Engine</code>）和评估土地利用变化（<code>Collect Earth</code>）等等。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://www.aisoutu.com/a/776592">遥感云计算平台:Google Earth Engine</a></li><li>遥感大数据工具（<code>Google Earth Engine</code>）基础教程，作者：王金柱</li></ol>]]></content>
      
      
      <categories>
          
          <category> GEE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GEE </tag>
            
            <tag> API </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo之常见的问题及小技巧</title>
      <link href="/2022/05/13/Hexo-problem/"/>
      <url>/2022/05/13/Hexo-problem/</url>
      
        <content type="html"><![CDATA[<h2 id="⛄提高GitHub-访问速度"><a href="#⛄提高GitHub-访问速度" class="headerlink" title="⛄提高GitHub 访问速度"></a>⛄提高GitHub 访问速度</h2><p>将<code>Hexo</code>项目托管在<code>GitHub</code>数据仓库中，面临的问题通常就是<code>GitHub</code>访问速度比较慢。本人通过搜索资料、不断尝试，发现通过修改 <code>hosts</code> 文件可以进行加速，访问速度得到了有效的提高，亲测有效。手动把<code>cdn</code>和<code>ip</code>地址绑定，具体的步骤为：</p><p>第一步：获取 <code>GitHub</code> 的 global.ssl.fastly 地址</p><p>访问入口：<a href="https://ipaddress.com/website/github.global.ssl.fastly.net#ipinfo">点击进入</a></p><p>获得<code>IP Address</code>：<code>199.232.69.194</code></p><p>第二步：获取 <code>github.com</code> 的地址</p><p>访问入口：<a href="https://ipaddress.com/website/github.com#ipinfo">点击进入</a></p><p>获得<code>IP Address</code>：<code>140.82.113.4</code></p><p>第三步：修改 <code>hosts</code> 文件映射上面查找到的 <code>IP</code></p><p>①首先，针对<code>windows</code>系统，修改<code>C:\Windows\System32\drivers\etc\hosts</code>文件的权限，指定可写入：右击-&gt;<code>hosts</code>-&gt;属性-&gt;安全-&gt;编辑-&gt;点击Users-&gt;在Users的权限”写入“后面打勾，点击确定。</p><p>②然后，右击-&gt;<code>hosts</code>-&gt;打开方式-&gt;选定记事本（或者Notepad++、EmEditor工具）-&gt;在末尾处添加以下内容：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">199.232.69.194 github.global.ssl.fastly.net</span><br><span class="line">140.82.113.4 github.com</span><br></pre></td></tr></table></figure><h2 id="⛄Hexo常见问题"><a href="#⛄Hexo常见问题" class="headerlink" title="⛄Hexo常见问题"></a>⛄Hexo常见问题</h2><h3 id="👀问题一，hexo命令运行出错"><a href="#👀问题一，hexo命令运行出错" class="headerlink" title="👀问题一，hexo命令运行出错"></a>👀问题一，hexo命令运行出错</h3><p><strong>①问题描述</strong>：运行Hexo报错hexo : 无法加载文件hexo.ps1，因为在此系统上禁止运行脚本</p><p>使用如下命令安装 <code>Hexo</code>成功：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure><p>运行<code>hexo -v、hexo clean、hexo g、hexo s、hexo d</code>会出现错误：</p><figure class="highlight plaintext"><figcaption><span>bash</span></figcaption><table><tr><td class="code"><pre><span class="line">PS C:\Users\Desktop\heartlovelife&gt; hexo s</span><br><span class="line">hexo : 无法加载文件 C:\Users\AppData\Roaming\npm\hexo.ps1，因为在此系统上禁止运行脚本。有关详细信息，请参阅 https:/go.microsoft.com/fwlink/?LinkID</span><br><span class="line">=135170 中的 about_Execution_Policies。</span><br><span class="line">所在位置 行:1 字符: 1</span><br><span class="line">+ hexo s</span><br><span class="line">+ ~~~~</span><br><span class="line">    + CategoryInfo          : SecurityError: (:) []，PSSecurityException</span><br><span class="line">    + FullyQualifiedErrorId : UnauthorizedAccess</span><br></pre></td></tr></table></figure><p><strong>②解决方案</strong>：针对<code>windows</code>系统，设置-&gt;隐私和安全性-&gt;开发者选项-&gt;允许本地<code>PowerShell</code>脚本在为签名的情况下运行。</p><h3 id="👀问题二，-hexo-init初始化失败"><a href="#👀问题二，-hexo-init初始化失败" class="headerlink" title="👀问题二， hexo init初始化失败"></a>👀问题二， <code>hexo init</code>初始化失败</h3><p><strong>①问题描述</strong>：<code>WARN Failed to install dependencies. Please run ‘npm install’ manually!</code></p><p><strong>②解决方案</strong>：如果我们输入命令<code>npm install</code>还是会出现错误，这时我们需要修改<code>npm</code>的镜像：</p><figure class="highlight plaintext"><figcaption><span>bash</span></figcaption><table><tr><td class="code"><pre><span class="line">npm -v</span><br><span class="line"># 修改镜像</span><br><span class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br><span class="line"># 初始化</span><br><span class="line">hexo init</span><br><span class="line"># 利用cnpm执行cnpm install</span><br><span class="line">cnpm install </span><br></pre></td></tr></table></figure><h3 id="👀问题三，hexo-d部署失败"><a href="#👀问题三，hexo-d部署失败" class="headerlink" title="👀问题三，hexo d部署失败"></a>👀问题三，<code>hexo d</code>部署失败</h3><p><strong>①问题描述</strong>：<code>fatal: unable to auto-detect email address....</code></p><figure class="highlight plaintext"><figcaption><span>bash</span></figcaption><table><tr><td class="code"><pre><span class="line">fatal: unable to auto-detect email address</span><br><span class="line">error:src refspec HEAD does not match any</span><br><span class="line">error:failed to push some refs to &quot;*******&quot;</span><br><span class="line">FATAL &#123;</span><br><span class="line">err:Error:Spawn failed</span><br><span class="line">.......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>②解决方案</strong>：在文件浏览器中勾选显示隐藏的项目，进入我们的博客目录</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">D:\Blog_Hexo\Blog\.deploy_git\.git</span><br></pre></td></tr></table></figure><p>找到config文件，添加</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[user]</span><br><span class="line">email = 3086786161@qq.com</span><br><span class="line">name = HeartLoveLife</span><br><span class="line">[core]</span><br><span class="line">repositoryformatversion = 0</span><br><span class="line">filemode = false</span><br><span class="line">bare = false</span><br><span class="line">logallrefupdates = true</span><br><span class="line">symlinks = false</span><br><span class="line">ignorecase = true</span><br><span class="line">[branch &quot;main&quot;]</span><br><span class="line">remote = https://github.com/HeartLoveLife/HeartLoveLife.github.io.git</span><br><span class="line">merge = refs/heads/main</span><br></pre></td></tr></table></figure><h3 id="👀问题四，hexo-s出现警告"><a href="#👀问题四，hexo-s出现警告" class="headerlink" title="👀问题四，hexo s出现警告"></a>👀问题四，<code>hexo s</code>出现警告</h3><p><strong>①问题描述</strong>：<code>Accessing non-existent property &#39;*&#39; of module exports inside circular dependency</code></p><figure class="highlight plaintext"><figcaption><span>bash</span></figcaption><table><tr><td class="code"><pre><span class="line">INFO  Start processing</span><br><span class="line">INFO  Hexo is running at http://localhost:4000/ . Press Ctrl+C to stop.</span><br><span class="line">(node:60224) Warning: Accessing non-existent property &#x27;lineno&#x27; of module exports inside circular dependency</span><br><span class="line">(Use `node --trace-warnings ...` to show where the warning was created)</span><br><span class="line">(node:60224) Warning: Accessing non-existent property &#x27;column&#x27; of module exports inside circular dependency</span><br><span class="line">(node:60224) Warning: Accessing non-existent property &#x27;filename&#x27; of module exports inside circular dependency</span><br><span class="line">(node:60224) Warning: Accessing non-existent property &#x27;lineno&#x27; of module exports inside circular dependency</span><br><span class="line">(node:60224) Warning: Accessing non-existent property &#x27;column&#x27; of module exports inside circular dependency</span><br><span class="line">(node:60224) Warning: Accessing non-existent property &#x27;filename&#x27; of module exports inside circular dependency</span><br></pre></td></tr></table></figure><p><strong>②解决方案</strong>：出现警告，是因为<code>node</code>版本太高，切换成低版本的<code>node</code>来安装<code>Hexo</code>就可以了</p><h2 id="⛄Hexo更换主题"><a href="#⛄Hexo更换主题" class="headerlink" title="⛄Hexo更换主题"></a>⛄Hexo更换主题</h2><p>在博客的项目文件夹下打开<code>git bash</code>执行命令，以<code>hexo-theme-butterfly</code>主题为例</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone -b master https://github.com/jerryc127/hexo-theme-butterfly.git themes/butterfly</span><br></pre></td></tr></table></figure><p>运行成功之后，在项目文件夹<code>source</code>中可以查看到新的主题<code>themes</code>文件夹：<code>butterfly</code></p><p>在博客的项目文件夹下，修改<code>_config.yml</code>配置文件如下:</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># theme: landscape  默认主题</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">butterfly</span></span><br></pre></td></tr></table></figure><p>此时主题还不能正常配置使用，需要安装<code>pug</code> 以及<code>stylus</code> 的渲染器:</p><figure class="highlight plaintext"><figcaption><span>bash</span></figcaption><table><tr><td class="code"><pre><span class="line"># npm install hexo-renderer-pug hexo-renderer-stylus --save</span><br><span class="line">cnpm install hexo-renderer-pug hexo-renderer-stylus --save</span><br></pre></td></tr></table></figure><p>执行<code>hexo s</code>部署到本地运行</p><figure class="highlight plaintext"><figcaption><span>bash</span></figcaption><table><tr><td class="code"><pre><span class="line"># 清除缓存b.json 和已生成的静态文件 public</span><br><span class="line">hexo clean</span><br><span class="line"># 生成静态页面到默认设置的 public 文件夹</span><br><span class="line">hexo g</span><br><span class="line"># 启动本地服务器，用于预览</span><br><span class="line">hexo s</span><br><span class="line"># 自动生成网站静态文件，并部署到设定的仓库或上传部署至服务端</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>默认地址：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://localhost:4000/</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客Blog框架简介</title>
      <link href="/2022/05/12/Blog/"/>
      <url>/2022/05/12/Blog/</url>
      
        <content type="html"><![CDATA[<p>简言之，<a href="https://baike.baidu.com/item/%E5%8D%9A%E5%AE%A2/124?fromtitle=blog&fromid=70149&fr=aladdin">Blog</a>就是以网络作为载体，简易迅速便捷地发布自己的心得，及时有效轻松地与他人进行交流，再集丰富多彩的个性化展示于一体的综合性平台。</p><h2 id="⛄博客搭建的方式"><a href="#⛄博客搭建的方式" class="headerlink" title="⛄博客搭建的方式"></a>⛄博客搭建的方式</h2><p>总体来说，Blog搭建的方式可以分为静态博客和动态博客。顾名思义，静态博客：博文内容是通过文档（如：.md文件等）记录的（一个独立的文件），通过生成工具编译成最终的<code>hml</code>、<code>css</code>、<code>js</code>等静态文件，然后部署在静态Server服务器上或<code>Web托管</code>至数据<code>仓库</code>（如：<code>Github</code>），即可在互联网中被访问，不需要数据库的支撑。动态博客：是以数据库技术为基础，其博文内容是通过数据库记录存储的，主要特点体现在<code>交互性</code>；<code>动</code>不是指网页中的页面元素或特效在动，而是与后台数据库进行交互和数据传递（如：注册登录、评论、用户管理等）。</p><p>常见的博客框架：</p><h3 id="👀静态框架"><a href="#👀静态框架" class="headerlink" title="👀静态框架"></a>👀静态框架</h3><ul><li><p>Hexo (<a href="https://hexo.io/zh-cn/">https://hexo.io/zh-cn/</a>)</p></li><li><p>Hugo (<a href="https://www.gohugo.cn/">https://www.gohugo.cn/</a>)</p></li><li><p>VuePress (<a href="https://www.vuepress.cn/">https://www.vuepress.cn/</a>)</p></li><li><p>Jekyll (<a href="https://www.jekyll.com.cn/">https://www.jekyll.com.cn/</a>)</p></li></ul><h3 id="👀动态框架"><a href="#👀动态框架" class="headerlink" title="👀动态框架"></a>👀动态框架</h3><ul><li><p>WordPress  (<a href="https://wordpress.org/">https://wordpress.org/</a>)</p></li><li><p>Typecho (<a href="https://typecho.org/">https://typecho.org/</a>)</p></li><li><p>Halo (<a href="https://halo.run/">https://halo.run/</a>)</p></li><li><p>Solo (<a href="https://b3log.org/solo/">https://b3log.org/solo/</a>)</p></li></ul><h2 id="⛄框架简介"><a href="#⛄框架简介" class="headerlink" title="⛄框架简介"></a>⛄框架简介</h2><h3 id="👀Hexo"><a href="#👀Hexo" class="headerlink" title="👀Hexo"></a>👀Hexo</h3><p><code>Hexo</code> 是一个基于<code>Node.js</code>的快速、简洁且高效的静态博客框架。Hexo 使用 <a href="http://daringfireball.net/projects/markdown/">Markdown</a>（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。Hexo具有丰富的主题、插件系统。</p><p><strong>优点：</strong></p><ul><li>纯静态博客，部署简单、成本低廉、运行优化非常高效。</li><li>Hexo 静态博客框架可以在云端，也可以在本地电脑上甚至手机上。</li><li>Hexo 框架的博客网站没有网站后台，不存在后台安全漏洞的问题。</li><li>因为是纯静态的，几乎所有的 CDN 服务都可以完美的加速提升浏览速度。</li><li>搜索引擎对纯静态网站有天然的青睐度，收录、权重优先权明显。</li><li>纯静态网站会让网络攻击成本大大的增加也就是说纯静态网站被攻击的可能性更低了。</li></ul><h3 id="👀Hugo"><a href="#👀Hugo" class="headerlink" title="👀Hugo"></a>👀Hugo</h3><p><code>Hugo</code> 被称为是世界上最快的构建网站的框架。Hugo 是一个快速且现代的静态网站生成器，采用 Go 编程语言开发，Hugo 的设计目标是让创建网站重新变得有趣。Hugo 是一个通用的网站框架。从技术上讲，Hugo 是一个<a href="https://www.gohugo.cn/about/benefits/">静态站点生成器</a>。与动态构建页面的系统不同，Hugo 在创建或更新内容时构建页面。由于网站的浏览频率远高于编辑频率，因此 Hugo 旨在为您的网站最终用户提供最佳的浏览体验，并为网站作者提供理想的写作体验。使用 Hugo 构建的网站非常快速和安全。Hugo 构建的网站可以托管在任何地方，包括 <a href="https://netlify.com/">Netlify</a>、<a href="https://www.heroku.com/">Heroku</a>、<a href="https://www.godaddy.com/">GoDaddy</a>、<a href="https://www.dreamhost.com/">DreamHost</a>、<a href="https://pages.github.com/">GitHub Pages</a>、<a href="https://about.gitlab.com/features/pages/">GitLab Pages</a>、<a href="https://surge.sh/">Surge</a>、<a href="https://www.aerobatic.com/">Aerobatic</a>、<a href="https://firebase.google.com/docs/hosting/">Firebase</a>、<a href="https://cloud.google.com/storage/">Google Cloud Storage</a>、<a href="https://aws.amazon.com/s3/">Amazon S3</a>、<a href="https://www.rackspace.com/cloud/files">Rackspace</a>、<a href="https://docs.microsoft.com/en-us/azure/storage/blobs/storage-blob-static-website">Azure</a>, 和 <a href="https://aws.amazon.com/cloudfront/">CloudFront</a>，并且与 CDN 更配。Hugo 网站在运行时不需要数据库或依赖于诸如 Ruby、Python 或 PHP 等昂贵的运行时环境。我们认为 Hugo 是一个理想的网站创建工具，具有几乎即时的构建时间，能够在网站修改时即刻重建。</p><p><strong>优点：</strong></p><ul><li>飞快的构建速度。在等待网站构建时有多无聊？Hugo 是同类中最快的工具。每个页面的构建时间小于一毫秒时，网站的平均构建时间不到一秒钟。</li><li>健壮的内容管理。灵活性为王。Hugo 是内容战略家的梦想。Hugo 支持无限的内容类型、分类、菜单、动态 API 驱动的内容等，所有这些都无需插件。</li><li>短代码(shortcodes)。Hugo 短代增强了 Markdown 的能力。我们喜欢 Markdown 语法的漂亮、简洁，但有时我们需要更多的灵活性。Hugo 短代码满足了美观和灵活的需求。</li><li>内置模板。Hugo 提供的通用模式让您的工作迅速完成。Hugo 提供了预制的模板，可以快速完成 SEO、评论、统计和其他功能。一行代码，完成所有工作。</li><li>支持多语言和 i18n。原生支持多语言。Hugo 为多语言站点提供了完整的 i18n 支持，并且与 Hugo 用户喜欢的单语言站点的开发体验完全相同。</li><li>定制输出。HTML 够吗？Hugo 允许以多种格式输出您的内容，包括 JSON 或 AMP，并使您可以轻松创建自己的内容。</li></ul><h3 id="👀VuePress"><a href="#👀VuePress" class="headerlink" title="👀VuePress"></a>👀VuePress</h3><p><code>VuePress</code> 由两部分组成：第一部分是一个<a href="https://github.com/vuejs/vuepress/tree/master/packages/%40vuepress/core">极简静态网站生成器 (opens new window)</a>，它包含由 Vue 驱动的<a href="https://www.vuepress.cn/theme/">主题系统</a>和<a href="https://www.vuepress.cn/plugin/">插件 API</a>，另一个部分是为书写技术文档而优化的<a href="https://www.vuepress.cn/theme/default-theme-config.html">默认主题</a>，它的诞生初衷是为了支持 Vue 及其子项目的文档需求。每一个由 VuePress 生成的页面都带有预渲染好的 HTML，也因此具有非常好的加载性能和搜索引擎优化（SEO）。同时，一旦页面被加载，Vue 将接管这些静态内容，并将其转换成一个完整的单页应用（SPA），其他的页面则会只在用户浏览到的时候才按需加载。</p><p>事实上，一个 VuePress 网站是一个由 <a href="http://vuejs.org/">Vue (opens new window)</a>、<a href="https://github.com/vuejs/vue-router">Vue Router (opens new window)</a>和 <a href="http://webpack.js.org/">webpack (opens new window)</a>驱动的单页应用。如果你以前使用过 Vue 的话，当你在开发一个自定义主题的时候，你会感受到非常熟悉的开发体验，你甚至可以使用 Vue DevTools 去调试你的自定义主题。在构建时，我们会为应用创建一个服务端渲染（SSR）的版本，然后通过虚拟访问每一条路径来渲染对应的HTML。这种做法的灵感来源于 <a href="https://nuxtjs.org/">Nuxt (opens new window)</a>的 <code>nuxt generate</code> 命令，以及其他的一些项目，比如 <a href="https://www.gatsbyjs.org/">Gatsby (opens new window)</a>。</p><p><strong>优点：</strong></p><ul><li>简洁至上。以 Markdown 为中心的项目结构，以最少的配置帮助你专注于写作。</li><li>Vue 驱动。享受 Vue + webpack 的开发体验，可以在 Markdown 中使用 Vue 组件，又可以使用 Vue 来开发自定义主题。</li><li>高性能。VuePress 会为每个页面预渲染生成静态的 HTML，同时，每个页面被加载的时候，将作为 SPA 运行。</li></ul><h3 id="👀Jekyll"><a href="#👀Jekyll" class="headerlink" title="👀Jekyll"></a>👀Jekyll</h3><p><code>Jekyll</code> 是一个静态网站生成器。用你喜欢的标记语言书写内容并交给 Jekyll 处理，它将利用模板为你创建一个静态网站。你可以调整你想要的网址样式、在网站上显示哪些数据等等。jekyll是一个简单的免费的Blog生成工具，类似WordPress。但是和WordPress又有很大的不同，原因是jekyll只是一个生成静态网页的工具，不需要<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%BA%93/103728">数据库</a>支持。但是可以配合第三方服务,例如Disqus。最关键的是jekyll可以免费部署在Github上，而且可以绑定自己的域名。</p><p><strong>优点：</strong></p><ul><li>简单。无需数据库、评论功能或频繁的版本更新—只需关注<em>你的内容</em>。</li><li>静态。只用 <a href="https://daringfireball.net/projects/markdown/">Markdown</a>、<a href="https://github.com/Shopify/liquid/wiki">Liquid</a>、HTML &amp; CSS g就可以构建可部署的静态网站。</li><li>博客。原生支持自定义链接、分类、静态页、文章以及自定义布局。</li></ul><h3 id="👀WordPress"><a href="#👀WordPress" class="headerlink" title="👀WordPress"></a>👀WordPress</h3><p><code>WordPress</code>是一款能让您建立出色网站、博客或应用程序的开源软件。WordPress是使用<a href="https://baike.baidu.com/item/PHP/9337">PHP</a>语言开发的博客平台，用户可以在支持PHP和MySQL数据库的<a href="https://baike.baidu.com/item/%E6%9C%8D%E5%8A%A1%E5%99%A8/100571">服务器</a>上架设属于自己的网站。也可以把 WordPress当作一个<a href="https://baike.baidu.com/item/%E5%86%85%E5%AE%B9%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/2683135">内容管理系统</a>（CMS）来使用。WordPress是一款<a href="https://baike.baidu.com/item/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/5466014">个人博客</a>系统，并逐步演化成一款内容管理系统软件，它是使用PHP语言和<a href="https://baike.baidu.com/item/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93/10991669">MySQL数据库</a>开发的，用户可以在支持 PHP 和 MySQL数据库的服务器上使用自己的博客。WordPress有许多第三方开发的免费模板，安装方式简单易用。不过要做一个自己的模板，则需要你有一定的专业知识。比如你至少要懂的<a href="https://baike.baidu.com/item/%E6%A0%87%E5%87%86%E9%80%9A%E7%94%A8%E6%A0%87%E8%AE%B0%E8%AF%AD%E8%A8%80/6805073">标准通用标记语言</a>下的一个应用<a href="https://baike.baidu.com/item/HTML">HTML</a>、<a href="https://baike.baidu.com/item/CSS/5457">CSS</a>、PHP等相关知识。</p><p><strong>优点：</strong></p><ul><li>WordPress 功能强大、扩展性强、生态丰富，这主要得益于其插件众多，易于扩充功能，基本上一个完整网站该有的功能，通过其第三方插件都能实现所有功能。</li><li>wordpress搭建的博客对seo搜索引擎友好，收录也快，排名靠前。</li><li>适合DIY，如果你是喜欢丰富内容的网站，那么wordpress可以很好地符合你的胃口。</li><li>主题很多，网站上一大片都是wordpress的主题，各色各样，应有尽有！</li><li>wordpress备份和网站转移比较方便，原站点使用站内工具导出后，使用WordPress Importer插件就能方便地将内容导入新网站。</li><li>wordpress有强大的社区支持，有上千万的开发者贡献和审查wordpress，所以wordpress是安全并且活跃的。</li></ul><h3 id="👀Typecho"><a href="#👀Typecho" class="headerlink" title="👀Typecho"></a>👀Typecho</h3><p><code>Typecho</code>是由type和echo两个词合成的，来自于开发团队的头脑风暴。Typecho基于PHP5开发，支持多种数据库，是一款内核强健﹑扩展方便﹑体验友好﹑运行流畅的轻量级开源博客程序。选用Typecho，搭建独一无二个人<a href="https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E6%97%A5%E5%BF%97/87941">网络日志</a>发布平台，享受创作的快乐。</p><p><strong>优点：</strong></p><ul><li>轻量高效。仅仅 7 张数据表，加上不足 400KB 的代码，就实现了完整的插件与模板机制。超低的 CPU 和内存使用率，足以发挥主机的最高性能。</li><li>先进稳定。原生支持 Markdown 排版语法，易读更易写。支持 BAE&#x2F;GAE&#x2F;SAE 等各类云主机，即使面对突如其来的高访问量，也能轻松应对。</li><li>简洁友好。精心打磨过的操作界面，依然是你熟悉的面孔，更多了一份成熟与贴心。每一个像素的剪裁，都只为离完美更进一步。</li></ul><h3 id="👀Halo"><a href="#👀Halo" class="headerlink" title="👀Halo"></a>👀Halo</h3><p><code>Halo</code>是一款基于<code>Java</code>语言，使用<a href="https://baike.baidu.com/item/Spring%20Boot/20249767?fr=aladdin">Spring Boot</a>框架开发的博客系统，致力于打造最好的 Java 博客系统，且只想安安静静的做一个博客系统。</p><p><strong>优点：</strong></p><ul><li>代码开源。我们的所有代码开源在 <a href="https://github.com/halo-dev">GitHub</a> 上且处于积极维护状态，截止目前已经发布了 <a href="https://github.com/halo-dev/halo/releases">81</a> 个版本。您也可以在上面提交您的问题或者参与代码贡献。</li><li>易于部署。采用了程序与用户配置分离的方式，迁移和备份成本大大降低。您只需要一条命令即可运行成功，同时也支持 Docker 部署。</li><li>REST API。提供了完善的 <a href="https://api.halo.run/content-api.html">Content API</a> 和 <a href="https://api.halo.run/admin-api.html">Admin API</a>，你可以用于开发单页面模板，微信小程序，各种系统的插件等。</li><li>模板系统完善的模板系统，支持自定义配置，支持在线安装和更新。开发主题也十分方便，欢迎大家参与主题的开发。</li><li>附件系统。支持本地上传，阿里云 OSS&#x2F;又拍云 OSS&#x2F;七牛云 OSS&#x2F;SM.MS 等云存储，你可以更方便的管理你文章中的附件。</li><li>评论系统拥有独立的评论插件，使用 Vue 开发，只需在页面引入构建好的 JS 文件即可，完美地和主题相结合。目前已有多款评论组件，你可以非常方便的切换。</li></ul><h3 id="👀Solo"><a href="#👀Solo" class="headerlink" title="👀Solo"></a>👀Solo</h3><p><code>Solo</code> 是一款基于Java语言有后台管理的，小而美的博客系统，专为程序员设计</p><p><strong>优点：</strong></p><ul><li>Markdown 编辑器支持三种编辑模式：所见即所得 &#x2F; 即时渲染 &#x2F; 分屏预览。</li><li><a href="https://ld246.com/article/1498490209748">Hexo &#x2F; Jekyll &#x2F; Markdown 导入</a>。</li><li>SQL &#x2F; JSON &#x2F; Markdown 导出。</li><li>拉取 GitHub 仓库和自动备份。</li><li>内置 HTTPS+CDN 文件存储。</li><li>支持生成导出静态站点，用于发布 GitHub Pages。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Blog </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
