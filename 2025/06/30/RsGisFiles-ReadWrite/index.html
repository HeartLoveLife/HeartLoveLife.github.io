<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>基于Python的GIS-RS多源数据处理(TIF/SHP/NC/...)【20250630】 | 江湖是你画中亦是你</title><meta name="keywords" content="数据处理,文件读写"><meta name="author" content="Xiaotangsmiles"><meta name="copyright" content="Xiaotangsmiles"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="栅格数据以规则网格(像素)的数值矩阵表达地理现象，每个单元格代表一个属性值(如高程、温度)。例如卫星影像、数字高程模型、温度分布图。存储格式包括ENVI DAT、GeoTIFF、JPEG、PNG、ASCII Grid等等。 矢量数据是通过几何图形(点、线、面)表示地理实体，基于坐标和拓扑关系存储空间信息。例如城市(点)、河流(线)、国家边界(面)。存储格式包括Shapefile、GeoJSON、">
<meta property="og:type" content="article">
<meta property="og:title" content="基于Python的GIS-RS多源数据处理(TIF&#x2F;SHP&#x2F;NC&#x2F;...)【20250630】">
<meta property="og:url" content="https://heartlovelife.github.io/2025/06/30/RsGisFiles-ReadWrite/index.html">
<meta property="og:site_name" content="江湖是你画中亦是你">
<meta property="og:description" content="栅格数据以规则网格(像素)的数值矩阵表达地理现象，每个单元格代表一个属性值(如高程、温度)。例如卫星影像、数字高程模型、温度分布图。存储格式包括ENVI DAT、GeoTIFF、JPEG、PNG、ASCII Grid等等。 矢量数据是通过几何图形(点、线、面)表示地理实体，基于坐标和拓扑关系存储空间信息。例如城市(点)、河流(线)、国家边界(面)。存储格式包括Shapefile、GeoJSON、">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s2.loli.net/2025/06/30/NztQZxneq12OYjM.jpg">
<meta property="article:published_time" content="2025-06-30T14:20:00.000Z">
<meta property="article:modified_time" content="2025-06-30T15:21:44.993Z">
<meta property="article:author" content="Xiaotangsmiles">
<meta property="article:tag" content="数据处理">
<meta property="article:tag" content="文件读写">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s2.loli.net/2025/06/30/NztQZxneq12OYjM.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://heartlovelife.github.io/2025/06/30/RsGisFiles-ReadWrite/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":250},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '基于Python的GIS-RS多源数据处理(TIF/SHP/NC/...)【20250630】',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-06-30 23:21:44'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/loading1.gif" data-original="/img/touxiang.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">30</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">27</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">12</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/photos/"><span> 相册</span></a></li><li><a class="site-page child" href="/music/"><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><span> 影视</span></a></li><li><a class="site-page child" href="/shuoshuo/"><span> 分享</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><span> 关于笔者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://s2.loli.net/2025/06/30/NztQZxneq12OYjM.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">江湖是你画中亦是你</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/photos/"><span> 相册</span></a></li><li><a class="site-page child" href="/music/"><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><span> 影视</span></a></li><li><a class="site-page child" href="/shuoshuo/"><span> 分享</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><span> 关于笔者</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">基于Python的GIS-RS多源数据处理(TIF/SHP/NC/...)【20250630】</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-06-30T14:20:00.000Z" title="发表于 2025-06-30 22:20:00">2025-06-30</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-06-30T15:21:44.993Z" title="更新于 2025-06-30 23:21:44">2025-06-30</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Python/">Python</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E9%81%A5%E6%84%9F%E6%95%B0%E6%8D%AE/">遥感数据</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/GIS%E6%95%B0%E6%8D%AE/">GIS数据</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">13.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>51分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="基于Python的GIS-RS多源数据处理(TIF/SHP/NC/...)【20250630】"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>栅格数据以规则网格(像素)的数值矩阵表达地理现象，每个单元格代表一个属性值(如高程、温度)。例如卫星影像、数字高程模型、温度分布图。存储格式包括<code>ENVI DAT</code>、<code>GeoTIFF</code>、<code>JPEG</code>、<code>PNG</code>、<code>ASCII Grid</code>等等。</p>
<p>矢量数据是通过几何图形(点、线、面)表示地理实体，基于坐标和拓扑关系存储空间信息。例如城市(点)、河流(线)、国家边界(面)。存储格式包括<code>Shapefile</code>、<code>GeoJSON</code>、<code>KML</code>、<code>GML</code>等。</p>
<p><strong>（1）栅格数据优点：</strong></p>
<ul>
<li>自然现象表达：直接记录连续或分类数据(如植被覆盖、高程)。</li>
<li>计算高效：适合矩阵运算(如地图代数、坡度计算)。</li>
<li>简单结构：数据存储为规则网格，易于编程处理(如<code>Python</code>的<code>NumPy</code>)。</li>
<li>视觉直观：支持平滑色彩过渡(如遥感影像渲染)。</li>
</ul>
<p><strong>（2）矢量数据优点：</strong></p>
<ul>
<li>高精度：几何形状由数学公式定义，可无限缩放而不失真。</li>
<li>存储高效：仅记录关键坐标，数据体积小(尤其适合稀疏数据)。</li>
<li>灵活分析：支持拓扑分析(邻接、连通性)、网络分析(路径规划)、属性查询。</li>
<li>易编辑：可单独修改单个要素(如移动一个点、调整边界)。</li>
</ul>
<p><strong>（3）矢量化（Raster → Vector）</strong></p>
<ul>
<li>用途：从栅格中提取边界(如从卫星图提取建筑物轮廓)。</li>
<li>挑战：可能引入锯齿或拓扑错误(需人工修正)。</li>
</ul>
<p><strong>（4）栅格化（Vector → Raster）</strong></p>
<ul>
<li>用途：将矢量数据转换为分类栅格(如土地利用图)。</li>
<li>挑战：精度损失(依赖分辨率，如细小多边形可能丢失)。</li>
</ul>
<p>矢量数据是"几何的艺术"，适合精确、离散的地理实体。栅格数据是"像素的科学"，擅长表达连续、渐变的地理现象。以下主要基于<code>Python</code>阐述栅格数据和矢量数据的多种处理方式。</p>
<blockquote>
<p>波段按行交叉格式(<code>BIL</code>)、波段按像元交叉格式(<code>BIP</code>)以及波段顺序格式(<code>BSQ</code>)是三种用来为多波段影像组织影像数据的常见方法。<code>BIL</code>、<code>BIP</code>和<code>BSQ</code>本身并不是影像格式，而是用来将影像的实际像素值存储在文件中的方案。</p>
</blockquote>
<h2 id="栅格数据">⛄栅格数据</h2>
<blockquote>
<p>示例数据：共7各波段（<code>Coastal aerosol</code>、<code>Blue</code>、<code>Green</code>、<code>Red</code>、<code>NIR</code>、<code>SWIR1</code>、<code>SWIR2</code>）</p>
<p><code>zhengzhou_Landsat_20240517.tif</code></p>
<p><code>zhengzhou_Landsat_20240517.dat</code></p>
</blockquote>
<h3 id="常用python库">👀常用Python库</h3>
<p><strong>（1）GDAL</strong>——<a target="_blank" rel="noopener" href="https://gdal.org/en/stable/">GDAL教程API</a></p>
<p><code>GDAL</code>(<code>Geospatial Data Abstraction Library</code>)是一个开源的地理空间数据处理库，广泛应用于<code>GIS</code>软件如<code>ArcGIS</code>、<code>QGIS</code>等。它提供了多种格式的读写支持，包括<code>GeoTIFF</code>、<code>GeoJSON</code>等，并具有众多功能，如数据转换、地理配准。</p>
<p><strong>核心特点</strong>：</p>
<ul>
<li>格式支持广泛：支持200+栅格/矢量格式(<code>GeoTIFF</code>/<code>HDF</code>/<code>NetCDF</code>等)</li>
<li>专业级处理：投影变换、重采样、镶嵌、栅格计算等</li>
<li>命令行工具集：<code>gdal_translate</code>/<code>gdalwarp</code>/<code>gdalinfo</code>等</li>
<li>多语言绑定：Python/C++/Java 接口统一</li>
</ul>
<p><strong>依赖库</strong>：</p>
<ul>
<li><code>NumPy</code>(数组支持)</li>
<li><code>PROJ</code>(坐标转换)</li>
<li><code>GEOS</code>(几何运算)</li>
<li>底层<code>C++</code>库(<code>libgdal</code>)</li>
</ul>
<blockquote>
<p><strong><code>GDAL</code>常用函数：</strong><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_43920838/article/details/136387127">GDAL库简介及函数说明</a></p>
<p>①<code>gdal.Open()</code>：打开数据。</p>
<p>②<code>gdal.GetDriverByName()</code>：获取指定名称的驱动程序(<code>driver</code>)，比如<code>GeoTIFF</code>格式对应的驱动程序"<code>GTiff</code>"。</p>
<p>③<code>gdal.Warp()</code>：实现裁剪、重采样、几何校正、转换格式、投影转换、查看处理进度等操作。</p>
<p>④虚拟内存：允许在内存中创建和处理栅格数据，避免磁盘<code>I/O</code>操作，特别适合临时数据处理或需要高性能的场景。以<code>/vsimem/</code>开头的路径来创建内存中的文件。</p>
<p>......</p>
</blockquote>
<p><strong>（2）Rasterio</strong>——<a target="_blank" rel="noopener" href="https://rasterio.readthedocs.io/en/latest/index.html">Rasterio教程API</a></p>
<p><code>Rasterio</code>是一个专门用于栅格数据读写操作的<code>Python</code>库。它基于<code>GDAL</code>库进行二次封装，更加符合<code>Python</code>风格，适用于处理和分析各种栅格数据，如<code>GeoTIFF</code>、<code>ENVI</code>和<code>HDF5</code>等格式。<code>Rasterio</code>提供了强大的工具，可以方便地读取、写入和操作栅格数据，提高数据处理效率。</p>
<p><strong>核心特点</strong>：</p>
<ul>
<li><code>Pythonic API</code>：<code>GDAL</code>的现代<code>Python</code>封装</li>
<li>上下文管理器：自动资源清理</li>
<li><code>NumPy</code>集成：栅格数据直接转为数组</li>
<li>窗口读写：高效处理大文件</li>
<li>地理上下文保持：自动维护变换矩阵和CRS</li>
</ul>
<p><strong>依赖库</strong>：</p>
<ul>
<li><code>GDAL</code>(核心依赖)</li>
<li><code>NumPy</code></li>
<li><code>affine</code>(变换矩阵)</li>
<li><code>snuggs</code>(表达式求值)</li>
<li><code>cligj</code>(命令行支持)</li>
</ul>
<blockquote>
<p><strong><code>Rasterio</code>常用函数：</strong></p>
<p>①<code>rasterio.open()</code>：打开数据。</p>
<p>②<code>rasterio.mask()</code>：根据给定的几何掩膜提取栅格数据，影像裁剪。</p>
<p>③<code>rasterio.merge()</code>：将所有读取的影像合并成一幅影像，影像镶嵌。</p>
<p>④<code>MemoryFile</code>类：允许在内存中创建和处理栅格数据，避免磁盘<code>I/O</code>操作，特别适合临时数据处理或需要高性能的场景。</p>
<p>......</p>
</blockquote>
<p><strong>（3）rioxarray</strong>——<a target="_blank" rel="noopener" href="https://corteva.github.io/rioxarray/html/modules.html">rioxarray教程API</a></p>
<p><code>rioxarray</code>是一个基于<code>rasterio</code>的<code>xarray</code>扩展库，专门用于处理地理空间数据。它结合了<code>xarray</code>的强大数据结构和<code>rasterio</code>的地理空间数据处理能力，使得用户可以更简单高效地进行地理空间数据的读取、处理和分析。<code>rioxarray</code>提供了以下核心功能：栅格数据读取、地理坐标系处理、数据切片和裁剪、数据重采样、数据掩膜、数据写入等等。</p>
<p><strong>核心特点</strong>：</p>
<ul>
<li><code>xarray</code>扩展：为栅格数据添加地理标签</li>
<li>维度感知：处理时间序列/多波段数据</li>
<li>惰性计算：<code>Dask</code>集成支持大数据</li>
<li>无缝互操作：与<code>Rasterio</code>/<code>GeoPandas</code>集成</li>
<li>链式操作：方法链式调用风格</li>
</ul>
<p><strong>依赖库</strong>：</p>
<ul>
<li><code>xarray</code>(核心)</li>
<li><code>rasterio</code>(I/O)</li>
<li><code>pyproj</code>(坐标系统)</li>
<li><code>dask</code>(并行计算)</li>
<li><code>cartopy</code>(可视化)</li>
</ul>
<p><strong>（3）Pillow</strong></p>
<p><code>Pillow</code>是<code>Python Imaging Library（PIL）</code>的一个分支，它提供了广泛的图像处理功能，包括图像缩放、旋转、剪裁、颜色转换、滤镜效果等，可以方便地对图像进行操作。</p>
<p><strong>核心特点</strong>：</p>
<ul>
<li>基础图像处理：裁剪/旋转/缩放/滤镜</li>
<li>格式转换：<code>JPEG</code>/<code>PNG</code>/<code>TIFF</code>/<code>BMP</code>等互转</li>
<li>轻量级：无复杂依赖</li>
<li>非地理空间：不保留地理信息</li>
<li>直方图操作：图像增强基础</li>
</ul>
<p><strong>依赖库</strong>：</p>
<ul>
<li>纯 <code>Python</code>实现 (部分C扩展)</li>
<li>无强制外部依赖</li>
</ul>
<p><strong>（4）h5py</strong></p>
<p><code>h5py</code>是一个用于与<code>HDF5</code>文件交互的<code>Python</code>库。<code>HDF5</code>（<code>Hierarchical Data Format version 5</code>）是一种用于存储和组织大型数据集的文件格式，<code>h5py</code>结合了<code>HDF5</code>的强大功能和<code>Python</code>的易用性，使得处理大型数据集变得更加方便和高效。</p>
<p><strong>核心特点</strong>：</p>
<ul>
<li><code>HDF5</code>接口：处理科学数据格式</li>
<li>层级存储：类似文件系统的数据组织</li>
<li>高效压缩：支持多种压缩过滤器</li>
<li>并行<code>I/O</code>：支持<code>MPI</code>并行读写</li>
<li>大数据优化：分块存储/部分读取</li>
</ul>
<p><strong>依赖库</strong>：</p>
<ul>
<li><code>HDF5 C</code>库</li>
<li><code>NumPy</code></li>
<li><code>mpi4py</code>(可选，并行支持)</li>
</ul>
<h3 id="geotiff数据">👀<code>GeoTIFF</code>数据</h3>
<p><strong>（1）GDAL方式</strong></p>
<ul>
<li>影像读取</li>
<li>影像写入</li>
<li>基于矢量边界的影像裁剪<code>Warp()</code>。<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44778507/article/details/134041920">参考博客①</a>、<a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_56729804/article/details/132270121">参考博客②</a></li>
<li>虚拟内存读写数据（文件路径前缀添加<code>/vsimem/</code>）</li>
<li>......</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> osgeo <span class="keyword">import</span> gdal</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取影像</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">read_img</span>(<span class="params">filename</span>):</span><br><span class="line">    <span class="comment"># 打开文件</span></span><br><span class="line">    dataset = gdal.Open(filename)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 获取栅格的描述信息</span></span><br><span class="line">    im_Description = dataset.GetDescription()</span><br><span class="line">    <span class="comment"># 获取影像中的一个波段，波段的编号从1到dataset.RasterCount</span></span><br><span class="line">    im_band = dataset.GetRasterBand(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(im_band.GetMinimum())</span><br><span class="line">    <span class="built_in">print</span>(im_band.GetMaximum())</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 栅格矩阵的列数</span></span><br><span class="line">    im_width = dataset.RasterXSize</span><br><span class="line">    <span class="comment"># 栅格矩阵的行数 </span></span><br><span class="line">    im_height = dataset.RasterYSize</span><br><span class="line">    <span class="comment"># 波段数</span></span><br><span class="line">    im_bands = dataset.RasterCount</span><br><span class="line">    <span class="comment"># 仿射矩阵，返回的是六个参数的tuple</span></span><br><span class="line">    im_geotrans = dataset.GetGeoTransform()</span><br><span class="line">    <span class="comment"># 地图投影信息 返回的是WKT格式的字符串</span></span><br><span class="line">    im_proj = dataset.GetProjection()</span><br><span class="line">    <span class="comment"># 将数据写成数组，对应栅格矩阵；同时也可以设置获取对应像元的邻域(8邻域)的像元值</span></span><br><span class="line">    im_data = dataset.ReadAsArray(<span class="number">0</span>, <span class="number">0</span>, im_width, im_height).astype(<span class="built_in">float</span>)</span><br><span class="line">    <span class="comment"># 关闭对象，文件dataset</span></span><br><span class="line">    <span class="keyword">del</span> dataset</span><br><span class="line">    <span class="keyword">return</span> im_proj, im_geotrans, im_data, im_height, im_width</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> osgeo <span class="keyword">import</span> gdal</span><br><span class="line"></span><br><span class="line"><span class="comment"># 写入影像(TIFF格式或者ENVI的Dat格式)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">write_img</span>(<span class="params">filename, im_proj, im_geotrans, im_data</span>):</span><br><span class="line">    <span class="comment"># 判断栅格数据的数据类型</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;int8&#x27;</span> <span class="keyword">in</span> im_data.dtype.name:</span><br><span class="line">        datatype = gdal.GDT_Byte</span><br><span class="line">    <span class="keyword">elif</span> <span class="string">&#x27;int16&#x27;</span> <span class="keyword">in</span> im_data.dtype.name:</span><br><span class="line">        datatype = gdal.GDT_UInt16</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        datatype = gdal.GDT_Float32</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 判读数组维数</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(im_data.shape) == <span class="number">3</span>:</span><br><span class="line">        im_bands, im_height, im_width = im_data.shape</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        im_bands, (im_height, im_width) = <span class="number">1</span>, im_data.shape</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># (1)创建文件GeoTIFF驱动</span></span><br><span class="line">    driver = gdal.GetDriverByName(<span class="string">&quot;GTiff&quot;</span>)</span><br><span class="line">    options = [<span class="string">&#x27;INTERLEAVE=BAND&#x27;</span>]  <span class="comment"># BSQ格式(通常默认)</span></span><br><span class="line">    <span class="comment"># &#x27;LINE&#x27; is an unexpected value for INTERLEAVE creation option of type string-select.value must be PIXEL or BAND</span></span><br><span class="line">    <span class="comment"># options = [&#x27;INTERLEAVE=LINE&#x27;]  # BIL格式</span></span><br><span class="line">    <span class="comment"># options = [&#x27;INTERLEAVE=PIXEL&#x27;] # BIP格式</span></span><br><span class="line">    dataset = driver.Create(filename, im_width, im_height, im_bands, datatype, options)</span><br><span class="line">    </span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    # (2)创建文件ENVI驱动</span></span><br><span class="line"><span class="string">    driver = gdal.GetDriverByName(&quot;ENVI&quot;)</span></span><br><span class="line"><span class="string">    options = [&#x27;INTERLEAVE=BSQ&#x27;]  # Band Sequential(通常默认)</span></span><br><span class="line"><span class="string">    # options = [&#x27;INTERLEAVE=BIL&#x27;]  # Band Interleaved by Line</span></span><br><span class="line"><span class="string">    # options = [&#x27;INTERLEAVE=BIP&#x27;]  # Band Interleaved by Pixel</span></span><br><span class="line"><span class="string">    dataset = driver.Create(filename, im_width, im_height, im_bands, datatype, options)</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    dataset.SetGeoTransform(im_geotrans)  <span class="comment"># 写入仿射变换参数</span></span><br><span class="line">    dataset.SetProjection(im_proj)  <span class="comment"># 写入投影</span></span><br><span class="line">    <span class="keyword">if</span> im_bands == <span class="number">1</span>:</span><br><span class="line">        dataset.GetRasterBand(<span class="number">1</span>).WriteArray(im_data)  <span class="comment"># 写入数组数据</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(im_bands):</span><br><span class="line">            dataset.GetRasterBand(i + <span class="number">1</span>).WriteArray(im_data[i,:,:])</span><br><span class="line">    <span class="keyword">del</span> dataset</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> rasterio</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过设置虚拟内存，将格式转换（NC→TIF）后的数据保存到虚拟内存中，再读取进行裁剪（基于矢量）</span></span><br><span class="line"><span class="comment"># 此处读取数据的过程暂时省略（代码不全），仅仅展示虚拟路径保存和读取的方式。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置GDAL的虚拟路径标识符</span></span><br><span class="line">temp_path = <span class="string">&quot;/vsimem/&quot;</span></span><br><span class="line">shp_path = <span class="string">r&quot;D:\Study\...\shp\MinimumBound_buffer.shp&quot;</span></span><br><span class="line">output_path = <span class="string">r&quot;D:\Study\...\Himawari_pre&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取数据</span></span><br><span class="line">SWR = tep_data.variables[<span class="string">&quot;SWR&quot;</span>][:]</span><br><span class="line">SWR_arr = np.asarray(SWR)</span><br><span class="line"><span class="comment"># 虚拟路径文件</span></span><br><span class="line">temp_path1 = temp_path + dates[<span class="number">0</span>] + <span class="string">&quot;_SWR_5km.tif&quot;</span></span><br><span class="line">write_img(temp_path1, proj, geotransform, SWR_arr)</span><br><span class="line"><span class="comment"># rasterio.open(temp_path1)访问不到GDAL的虚拟路径文件</span></span><br><span class="line">dataset1 = gdal.Open(temp_path1)</span><br><span class="line">outpath1 = os.sep.join([out_path, <span class="string">&quot;SWR&quot;</span>, dates[<span class="number">0</span>] + <span class="string">&quot;_SWR_5km_clip.tif&quot;</span>])</span><br><span class="line">clip_result1 = gdal.Warp(</span><br><span class="line">    outpath1,</span><br><span class="line">    dataset1,</span><br><span class="line">    <span class="built_in">format</span>=<span class="string">&#x27;GTiff&#x27;</span>,</span><br><span class="line">    cutlineDSName=shp_path,</span><br><span class="line">    cropToCutline=<span class="literal">True</span>,</span><br><span class="line">    dstNodata=<span class="number">0</span></span><br><span class="line">)</span><br><span class="line">clip_result1.FlushCache()  <span class="comment"># 先强制写入磁盘</span></span><br><span class="line"><span class="keyword">del</span> clip_result1           <span class="comment"># 再释放内存</span></span><br><span class="line">gdal.Unlink(temp_path1)    <span class="comment"># 删除虚拟文件</span></span><br></pre></td></tr></table></figure>
<p><strong>（2）Rasterio方式</strong></p>
<ul>
<li>影像读取和写入</li>
<li>基于矢量边界的影像裁剪<code>mask()</code></li>
<li>影像镶嵌<code>merge()</code></li>
<li>虚拟内存读写数据(<code>MemoryFile</code>类)</li>
<li>......</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> rasterio</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取影像</span></span><br><span class="line">filename = <span class="string">r&quot;D:\Desktop\data\郑州\pre\ly\zhengzhou_Landsat_20240517_clip.tif&quot;</span></span><br><span class="line"><span class="keyword">with</span> rasterio.<span class="built_in">open</span>(filename) <span class="keyword">as</span> dataset:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;文件名:&quot;</span>, dataset.name)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;宽度:&quot;</span>, dataset.width)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;高度:&quot;</span>, dataset.height)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;波段数量:&quot;</span>, dataset.count)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;四至范围:&quot;</span>, dataset.bounds)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;坐标参考信息:&quot;</span>, dataset.crs)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;坐标参考信息wkt:&quot;</span>, dataset.crs.wkt)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;仿射地理变换参数:&quot;</span>, dataset.transform)</span><br><span class="line">    <span class="comment"># 读取第一个波段的数据</span></span><br><span class="line">    band1 = dataset.read(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;波段1的形状&quot;</span>, band1.shape)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">文件名: D:/Desktop/data/郑州/pre/ly/zhengzhou_Landsat_20240517_clip.tif</span><br><span class="line">宽度: <span class="number">4650</span></span><br><span class="line">高度: <span class="number">2802</span></span><br><span class="line">波段数量: <span class="number">7</span></span><br><span class="line">四至范围: BoundingBox(left=<span class="number">657088.5475157951</span>, bottom=<span class="number">3792558.9565376947</span>, right=<span class="number">796588.5475157951</span>, top=<span class="number">3876618.9565376947</span>)</span><br><span class="line">坐标参考信息: EPSG:<span class="number">32649</span></span><br><span class="line">坐标参考信息wkt: PROJCS[<span class="string">&quot;WGS 84 / UTM zone 49N&quot;</span>,GEOGCS[<span class="string">&quot;WGS 84&quot;</span>,DATUM[<span class="string">&quot;WGS_1984&quot;</span>,SPHEROID[<span class="string">&quot;WGS 84&quot;</span>,<span class="number">6378137</span>,<span class="number">298.257223563</span>,AUTHORITY[<span class="string">&quot;EPSG&quot;</span>,<span class="string">&quot;7030&quot;</span>]],AUTHORITY[<span class="string">&quot;EPSG&quot;</span>,<span class="string">&quot;6326&quot;</span>]],PRIMEM[<span class="string">&quot;Greenwich&quot;</span>,<span class="number">0</span>,AUTHORITY[<span class="string">&quot;EPSG&quot;</span>,<span class="string">&quot;8901&quot;</span>]],UNIT[<span class="string">&quot;degree&quot;</span>,<span class="number">0.0174532925199433</span>,AUTHORITY[<span class="string">&quot;EPSG&quot;</span>,<span class="string">&quot;9122&quot;</span>]],AUTHORITY[<span class="string">&quot;EPSG&quot;</span>,<span class="string">&quot;4326&quot;</span>]],PROJECTION[<span class="string">&quot;Transverse_Mercator&quot;</span>],PARAMETER[<span class="string">&quot;latitude_of_origin&quot;</span>,<span class="number">0</span>],PARAMETER[<span class="string">&quot;central_meridian&quot;</span>,<span class="number">111</span>],PARAMETER[<span class="string">&quot;scale_factor&quot;</span>,<span class="number">0.9996</span>],PARAMETER[<span class="string">&quot;false_easting&quot;</span>,<span class="number">500000</span>],PARAMETER[<span class="string">&quot;false_northing&quot;</span>,<span class="number">0</span>],UNIT[<span class="string">&quot;metre&quot;</span>,<span class="number">1</span>,AUTHORITY[<span class="string">&quot;EPSG&quot;</span>,<span class="string">&quot;9001&quot;</span>]],AXIS[<span class="string">&quot;Easting&quot;</span>,EAST],AXIS[<span class="string">&quot;Northing&quot;</span>,NORTH],AUTHORITY[<span class="string">&quot;EPSG&quot;</span>,<span class="string">&quot;32649&quot;</span>]]</span><br><span class="line">仿射地理变换参数: | <span class="number">30.00</span>, <span class="number">0.00</span>, <span class="number">657088.55</span>|</span><br><span class="line">| <span class="number">0.00</span>,-<span class="number">30.00</span>, <span class="number">3876618.96</span>|</span><br><span class="line">| <span class="number">0.00</span>, <span class="number">0.00</span>, <span class="number">1.00</span>|</span><br><span class="line">波段<span class="number">1</span>的形状 (<span class="number">2802</span>, <span class="number">4650</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> rasterio</span><br><span class="line"><span class="keyword">import</span> geopandas <span class="keyword">as</span> gpd</span><br><span class="line"><span class="keyword">from</span> rasterio.mask <span class="keyword">import</span> mask</span><br><span class="line"></span><br><span class="line"><span class="comment"># 基于矢量边界的影像裁剪</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Shp_Clip_Raster</span>(<span class="params">Shp_path, Raster_path, Clip_path</span>):</span><br><span class="line">    <span class="comment"># 打开矢量数据集</span></span><br><span class="line">    outline_shp = gpd.read_file(Shp_path)</span><br><span class="line">    <span class="keyword">with</span> rasterio.<span class="built_in">open</span>(Raster_path) <span class="keyword">as</span> dataset:</span><br><span class="line">        <span class="comment"># 裁剪栅格数据</span></span><br><span class="line">        out_image, out_transform = mask(dataset, outline_shp.geometry, crop=<span class="literal">True</span>)</span><br><span class="line">        <span class="comment"># 更新元数据信息</span></span><br><span class="line">        out_meta = dataset.meta.copy()</span><br><span class="line">        out_meta.update(&#123;</span><br><span class="line">            <span class="string">&quot;driver&quot;</span>: <span class="string">&quot;GTiff&quot;</span>,</span><br><span class="line">            <span class="string">&quot;height&quot;</span>: out_image.shape[<span class="number">1</span>],</span><br><span class="line">            <span class="string">&quot;width&quot;</span>: out_image.shape[<span class="number">2</span>],</span><br><span class="line">            <span class="string">&quot;transform&quot;</span>: out_transform</span><br><span class="line">            &#125;)</span><br><span class="line">        <span class="keyword">with</span> rasterio.<span class="built_in">open</span>(Clip_path, <span class="string">&quot;w&quot;</span>, **out_meta) <span class="keyword">as</span> dest:</span><br><span class="line">            dest.write(out_image)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    Shp_path = <span class="string">r&quot;D:\...\郑州市\郑州市prj.shp&quot;</span></span><br><span class="line">    Raster_path = <span class="string">r&quot;D:\...\LC08_L2SP_124036_20240517_20240521_02_T1_SR_ly.tif&quot;</span></span><br><span class="line">    Clip_path = <span class="string">r&quot;D:\...\clip\zhengzhou_Landsat_20240517_clip.tif&quot;</span></span><br><span class="line">    Shp_Clip_Raster(Shp_path, Raster_path, Clip_path)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> glob</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> rasterio</span><br><span class="line"><span class="keyword">from</span> rasterio.merge <span class="keyword">import</span> merge</span><br><span class="line"></span><br><span class="line"><span class="comment"># 影像镶嵌</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Raster1_Merge_Raster2</span>(<span class="params">Rasters_path, Mosaic_path</span>):</span><br><span class="line">    <span class="comment"># 打开栅格数据</span></span><br><span class="line">    mosaic_files = [rasterio.<span class="built_in">open</span>(path) <span class="keyword">for</span> path <span class="keyword">in</span> Rasters_path]</span><br><span class="line">    mosaic_image, mosaic_transform = merge(mosaic_files)</span><br><span class="line">    mosaic_meta = mosaic_files[<span class="number">0</span>].meta.copy()</span><br><span class="line">    mosaic_meta.update(&#123;</span><br><span class="line">        <span class="string">&quot;driver&quot;</span>: <span class="string">&quot;GTiff&quot;</span>,</span><br><span class="line">        <span class="string">&quot;height&quot;</span>: mosaic_image.shape[<span class="number">1</span>],</span><br><span class="line">        <span class="string">&quot;width&quot;</span>: mosaic_image.shape[<span class="number">2</span>],</span><br><span class="line">        <span class="string">&quot;transform&quot;</span>: mosaic_transform</span><br><span class="line">        &#125;)</span><br><span class="line">    <span class="comment"># 保存镶嵌后的栅格数据</span></span><br><span class="line">    <span class="keyword">with</span> rasterio.<span class="built_in">open</span>(Mosaic_path, <span class="string">&quot;w&quot;</span>, **mosaic_meta) <span class="keyword">as</span> dest:</span><br><span class="line">        dest.write(mosaic_image)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    Rasters_Folder = <span class="string">r&quot;D:\...\mos\Rasters&quot;</span>      <span class="comment"># Rasters文件夹下包含两个镶嵌的TIF文件</span></span><br><span class="line">    Mosaic_path = <span class="string">r&quot;D:\...\mos\LC08_L2SP_124036_20240517_layer1_2_Mosaic.tif&quot;</span></span><br><span class="line">    Rasters_path = glob.glob(os.sep.join([Rasters_Folder, <span class="string">&#x27;*.tif&#x27;</span>]))</span><br><span class="line">    Raster1_Merge_Raster2(Rasters_path, Mosaic_path) </span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> geopandas <span class="keyword">as</span> gpd</span><br><span class="line"><span class="keyword">import</span> rasterio</span><br><span class="line"><span class="keyword">from</span> rasterio.io <span class="keyword">import</span> MemoryFile</span><br><span class="line"><span class="keyword">from</span> rasterio.mask <span class="keyword">import</span> mask</span><br><span class="line"></span><br><span class="line"><span class="comment"># 虚拟内存读写数据</span></span><br><span class="line"><span class="comment"># 在内存中实现掩膜裁剪处理，并计算保存NDVI结果</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ndvi_computer</span>(<span class="params">shp_path, image_path, ndvi_path</span>):</span><br><span class="line">    <span class="comment"># 读取矢量边界</span></span><br><span class="line">    clip_shp = gpd.read_file(shp_path)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">with</span> rasterio.<span class="built_in">open</span>(image_path) <span class="keyword">as</span> dataset:</span><br><span class="line">        <span class="comment"># 直接在内存中裁剪</span></span><br><span class="line">        <span class="keyword">with</span> MemoryFile() <span class="keyword">as</span> memfile:</span><br><span class="line">            out_image, out_transform = mask(dataset, clip_shp.geometry, crop=<span class="literal">True</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 更新元数据信息</span></span><br><span class="line">            out_meta = dataset.meta.copy()</span><br><span class="line">            out_meta.update(&#123;</span><br><span class="line">                <span class="string">&quot;driver&quot;</span>: <span class="string">&quot;GTiff&quot;</span>,</span><br><span class="line">                <span class="string">&quot;height&quot;</span>: out_image.shape[<span class="number">1</span>],</span><br><span class="line">                <span class="string">&quot;width&quot;</span>: out_image.shape[<span class="number">2</span>],</span><br><span class="line">                <span class="string">&quot;transform&quot;</span>: out_transform</span><br><span class="line">            &#125;)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">with</span> memfile.<span class="built_in">open</span>(**out_meta) <span class="keyword">as</span> clipped_ds:</span><br><span class="line">                clipped_ds.write(out_image)</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;裁剪后尺寸:&quot;</span>, out_image.shape)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 使用内存栅格进行分析</span></span><br><span class="line">            <span class="keyword">with</span> memfile.<span class="built_in">open</span>() <span class="keyword">as</span> ds:</span><br><span class="line">                ndvi = (ds.read(<span class="number">4</span>) - ds.read(<span class="number">3</span>)) / (ds.read(<span class="number">4</span>) + ds.read(<span class="number">3</span>))</span><br><span class="line">                <span class="comment"># 保存NDVI结果</span></span><br><span class="line">                save_ndvi(ndvi, ds.meta, ndvi_path)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">save_ndvi</span>(<span class="params">ndvi, image_meta, ndvi_path</span>):</span><br><span class="line">    <span class="comment"># 更新元数据信息</span></span><br><span class="line">    ndvi_meta = image_meta.copy()</span><br><span class="line">    ndvi_meta.update(&#123;</span><br><span class="line">        <span class="string">&quot;driver&quot;</span>: <span class="string">&quot;GTiff&quot;</span>,</span><br><span class="line">        <span class="string">&quot;count&quot;</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="string">&quot;dtype&quot;</span>: <span class="string">&quot;float32&quot;</span>,</span><br><span class="line">        <span class="string">&quot;nodata&quot;</span>: <span class="number">0</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment"># 写入文件</span></span><br><span class="line">    <span class="keyword">with</span> rasterio.<span class="built_in">open</span>(ndvi_path, <span class="string">&quot;w&quot;</span>, **ndvi_meta) <span class="keyword">as</span> dest:</span><br><span class="line">        <span class="comment"># 写入数据到第1波段</span></span><br><span class="line">        dest.write(ndvi, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    shp_path = <span class="string">r&quot;D:\Desktop\data\...\Layer1.shp&quot;</span></span><br><span class="line">    image_path = <span class="string">r&quot;D:\Desktop\data\...\Landsat_20240517_clip.tif&quot;</span></span><br><span class="line">    ndvi_path = <span class="string">r&quot;D:\Desktop\data\...\Layer1_NDVI.tif&quot;</span></span><br><span class="line">    <span class="comment"># 裁剪影像并计算NDVI，同时将裁剪后的影像先保存在内存中，再读取</span></span><br><span class="line">    ndvi_computer(shp_path, image_path, ndvi_path)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>小编基于<code>rasterio</code>库的"<code>mask</code>"和<code>ArcGIS</code>的"<code>Extract by Mask</code>"工具两种方式，对栅格影像进行裁剪：</p>
<ul>
<li>利用<code>ArcGIS</code>的"<code>Extract by Mask</code>"工具裁剪影像会出现像元偏移的问题，像元值与原始影像存在比较小的差异；利用<code>rasterio</code>库的"<code>mask</code>"裁剪影像，像元值是对应的。</li>
<li>基于<code>rasterio</code>库的"<code>mask</code>"和<code>ArcGIS</code>的"<code>Extract by Mask</code>"工具两种方式对原始影像进行裁剪，分别得到有交集的<code>Layer1</code>和<code>Layer2</code>，统一利用<code>rasterio</code>库的"<code>merge</code>"进行影像镶嵌，同样存在上述问题。</li>
</ul>
</blockquote>
<p>在<code>Rasterio</code>中，<code>dataset.profile</code>和<code>dataset.meta</code>都是用于访问栅格数据集元数据的属性，但它们在使用场景和返回内容上有一些关键区别：<code>rasterio</code>中<code>dataset.profile</code>和<code>dataset.meta</code>的区别：</p>
<table>
<thead>
<tr class="header">
<th>特性</th>
<th>dataset.profile</th>
<th>dataset.meta</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>返回类型</strong></td>
<td>字典(可写，可直接用于创建新文件)</td>
<td>字典(只读副本)</td>
</tr>
<tr class="even">
<td><strong>主要用途</strong></td>
<td>创建新栅格时的模板</td>
<td>查看元数据</td>
</tr>
<tr class="odd">
<td><strong>可变性</strong></td>
<td>可修改(修改后会影响数据集)</td>
<td>不可修改</td>
</tr>
<tr class="even">
<td><strong>包含内容</strong></td>
<td>核心元数据 + 部分驱动特定选项</td>
<td>仅核心元数据</td>
</tr>
<tr class="odd">
<td><strong>版本引入</strong></td>
<td><code>Rasterio 1.0+</code></td>
<td>早期版本即有</td>
</tr>
</tbody>
</table>
<p><code>rasterio</code>中<code>dataset.meta</code>属性设置及其详细说明：</p>
<table>
<thead>
<tr class="header">
<th>属性名</th>
<th>数据类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>driver</code></td>
<td><code>str</code></td>
<td>栅格驱动名称(如<code>'GTiff'</code>、<code>'PNG'</code>、<code>'HFA'</code>等)</td>
</tr>
<tr class="even">
<td><code>dtype</code></td>
<td><code>str</code></td>
<td>数据类型(如<code>'uint8'</code>、<code>'float32'</code>等)，对应<code>NumPy</code>数据类型</td>
</tr>
<tr class="odd">
<td><code>nodata</code></td>
<td><code>int</code>/<code>float</code>/<code>None</code></td>
<td>表示无效数据的值(如<code>0</code>、<code>-9999</code>或<code>None</code>表示无<code>Nodata</code>值)</td>
</tr>
<tr class="even">
<td><code>width</code></td>
<td><code>int</code></td>
<td>栅格列数(宽度)</td>
</tr>
<tr class="odd">
<td><code>height</code></td>
<td><code>int</code></td>
<td>栅格行数(高度)</td>
</tr>
<tr class="even">
<td><code>count</code></td>
<td><code>int</code></td>
<td>波段数量(如<code>RGB</code>图像为3)</td>
</tr>
<tr class="odd">
<td><code>crs</code></td>
<td><code>rasterio.crs.CRS</code></td>
<td>坐标参考系统(如<code>CRS.from_epsg(4326)</code>表示<code>WGS84</code>)</td>
</tr>
<tr class="even">
<td><code>transform</code></td>
<td><code>Affine</code></td>
<td>仿射变换矩阵</td>
</tr>
</tbody>
</table>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 示例meta输出</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&#x27;driver&#x27;</span>: <span class="string">&#x27;GTiff&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;dtype&#x27;</span>: <span class="string">&#x27;uint16&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;nodata&#x27;</span>: <span class="literal">None</span>,</span><br><span class="line">    <span class="string">&#x27;width&#x27;</span>: <span class="number">1000</span>,</span><br><span class="line">    <span class="string">&#x27;height&#x27;</span>: <span class="number">800</span>,</span><br><span class="line">    <span class="string">&#x27;count&#x27;</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="string">&#x27;crs&#x27;</span>: CRS.from_epsg(<span class="number">32650</span>),</span><br><span class="line">    <span class="string">&#x27;transform&#x27;</span>: Affine(<span class="number">10.0</span>, <span class="number">0.0</span>, <span class="number">500000.0</span>,</span><br><span class="line">                       <span class="number">0.0</span>, -<span class="number">10.0</span>, <span class="number">1200000.0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 示例profile输出</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&#x27;driver&#x27;</span>: <span class="string">&#x27;GTiff&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;dtype&#x27;</span>: <span class="string">&#x27;uint16&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;nodata&#x27;</span>: <span class="number">0.0</span>,</span><br><span class="line">    <span class="string">&#x27;width&#x27;</span>: <span class="number">1024</span>,</span><br><span class="line">    <span class="string">&#x27;height&#x27;</span>: <span class="number">768</span>,</span><br><span class="line">    <span class="string">&#x27;count&#x27;</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="string">&#x27;crs&#x27;</span>: CRS.from_epsg(<span class="number">4326</span>),</span><br><span class="line">    <span class="string">&#x27;transform&#x27;</span>: Affine(<span class="number">0.1</span>, <span class="number">0.0</span>, <span class="number">30.0</span>,</span><br><span class="line">                       <span class="number">0.0</span>, -<span class="number">0.1</span>, <span class="number">50.0</span>),</span><br><span class="line">    <span class="string">&#x27;compress&#x27;</span>: <span class="string">&#x27;lzw&#x27;</span>,          <span class="comment"># 驱动特定选项</span></span><br><span class="line">    <span class="string">&#x27;tiled&#x27;</span>: <span class="literal">True</span>,              <span class="comment"># 驱动特定选项</span></span><br><span class="line">    <span class="string">&#x27;blockxsize&#x27;</span>: <span class="number">256</span>,          <span class="comment"># 驱动特定选项</span></span><br><span class="line">    <span class="string">&#x27;blockysize&#x27;</span>: <span class="number">256</span>           <span class="comment"># 驱动特定选项</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>使用场景示例：</strong></p>
<p>①创建新文件时：优先使用<code>.profile</code></p>
<p>②修改参数时：复制<code>.profile</code>后再修改</p>
<p>③仅查看元数据时：使用<code>.meta</code>更安全</p>
<p>④需要驱动特定参数时：必须用<code>.profile</code></p>
<p>总结来说：需要修改或创建新文件时用<code>.profile</code>，只读访问时用<code>.meta</code>。</p>
</blockquote>
<h3 id="hdf数据">👀<code>HDF</code>数据</h3>
<p><code>HDF</code>(<code>Hierarchical Data Format</code>)是用于存储和分发科学数据的一种自我描述、多对象文件格式。<code>HDF</code>是由美国国家超级计算应用中心(<code>NCSA</code>)创建的，中文名称为<strong>层次型数据格式</strong>，以满足不同群体的科学家在不同工程项目领域之需要。<code>HDF</code>主要特征是：</p>
<ul>
<li>自述性： <code>HDF</code>文件里的每一个数据对象，有关于该数据的综合信息（元数据）。在没有任何外部信息的情况下，应用程序能够解读<code>HDF</code>文件的结构和内容。</li>
<li>通用性：许多数据类型都可以被嵌入在一个<code>HDF</code>文件里。例如，通过使用合适的<code>HDF</code>数据结构，符号、数字和图形数据可以同时存储在一个<code>HDF</code>文件里。</li>
<li>灵活性：<code>HDF</code>允许用户把相关的数据对象组合在一起，放到一个分层结构中，可在数据对象中添加描述和标签。它还允许用户把科学数据放到多个<code>HDF</code>文件里。</li>
<li>扩展性：<code>HDF</code>极易容纳新增加的数据模式，容易与其他标准格式兼容。</li>
<li>跨平台性：<code>HDF</code>是一个与平台无关的文件格式。<code>HDF</code>文件无需任何转换就可以在不同平台上使用。</li>
</ul>
<p><code>HDF</code>的最初产生于20世纪80年代，到现在已经具有两个不同的产品。从<code>HDF1</code>到<code>HDF4</code>的各个版本在本质上是一致的，因而<code>HDF4</code>可以兼容早期的版本。<code>HDF5</code>推出于1998年，相较于以前的<code>HDF</code>文件，可以说是一种全新的文件格式。它与<code>HDF4</code>只在概念上一脉相承，而在数据结构的组织上却截然迥异。<code>HDF5</code>的产生与发展反映了<code>HDF</code>在不断适应现代计算机发展和数据处理日益庞大复杂的要求。<code>HDF</code>强大的机制适应了遥感影像的特点，能够有条不紊、完备地保存遥感影像的属性和空间信息数据，同时使查询和提取相关数据也很方便容易。<code>HDF4</code>与<code>HDF5</code>的优缺点对比：</p>
<ul>
<li><p><code>HDF4</code>文件由文件头，数据描述符块和数据元素组成，后两者组成数据对象。数据描述符块由若干描述符组成，它们由标识符、参照符、数据偏移量、数据长度等组成。标识符和参照数组合在一起唯一确定一个数据对象。</p></li>
<li><p><code>HDF4</code>不能存储多于2万个复杂对象，文件大小不能超过2G字节，其数据结构不能完全包含它的内容。随着对象的增多，数据类型也受到限制，库代码过时，过于琐碎，不能有效执行并行I/O，难于运用到线程程序中，<code>HDF5</code>不但能处理更多对象，存储更大的文件，支持并行I/O，线程和具备现代操作系统与应用程序所要求的其他特性。而且数据模型变得更简单，概括性更强。</p></li>
<li><p><code>HDF5</code>格式运用了<code>HDF4</code>和<code>AIO</code>文件的某些关键思想, 比<code>HDF4</code>的自描述性更强, 它由一个超级块(super block)、B树结点(B-tree node)、对象头(object header)、集合(collection)、局部堆(local heaps)和自由空间(free space)组成。</p></li>
</ul>
<p><code>HDF</code>是一种功能强大, 广泛运用于科学领域的文件格式。研究它的组织结构特别是<code>HDF5</code>的组织结构对于处理和管理地理信息系统的海量图形数据和属性数据具有一定的借鉴作用。掌握和运用<code>NCSA</code>提供的<code>API</code>提取影像数据，可以节省时间，提高程序编写效率。因此，<code>HDF</code>将会得到很广泛的应用。而<code>HDF5</code>由于前面所述很多优点，已经可以在未来取代<code>HDF4</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 小编以批处理夜间灯光数据VNP46A4为例</span></span><br><span class="line"><span class="comment"># VNP46A4.A2012001.h28v04.001.2021125015952.hdf</span></span><br><span class="line"><span class="comment"># VNP46A4.A2012001.h28v05.001.2021125045353.hdf</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> h5py</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> osgeo <span class="keyword">import</span> gdal, osr</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存影像</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">write_img</span>(<span class="params">filename, im_proj, im_geotrans, im_data</span>):</span><br><span class="line">    <span class="comment"># 判断栅格数据的数据类型</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;int8&#x27;</span> <span class="keyword">in</span> im_data.dtype.name:</span><br><span class="line">        datatype = gdal.GDT_Byte</span><br><span class="line">    <span class="keyword">elif</span> <span class="string">&#x27;int16&#x27;</span> <span class="keyword">in</span> im_data.dtype.name:</span><br><span class="line">        datatype = gdal.GDT_UInt16</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        datatype = gdal.GDT_Float32</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 判读数组维数</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(im_data.shape) == <span class="number">3</span>:</span><br><span class="line">        im_bands, im_height, im_width = im_data.shape</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        im_bands, (im_height, im_width) = <span class="number">1</span>, im_data.shape</span><br><span class="line">    <span class="comment"># 创建文件</span></span><br><span class="line">    driver = gdal.GetDriverByName(<span class="string">&quot;GTiff&quot;</span>)</span><br><span class="line">    dataset = driver.Create(filename, im_width, im_height, im_bands, datatype)</span><br><span class="line">    dataset.SetGeoTransform(im_geotrans)  <span class="comment"># 写入仿射变换参数</span></span><br><span class="line">    dataset.SetProjection(im_proj)  <span class="comment"># 写入投影</span></span><br><span class="line">    <span class="keyword">if</span> im_bands == <span class="number">1</span>:</span><br><span class="line">        dataset.GetRasterBand(<span class="number">1</span>).WriteArray(im_data)  <span class="comment"># 写入数组数据</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(im_bands):</span><br><span class="line">            dataset.GetRasterBand(i + <span class="number">1</span>).WriteArray(im_data[i,:,:])</span><br><span class="line">    <span class="keyword">del</span> dataset</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hdf_to_tif</span>(<span class="params">input_folder_path, output_path</span>):</span><br><span class="line">    <span class="comment"># 批量获取hdf文件名</span></span><br><span class="line">    files_name = []</span><br><span class="line">    <span class="comment"># 获取目标路径下的文件和文件夹的名字列表</span></span><br><span class="line">    <span class="keyword">for</span> path <span class="keyword">in</span> os.listdir(input_folder_path):</span><br><span class="line">        <span class="keyword">if</span> os.path.isfile(os.path.join(input_folder_path, path)):</span><br><span class="line">            files_name.append(path)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(files_name)):</span><br><span class="line">        input_path = os.sep.join([input_folder_path, files_name[i]])</span><br><span class="line">        <span class="keyword">with</span> h5py.File(input_path, <span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">            for key in f.keys():</span></span><br><span class="line"><span class="string">                # print(f[key], key, f[key].name, f[key].value)</span></span><br><span class="line"><span class="string">                # 因为这里有group对象,它是没有value属性的,故会异常。另外字符串读出来的是字节流，需要解码成字符串</span></span><br><span class="line"><span class="string">                # f[key]表示dataset或group对象,f[key].value访问dataset的值,group对象除外。</span></span><br><span class="line"><span class="string">                print(f[key], key, f[key].name)</span></span><br><span class="line"><span class="string">            print(&quot;*&quot;*50)</span></span><br><span class="line"><span class="string">            &#x27;&#x27;&#x27;</span></span><br><span class="line">            <span class="comment"># 根据夜间灯光数据hdf格式的数据结构,读取对应的数据层获取数据</span></span><br><span class="line">            HDF5_group = f[<span class="string">&quot;HDFEOS&quot;</span>][<span class="string">&quot;GRIDS&quot;</span>][<span class="string">&quot;VIIRS_Grid_DNB_2d&quot;</span>][<span class="string">&quot;Data Fields&quot;</span>]</span><br><span class="line">            <span class="comment"># print(HDF5_group.keys())</span></span><br><span class="line">            DNB_data = HDF5_group[<span class="string">&quot;AllAngle_Composite_Snow_Free&quot;</span>][:]*<span class="number">0.1</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 获取hdf文件中对应经纬度变量的信息</span></span><br><span class="line">            lon_data = HDF5_group[<span class="string">&quot;lon&quot;</span>][:]</span><br><span class="line">            lat_data = HDF5_group[<span class="string">&quot;lat&quot;</span>][:]</span><br><span class="line">            <span class="comment"># 影像的左上角&amp;右下角坐标</span></span><br><span class="line">            lonmin, latmax, lonmax, latmin = [lon_data.<span class="built_in">min</span>(), lat_data.<span class="built_in">max</span>(), lon_data.<span class="built_in">max</span>(), lat_data.<span class="built_in">min</span>()]</span><br><span class="line">            <span class="comment"># 分辨率计算</span></span><br><span class="line">            num_lon = <span class="built_in">len</span>(lon_data)</span><br><span class="line">            num_lat = <span class="built_in">len</span>(lat_data)</span><br><span class="line">            lon_res = (lonmax - lonmin) / (<span class="built_in">float</span>(num_lon) - <span class="number">1</span>)</span><br><span class="line">            lat_res = (latmax - latmin) / (<span class="built_in">float</span>(num_lat) - <span class="number">1</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 定义投影</span></span><br><span class="line">            proj = osr.SpatialReference()</span><br><span class="line">            proj.ImportFromEPSG(<span class="number">4326</span>)  <span class="comment"># WGS84</span></span><br><span class="line">            proj = proj.ExportToWkt()  <span class="comment"># 重点，转成wkt格式</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 定义六参数，设置影像的显示范围和分辨率</span></span><br><span class="line">            <span class="comment"># 影像左上角横坐标：geoTransform[0]</span></span><br><span class="line">            <span class="comment"># 影像左上角纵坐标：geoTransform[3]</span></span><br><span class="line">            <span class="comment"># 遥感图像的水平空间分辨率为geoTransform[1]</span></span><br><span class="line">            <span class="comment"># 遥感图像的垂直空间分辨率为geoTransform[5]</span></span><br><span class="line">            <span class="comment"># 通常geoTransform[5]与geoTransform[1]相等</span></span><br><span class="line">            <span class="comment"># 如果影像方向没有发生旋转，即上北、下南，则geoTransform[2]与geoTransform[4]为零。</span></span><br><span class="line">            geotransform = (lonmin, lon_res, <span class="number">0.0</span>, latmax, <span class="number">0.0</span>, -lat_res)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 注意os.path.join和os.sep.join的区别</span></span><br><span class="line">            save_name = files_name[i].split(<span class="string">&quot;.&quot;</span>)</span><br><span class="line">            save_name = <span class="string">&quot;_&quot;</span>.join(save_name[:<span class="number">3</span>])</span><br><span class="line">            output_file_path = os.path.join(output_path, save_name + <span class="string">&quot;.tif&quot;</span>)</span><br><span class="line">            write_img(output_file_path, proj, geotransform, DNB_data)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;转换成功&quot;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># hdf文件输入输出路径</span></span><br><span class="line">    input_folder_path = <span class="string">r&quot;D:\Desktop\data\hdf\VNP46A4&quot;</span></span><br><span class="line">    output_path = <span class="string">r&quot;D:\Desktop\data\hdf\tif&quot;</span></span><br><span class="line">    <span class="comment"># 批量读取hdf文件，转换为tif文件</span></span><br><span class="line">    hdf_to_tif(input_folder_path, output_path)</span><br></pre></td></tr></table></figure>
<h3 id="dat数据">👀<code>DAT</code>数据</h3>
<p><code>ENVI</code>软件中的<code>.dat</code>文件<strong>是存储遥感图像原始像元值数据的二进制文件</strong>。它本身缺乏解释自身内容的信息，必须依赖一个同名的<code>.hdr</code>头文件来提供解读这些二进制数据所需的元数据(尺寸、波段数、数据类型、排列方式、坐标等)。<code>.dat</code>和<code>.hdr</code>文件共同构成了<code>ENVI</code>的标准栅格数据格式。当你在<code>ENVI</code>中打开一个<code>.dat</code>文件时，软件实际上是同时读取了<code>.dat</code>和<code>.hdr</code>文件来正确显示和处理图像。</p>
<p><strong>（1）核心作用：存储像元值数据</strong></p>
<ul>
<li><code>.dat</code>文件包含了图像最基本的元素——像元(像素)的数值本身。</li>
<li>这些数值代表了传感器捕获的地物辐射能量(通常经过一定处理，如辐射定标后的辐亮度、反射率等，或原始的<code>DN</code>值)。</li>
</ul>
<p><strong>（2）与<code>.hdr</code>文件的密不可分性</strong></p>
<ul>
<li>单独的<code>.dat</code>文件本身是"无意义"的，因为它不包含任何解释这些二进制数据含义的信息。</li>
<li>它必须与一个同名的<code>.hdr</code>(头文件) 文件配对使用。</li>
<li><code>.hdr</code>文件是一个纯文本文件，包含了解读<code>.dat</code>文件所必需的元数据(<code>Metadata</code>)，例如：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">samples：图像列数（宽度）</span><br><span class="line">lines：图像行数（高度）。</span><br><span class="line">bands：图像波段数。</span><br><span class="line">data type：像元值的数据类型（如，1：无符号整数、2：有符号整数、4：浮点数等）。</span><br><span class="line">interleave：数据的排列方式（BSQ-按波段顺序排列、BIL-按行交叉排列、BIP-按像元交叉排列）。</span><br><span class="line">byte order：字节顺序（大端序1或小端序0）。</span><br><span class="line">map info：地理坐标信息（投影、像素大小、左上角坐标等）。</span><br><span class="line">wavelength：各个波段的中心波长（对于高光谱数据尤为重要）。</span><br><span class="line">以及其他描述性信息（如传感器类型、采集时间等）。</span><br><span class="line"></span><br><span class="line">ENVI</span><br><span class="line">description = &#123;</span><br><span class="line">  Band Math Result, Expression = [b1*0.0000275 - 0.2] B1:Band</span><br><span class="line">  1:LC08_L2SP_124036_20240517_20240521_02_T1_SR_B2.TIF [Mon Apr 07 22:49:04</span><br><span class="line">  2025]&#125;</span><br><span class="line">samples = 7571</span><br><span class="line">lines   = 7711</span><br><span class="line">bands   = 1</span><br><span class="line">header offset = 0</span><br><span class="line">file type = ENVI Standard</span><br><span class="line">data type = 4</span><br><span class="line">interleave = bsq</span><br><span class="line">sensor type = Unknown</span><br><span class="line">byte order = 0</span><br><span class="line">map info = &#123;UTM, 1.000, 1.000, 609585.000, 3947715.000, 3.0000000000e+001, 3.0000000000e+001, 49, North, WGS-84, units=Meters&#125;</span><br><span class="line">coordinate system string = &#123;PROJCS[&quot;WGS_1984_UTM_Zone_49N&quot;,GEOGCS[&quot;GCS_WGS_1984&quot;,DATUM[&quot;D_WGS_1984&quot;,SPHEROID[&quot;WGS_1984&quot;,6378137.0,298.257223563]],PRIMEM[&quot;Greenwich&quot;,0.0],UNIT[&quot;Degree&quot;,0.0174532925199433]],PROJECTION[&quot;Transverse_Mercator&quot;],PARAMETER[&quot;False_Easting&quot;,500000.0],PARAMETER[&quot;False_Northing&quot;,0.0],PARAMETER[&quot;Central_Meridian&quot;,111.0],PARAMETER[&quot;Scale_Factor&quot;,0.9996],PARAMETER[&quot;Latitude_Of_Origin&quot;,0.0],UNIT[&quot;Meter&quot;,1.0]]&#125;</span><br><span class="line">wavelength units = Unknown</span><br><span class="line">band names = &#123;</span><br><span class="line"> Band Math (b1*0.0000275-0.2)&#125;</span><br></pre></td></tr></table></figure>
<p><strong>（3）分离方式的优势</strong></p>
<ul>
<li><strong>灵活性：</strong> 可以轻松修改元数据<code>.hdr</code>而不需要重新生成庞大的数据文件<code>.dat</code>。例如，可以快速更改投影信息或添加波长信息。</li>
<li><strong>效率：</strong> 二进制存储<code>.dat</code>对于读写大型图像数据非常高效。</li>
<li><strong>兼容性：</strong> 文本格式的<code>.hdr</code>易于人类阅读和编辑，也易于被不同软件解析(只要它们理解<code>ENVI</code>头文件格式)。</li>
<li><strong>通用性：</strong> 这种"头文件+数据文件"的模式在科学数据处理领域非常常见。</li>
</ul>
<p><strong>（4）处理方式</strong></p>
<blockquote>
<p>可以参照"<code>GeoTIFF</code>"的处理方法，两者大同小异，基本一致。</p>
</blockquote>
<h2 id="矢量数据">⛄矢量数据</h2>
<h3 id="常用python库-1">👀常用Python库</h3>
<p><strong>（1）GeoPandas</strong></p>
<p><code>GeoPandas</code>是用于地理数据处理和分析的<code>Python</code>库。它扩展了<code>Pandas</code>库，能够轻松处理地理数据。<code>GeoPandas</code>提供了丰富的功能，包括读取和写入地理数据文件、几何操作、空间连接、地理编码等。<code>GeoPandas</code>提供两个主要的数据结构：<code>GeoSeries</code>和<code>GeoDataFrame</code>。<code>GeoSeries</code>是一个扩展的<code>Pandas Series</code>对象，用于存储几何对象。<code>GeoDataFrame</code>是一个扩展的<code>Pandas DataFrame</code>对象，其中包含一个特殊的 <code>geometry</code>(<code>GeoSeries</code>)列，用于存储地理几何对象（如点、线、多边形等）。<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_52964132/article/details/142440858">参考博客①</a></p>
<p><strong>核心特点</strong>：</p>
<ul>
<li>矢量数据操作(裁剪/合并/空间连接)</li>
<li>基于<code>Pandas</code>的数据结构(<code>GeoSeries</code>、<code>GeoDataFrame</code>)</li>
<li>坐标系管理(<code>CRS</code>转换)</li>
<li>空间可视化集成</li>
<li>支持多种文件格式(<code>Shapefile</code>/<code>GeoJSON</code>/<code>GPKG</code>)</li>
</ul>
<p><strong>主要依赖库：</strong></p>
<ul>
<li><code>Pandas</code>(数据处理)</li>
<li><code>Shapely</code>(几何操作)</li>
<li><code>Fiona</code>(文件I/O)</li>
<li><code>Pyproj</code>(坐标转换)</li>
</ul>
<blockquote>
<p><strong><code>geopandas</code>核心结构：</strong></p>
<p>①<code>GeoDataFrame</code>是<code>geopandas</code>的核心数据结构，类似于<code>pandas</code>的<code>DataFrame</code>，但包含一个特殊的<code>geometry</code>列，用于存储地理几何对象。</p>
<p>②<code>GeoSeries</code>是<code>geopandas</code>的另一个核心数据结构，类似于<code>pandas</code>的<code>Series</code>，但专门用于存储地理几何对象。</p>
<p><strong><code>geopandas</code>常用函数：</strong></p>
<p>①<code>read_file()</code>函数用于从文件中读取地理数据，支持多种格式，如<code>Shapefile</code>、<code>GeoJSON</code>、<code>KML</code>等。</p>
<p>②<code>to_file()</code>函数用于将<code>GeoDataFrame</code>或<code>GeoSeries</code>写入文件。</p>
<p>③<code>plot()</code>函数用于绘制地理数据。</p>
<p>④<code>sjoin()</code>函数用于空间连接(<code>Spatial Join</code>)，即将两个<code>GeoDataFrame</code>根据空间关系进行连接。连接方式('<code>inner</code>'，'<code>left</code>'，'<code>right</code>')。</p>
<p>⑤<code>overlay()</code>函数用于执行空间叠加操作(<code>Overlay</code>)，如交集、并集、差异等。叠加方式('<code>union</code>'，'<code>difference</code>'，'<code>intersection</code>'，'<code>symmetric_difference</code>')。</p>
<p>⑥<code>buffer()</code>函数用于计算几何对象的缓冲区。</p>
<p>⑦<code>centroid()</code>函数用于计算几何对象的质心。</p>
<p>⑧<code>dissolve()</code>函数用于根据某一列的值对<code>GeoDataFrame</code>进行聚合。</p>
<p>⑨<code>cx</code>属性用于根据坐标范围筛选<code>GeoDataFrame</code>或<code>GeoSeries</code>。</p>
<p>......</p>
</blockquote>
<p><strong>（2）Shapely</strong></p>
<p><code>Shapely</code>是一个<code>BSD</code>许可的<code>Python</code>包，用于操作和分析笛卡尔平面中的几何对象。它使用广泛部署的开源几何库<code>GEOS</code>(<code>PostGIS</code>的引擎，<code>JTS</code>的一个端口)。<code>Shapely</code>封装了<code>GEOS</code>的几何形状和操作，为单个(标量)几何形状提供了丰富的几何接口，并为使用几何数组的操作提供了更高性能的<code>NumPy ufuncs</code>。</p>
<p><strong>核心特点</strong>：</p>
<ul>
<li>基础几何对象操作(点/线/面)</li>
<li>空间关系计算(相交/包含/距离)</li>
<li>几何变换(缓冲区/仿射变换)</li>
<li>拓扑操作(并集/交集/差分)</li>
</ul>
<p><strong>主要依赖库</strong>：</p>
<ul>
<li><code>GEOS</code>(C++几何引擎)</li>
<li><code>Numpy</code>(数组支持)</li>
</ul>
<p><strong>（3）Fiona</strong></p>
<p><code>Fiona</code>是一个专为<code>Python</code>开发的地理空间矢量数据处理库，支持多种格式如<code>Shapefile</code>和<code>GeoJSON</code>。它通过简单的<code>Python IO</code>风格操作，帮助开发者读取和写入地理数据文件，同时与其他<code>GIS</code>工具(如<code>GDAL</code>、<code>Shapely</code>)无缝集成。<code>Fiona</code>的设计注重简洁和可靠，适合处理多层<code>GIS</code>格式数据。</p>
<p><strong>核心特点</strong>：</p>
<ul>
<li>多格式矢量数据读写(70+格式)</li>
<li>流式处理大文件</li>
<li>元数据访问</li>
<li>低级别要素操作</li>
</ul>
<p><strong>主要依赖库</strong>：</p>
<ul>
<li><code>GDAL</code>/<code>OGR</code>(地理数据抽象库)</li>
<li><code>Click</code>(命令行支持)</li>
</ul>
<p><strong>（4）GDAL/OGR</strong></p>
<p><code>OGR</code>是<code>GDAL</code>的一个子项目，提供对矢量数据的支持。它实现了一个对空间参考信息进行处理的类，用来对空间数据的空间信息进行处理。<code>GDAL</code>提供了一整套读写不同栅格数据格式功能的抽象类库， 而<code>OGR</code>是一个读写诸多矢量数据格式功能的抽象类库。两大类库用同一个生成系统进行维护，因此通常把这两个库合称为<code>GDAL</code>/<code>OGR</code> ，或者简称为<code>GDAL</code> 。</p>
<p><strong>核心特点</strong>：</p>
<ul>
<li>专业级空间数据转换</li>
<li>高级坐标系转换</li>
<li>格式互操作</li>
<li>栅格矢量互转</li>
</ul>
<p><strong>主要依赖库</strong>：</p>
<ul>
<li><code>GDAL C</code>库</li>
<li><code>Numpy</code></li>
</ul>
<p><strong>（5）Dask-geopandas</strong></p>
<p><code>Dask-geopandas</code>是一个结合了<code>Dask</code>和<code>GeoPandas</code>的框架，用于处理和分析大型地理空间数据。它通过并行计算和延迟执行来提高处理效率，特别适用于处理大规模的<code>GIS</code>数据。</p>
<p><strong>核心特点</strong>：</p>
<ul>
<li>分布式空间计算</li>
<li>大数据分块处理</li>
<li>延迟计算优化</li>
<li>集群部署支持</li>
</ul>
<p><strong>主要依赖库</strong>：</p>
<ul>
<li><code>Dask</code>(并行计算)</li>
<li><code>GeoPandas</code></li>
<li><code>Distributed</code>(任务调度)</li>
</ul>
<blockquote>
<p><code>Dask</code>库：<code>Dask</code>是一个开源的<code>Python</code>库，专为并行计算和大数据处理设计。它提供了与<code>Pandas</code>和<code>NumPy</code>类似的高层次接口，同时支持将计算分布到多核、集群或云环境中。<code>Dask</code>通过分块(<code>chunking</code>)和延迟计算(<code>lazy evaluation</code>)技术，实现了高效的数据处理和计算加速。核心功能：</p>
<ul>
<li><strong>并行数据处理</strong>：通过分块和延迟计算实现并行数据处理。</li>
<li><strong>大数据处理</strong>：支持处理超出内存容量的大规模数据集。</li>
<li><strong>数据帧操作</strong>：提供与<code>Pandas</code>类似的高层次数据帧接口。</li>
<li><strong>数组操作</strong>：提供与<code>NumPy</code>类似的高层次数组接口。</li>
<li><strong>并行计算</strong>：支持将计算任务分布到多核、集群或云环境中</li>
</ul>
</blockquote>
<h3 id="shapefile">👀Shapefile</h3>
<p><strong>（1）Shapefile矢量裁剪</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> geopandas <span class="keyword">as</span> gpd</span><br><span class="line"></span><br><span class="line">shp_path1 = <span class="string">r&quot;D:\Desktop\data\shp\Layer1.shp&quot;</span></span><br><span class="line">shp_path2 = <span class="string">r&quot;D:\Desktop\data\shp\Layer2.shp&quot;</span></span><br><span class="line">shp_clip_path = <span class="string">r&quot;D:\Desktop\data\shp\clip_result.shp&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取被裁剪数据和裁剪范围数据</span></span><br><span class="line">target = gpd.read_file(shp_path1)   <span class="comment"># 被裁剪的矢量</span></span><br><span class="line">clipper = gpd.read_file(shp_path2)  <span class="comment"># 裁剪范围</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行裁剪操作</span></span><br><span class="line">clipped = gpd.clip(target, clipper)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存结果</span></span><br><span class="line">clipped.to_file(shp_clip_path, encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p><strong>（2）Shapefile矢量合并</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 简单叠加合并</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> geopandas <span class="keyword">as</span> gpd</span><br><span class="line"><span class="keyword">import</span> glob</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取所有需要合并的Shapefile</span></span><br><span class="line">files = glob.glob(<span class="string">r&quot;D:\Desktop\data\shp\*.shp&quot;</span>)</span><br><span class="line">gdfs = [gpd.read_file(f) <span class="keyword">for</span> f <span class="keyword">in</span> files]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 确保所有几何类型一致（可选）</span></span><br><span class="line"><span class="keyword">for</span> gdf <span class="keyword">in</span> gdfs:</span><br><span class="line">    <span class="keyword">assert</span> gdf.geom_type[<span class="number">0</span>] <span class="keyword">in</span> (<span class="string">&#x27;Polygon&#x27;</span>, <span class="string">&#x27;MultiPolygon&#x27;</span>), <span class="string">&quot;几何类型不一致&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 合并数据</span></span><br><span class="line">merged = gpd.GeoDataFrame(pd.concat(gdfs, ignore_index=<span class="literal">True</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存结果</span></span><br><span class="line">shp_merged_path = <span class="string">r&quot;D:\Desktop\data\shp\merged_result.shp&quot;</span></span><br><span class="line">merged.to_file(shp_merged_path, encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 拓扑合并（融合相邻边界）,只针对一个矢量图层</span></span><br><span class="line"><span class="keyword">import</span> geopandas <span class="keyword">as</span> gpd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取数据</span></span><br><span class="line">shp_merged_path = <span class="string">r&quot;D:\Desktop\data\shp\merged_result.shp&quot;</span></span><br><span class="line">gdf = gpd.read_file(shp_merged_path)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按属性字段融合边界（例如根据&#x27;province&#x27;字段合并）,一个图层中把多个面融合为一个面</span></span><br><span class="line"><span class="comment"># 将多行数据合并为一行，geometry合并，其他行只保留一行信息</span></span><br><span class="line"><span class="comment"># 如果需要按照多个列进行合并，可以传递一个列名的列表</span></span><br><span class="line">dissolved = gdf.dissolve(by=<span class="string">&#x27;Id&#x27;</span>, aggfunc=<span class="string">&#x27;sum&#x27;</span>)</span><br><span class="line"><span class="comment"># dissolved = gdf.dissolve(by=[&#x27;Id&#x27;,&#x27;Shape&#x27;], aggfunc=&#x27;sum&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 无字段整体融合</span></span><br><span class="line">unified = gdf.dissolve()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存结果</span></span><br><span class="line">shp_dissolved_path = <span class="string">r&quot;D:\Desktop\data\shp\dissolved_result.shp&quot;</span></span><br><span class="line">dissolved.to_file(shp_dissolved_path)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在<code>Python</code>中，<code>assert</code>语句用于测试一个表达式，如果表达式结果为<code>False</code>，则会触发<code>AssertionError</code>异常。这种方式可以在条件不满足程序运行的情况下直接返回错误，而不必等待程序运行后出现崩溃的情况。</p>
</blockquote>
<p><strong>（3）Shapefile矢量交集</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 矢量图层交集取反</span></span><br><span class="line"><span class="keyword">import</span> geopandas <span class="keyword">as</span> gpd</span><br><span class="line"></span><br><span class="line">shp_path1 = <span class="string">r&quot;D:\Desktop\data\shp\Layer1.shp&quot;</span></span><br><span class="line">shp_path2 = <span class="string">r&quot;D:\Desktop\data\shp\Layer2.shp&quot;</span></span><br><span class="line"></span><br><span class="line">gdf_left = gpd.read_file(shp_path1)</span><br><span class="line">gdf_right = gpd.read_file(shp_path2)</span><br><span class="line"><span class="comment"># 计算矢量图层1和矢量图层2的交集部分，保留的geometry为矢量图层1去掉交集部分后的结果</span></span><br><span class="line">gdf_left_diff_ritht = gpd.overlay(gdf_left, gdf_right,<span class="string">&#x27;difference&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存结果</span></span><br><span class="line">shp_overlay_path = <span class="string">r&quot;D:\Desktop\data\shp\overlay_difference_result.shp&quot;</span></span><br><span class="line">gdf_left_diff_ritht.to_file(shp_overlay_path)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 矢量图层交集</span></span><br><span class="line"><span class="keyword">import</span> geopandas <span class="keyword">as</span> gpd</span><br><span class="line"></span><br><span class="line">shp_path1 = <span class="string">r&quot;D:\Desktop\data\shp\Layer1.shp&quot;</span></span><br><span class="line">shp_path2 = <span class="string">r&quot;D:\Desktop\data\shp\Layer2.shp&quot;</span></span><br><span class="line"></span><br><span class="line">gdf_left = gpd.read_file(shp_path1)</span><br><span class="line">gdf_right = gpd.read_file(shp_path2)</span><br><span class="line"><span class="comment"># 计算矢量图层1和矢量图层2的交集部分，保留的geometry为交集部分</span></span><br><span class="line">gdf_left_inte_ritht = gpd.overlay(gdf_left, gdf_right,<span class="string">&#x27;intersection&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存结果</span></span><br><span class="line">shp_overlay_path = <span class="string">r&quot;D:\Desktop\data\shp\overlay_intersection_result.shp&quot;</span></span><br><span class="line">gdf_left_inte_ritht.to_file(shp_overlay_path)</span><br></pre></td></tr></table></figure>
<p><strong>（4）区域统计</strong></p>
<p>基于区域矢量数据，利用<code>rasterstats</code>库批量实现<code>GTiff</code>数据的区域统计，并将其值保存至<code>CSV</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> rasterstats <span class="keyword">import</span> zonal_stats</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> glob</span><br><span class="line"></span><br><span class="line"><span class="comment"># 区域统计</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">zonal_stats_simple</span>(<span class="params">vector_path, raster_path, output_csv</span>):</span><br><span class="line">    raster_files = glob.glob(os.sep.join([raster_path, <span class="string">&quot;*.tif&quot;</span>]))</span><br><span class="line">    num = <span class="built_in">len</span>(raster_files)</span><br><span class="line">    result_df = pd.DataFrame()</span><br><span class="line">    times = []</span><br><span class="line">    mean_values = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num):</span><br><span class="line">        <span class="comment"># 计算区域统计</span></span><br><span class="line">        stats = zonal_stats(vector_path, raster_files[i], stats=<span class="string">&quot;mean&quot;</span>, all_touched=<span class="literal">False</span>, nodata=<span class="number">0</span>)</span><br><span class="line">        time = os.path.basename(os.path.basename(raster_files[i]).split(<span class="string">&quot;_&quot;</span>)[<span class="number">0</span>])</span><br><span class="line">        mean_value = [stat[<span class="string">&#x27;mean&#x27;</span>] <span class="keyword">for</span> stat <span class="keyword">in</span> stats]</span><br><span class="line">        times.append(time)</span><br><span class="line">        mean_values.append(mean_value[<span class="number">0</span>])</span><br><span class="line">    result_df[<span class="string">&quot;time&quot;</span>] = times</span><br><span class="line">    result_df[<span class="string">&quot;mean_values&quot;</span>] = mean_values</span><br><span class="line">    <span class="comment"># 保存为CSV</span></span><br><span class="line">    result_df.to_csv(output_csv, index=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># 读取矢量数据</span></span><br><span class="line">    vector_path = <span class="string">r&quot;D:\Desktop\data\...\shp\Sample.shp&quot;</span></span><br><span class="line">    raster_path = <span class="string">r&quot;D:\Desktop\data\...\2024_ERA5\rh1000hpa&quot;</span></span><br><span class="line">    output_csv = <span class="string">r&quot;D:\Desktop\data\...\excel\rh1000hpa.csv&quot;</span></span><br><span class="line">    zonal_stats_simple(vector_path, raster_path, output_csv)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>‌<code>rasterstats</code>是一个用于处理栅格和矢量数据的<code>Python</code>库，主要用于从栅格数据中提取基于矢量区划的统计信息，包括区域统计、分类统计和面状统计等，简化了栅格与矢量数据的交互‌。主要功能包括：</p>
<ul>
<li><p>‌<code>zonal_stats</code>：基于矢量区域从栅格数据中提取统计信息，如均值、最小值、最大值、方差等‌。</p></li>
<li><p>‌<code>point_query</code>：用于从栅格中提取给定点的数值信息‌。</p></li>
<li><p><code>gen_zonal_stats</code>：生成基于多边形的统计结果，适用于大规模的并行处理‌</p></li>
</ul>
</blockquote>
<h3 id="geojson">👀GeoJSON</h3>
<p><code>GeoJSON</code>是一种对各种地理数据结构进行编码的格式，基于<code>Javascript</code>对象表示法(<code>JSON</code>)的地理空间信息数据交换格式。<code>GeoJSON</code>对象可以表示几何、特征或者特征集合。<code>GeoJSON</code>支持的几何类型包括点、线、面、多点、多线、多面和几何集合。<code>GeoJSON</code>里的特征包含一个几何对象和其他属性，特征集合表示一系列特征。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;FeatureCollection&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;features&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Feature&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;geometry&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;coordinates&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">[</span><span class="punctuation">[</span><span class="number">113.68846316466124</span><span class="punctuation">,</span> <span class="number">34.83541413400329</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="punctuation">[</span><span class="number">113.68846316466124</span><span class="punctuation">,</span> <span class="number">34.79070319327178</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="punctuation">[</span><span class="number">113.76913047352139</span><span class="punctuation">,</span> <span class="number">34.79070319327178</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="punctuation">[</span><span class="number">113.76913047352139</span><span class="punctuation">,</span> <span class="number">34.83541413400329</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="punctuation">[</span><span class="number">113.68846316466124</span><span class="punctuation">,</span> <span class="number">34.83541413400329</span><span class="punctuation">]</span><span class="punctuation">]</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Polygon&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>利用<code>GeoPandas</code>库处理<code>GeoJSON</code>格式数据，并将其保存为<code>Shapefile</code>格式的代码示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> geopandas <span class="keyword">as</span> gpd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 读取GeoJSON文件（假设为面数据）</span></span><br><span class="line">input_geojson = <span class="string">r&quot;D:\Desktop\data\geojson\longhu.geojson&quot;</span></span><br><span class="line">gdf = gpd.read_file(input_geojson)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查数据是否为面类型（可选）</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">all</span>(gdf.geometry.<span class="built_in">type</span>.isin([<span class="string">&#x27;Polygon&#x27;</span>, <span class="string">&#x27;MultiPolygon&#x27;</span>])):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;警告：数据中包含非面类型几何体！&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># GeoPandas会保留原始数据的坐标参考系统（CRS）。如果需要强制转换，可添加：</span></span><br><span class="line"><span class="comment"># gdf = gdf.to_crs(&quot;EPSG:4326&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 保存为Shapefile</span></span><br><span class="line"><span class="comment"># Shapefile实际由多个文件组成（.shp、.shx、.dbf等），GeoPandas 会自动生成。</span></span><br><span class="line">output_shapefile = <span class="string">r&quot;D:\Desktop\data\geojson\output_data.shp&quot;</span></span><br><span class="line">gdf.to_file(output_shapefile, driver=<span class="string">&quot;ESRI Shapefile&quot;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="kmlkmz">👀KML/KMZ</h3>
<p><code>KML</code>(<code>Keyhole Markup Language</code>)是一种基于<code>XML</code>的地理数据标记语言，由<code>Google</code>旗下的<code>Keyhole</code>公司开发(后成为<code>Google Earth</code>的核心格式)，主要用于存储点、线、面等地理要素的存储和可视化，尤其适合用于三维轨迹数据展示和地图标注。‌‌<code>KML</code>的核心特点：</p>
<ul>
<li><code>XML</code>结构：<code>KML</code>文件本质上是<code>XML</code>文件，结构清晰，标签语义明确，易于阅读和编写。‌‌</li>
<li>三维可视化：支持三维模型和效果(如拉伸多边形)，适合展示复杂的地理空间数据。‌‌</li>
<li>跨平台兼容性：<code>KML</code>是开放标准，支持多种<code>GIS</code>平台(如<code>Google Earth</code>、<code>ArcGIS</code>、<code>QGIS</code>等)，可在不同工具间轻松导入和导出。‌‌</li>
<li>轻量级：文件通常较小，适合网络传输和在线加载。</li>
</ul>
<p>‌<code>KML</code>的应用场景：</p>
<ul>
<li><p>地图标注与路径规划：如旅游路线标注、无人机航线生成等。‌‌</p></li>
<li><p>三维数据展示：适用于毕业设计或项目中展示三维立体图。‌‌</p></li>
<li><p>数据共享：可通过<code>KMZ</code>(压缩版<code>KML</code>)打包分发包含图片、图标等资源的复杂地理数据。‌‌</p></li>
</ul>
<blockquote>
<p><code>KMZ</code>(<code>Keyhole Markup Zip</code>)：<code>KML</code>的压缩版本，本质是一个<code>ZIP</code>压缩包(扩展名为<code>.kmz</code>)，其用途是将<code>KML</code>文件及其关联资源(如图片、模型、图标等)打包为单一文件。其特点：</p>
<ul>
<li>节省存储空间，便于共享。</li>
<li>必须包含至少一个<code>doc.kml</code>(主文件)，其他资源(如纹理、<code>Collada</code>模型)存储在压缩包内。</li>
</ul>
</blockquote>
<table>
<thead>
<tr class="header">
<th>特性</th>
<th>KML</th>
<th>KMZ</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>格式</strong></td>
<td><code>XML</code>文本文件</td>
<td><code>ZIP</code>压缩包(内含<code>KML</code>+资源)</td>
</tr>
<tr class="even">
<td><strong>扩展名</strong></td>
<td><code>.KML</code></td>
<td><code>.KMZ</code></td>
</tr>
<tr class="odd">
<td><strong>文件大小</strong></td>
<td>较大(纯文本)</td>
<td>较小(压缩后)</td>
</tr>
<tr class="even">
<td><strong>资源支持</strong></td>
<td>需外部链接图片等</td>
<td>可内嵌图片、模型等</td>
</tr>
<tr class="odd">
<td><strong>编辑性</strong></td>
<td>可直接编辑</td>
<td>需解压后编辑</td>
</tr>
</tbody>
</table>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">kml</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.opengis.net/kml/2.2&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">Document</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">Placemark</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">ExtendedData</span>/&gt;</span>      <span class="comment">&lt;!-- 空标签 --&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">Polygon</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">outerBoundaryIs</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">LinearRing</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;<span class="name">coordinates</span>&gt;</span></span><br><span class="line">                        	113.68846316466124,34.83541413400329</span><br><span class="line">							113.68846316466124,34.79070319327178</span><br><span class="line">							113.76913047352139,34.79070319327178</span><br><span class="line">							113.76913047352139,34.83541413400329</span><br><span class="line">							113.68846316466124,34.83541413400329</span><br><span class="line">                 		<span class="tag">&lt;/<span class="name">coordinates</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;/<span class="name">LinearRing</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;/<span class="name">outerBoundaryIs</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">Polygon</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">Placemark</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">Document</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">kml</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>利用<code>GeoPandas</code>库处理<code>KML</code>格式数据，并将其保存为<code>Shapefile</code>格式的代码示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> geopandas <span class="keyword">as</span> gpd</span><br><span class="line"><span class="keyword">import</span> fiona</span><br><span class="line"></span><br><span class="line"><span class="comment"># 利用fiona库，激活KML文件读取格式</span></span><br><span class="line">fiona.drvsupport.supported_drivers[<span class="string">&#x27;KML&#x27;</span>] = <span class="string">&#x27;rw&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取KML文件</span></span><br><span class="line">input_kml = <span class="string">r&quot;D:\Desktop\data\kml\longhu.kml&quot;</span></span><br><span class="line">gdf = gpd.read_file(input_kml, driver=<span class="string">&#x27;KML&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(gdf.head())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存为Shapefile</span></span><br><span class="line">output_shapefile = <span class="string">r&quot;D:\Desktop\data\kml\output_data.shp&quot;</span></span><br><span class="line">gdf.to_file(output_shapefile, driver=<span class="string">&quot;ESRI Shapefile&quot;</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>（1）<code>KMZ</code>文件：需先解压提取内部的<code>KML</code>，利用<code>geopandas</code>读取解压后的<code>KML</code>(通常为<code>doc.kml</code>)。</p>
<p>（2）<code>pykml</code>库解析复杂<code>KML</code>：若需提取样式、描述等元数据，可使用<code>pykml</code>库。</p>
</blockquote>
<p><code>kml</code>文件中<code>&lt;ExtendedData&gt;</code>是一个非常重要的标签，用于存储自定义属性或元数据，这些数据可以附加到<code>KML</code> 的要素(如<code>Placemark</code>、<code>Polygon</code>等)上。它类似于<code>Shapefile</code>的"属性表"或<code>GeoJSON</code>的<code>properties</code>字段，但提供了更灵活的存储方式。<code>&lt;ExtendedData&gt;</code>标签的作用：</p>
<ul>
<li>存储额外的属性数据
<ul>
<li>例如：地名、描述、统计信息、ID、时间戳等非几何信息。</li>
</ul></li>
<li>兼容Google Earth和其他GIS工具
<ul>
<li>Google Earth会解析这些数据并在“详细信息”面板中显示。</li>
</ul></li>
<li>支持多种数据格式
<ul>
<li>可以存储文本、数字、嵌套结构(如<code>JSON</code>)，甚至二进制数据(需编码)。</li>
</ul></li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 示例 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Placemark</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>北京天安门<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ExtendedData</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Data</span> <span class="attr">name</span>=<span class="string">&quot;population&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">displayName</span>&gt;</span>人口<span class="tag">&lt;/<span class="name">displayName</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">value</span>&gt;</span>21540000<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Data</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Data</span> <span class="attr">name</span>=<span class="string">&quot;founded&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">displayName</span>&gt;</span>建城时间<span class="tag">&lt;/<span class="name">displayName</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">value</span>&gt;</span>1420<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Data</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ExtendedData</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Point</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">coordinates</span>&gt;</span>116.3975,39.9087<span class="tag">&lt;/<span class="name">coordinates</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">Point</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Placemark</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="wkt">👀WKT</h3>
<p>‌<code>WKT</code>(<code>Well-Known Text</code>)是一种用于描述地理空间几何对象的文本格式标准，由开放地理空间联盟<code>OGC</code>定义和维护。<code>WKT</code>是一种基于文本的地理空间数据表示方法，通过字符序列描述点、线、多边形等几何对象的形状和空间关系。‌‌常见几何类型包括点(<code>Point</code>)、线(<code>LineString</code>)、面(<code>Polygon</code>)、多点(<code>MultiPoint</code>)、复合面(<code>MultiPolygon</code>)。</p>
<ul>
<li>简洁易读，适合存储单个几何对象。</li>
<li>不支持属性数据(仅描述几何形状)。</li>
<li>扩展格式：<code>EWKT</code>(<code>PostGIS</code>扩展，支持<code>SRID</code>信息)。</li>
</ul>
<p><code>WKT</code>示例数据如下(第一行为面数据，第二行为点数据)：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POLYGON ((113.68846316466124 34.83541413400329, 113.68846316466124 34.79070319327178, 113.76913047352139 34.79070319327178, 113.76913047352139 34.83541413400329, 113.68846316466124 34.83541413400329))</span><br><span class="line">POINT (113.72885639495456 34.8140740745182)</span><br></pre></td></tr></table></figure>
<p>（1）利用<code>GeoPandas</code>和<code>shapely</code>库处理<code>WKT</code>格式数据，并将其保存为<code>Shapefile</code>格式的代码示例一：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> geopandas <span class="keyword">as</span> gpd</span><br><span class="line"><span class="keyword">from</span> shapely.wkt <span class="keyword">import</span> loads</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 读取WKT文件（假设每行一个WKT面数据）</span></span><br><span class="line">wkt_file = <span class="string">r&quot;D:\Desktop\data\wkt\longhu_polygon_point.wkt&quot;</span></span><br><span class="line">output_shp = <span class="string">&quot;D:\Desktop\data\wkt\output_polygons.shp&quot;</span></span><br><span class="line"><span class="comment"># 2. 读取并解析WKT数据（每行一个WKT字符串）</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(wkt_file, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    wkt_lines = [line.strip() <span class="keyword">for</span> line <span class="keyword">in</span> f <span class="keyword">if</span> line.strip()]</span><br><span class="line"><span class="built_in">print</span>(wkt_lines)</span><br><span class="line"><span class="comment"># 3. 创建几何对象列表和属性表</span></span><br><span class="line">geometries = []</span><br><span class="line">properties = []</span><br><span class="line"><span class="keyword">for</span> i, wkt <span class="keyword">in</span> <span class="built_in">enumerate</span>(wkt_lines, start=<span class="number">1</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        geom = loads(wkt)</span><br><span class="line">        <span class="comment"># 确保是面数据（Polygon或MultiPolygon）</span></span><br><span class="line">        <span class="keyword">if</span> geom.<span class="built_in">type</span> <span class="keyword">in</span> (<span class="string">&#x27;Polygon&#x27;</span>, <span class="string">&#x27;MultiPolygon&#x27;</span>):</span><br><span class="line">            geometries.append(geom)</span><br><span class="line">            properties.append(&#123;<span class="string">&#x27;id&#x27;</span>: i, <span class="string">&#x27;wkt&#x27;</span>: wkt[:]&#125;)  <span class="comment"># 示例属性</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;警告：跳过非面几何体（第<span class="subst">&#123;i&#125;</span>行）：<span class="subst">&#123;geom.<span class="built_in">type</span>&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;解析错误（第<span class="subst">&#123;i&#125;</span>行）：<span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line"><span class="comment"># 4. 创建GeoDataFrame</span></span><br><span class="line"><span class="keyword">if</span> geometries:</span><br><span class="line">    gdf = gpd.GeoDataFrame(properties, geometry=geometries, crs=<span class="string">&quot;EPSG:4326&quot;</span>)</span><br><span class="line">    <span class="comment"># 5. 保存为Shapefile</span></span><br><span class="line">    gdf.to_file(output_shp, driver=<span class="string">&quot;ESRI Shapefile&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;成功保存Shapefile：<span class="subst">&#123;output_shp&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;包含<span class="subst">&#123;<span class="built_in">len</span>(gdf)&#125;</span>个面要素&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;错误：未找到有效的面数据&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">[<span class="string">&#x27;POLYGON ((113.68846316466124 34.83541413400329, 113.68846316466124 34.79070319327178, 113.76913047352139 34.79070319327178, 113.76913047352139 34.83541413400329, 113.68846316466124 34.83541413400329))&#x27;</span>, <span class="string">&#x27;POINT (113.72885639495456 34.8140740745182)&#x27;</span>]</span><br><span class="line">警告：跳过非面几何体（第<span class="number">2</span>行）：Point</span><br><span class="line">成功保存Shapefile：D:\Desktop\data\wkt\output_polygons.shp</span><br><span class="line">包含<span class="number">1</span>个面要素</span><br></pre></td></tr></table></figure>
<p>（2）利用<code>GeoPandas</code>和<code>shapely</code>库处理<code>WKT</code>格式数据，并将其保存为<code>Shapefile</code>格式的代码示例二：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> geopandas <span class="keyword">as</span> gpd</span><br><span class="line"><span class="keyword">from</span> shapely.wkt <span class="keyword">import</span> loads</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例WKT面数据（Polygon 或 MultiPolygon）</span></span><br><span class="line">wkt_data = [</span><br><span class="line">    <span class="string">&quot;POLYGON ((116.404 39.915, 116.404 39.920, 116.410 39.920, 116.410 39.915, 116.404 39.915))&quot;</span>,</span><br><span class="line">    <span class="string">&quot;POLYGON ((116.415 39.925, 116.415 39.930, 116.420 39.930, 116.420 39.925, 116.415 39.925))&quot;</span></span><br><span class="line">]</span><br><span class="line"><span class="comment"># 示例属性数据（可选）</span></span><br><span class="line">attributes = [</span><br><span class="line">    &#123;<span class="string">&quot;id&quot;</span>: <span class="number">1</span>, <span class="string">&quot;name&quot;</span>: <span class="string">&quot;区域A&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;id&quot;</span>: <span class="number">2</span>, <span class="string">&quot;name&quot;</span>: <span class="string">&quot;区域B&quot;</span>&#125;</span><br><span class="line">]</span><br><span class="line"><span class="comment"># 1. 将WKT字符串转换为几何对象</span></span><br><span class="line">geometries = [loads(wkt) <span class="keyword">for</span> wkt <span class="keyword">in</span> wkt_data]</span><br><span class="line"><span class="comment"># 2. 创建GeoDataFrame</span></span><br><span class="line">gdf = gpd.GeoDataFrame(attributes, geometry=geometries, crs=<span class="string">&quot;EPSG:4326&quot;</span>)  <span class="comment"># 默认WGS84坐标系</span></span><br><span class="line"><span class="comment"># 3. 保存为Shapefile</span></span><br><span class="line">output_path = <span class="string">r&quot;D:\Desktop\data\wkt\output_polygons2.shp&quot;</span></span><br><span class="line">gdf.to_file(output_path, driver=<span class="string">&quot;ESRI Shapefile&quot;</span>, encoding=<span class="string">&quot;UTF-8&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Shapefile 已保存至：<span class="subst">&#123;output_path&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">Shapefile 已保存至：D:\Desktop\data\wkt\output_polygons2.shp</span><br></pre></td></tr></table></figure>
<h3 id="gml">👀GML</h3>
<p>‌<code>GML</code>(<code>Geography Markup Language</code>)是一种基于<code>XML</code>的地理信息编码语言，由开放地理空间联盟<code>OGC</code>制定，主要用于地理数据的建模、存储和交换，旨在解决不同来源、模型和格式的地理数据共享与互操作问题。其核心功能包括：‌‌</p>
<ul>
<li>编码地理要素的几何对象和属性信息，支持复杂空间要素和拓扑关系。</li>
<li>实现内容与表现的分离，支持灵活的数据解析与可视化。</li>
</ul>
<p><code>GML</code>示例数据如下:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">gml:FeatureCollection</span> <span class="attr">xmlns:gml</span>=<span class="string">&quot;http://www.opengis.net/gml/3.2&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">gml:featureMember</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">gml:Polygon</span> <span class="attr">gml:id</span>=<span class="string">&quot;polygon1&quot;</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">gml:extentOf</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">gml:Polygon</span> <span class="attr">srsName</span>=<span class="string">&quot;urn:ogc:def:crs:epsg::4326&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">gml:exterior</span>&gt;</span><span class="tag">&lt;<span class="name">gml:LinearRing</span>&gt;</span><span class="tag">&lt;<span class="name">gml:posList</span>&gt;</span>40.071713788991 116.374131643854 40.0715518439545 116.375167866672 40.0710444161736 116.375735659996 40.0703318580131 116.375636296165 40.0699863752687 116.37506850284 40.0700727459548 116.373691604027 40.0708824711371 116.373052836537 40.0709688418232 116.37302444687 40.0713791025823 116.3732515642 40.071713788991 116.374131643854<span class="tag">&lt;/<span class="name">gml:posList</span>&gt;</span><span class="tag">&lt;/<span class="name">gml:LinearRing</span>&gt;</span><span class="tag">&lt;/<span class="name">gml:exterior</span>&gt;</span><span class="tag">&lt;/<span class="name">gml:Polygon</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">gml:extentOf</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">gml:Polygon</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">gml:featureMember</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">gml:FeatureCollection</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>（1）利用<code>GeoPandas</code>库处理<code>GML</code>格式数据，并将其保存为<code>GeoJSON</code>格式的代码示例一：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> geopandas <span class="keyword">as</span> gpd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 直接读取GML文件</span></span><br><span class="line">input_gml = <span class="string">r&quot;D:\Desktop\data\gml\GML_sample.gml&quot;</span></span><br><span class="line">output_geojson = <span class="string">r&quot;D:\Desktop\data\gml\output.geojson&quot;</span></span><br><span class="line">gdf = gpd.read_file(input_gml, driver=<span class="string">&quot;GML&quot;</span>)</span><br><span class="line">gdf.to_file(output_geojson, driver=<span class="string">&quot;GeoJSON&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>（2）利用<code>GDAL</code>库的<code>ogr2ogr</code>处理<code>GML</code>格式数据，并将其保存为<code>Shapefile</code>格式的代码示例二：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">readGML</span>(<span class="params">gml_path, shp_path</span>):</span><br><span class="line">    <span class="comment"># 原始GML文件的投影信息的格式可能存在问题，不能匹配</span></span><br><span class="line">    cmd = [<span class="string">&quot;ogr2ogr&quot;</span>,</span><br><span class="line">           <span class="string">&quot;-f&quot;</span>, <span class="string">&quot;ESRI Shapefile&quot;</span>,</span><br><span class="line">           <span class="string">&quot;-t_srs&quot;</span>, <span class="string">&quot;EPSG:4326&quot;</span>,</span><br><span class="line">           shp_path,</span><br><span class="line">           gml_path]</span><br><span class="line">    subprocess.run(cmd, check=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    input_gml = <span class="string">r&quot;D:\Desktop\data\gml\GML_sample.gml&quot;</span></span><br><span class="line">    output_shp = <span class="string">r&quot;D:\Desktop\data\gml\output.shp&quot;</span></span><br><span class="line">    readGML(input_gml, output_shp)</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>subprocess</code>模块：<code>subprocess</code>模块是<code>Python</code>标准库中的一个模块，用于创建和管理子进程，允许用户执行外部命令、连接到输入/输出流，并获取子进程的返回码。该模块的主要功能包括执行外部命令、控制输入/输出、错误处理以及进程管理。</p>
<p><code>ogr2ogr</code>工具：‌ <code>ogr2ogr</code>是一个开源的命令行工具，属于<code>GDAL</code>库的一部分，主要用于处理和转换地理空间数据。它支持多种矢量数据格式的转换，包括<code>Shapefile</code>、<code>GeoJSON</code>、<code>KML</code>、<code>GML</code>、<code>GeoPackage</code>等，是地理信息系统数据处理中不可或缺的工具‌。</p>
</blockquote>
<h2 id="气象数据格式">⛄气象数据格式</h2>
<h3 id="netcdf">👀NetCDF</h3>
<p><code>NetCDF</code>(<code>network Common Data Form</code>)网络通用数据格式是由美国大学大气研究协会(<code>UCAR</code>)的<code>Unidata</code>项目科学家针对科学数据的特点开发的，是一种面向数组型并适于网络共享的数据的描述和编码标准。<code>NC</code>格式是一种用于存储多维科学数据的通用文件格式，广泛应用于气候科学、地球科学、水文等领域。它支持数组型数据，包含变量(<code>Variables</code>)、维度(<code>Dimensions</code>)和属性(<code>Attributes</code>)三种核心结构，便于网络共享和跨平台处理。<code>NetCDF</code>文件的数据结构包含三个主要组成部分：</p>
<ul>
<li>‌<strong>变量（Variables）</strong>‌：存储实际的多维数组数据(如温度、降水等)，每个变量关联到特定的维度。</li>
<li>‌<strong>维度（Dimensions）</strong>‌：定义变量的维度信息(如时间、经度、纬度等)，类似于变量的坐标轴。‌‌</li>
<li>‌<strong>属性（Attributes）</strong>‌：存储元数据信息。</li>
</ul>
<p>利用<code>netCDF4</code>和<code>GDAL</code>库处理<code>NetCDF</code>格式数据，并将其保存为<code>GTiff</code>格式的代码示例：</p>
<ul>
<li>格式转换：<code>NetCDF</code>→<code>GTiff</code></li>
<li>逐小时数据自动进行<strong>时区转换</strong>（可选）</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> netCDF4 <span class="keyword">as</span> nc</span><br><span class="line"><span class="keyword">from</span> osgeo <span class="keyword">import</span> gdal, osr</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> cftime</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> pytz <span class="keyword">import</span> timezone</span><br><span class="line"></span><br><span class="line"><span class="comment"># 写入影像</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">write_img</span>(<span class="params">filename, im_proj, im_geotrans, im_data</span>):</span><br><span class="line">    <span class="comment"># 判断栅格数据的数据类型</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;int8&#x27;</span> <span class="keyword">in</span> im_data.dtype.name:</span><br><span class="line">        datatype = gdal.GDT_Byte</span><br><span class="line">    <span class="keyword">elif</span> <span class="string">&#x27;int16&#x27;</span> <span class="keyword">in</span> im_data.dtype.name:</span><br><span class="line">        datatype = gdal.GDT_UInt16</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        datatype = gdal.GDT_Float32</span><br><span class="line">    <span class="comment"># 判读数组维数</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(im_data.shape) == <span class="number">3</span>:</span><br><span class="line">        im_bands, im_height, im_width = im_data.shape</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        im_bands, (im_height, im_width) = <span class="number">1</span>, im_data.shape</span><br><span class="line">    <span class="comment"># 创建文件</span></span><br><span class="line">    driver = gdal.GetDriverByName(<span class="string">&quot;GTiff&quot;</span>)</span><br><span class="line">    dataset = driver.Create(filename, im_width, im_height, im_bands, datatype)</span><br><span class="line">    dataset.SetGeoTransform(im_geotrans) <span class="comment"># 写入仿射变换参数</span></span><br><span class="line">    dataset.SetProjection(im_proj) <span class="comment"># 写入投影</span></span><br><span class="line">    <span class="keyword">if</span> im_bands == <span class="number">1</span>:</span><br><span class="line">        dataset.GetRasterBand(<span class="number">1</span>).WriteArray(im_data) <span class="comment"># 写入数组数据</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(im_bands):</span><br><span class="line">            dataset.GetRasterBand(i + <span class="number">1</span>).WriteArray(im_data[i,:,:])</span><br><span class="line">    <span class="keyword">del</span> dataset</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将NetCDF数据转化为GTiff</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">nc_totif</span>(<span class="params">input_path, output_path</span>):</span><br><span class="line">    <span class="comment"># 读取nc文件</span></span><br><span class="line">    tep_data = nc.Dataset(input_path)</span><br><span class="line">    <span class="built_in">print</span>(tep_data.variables.keys())</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 获取nc文件中对应变量的信息</span></span><br><span class="line">    lon_data = tep_data.variables[<span class="string">&quot;longitude&quot;</span>][:]</span><br><span class="line">    lat_data = tep_data.variables[<span class="string">&quot;latitude&quot;</span>][:]</span><br><span class="line">    <span class="comment"># 影像的左上角&amp;右下角坐标</span></span><br><span class="line">    lonmin, latmax, lonmax, latmin = [lon_data.<span class="built_in">min</span>(), lat_data.<span class="built_in">max</span>(), lon_data.<span class="built_in">max</span>(), lat_data.<span class="built_in">min</span>()]</span><br><span class="line">    <span class="comment"># 分辨率计算</span></span><br><span class="line">    num_lon = <span class="built_in">len</span>(lon_data)</span><br><span class="line">    num_lat = <span class="built_in">len</span>(lat_data)</span><br><span class="line">    lon_res = (lonmax - lonmin) / (<span class="built_in">float</span>(num_lon) - <span class="number">1</span>)</span><br><span class="line">    lat_res = (latmax - latmin) / (<span class="built_in">float</span>(num_lat) - <span class="number">1</span>)</span><br><span class="line">    <span class="comment"># 定义投影</span></span><br><span class="line">    proj = osr.SpatialReference()</span><br><span class="line">    proj.ImportFromEPSG(<span class="number">4326</span>) 		<span class="comment"># WGS84</span></span><br><span class="line">    proj = proj.ExportToWkt() 		<span class="comment"># 重点，转成wkt格式</span></span><br><span class="line">    <span class="comment"># 仿射变换矩阵</span></span><br><span class="line">    geotransform = (lonmin, lon_res, <span class="number">0.0</span>, latmax, <span class="number">0.0</span>, -lat_res)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取时间</span></span><br><span class="line">    time_var = tep_data.variables[<span class="string">&quot;valid_time&quot;</span>]</span><br><span class="line">    time_units = time_var.units</span><br><span class="line">    <span class="built_in">print</span>(time_units)</span><br><span class="line">    time_values = time_var[:]</span><br><span class="line">    <span class="comment"># 将时间戳转换为日期时间对象</span></span><br><span class="line">    datetimes = cftime.num2date(time_values, units=time_units, calendar=<span class="string">&quot;gregorian&quot;</span>)</span><br><span class="line">    dates = [dt.strftime(<span class="string">&quot;%Y%m%d&quot;</span>) <span class="keyword">for</span> dt <span class="keyword">in</span> datetimes]</span><br><span class="line">    times = [dt.strftime(<span class="string">&quot;%H%M%S&quot;</span>) <span class="keyword">for</span> dt <span class="keyword">in</span> datetimes]</span><br><span class="line">    dates = np.unique(dates)</span><br><span class="line">    </span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    # 获取时间(逐小时一般进行时区转换)</span></span><br><span class="line"><span class="string">    time_var = tep_data.variables[&quot;valid_time&quot;]  # 获取时间变量</span></span><br><span class="line"><span class="string">    time_units = time_var.units   # 获取时间单位</span></span><br><span class="line"><span class="string">    print(time_units)</span></span><br><span class="line"><span class="string">    time_values = time_var[:]     # 获取时间值</span></span><br><span class="line"><span class="string">    # 将时间戳转换为日期时间对象</span></span><br><span class="line"><span class="string">    datetimes = cftime.num2date(time_values, units = time_units, calendar = &quot;gregorian&quot;)</span></span><br><span class="line"><span class="string">    utc_time_str = [dt.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;) for dt in datetimes]</span></span><br><span class="line"><span class="string">    beijing_time_str = []</span></span><br><span class="line"><span class="string">    for i in range(len(utc_time_str)):</span></span><br><span class="line"><span class="string">        utc_time = pd.to_datetime(utc_time_str[i], format=&quot;%Y-%m-%d %H:%M:%S&quot;)</span></span><br><span class="line"><span class="string">        utc_time = utc_time.tz_localize(&quot;UTC&quot;)</span></span><br><span class="line"><span class="string">        beijing_time = utc_time.astimezone(timezone(&quot;Asia/Shanghai&quot;)).strftime(&quot;%Y%m%d%H&quot;)</span></span><br><span class="line"><span class="string">        beijing_time_str.append(beijing_time)</span></span><br><span class="line"><span class="string">    beijing_time_str = np.unique(beijing_time_str)</span></span><br><span class="line"><span class="string">    print(beijing_time_str)</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    t2m = tep_data.variables[<span class="string">&quot;t2m&quot;</span>][:]</span><br><span class="line">    t2m_arr = np.asarray(t2m)</span><br><span class="line">    t2m_day_mean = np.mean(t2m_arr, <span class="number">0</span>)</span><br><span class="line">    outpath = os.sep.join([output_path, dates[<span class="number">0</span>]+<span class="string">&quot;_daymean_t2m.tif&quot;</span>])</span><br><span class="line">    write_img(outpath, proj, geotransform, t2m_day_mean)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># nc文件输入输出路径</span></span><br><span class="line">    input_path = <span class="string">r&quot;D:\Desktop\data\20250528\20250528_ERA5_t2m_wind_tp.nc&quot;</span></span><br><span class="line">    output_path = <span class="string">r&quot;D:\Desktop\data\20250528\tif&quot;</span></span><br><span class="line">    <span class="comment"># 读取nc文件，转换为tif文件</span></span><br><span class="line">    nc_totif(input_path, output_path)</span><br></pre></td></tr></table></figure>
<h3 id="grib">👀GRIB</h3>
<p><code>GRIB</code>(<code>Gridded Binary</code>)是世界气象组织(<code>WMO</code>)开发的一种用于存储和传输网格化气象数据的二进制文件格式，广泛应用于数值天气预报、气候研究等领域。其基本特点：</p>
<ul>
<li><strong>二进制格式</strong>：紧凑高效，适合大量数据存储和传输</li>
<li><strong>自描述性</strong>：包含元数据描述数据内容</li>
<li><strong>压缩存储</strong>：支持多种压缩算法</li>
<li><strong>分节结构</strong>：数据按节(<code>Section</code>)组织</li>
<li><strong>国际标准</strong>：<code>WMO</code>标准格式，全球气象业务通用</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> xarray <span class="keyword">as</span> xr</span><br><span class="line"><span class="keyword">import</span> rioxarray</span><br><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> Path</span><br><span class="line"><span class="keyword">import</span> warnings</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">grib_to_tiff</span>(<span class="params">grib_path, tiff_path, variable=<span class="literal">None</span>, time_idx=<span class="number">0</span>, level_idx=<span class="number">0</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    使用xarray和cfgrib将GRIB文件转换为GeoTIFF</span></span><br><span class="line"><span class="string">    参数:</span></span><br><span class="line"><span class="string">        grib_path (str): 输入GRIB文件路径</span></span><br><span class="line"><span class="string">        tiff_path (str): 输出TIFF文件路径</span></span><br><span class="line"><span class="string">        variable (str): 可选，指定要提取的变量名</span></span><br><span class="line"><span class="string">        time_idx (int): 可选，时间维度索引(默认为0)</span></span><br><span class="line"><span class="string">        level_idx (int): 可选，高度层索引(默认为0)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 禁用不必要的警告</span></span><br><span class="line">        warnings.filterwarnings(<span class="string">&quot;ignore&quot;</span>, category=UserWarning)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 打开GRIB文件</span></span><br><span class="line">        ds = xr.open_dataset(grib_path, engine=<span class="string">&quot;cfgrib&quot;</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 如果没有指定变量，选择第一个数据变量</span></span><br><span class="line">        <span class="keyword">if</span> variable <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            variable = <span class="built_in">list</span>(ds.data_vars.keys())[<span class="number">0</span>]</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;未指定变量，自动选择: <span class="subst">&#123;variable&#125;</span>&quot;</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 获取数据数组</span></span><br><span class="line">        data = ds[variable]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 处理多维数据(时间、高度层等)</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;time&quot;</span> <span class="keyword">in</span> data.dims:</span><br><span class="line">            data = data.isel(time=time_idx)</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;isobaricInhPa&quot;</span> <span class="keyword">in</span> data.dims:</span><br><span class="line">            data = data.isel(isobaricInhPa=level_idx)</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;heightAboveGround&quot;</span> <span class="keyword">in</span> data.dims:</span><br><span class="line">            data = data.isel(heightAboveGround=level_idx)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 添加地理参考信息</span></span><br><span class="line">        data = data.rio.set_spatial_dims(x=<span class="string">&quot;longitude&quot;</span>, y=<span class="string">&quot;latitude&quot;</span>, inplace=<span class="literal">False</span>)</span><br><span class="line">        data.rio.write_crs(<span class="string">&quot;EPSG:4326&quot;</span>, inplace=<span class="literal">True</span>)  <span class="comment"># WGS84坐标系</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 保存为GeoTIFF</span></span><br><span class="line">        data.rio.to_raster(tiff_path)</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;成功转换: <span class="subst">&#123;Path(grib_path).name&#125;</span> → <span class="subst">&#123;Path(tiff_path).name&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;转换失败: <span class="subst">&#123;<span class="built_in">str</span>(e)&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        warnings.resetwarnings()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用示例</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    input_file = <span class="string">&quot;example.grib&quot;</span>  <span class="comment"># 输入GRIB文件</span></span><br><span class="line">    output_file = <span class="string">&quot;output.tif&quot;</span>   <span class="comment"># 输出TIFF文件</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 基本转换</span></span><br><span class="line">    grib_to_tiff(input_file, output_file)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 高级用法：指定变量和时间层</span></span><br><span class="line">    <span class="comment"># 850hPa温度</span></span><br><span class="line">    <span class="comment"># grib_to_tiff(input_file, &quot;temp_850hPa.tif&quot;, variable=&quot;t&quot;, level_idx=2)</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>GRIB</code>数据读取方法：</p>
<p>（1）使用<code>xarray+cfgrib</code>组合</p>
<p>（2）使用<code>pygrib</code>库，小编一直安装错误......</p>
</blockquote>
<p><code>NetCDF</code>和<code>GRIB</code>是气象和地球科学领域常用的两种数据格式，它们的主要区别如下：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">特性</th>
<th style="text-align: left;">NetCDF</th>
<th style="text-align: left;">GRIB</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><strong>设计目的</strong></td>
<td style="text-align: left;">通用科学数据格式</td>
<td style="text-align: left;">气象领域专用格式</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>标准组织</strong></td>
<td style="text-align: left;">UCAR/Unidata</td>
<td style="text-align: left;">WMO(世界气象组织)</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>版本</strong></td>
<td style="text-align: left;">NetCDF3/4</td>
<td style="text-align: left;">GRIB1/GRIB2</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>数据结构</strong></td>
<td style="text-align: left;">多维数组+元数据</td>
<td style="text-align: left;">消息集合(每个消息独立)</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>压缩效率</strong></td>
<td style="text-align: left;">中等(支持压缩)</td>
<td style="text-align: left;">高(专为气象数据优化)</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>元数据灵活性</strong></td>
<td style="text-align: left;">高(可自定义属性)</td>
<td style="text-align: left;">固定模板(参数代码表)</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>时间处理</strong></td>
<td style="text-align: left;">灵活的时间坐标</td>
<td style="text-align: left;">基于参考时间+预报时长</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>空间参考</strong></td>
<td style="text-align: left;">可自由定义</td>
<td style="text-align: left;">预定义投影系统</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>编程接口</strong></td>
<td style="text-align: left;">丰富(多种语言支持)</td>
<td style="text-align: left;">较复杂(需专用库)</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>典型扩展名</strong></td>
<td style="text-align: left;"><code>.nc</code>、<code>.cdf</code></td>
<td style="text-align: left;"><code>.grb</code>、<code>.grib</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>主要用途</strong></td>
<td style="text-align: left;">科研数据存储/交换</td>
<td style="text-align: left;">气象业务数据传输</td>
</tr>
</tbody>
</table>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://heartlovelife.github.io">Xiaotangsmiles</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://heartlovelife.github.io/2025/06/30/RsGisFiles-ReadWrite/">https://heartlovelife.github.io/2025/06/30/RsGisFiles-ReadWrite/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://heartlovelife.github.io" target="_blank">江湖是你画中亦是你</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/">数据处理</a><a class="post-meta__tags" href="/tags/%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99/">文件读写</a></div><div class="post_share"><div class="social-share" data-image="https://s2.loli.net/2025/06/30/NztQZxneq12OYjM.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/gh/overtrue/share.js@master/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/loading1.gif" data-original="/img/wechat.jpg" alt="wechat(微信)"/></a><div class="post-qr-code-desc">wechat(微信)</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/loading1.gif" data-original="/img/alipay.jpg" alt="alipay(支付宝)"/></a><div class="post-qr-code-desc">alipay(支付宝)</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2025/03/30/GEE02/"><img class="next-cover" src="/img/loading1.gif" data-original="https://s2.loli.net/2022/05/17/7UCAtTuqoSfpMmy.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">（二）GEE基础学习初探及案例详解【20250330】</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/09/08/ERA5-data/" title="ERA5数据下载和批处理教程"><img class="cover" src="/img/loading1.gif" data-original="https://s2.loli.net/2022/12/10/UNrouOseVYvwRhL.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-08</div><div class="title">ERA5数据下载和批处理教程</div></div></a></div><div><a href="/2023/04/09/RS-Data-Process01/" title="Himawari8-9数据下载和预处理教程"><img class="cover" src="/img/loading1.gif" data-original="https://s2.loli.net/2023/04/09/beX9VQlxpYdPTc2.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-09</div><div class="title">Himawari8-9数据下载和预处理教程</div></div></a></div><div><a href="/2023/11/28/Files-ReadWrite/" title="Python&#x2F;Matlab&#x2F;IDL之文件读写操作【CSV&#x2F;Excel&#x2F;JSON&#x2F;XML&#x2F;TXT】"><img class="cover" src="/img/loading1.gif" data-original="https://s2.loli.net/2024/01/17/5fyvO89JhpKPiz4.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-28</div><div class="title">Python&#x2F;Matlab&#x2F;IDL之文件读写操作【CSV&#x2F;Excel&#x2F;JSON&#x2F;XML&#x2F;TXT】</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/loading1.gif" data-original="/img/touxiang.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Xiaotangsmiles</div><div class="author-info__description">我们总以为来日方长，却忘了世事无常</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">30</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">27</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">12</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/HeartLoveLife"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/HeartLoveLife" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="https://blog.csdn.net/twg666" target="_blank" title="CSDN"><i class="fa fa-book-open"></i></a><a class="social-icon" href="tencent://AddContact/?fromId=45&amp;fromSubId=1&amp;subcmd=all&amp;uin=491037927&amp;website=www.oicqzone.com" target="_blank" title="QQ"><i class="fab fa-qq"></i></a><a class="social-icon" href="mailto:xiaotangsmiles@163.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">我有我自己的太阳、月亮和星星，我有一个完全属于我自己的小世界。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%85%E6%A0%BC%E6%95%B0%E6%8D%AE"><span class="toc-number">1.</span> <span class="toc-text">⛄栅格数据</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8python%E5%BA%93"><span class="toc-number">1.1.</span> <span class="toc-text">👀常用Python库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#geotiff%E6%95%B0%E6%8D%AE"><span class="toc-number">1.2.</span> <span class="toc-text">👀GeoTIFF数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hdf%E6%95%B0%E6%8D%AE"><span class="toc-number">1.3.</span> <span class="toc-text">👀HDF数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dat%E6%95%B0%E6%8D%AE"><span class="toc-number">1.4.</span> <span class="toc-text">👀DAT数据</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A2%E9%87%8F%E6%95%B0%E6%8D%AE"><span class="toc-number">2.</span> <span class="toc-text">⛄矢量数据</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8python%E5%BA%93-1"><span class="toc-number">2.1.</span> <span class="toc-text">👀常用Python库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#shapefile"><span class="toc-number">2.2.</span> <span class="toc-text">👀Shapefile</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#geojson"><span class="toc-number">2.3.</span> <span class="toc-text">👀GeoJSON</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#kmlkmz"><span class="toc-number">2.4.</span> <span class="toc-text">👀KML&#x2F;KMZ</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#wkt"><span class="toc-number">2.5.</span> <span class="toc-text">👀WKT</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#gml"><span class="toc-number">2.6.</span> <span class="toc-text">👀GML</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B0%94%E8%B1%A1%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F"><span class="toc-number">3.</span> <span class="toc-text">⛄气象数据格式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#netcdf"><span class="toc-number">3.1.</span> <span class="toc-text">👀NetCDF</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#grib"><span class="toc-number">3.2.</span> <span class="toc-text">👀GRIB</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/06/30/RsGisFiles-ReadWrite/" title="基于Python的GIS-RS多源数据处理(TIF/SHP/NC/...)【20250630】"><img src="/img/loading1.gif" data-original="https://s2.loli.net/2025/06/30/NztQZxneq12OYjM.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="基于Python的GIS-RS多源数据处理(TIF/SHP/NC/...)【20250630】"/></a><div class="content"><a class="title" href="/2025/06/30/RsGisFiles-ReadWrite/" title="基于Python的GIS-RS多源数据处理(TIF/SHP/NC/...)【20250630】">基于Python的GIS-RS多源数据处理(TIF/SHP/NC/...)【20250630】</a><time datetime="2025-06-30T14:20:00.000Z" title="发表于 2025-06-30 22:20:00">2025-06-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/03/30/GEE02/" title="（二）GEE基础学习初探及案例详解【20250330】"><img src="/img/loading1.gif" data-original="https://s2.loli.net/2022/05/17/7UCAtTuqoSfpMmy.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="（二）GEE基础学习初探及案例详解【20250330】"/></a><div class="content"><a class="title" href="/2025/03/30/GEE02/" title="（二）GEE基础学习初探及案例详解【20250330】">（二）GEE基础学习初探及案例详解【20250330】</a><time datetime="2025-03-30T09:32:36.000Z" title="发表于 2025-03-30 17:32:36">2025-03-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/01/05/Sentinel5P-Process/" title="Sentinel-5P遥感数据下载及预处理教程【20250105】"><img src="/img/loading1.gif" data-original="https://s2.loli.net/2023/10/28/Ure9cF4EkpH8QZJ.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Sentinel-5P遥感数据下载及预处理教程【20250105】"/></a><div class="content"><a class="title" href="/2025/01/05/Sentinel5P-Process/" title="Sentinel-5P遥感数据下载及预处理教程【20250105】">Sentinel-5P遥感数据下载及预处理教程【20250105】</a><time datetime="2025-01-05T14:05:05.000Z" title="发表于 2025-01-05 22:05:05">2025-01-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/11/16/RS-CSink-Method/" title="碳汇估算方法概述及基于RS的碳汇估算模型详述【20241116】"><img src="/img/loading1.gif" data-original="https://s2.loli.net/2024/11/16/2lwpstimg6HCTod.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="碳汇估算方法概述及基于RS的碳汇估算模型详述【20241116】"/></a><div class="content"><a class="title" href="/2024/11/16/RS-CSink-Method/" title="碳汇估算方法概述及基于RS的碳汇估算模型详述【20241116】">碳汇估算方法概述及基于RS的碳汇估算模型详述【20241116】</a><time datetime="2024-11-16T08:00:00.000Z" title="发表于 2024-11-16 16:00:00">2024-11-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/10/28/Py6S-Model-Use/" title="常见大气校正模型及6S模型安装部署【20241028】"><img src="/img/loading1.gif" data-original="https://s2.loli.net/2024/10/28/mOhXvaL3YTEdMo9.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="常见大气校正模型及6S模型安装部署【20241028】"/></a><div class="content"><a class="title" href="/2024/10/28/Py6S-Model-Use/" title="常见大气校正模型及6S模型安装部署【20241028】">常见大气校正模型及6S模型安装部署【20241028】</a><time datetime="2024-10-28T12:13:14.000Z" title="发表于 2024-10-28 20:13:14">2024-10-28</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2025 By Xiaotangsmiles</div><div class="framework-info"><span>地址 </span><a href="https://heartlovelife.github.io">HeartLoveLife</a><span class="footer-separator">|</span><span>邮箱 </span><a href="javascript:void(0);">xiaotangsmiles@163.com</a></div><div class="footer_custom_text">Hi, welcome to my <a href="https://heartlovelife.github.io/">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div>
        <style>
            [bg-lazy] {
                background-image: none !important;
                background-color: #eee !important;
            }
        </style>
        <script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script><script>!function(r){r.imageLazyLoadSetting.processImages=t;var e=r.imageLazyLoadSetting.isSPA,n=r.imageLazyLoadSetting.preloadRatio||1,c=a();function a(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(){e&&(c=a());for(var t,o=0;o<c.length;o++)0<=(t=(t=c[o]).getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(r.innerHeight*n||document.documentElement.clientHeight*n)&&function(){var t,e,n,a,i=c[o];e=function(){c=c.filter(function(t){return i!==t}),r.imageLazyLoadSetting.onImageLoaded&&r.imageLazyLoadSetting.onImageLoaded(i)},(t=i).hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),e&&e()):(n=new Image,a=t.getAttribute("data-original"),n.onload=function(){t.src=a,t.removeAttribute("data-original"),e&&e()},t.src!==a&&(n.src=a))}()}function i(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",i),r.addEventListener("resize",i),r.addEventListener("orientationchange",i)}(this);</script></body></html>